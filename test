<script>
document.addEventListener('DOMContentLoaded', () => {
  // === помощни функции ===
  function getTextColor() {
    return document.body.classList.contains('dark-mode') ? 'white' : 'black';
  }
  function parseElapsedToHours(timeStr) {
    const [h, m] = timeStr.split(':').map(v => parseInt(v, 10));
    return (isNaN(h) || isNaN(m)) ? 0 : h + m / 60;
  }
  function formatHHMM(hoursFloat) {
    const h = Math.floor(hoursFloat);
    const m = Math.round((hoursFloat - h) * 60);
    return `${h}:${m.toString().padStart(2,'0')}`;
  }

  // === събиране на данни от таблицата ===
  function getElapsedChartData() {
    const rows = Array.from(
      document.getElementById('recordsTable')
              .getElementsByTagName('tr')
    ).slice(1);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10);
    const dates = [], cob = [], rr = [];
    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
      const cells = rows[i].getElementsByTagName('td');
      if (cells.length >= 9) {
        const d = cells[0].innerText.trim();
        const c = cells[4].innerText.trim();
        const r = cells[8].innerText.trim();
        if (d && c && r) {
          dates.push(d);
          cob.push(parseElapsedToHours(c));
          rr.push(parseElapsedToHours(r));
        }
      }
    }
    return {
      dates: dates.reverse(),
      cobElapsed: cob.reverse(),
      rrElapsed:  rr.reverse()
    };
  }

  // === функция за рендер на Chart.js ===
  let elapsedChartInstance;
  function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    // 1) динамична височина
    const perDayH = 20, minH = 200, maxH = 800;
    const h = Math.min(maxH, Math.max(minH, dates.length * perDayH + 100));
    document.getElementById('chartContainer').style.height = h + 'px';

    // 2) destroy стария чарт
    if (elapsedChartInstance) {
      elapsedChartInstance.destroy();
    }

    // 3) създаване на новия чарт
    const ctx = document.getElementById('elapsedChart').getContext('2d');
    elapsedChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: dates,
        datasets: [
          {
            label: 'COB Elapsed',
            data: cobElapsed,
            backgroundColor: 'rgba(154,200,245,1)',
            stack: 's1',
            order: 1
          },
          {
            label: 'RR Elapsed',
            data: rrElapsed,
            backgroundColor: 'rgba(181,181,181,1)',
            stack: 's1',
            order: 2
          },
          {
            label: 'Duration Limit (2:30)',
            data: Array(dates.length).fill(2.5),
            type: 'line',
            borderColor: 'red',
            borderDash: [6,4],
            pointRadius: 0,
            borderWidth: 2,
            order: 0
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: { top:20, bottom:20, left:10, right:10 } },
        scales: {
          x: {
            stacked: true,
            ticks: {
              autoSkip: false,
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true,
            max: 7,
            ticks: {
              maxTicksLimit: 8,
              callback: v => formatHHMM(v)
            }
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
            }
          },
          title: {
            display: true,
            text: 'COB & RR Elapsed Times vs Duration Limit',
            color: getTextColor(),
            font: { size:13, weight:'bold' }
          },
          legend: { labels: { font: { size:13 } } }
        }
      },
      plugins: [{
        id: 'totalLabel',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const meta = chart.getDatasetMeta(0);
          const yScale = scales.y;
          ctx.save();
          ctx.font = 'bold 11px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = getTextColor();
          data.labels.forEach((_, i) => {
            const total = data.datasets[0].data[i] + data.datasets[1].data[i];
            if (!total) return;
            const x = meta.data[i].x;
            const y = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, y);
          });
          ctx.restore();
        }
      }]
    });
  }

  // === функция за широчина на контейнера според дни ===
  function updateContainerWidth(days) {
    const ctr = document.getElementById('chartContainer');
    ctr.classList.remove('w-0-10', 'w-11-20', 'w-21-plus');
    if (days <= 10) {
      ctr.classList.add('w-0-10');
    } else if (days <= 20) {
      ctr.classList.add('w-11-20');
    } else {
      ctr.classList.add('w-21-plus');
    }
  }

  // === hook на slider-а ===
  const slider = document.getElementById('daysRange');
  const label  = document.getElementById('daysValue');
  function onDaysChange() {
    const days = parseInt(slider.value, 10);
    label.textContent = days;
    updateContainerWidth(days);
    renderElapsedChart();
  }
  slider.addEventListener('input', onDaysChange);

  // първоначално извикване
  onDaysChange();
});
</script>
