<script>
function setupCanvas(canvas, width, height) {
  const dpr = window.devicePixelRatio || 1;

  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;

  canvas.width = width * dpr;
  canvas.height = height * dpr;

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return ctx;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 30 }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';

          const x = bar.x;
          const y = bar.y - 5;

          ctx.lineWidth = 3;
          ctx.strokeStyle = dark ? '#111' : '#fff';
          ctx.strokeText(label, x, y);

          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, x, y);

          ctx.restore();
        });
      }
    }]
  });
}
</script>



function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = canvas.getContext('2d');

  const ratio = window.devicePixelRatio || 1;
  canvas.width = 500 * ratio;
  canvas.height = 500 * ratio;
  canvas.style.width = '500px';
  canvas.style.height = '500px';
  ctx.scale(ratio, ratio);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false // prevent clipping text outside chart area
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: {
          top: 20
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';

          const x = bar.x;
          const y = bar.y - 5;

          // Outline for better contrast
          ctx.lineWidth = 3;
          ctx.strokeStyle = dark ? '#111' : '#fff';
          ctx.strokeText(label, x, y);

          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, x, y);

          ctx.restore();
        });
      }
    }]
  });
}




function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = canvas.getContext('2d');

  const ratio = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * ratio;
  canvas.height = canvas.clientHeight * ratio;
  ctx.scale(ratio, ratio);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          display: true
        },
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    }
  });
}



afterDatasetsDraw(chart) {
    const ctx = chart.ctx;
    const datasetMeta = chart.getDatasetMeta(0);
    const dark = document.body.classList.contains('dark-mode');

    ctx.save();
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    datasetMeta.data.forEach((bar, i) => {
        const val = chart.data.datasets[0].data[i];
        const label = formatSecondsToHMS(val);

        const x = bar.x;
        const y = bar.y - 6;

        // Outline за по-добър контраст
        ctx.lineWidth = 3;
        ctx.strokeStyle = dark ? '#111' : '#fff';
        ctx.strokeText(label, x, y);

        ctx.fillStyle = dark ? '#fff' : '#000';
        ctx.fillText(label, x, y);
    });
    ctx.restore();
}




plugins: [{
    id: 'barLabelsOnly',
    afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');
        ctx.save();
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        datasetMeta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);

            // Добавяме фон за четимост
            const padding = 2;
            const textWidth = ctx.measureText(label).width;
            const x = bar.x;
            const y = bar.y - 10;

            ctx.fillStyle = dark ? '#222' : '#fff';
            ctx.fillRect(x - textWidth / 2 - padding, y - 12, textWidth + padding * 2, 16);

            ctx.fillStyle = dark ? '#fff' : '#000';
            ctx.fillText(label, x, y);
        });
        ctx.restore();
    }
}]



function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendLine(values);

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    const ratio = window.devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * ratio;
    canvas.height = 400 * ratio;
    canvas.style.height = '400px';
    ctx.scale(ratio, ratio);

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        },
        plugins: [{
            id: 'barLabelsOnly',
            afterDatasetsDraw(chart) {
                const ctx = chart.ctx;
                const datasetMeta = chart.getDatasetMeta(0);
                const dark = document.body.classList.contains('dark-mode');
                ctx.save();
                ctx.fillStyle = dark ? '#ffffff' : 'black';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                datasetMeta.data.forEach((bar, i) => {
                    const val = chart.data.datasets[0].data[i];
                    const label = formatSecondsToHMS(val);
                    ctx.fillText(label, bar.x, bar.y - 6);
                });
                ctx.restore();
            }
        }]
    });
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendLine(values);

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');
    const ratio = window.devicePixelRatio || 1;

    // Истински пиксели спрямо контейнера
    const containerWidth = canvas.parentElement.offsetWidth;

    // Реално пикселно мащабиране, независимо от скалирането на Windows
    canvas.width = containerWidth * ratio;
    canvas.height = 400 * ratio;
    canvas.style.width = containerWidth + 'px';
    canvas.style.height = '400px';
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // Рисувай в пълна резолюция

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                }
            ]
        },
        options: {
            responsive: false, // Важно! За да не презапише мащабите
            plugins: {
                legend: {
                    display: true
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            animation: false
        },
        plugins: [{
            id: 'barLabelsOnly',
            afterDatasetsDraw(chart) {
                const ctx = chart.ctx;
                const datasetMeta = chart.getDatasetMeta(0);
                const dark = document.body.classList.contains('dark-mode');

                ctx.save();
                ctx.fillStyle = dark ? '#ffffff' : 'black';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';

                datasetMeta.data.forEach((bar, i) => {
                    const val = chart.data.datasets[0].data[i];
                    const label = formatSecondsToHMS(val);
                    ctx.fillText(label, bar.x, bar.y - 6);
                });

                ctx.restore();
            }
        }]
    });
}





const ratio = window.devicePixelRatio || 1;
canvas.style.width = rect.width + "px";
canvas.style.height = rect.height + "px";
canvas.width = rect.width * ratio;
canvas.height = rect.height * ratio;
ctx.setTransform(ratio, 0, 0, ratio, 0, 0);




function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById("cobChart");
  const ctx = canvas.getContext("2d");

  // Изчисли реален размер спрямо CSS
  const rect = canvas.getBoundingClientRect();
  const ratio = window.devicePixelRatio || 1;

  // Задай физически размери
  canvas.width = rect.width * ratio;
  canvas.height = rect.height * ratio;

  // Скалирай контекста
  ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

  // Рендерирай графиката
  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: values,
          backgroundColor: "rgba(154, 208, 245, 1)",
          borderColor: "rgba(154, 208, 245, 1)",
          borderWidth: 1,
          order: 1
        },
        {
          label: "Trend Line",
          data: trend,
          type: "line",
          borderColor: "red",
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        title: {
          display: true,
          text: "COB Elapsed Time & Trend",
          color: 'black',
          font: {
            size: 13,
            weight: "bold"
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false
          }
        }
      }
    },
    plugins: [{
      id: "barLabelsOnly",
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);

        ctx.save();
        ctx.fillStyle = "black";
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          ctx.fillText(label, bar.x, bar.y - 6);
        });

        ctx.restore();
      }
    }]
  });
}





function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = canvas.getContext('2d');

  const ratio = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * ratio;
  canvas.height = canvas.clientHeight * ratio;
  ctx.scale(ratio, ratio);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 200, 245, 1)',
          borderColor: 'rgba(154, 200, 245, 1)',
          borderWidth: 1,
          order: 1
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: 'black',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          labels: {
            color: 'black',
            font: {
              size: 12
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const { ctx } = chart;
        const datasetMeta = chart.getDatasetMeta(0);
        ctx.save();
        ctx.fillStyle = 'black';
        ctx.font = `${12}px sans-serif`;
        ctx.textAlign = 'center';

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          ctx.fillText(label, bar.x, bar.y - 6);
        });
        ctx.restore();
      }
    }]
  });
}







function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = canvas.getContext('2d');

  // Висококачествен рендер без ctx.scale()
  const pixelRatio = window.devicePixelRatio || 1;
  canvas.width = 1000 * pixelRatio;
  canvas.height = 400 * pixelRatio;
  canvas.style.width = '1000px';
  canvas.style.height = '400px';
  ctx.setTransform(1, 0, 0, 1, 0, 0); // нулиране
  ctx.scale(pixelRatio, pixelRatio); // правилен начин

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 200, 245, 1)',
          borderColor: 'rgba(154, 200, 245, 1)',
          borderWidth: 1,
          order: 1
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: false, // защото ние контролираме размера
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: 'black',
          font: {
            size: 13,
            weight: 'bold'
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    }
  });
}




function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = canvas.getContext('2d');

  // Фиксирани размери, без скалиране
  canvas.width = 1000;
  canvas.height = 400;

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 200, 245, 1)',
          borderColor: 'rgba(154, 200, 245, 1)',
          borderWidth: 1,
          order: 1
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 2
        }
      ]
    },
    options: {
      responsive: false, // Много важно
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: 'black',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          labels: {
            color: 'black'
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            },
            color: 'black'
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        },
        x: {
          ticks: {
            color: 'black'
          }
        }
      }
    },
    plugins: [
      {
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          const datasetMeta = chart.getDatasetMeta(0);
          ctx.save();
          ctx.fillStyle = 'black';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          datasetMeta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            ctx.fillText(label, bar.x, bar.y - 6);
          });
          ctx.restore();
        }
      }
    ]
  });
}



plugins: [{
  id: 'barLabelsOnly',
  afterDatasetsDraw(chart) {
    const { ctx } = chart;
    const datasetMeta = chart.getDatasetMeta(0);
    const dark = document.body.classList.contains('dark-mode');

    ctx.save();
    ctx.fillStyle = dark ? "#ffffff" : "black";
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";

    datasetMeta.data.forEach((bar, i) => {
      const val = chart.data.datasets[0].data[i];
      const label = formatSecondsToHMS(val);
      ctx.fillText(label, bar.x, bar.y - 6);
    });

    ctx.restore();
  }
}]


document.getElementById("exportGraphsBtn").addEventListener("click", () => {
  const options = ["recordChart", "timingChart", "elapsedChart", "cpuChart"];
  const selected = confirm("Export all graphs as images?");
  const date = document.getElementById("reportDate")?.textContent.trim() || 'export';

  if (selected) {
    options.forEach((id, i) => {
      const canvas = document.getElementById(id);
      if (canvas) {
        html2canvas(canvas.parentElement, {
          scale: 2, // Увеличаване на качеството
          useCORS: true
        }).then(canvasImg => {
          const link = document.createElement("a");
          link.download = `${date}_${id}.png`;
          link.href = canvasImg.toDataURL("image/png", 1.0); // 1.0 = най-високо качество
          link.click();
        });
      }
    });
  }
});



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <title>COB Analyser Report - CSOB PROD</title>
  <link rel="icon" href="https://obamarketforyoungresearchers.be/files/attachments/28736/w1120xh1200q85_KBClogonieuw.png" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root {
      --toggle-bg-light: #333333;
      --toggle-bg-dark: #f0f0f0;
      --thumb-bg-light: #767666;
      --thumb-bg-dark: #d7d7d7;
    }

    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) { background-color: #f9f9f9; }
    tr:nth-child(odd) { background-color: #ffffff; }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    .dark-mode th { background-color: #e0e0e0; }
    .dark-mode table, .dark-mode td {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) { background-color: #2a2a2a; }
    .dark-mode tr:nth-child(odd) { background-color: #222222; }
    .dark-mode canvas { background-color: #1f1f1f; }

    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 40px;
      background: #ffffff;
      color: #111;
      padding: 15px;
      border-radius: 18px;
      box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
      width: 180px;
      z-index: 99999;
      text-align: left;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .dark-mode #toolsPanel {
      background: #222;
      color: #f0f0f0;
    }

    .tools-title {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 10px;
      text-align: center;
    }

    .tool-button {
      width: 100%;
      height: 48px;
      margin: 8px 0;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      padding: 0 14px;
      border-radius: 9999px;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #darkModeToggle {
      background-color: var(--toggle-bg-light);
    }

    .dark-mode #darkModeToggle {
      background-color: var(--toggle-bg-dark);
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      background-color: var(--thumb-bg-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.4s ease, background-color 0.4s ease;
      transform: translateX(0);
    }

    .dark-mode #darkModeToggle .toggle-thumb {
      background-color: var(--thumb-bg-dark);
      transform: translateX(95px);
    }

    #darkModeToggle .icon {
      width: 25px;
      height: 25px;
      font-size: 18px;
      transition: transform 0.6s ease;
    }

    .dark-mode #darkModeToggle .icon {
      transform: rotate(360deg);
    }

    #exportGraphsBtn {
      background-color: #333;
      color: white;
    }

    .dark-mode #exportGraphsBtn {
      background-color: #eee;
      color: #111;
    }
  </style>
</head>
<body>

  <div id="toolsPanel">
    <div class="tools-title">COB Analyser Tools 🛠️</div>

    <button id="darkModeToggle" class="tool-button" title="Toggle Dark Mode">
      <div class="toggle-thumb">
        <span class="icon sun">☀️</span>
      </div>
    </button>

    <button id="exportGraphsBtn" class="tool-button">
      <span class="icon">🖼️</span>&nbsp; Export Graphs
    </button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    const toggleThumb = toggleBtn.querySelector('.toggle-thumb');

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
    });

    // Scroll follows panel
    window.addEventListener('scroll', () => {
      const toolsPanel = document.getElementById('toolsPanel');
      toolsPanel.style.top = `${window.scrollY + 110}px`;
    });

    window.addEventListener('load', () => {
      const toolsPanel = document.getElementById('toolsPanel');
      toolsPanel.style.top = `${window.scrollY + 110}px`;
    });
  </script>
</body>
</html>




<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - CSOB PROD</title>
  <style>
    :root {
      --toggle-bg-light: #333333;
      --toggle-bg-dark: #f0f0f0;
      --thumb-bg-light: #767666;
      --thumb-bg-dark: #d7d7d7;
    }

    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    /* COB Tools Panel */
    #toolsPanel {
      position: fixed;
      top: 120px;
      left: 40px;
      background: #ffffff;
      color: #111;
      border-radius: 18px;
      box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
      padding: 20px 15px;
      width: 180px;
      z-index: 99999;
      transition: background 0.3s ease, color 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: #222;
      color: #f0f0f0;
    }

    .tools-title {
      font-weight: bold;
      font-size: 16px;
      text-align: center;
      margin-bottom: 20px;
    }

    /* Tool Buttons */
    .tool-button {
      width: 100%;
      height: 50px;
      margin-bottom: 15px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 20px;
      cursor: pointer;
      box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #exportGraphsBtn {
      background-color: #333;
      color: white;
    }

    body.dark-mode #exportGraphsBtn {
      background-color: #eee;
      color: #111;
    }

    #exportGraphsBtn .icon {
      font-size: 18px;
    }

    /* Dark Mode Toggle */
    #darkModeToggle {
      width: 100%;
      height: 50px;
      background-color: var(--toggle-bg-light);
      border-radius: 999px;
      box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
      padding: 6px;
      display: flex;
      align-items: center;
      cursor: pointer;
      transition: background-color 0.4s ease;
    }

    body.dark-mode #darkModeToggle {
      background-color: var(--toggle-bg-dark);
    }

    #darkModeToggle .toggle-thumb {
      width: 36px;
      height: 36px;
      background-color: var(--thumb-bg-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.4s ease, background-color 0.4s ease;
      transform: translateX(0);
    }

    body.dark-mode #darkModeToggle .toggle-thumb {
      background-color: var(--thumb-bg-dark);
      transform: translateX(92px);
    }

    #darkModeToggle .icon {
      font-size: 18px;
      transition: transform 0.5s ease;
    }

    body.dark-mode #darkModeToggle .icon {
      transform: rotate(360deg);
    }

    /* Animation on page scroll */
    window, body {
      scroll-behavior: smooth;
    }
  </style>
</head>
<body>
  <div id="toolsPanel">
    <div class="tools-title">COB Analyser Tools 🛠️</div>

    <div id="darkModeToggle" title="Switch Theme">
      <div class="toggle-thumb">
        <span class="icon">☀️</span>
      </div>
    </div>

    <button id="exportGraphsBtn" class="tool-button">
      <span class="icon">🖼️</span>
      Export Graphs
    </button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    const thumb = toggleBtn.querySelector('.toggle-thumb');
    const icon = thumb.querySelector('.icon');

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    });

    // Optional: follow scroll if needed (already positioned fixed, so optional)
    window.addEventListener('scroll', () => {
      const scrollTop = window.scrollY + 120;
      document.getElementById('toolsPanel').style.top = `${scrollTop}px`;
    });
  </script>
</body>
</html>




#darkModeToggle .left-icon {
  margin-right: auto;
  padding-left: 10px;
  transition: opacity 0.3s ease;
}

#darkModeToggle .moon {
  opacity: 0;
  transition: opacity 0.3s ease, transform 1s ease;
}

body.dark-mode #darkModeToggle .left-icon {
  opacity: 0;
}

body.dark-mode #darkModeToggle .moon {
  opacity: 1;
  transform: rotate(360deg);
}


<button id="darkModeToggle" class="tool-button" title="Toggle Dark Mode">
  <span class="icon left-icon">🌞</span>
  <div class="toggle-thumb">
    <span class="icon moon">🌙</span>
  </div>
</button>




<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - SP24 PROD</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    tr:nth-child(odd) {
      background-color: #ffffff;
    }

    .rounded {
      border-radius: 10px;
    }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    .dark-mode th {
      border-color: #e0e0e0;
    }

    .dark-mode table,
    .dark-mode td {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    .dark-mode tr:nth-child(odd) {
      background-color: #222222;
    }

    .dark-mode canvas {
      background-color: #1f1f1f;
    }

    .chart-container {
      width: 100%;
      max-width: 1000px;
      height: 400px;
      margin: auto;
      padding: 10px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    :root {
      --toggle-bg-light: #333333;
      --toggle-bg-dark: #fef0f0;
      --thumb-bg-light: #767666;
      --thumb-bg-dark: #d7d7d7;
    }

    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 41px;
      background: #ffffff;
      color: #111;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
      z-index: 99999;
      transition: background 0.3s ease, color 0.3s ease;
      width: 130px;
      text-align: left;
    }

    body.dark-mode #toolsPanel {
      background: #222;
      color: #fef0f0;
    }

    .tools-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
      text-align: center;
    }

    .tool-button {
      width: 100%;
      height: 40px;
      margin: 8px 0;
      display: flex;
      justify-content: left;
      align-items: center;
      padding-left: 10px;
      border-radius: 9999px;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
      border: none;
      cursor: pointer;
      transition: background 0.3s ease, color 0.3s ease;
    }

    #darkModeToggle {
      background-color: var(--toggle-bg-light);
    }

    body.dark-mode #darkModeToggle {
      background-color: var(--toggle-bg-dark);
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      background-color: var(--thumb-bg-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.4s ease, background-color 0.4s ease;
      transform: translateX(0);
    }

    body.dark-mode #darkModeToggle .toggle-thumb {
      background-color: var(--thumb-bg-dark);
      transform: translateX(32px);
    }

    #darkModeToggle .icon {
      font-size: 18px;
      transition: transform 1s ease;
    }

    body.dark-mode #darkModeToggle .icon {
      transform: rotate(360deg);
    }

    /* Export Button */
    #exportGraphsBtn {
      background-color: #333;
      color: white;
    }

    body.dark-mode #exportGraphsBtn {
      background-color: #eee;
      color: #111;
    }

    #exportGraphsBtn:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div id="toolsPanel">
    <div class="tools-title">COB Analyser<br>Tools 🛠</div>
    <button id="darkModeToggle" class="tool-button" title="Toggle Dark Mode">
      <div class="toggle-thumb">
        <span class="icon">🌞</span>
      </div>
    </button>
    <button id="exportGraphsBtn" class="tool-button">
      🖼 Export<br>Graphs
    </button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    const thumb = toggleBtn.querySelector('.toggle-thumb');
    const icon = thumb.querySelector('.icon');

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
      toggleBtn.classList.toggle('active');
    });
  </script>
</body>
</html>




<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <title>COB Analyser Report - CSOB PROD</title>
  <style>
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.2s, color 0s;
    }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    tr:nth-child(odd) {
      background-color: #ffffff;
    }

    .dark-mode th {
      background-color: #e0e0e0;
    }

    .dark-mode td,
    .dark-mode table {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    .dark-mode tr:nth-child(odd) {
      background-color: #222222;
    }

    .dark-mode canvas {
      background-color: #1f1f1f;
    }

    /* Tools Panel */
    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 40px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 15px;
      box-shadow: 2px 6px 8px rgba(0,0,0,0.3);
      z-index: 99999;
      transition: background 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: rgba(0,0,0,0.6);
    }

    .tools-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 10px;
      text-align: center;
    }

    /* Toggle */
    #darkModeToggle {
      position: relative;
      width: 130px;
      height: 50px;
      background-color: var(--toggle-bg, #333333);
      border-radius: 30px;
      box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.4);
      cursor: pointer;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 5px;
      transition: background-color 0.3s ease;
      margin: 0 auto 10px auto;
    }

    #darkModeToggle .toggle-thumb {
      width: 40px;
      height: 40px;
      background-color: var(--thumb-bg, #767676);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    #darkModeToggle .icon {
      font-size: 22px;
      transition: opacity 0.3s ease, transform 0.5s ease;
      pointer-events: none;
    }

    #darkModeToggle .sun {
      opacity: 1;
    }

    #darkModeToggle .moon {
      opacity: 0;
      position: absolute;
    }

    #darkModeToggle.active .toggle-thumb {
      transform: translateX(80px);
    }

    #darkModeToggle.active .sun {
      opacity: 0;
      transform: rotate(360deg);
    }

    #darkModeToggle.active .moon {
      opacity: 1;
      transform: rotate(360deg);
    }

    body:not(.dark-mode) {
      --toggle-bg: #333333;
      --thumb-bg: #767676;
    }

    body.dark-mode {
      --toggle-bg: #fef0f0;
      --thumb-bg: #d7d7d7;
    }

    /* Export Button */
    #exportGraphsBtn {
      width: 130px;
      height: 50px;
      background-color: #333333;
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #exportGraphsBtn::before {
      content: '🖼️';
      margin-right: 6px;
      font-size: 16px;
    }

    body.dark-mode #exportGraphsBtn {
      background-color: #eeeeee;
      color: #000000;
    }
  </style>
</head>
<body>

  <div id="toolsPanel">
    <div class="tools-title">COB Analyser<br>Tools 🛠️</div>
    
    <div id="darkModeToggle" title="Switch Dark Mode">
      <div class="toggle-thumb">
        <span class="icon sun">🌞</span>
        <span class="icon moon">🌜</span>
      </div>
    </div>

    <button id="exportGraphsBtn">Export<br>Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
      updateChartsTheme?.();
    });
  </script>

</body>
</html>



<style>
  #darkModeToggle {
    width: 100px;
    height: 40px;
    background-color: var(--toggle-bg-light);
    border-radius: 999px;
    position: relative;
    display: flex;
    align-items: center;
    padding: 0;
    overflow: hidden;
    cursor: pointer;
    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease;
  }

  body.dark-mode #darkModeToggle {
    background-color: var(--toggle-bg-dark);
  }

  #darkModeToggle .toggle-thumb {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    background-color: var(--thumb-bg-light);
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translateX(4px);
    transition: transform 0.4s ease, background-color 0.4s ease;
    position: absolute;
    left: 0;
  }

  body.dark-mode #darkModeToggle .toggle-thumb {
    transform: translateX(62px);
    background-color: var(--thumb-bg-dark);
  }

  #darkModeToggle .icon {
    font-size: 18px;
    transition: transform 0.5s ease, opacity 0.4s ease;
    transform-origin: center;
  }

  body.dark-mode #darkModeToggle .icon {
    transform: rotate(360deg);
  }
</style>

<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
  </div>
</div>

<script>
  const toggleBtn = document.getElementById('darkModeToggle');
  const icon = document.getElementById('themeIcon');

  toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    updateChartsTheme?.();
  });
</script>



<style>
  :root {
    --toggle-bg-light: #333333;
    --toggle-bg-dark: #f0f0f0;
    --thumb-bg-light: #767666;
    --thumb-bg-dark: #d7d7d7;
  }

  /* Tools Panel */
  #toolsPanel {
    position: fixed;
    top: 110px;
    left: 41px;
    background: #ffffff;
    color: #111;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
    z-index: 99999;
    transition: background 0.3s ease, color 0.3s ease;
    width: 130px;
    text-align: center;
  }

  body.dark-mode #toolsPanel {
    background: #222;
    color: #f0f0f0;
  }

  .tools-title {
    font-weight: bold;
    font-size: 14px;
    margin-bottom: 10px;
  }

  /* Buttons shared style */
  .tool-button {
    width: 100px;
    height: 40px;
    margin: 8px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 999px;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
    border: none;
    cursor: pointer;
    transition: background 0.3s ease, color 0.3s ease;
  }

  /* Toggle Button */
  #darkModeToggle {
    background-color: var(--toggle-bg-light);
  }

  body.dark-mode #darkModeToggle {
    background-color: var(--toggle-bg-dark);
  }

  #darkModeToggle .toggle-thumb {
    width: 30px;
    height: 30px;
    background-color: var(--thumb-bg-light);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.4s ease, background-color 0.4s ease;
    transform: translateX(0);
  }

  body.dark-mode #darkModeToggle .toggle-thumb {
    background-color: var(--thumb-bg-dark);
    transform: translateX(32px);
  }

  #darkModeToggle .icon {
    font-size: 18px;
    transition: transform 0.5s ease;
  }

  body.dark-mode #darkModeToggle .icon {
    transform: rotate(360deg);
  }

  /* Export Button */
  #exportGraphsBtn {
    background-color: #333;
    color: white;
  }

  body.dark-mode #exportGraphsBtn {
    background-color: #eee;
    color: #111;
  }

  #exportGraphsBtn:hover {
    opacity: 0.9;
  }
</style>

<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>

    <div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
      <div class="toggle-thumb">
        <span class="icon" id="themeIcon">☀️</span>
      </div>
    </div>

    <button id="exportGraphsBtn" class="tool-button">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    const icon = document.getElementById('themeIcon');

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
      updateChartsTheme?.();
    });
  </script>
</body>



<style>
  :root {
    --toggle-bg-light: #333333;
    --toggle-bg-dark: #f0f0f0;
    --thumb-bg-light: #767666;
    --thumb-bg-dark: #d7d7d7;
  }

  #toolsPanel {
    position: fixed;
    top: 110px;
    left: 41px;
    background: rgba(255, 255, 255, 0.85);
    padding: 10px;
    border-radius: 10px;
    box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
    z-index: 99999;
    transition: background 0.3s ease;
  }

  body.dark-mode #toolsPanel {
    background: rgba(0, 0, 0, 0.6);
  }

  .tools-title {
    font-weight: bold;
    margin-bottom: 10px;
    font-size: 14px;
    text-align: center;
  }

  /* Toggle Button */
  #darkModeToggle {
    position: relative;
    width: 72px;
    height: 40px;
    border-radius: 20px;
    background-color: var(--toggle-bg-light);
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    overflow: hidden;
    margin: 0 auto 10px auto;
    transition: background-color 0.4s ease;
  }

  body.dark-mode #darkModeToggle {
    background-color: var(--toggle-bg-dark);
  }

  #darkModeToggle .toggle-thumb {
    width: 30px;
    height: 30px;
    background-color: var(--thumb-bg-light);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.4s ease, background-color 0.4s ease;
    transform: translateX(0);
  }

  body.dark-mode #darkModeToggle .toggle-thumb {
    background-color: var(--thumb-bg-dark);
    transform: translateX(32px);
  }

  #darkModeToggle .icon {
    font-size: 18px;
    transition: transform 0.5s ease;
  }

  body.dark-mode #darkModeToggle .icon {
    transform: rotate(360deg);
  }

  /* Export Button */
  #exportGraphsBtn {
    background-color: #333;
    color: white;
    padding: 10px 20px;
    border-radius: 999px;
    border: none;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    display: block;
    margin: 0 auto;
    transition: background 0.3s ease;
  }

  body.dark-mode #exportGraphsBtn {
    background-color: #eee;
    color: #111;
  }

  #exportGraphsBtn:hover {
    opacity: 0.9;
  }
</style>

<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>

    <div id="darkModeToggle" title="Switch Dark Mode">
      <div class="toggle-thumb">
        <span class="icon" id="themeIcon">☀️</span>
      </div>
    </div>

    <button id="exportGraphsBtn">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    const icon = document.getElementById('themeIcon');

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
      updateChartsTheme?.(); // ако използваш такава функция
    });
  </script>
</body>


<style>
  /* Tools panel */
  #toolsPanel {
    position: fixed;
    top: 110px;
    left: 41px;
    background: rgba(255, 255, 255, 0.85);
    padding: 10px;
    border-radius: 10px;
    box-shadow: 2px 6px 8px rgba(0, 0, 0, 0.3);
    z-index: 99999;
    transition: background 0.3s ease;
  }

  body.dark-mode #toolsPanel {
    background: rgba(0, 0, 0, 0.6);
  }

  .tools-title {
    font-weight: bold;
    margin-bottom: 10px;
    font-size: 14px;
    text-align: center;
  }

  /* Dark mode toggle button */
  #darkModeToggle {
    position: relative;
    width: 72px;
    height: 40px;
    border-radius: 20px;
    background-color: var(--toggle-bg);
    box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 6px;
    overflow: hidden;
    margin: 0 auto 10px auto;
    transition: background-color 0.4s ease, box-shadow 0.45s ease;
  }

  #darkModeToggle .toggle-thumb {
    width: 30px;
    height: 30px;
    background-color: var(--thumb-bg);
    border-radius: 100%;
    position: relative;
  }

  #darkModeToggle .icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 20px;
    transition: left 0.4s ease, transform 0.4s ease, opacity 0.4s ease;
  }

  #darkModeToggle .sun {
    left: 6px;
    opacity: 1;
  }

  #darkModeToggle .moon {
    left: 42px;
    opacity: 0;
  }

  #darkModeToggle.active .sun {
    left: 42px;
    opacity: 0;
    transform: translateY(-50%) rotate(360deg);
  }

  #darkModeToggle.active .moon {
    left: 6px;
    opacity: 1;
    transform: translateY(-50%) rotate(360deg);
  }

  body:not(.dark-mode) {
    --toggle-bg: #333333;
    --thumb-bg: #767666;
  }

  body.dark-mode {
    --toggle-bg: #f0f0f0;
    --thumb-bg: #d7d7d7;
  }

  /* Export button */
  #exportGraphsBtn {
    background-color: #333;
    color: white;
    padding: 10px 20px;
    border-radius: 999px;
    border: none;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
    cursor: pointer;
    display: block;
    margin: 0 auto;
    transition: background 0.3s ease;
  }

  body.dark-mode #exportGraphsBtn {
    background-color: #eee;
    color: #111;
  }

  #exportGraphsBtn:hover {
    opacity: 0.9;
  }
</style>

<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>

    <div id="darkModeToggle" title="Switch Dark Mode">
      <div class="toggle-thumb">
        <span class="icon sun">☀️</span>
        <span class="icon moon">🌙</span>
      </div>
    </div>

    <button id="exportGraphsBtn">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
      updateChartsTheme?.(); // ако имаш тази функция
    });
  </script>
</body>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - SP24 PROD</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    tr:nth-child(odd) {
      background-color: #ffffff;
    }

    .rounded {
      border-radius: 10px;
    }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    .dark-mode th {
      border-color: #e0e0e0;
    }

    .dark-mode table,
    .dark-mode td {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    .dark-mode tr:nth-child(odd) {
      background-color: #222222;
    }

    .dark-mode canvas {
      background-color: #1f1f1f;
    }

    .chart-container {
      width: 100%;
      max-width: 1000px;
      height: 400px;
      margin: auto;
      padding: 10px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 40px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 2px 6px rgba(0,0,0,0.3);
      z-index: 99999;
      transition: background 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: rgba(0,0,0,0.6);
    }

    .tools-title {
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 14px;
      text-align: center;
    }

    #darkModeToggle {
      position: relative;
      width: 72px;
      height: 40px;
      background-color: var(--toggle-bg);
      border-radius: 20px;
      box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 6px;
      overflow: hidden;
      margin: auto;
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      background-color: var(--thumb-bg);
      border-radius: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    #darkModeToggle .icon {
      width: 25px;
      height: 25px;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.5s ease;
      pointer-events: none;
      font-size: 18px;
      transform-origin: center;
    }

    #darkModeToggle .moon {
      position: absolute;
    }

    #darkModeToggle.active .toggle-thumb {
      transform: translateX(42px);
    }

    #darkModeToggle.active .sun {
      opacity: 0;
      transform: rotate(360deg);
    }

    #darkModeToggle.active .moon {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .sun {
      opacity: 1;
      transform: rotate(0deg);
    }

    #darkModeToggle:not(.active) .moon {
      opacity: 0;
      transform: rotate(0deg);
    }

    body:not(.dark-mode) {
      --toggle-bg: #333333;
      --thumb-bg: #676666;
    }

    body.dark-mode {
      --toggle-bg: #fef0f0;
      --thumb-bg: #d7d7d7;
    }

    #exportGraphsBtn {
      margin-top: 10px;
      padding: 10px;
      border-radius: 20px;
      font-size: 12px;
      background-color: var(--toggle-bg);
      color: var(--thumb-bg);
      border: none;
      cursor: pointer;
      display: block;
      margin-left: auto;
      margin-right: auto;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #exportGraphsBtn:hover {
      filter: brightness(1.2);
    }
  </style>
</head>
<body>

<div id="toolsPanel">
  <div class="tools-title">Tools</div>
  <div id="darkModeToggle" title="Switch Dark Mode">
    <div class="toggle-thumb"></div>
    <span class="icon sun">☀️</span>
    <span class="icon moon">🌙</span>
  </div>
  <button id="exportGraphsBtn">Export Graphs</button>
</div>

<script>
  const toggleBtn = document.getElementById('darkModeToggle');
  toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    toggleBtn.classList.toggle('active');
    updateChartsTheme?.();
  });
</script>

</body>
</html>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - SP24 PROD</title>
  <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/...png">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* Запазваме стиловете на таблиците */
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.2s, color 0s;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    tr:nth-child(odd) {
      background-color: #ffffff;
    }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    .dark-mode th {
      border-color: #e0e0e0;
    }

    .dark-mode table, .dark-mode td {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    .dark-mode tr:nth-child(odd) {
      background-color: #222222;
    }

    /* -------------------- TOOLS SECTION -------------------- */
    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 40px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 2px 6px rgba(0, 0, 0, 0.3);
      z-index: 99999;
      transition: background 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: rgba(0, 0, 0, 0.6);
    }

    .tools-title {
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 14px;
      text-align: center;
    }

    #darkModeToggle {
      width: 72px;
      height: 40px;
      border-radius: 20px;
      background-color: var(--toggle-bg);
      transition: background-color 0.4s ease, box-shadow 0.45s ease;
      box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 6px;
      overflow: hidden;
      margin: 0 auto 10px;
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      background-color: var(--thumb-bg);
      border-radius: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    #darkModeToggle .icon {
      width: 25px;
      height: 25px;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.55s ease;
      pointer-events: none;
      font-size: 18px;
      transform-origin: center;
    }

    #darkModeToggle .moon {
      position: absolute;
    }

    #darkModeToggle.active .toggle-thumb {
      transform: translateX(42px);
    }

    #darkModeToggle.active .sun {
      opacity: 0;
      transform: rotate(360deg);
    }

    #darkModeToggle.active .moon {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .sun {
      opacity: 1;
      transform: rotate(0deg);
    }

    #darkModeToggle:not(.active) .moon {
      opacity: 0;
      transform: rotate(0deg);
    }

    body:not(.dark-mode) {
      --toggle-bg: #333333;
      --thumb-bg: #767666;
    }

    body.dark-mode {
      --toggle-bg: #fef0f0;
      --thumb-bg: #d7d7d7;
    }

    #exportGraphsBtn {
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 12px;
      border: none;
      cursor: pointer;
      margin: 0 auto;
      display: block;
      background: #333;
      color: white;
      transition: background 0.3s ease;
    }

    body.dark-mode #exportGraphsBtn {
      background: #eee;
      color: black;
    }
  </style>
</head>

<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>

    <div id="darkModeToggle" title="Switch Dark Mode">
      <span class="toggle-thumb"></span>
      <span class="icon sun">☀️</span>
      <span class="icon moon">🌙</span>
    </div>

    <button id="exportGraphsBtn">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
      updateChartsTheme?.();
    });
  </script>
</body>
</html>








body:not(.dark-mode) {
  --toggle-bg: #e0e0e0;       /* Светлосиво тяло на бутона */
  --thumb-bg: #ffffff;        /* Бяла иконка вътре */
  --panel-bg: rgba(255,255,255,0.85);
  --panel-shadow: rgba(0, 0, 0, 0.1);
  --export-bg: #ffffff;
  --export-text: #222;
  --export-border: #ccc;
}

body.dark-mode {
  --toggle-bg: #2c2c2c;       /* Тъмносиво тяло на бутона */
  --thumb-bg: #444;           /* Тъмна иконка вътре */
  --panel-bg: rgba(20,20,20,0.85);
  --panel-shadow: rgba(0, 0, 0, 0.4);
  --export-bg: #333;
  --export-text: #eee;
  --export-border: #666;
}

/* Tools панел */
#toolsPanel {
  background: var(--panel-bg);
  box-shadow: 0 4px 12px var(--panel-shadow);
  transition: background 0.3s ease, box-shadow 0.3s ease;
}

/* Export бутона */
#exportGraphsBtn {
  background-color: var(--export-bg);
  color: var(--export-text);
  border: 1px solid var(--export-border);
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
}



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - SP24 PROD</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.2s, color 0s;
    }
    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    /* Таблици и графики */
    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
      transition: background-color 0.2s, color 0.2s;
    }
    th { background-color: #b3e0ff; color: black; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    tr:nth-child(odd) { background-color: #ffffff; }

    .dark-mode th {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }
    .dark-mode td {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }
    .dark-mode tr:nth-child(even) { background-color: #2a2a2a; }
    .dark-mode tr:nth-child(odd) { background-color: #222222; }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* TOOLS PANEL */
    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 41px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 2px 6px rgba(0, 0, 0, 0.3);
      z-index: 99999;
      transition: background 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: rgba(0, 0, 0, 0.6);
    }

    .tools-title {
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 14px;
      text-align: center;
    }

    #exportGraphsBtn {
      margin-top: 10px;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 12px;
      border: none;
      cursor: pointer;
      background: #333;
      color: white;
      transition: background 0.3s ease;
    }

    body.dark-mode #exportGraphsBtn {
      background: #e0e0e0;
      color: #111;
    }

    /* DARK MODE TOGGLE */
    #darkModeToggle {
      position: relative;
      width: 72px;
      height: 40px;
      border-radius: 20px;
      background-color: var(--toggle-bg, #333);
      box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
      transition: background-color 0.4s ease, box-shadow 0.45s ease;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      cursor: pointer;
      overflow: hidden;
      margin: 0 auto;
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      border-radius: 100%;
      background-color: var(--thumb-bg, #777);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    #darkModeToggle .icon {
      width: 25px;
      height: 25px;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.55s ease;
      pointer-events: none;
      font-size: 18px;
      transform-origin: center;
    }

    #darkModeToggle .moon { position: absolute; }
    #darkModeToggle.active .toggle-thumb {
      transform: translateX(42px);
    }

    #darkModeToggle.active .sun {
      opacity: 0;
      transform: rotate(360deg);
    }

    #darkModeToggle.active .moon {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .sun {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .moon {
      opacity: 0;
      transform: rotate(0deg);
    }

    body:not(.dark-mode) {
      --toggle-bg: #333333;
      --thumb-bg: #676666;
    }

    body.dark-mode {
      --toggle-bg: #fef0f0;
      --thumb-bg: #d7d7d7;
    }
  </style>
</head>
<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>
    <div id="darkModeToggle" title="Switch Dark Mode">
      <div class="toggle-thumb">
        <span class="icon sun">☀️</span>
        <span class="icon moon">🌙</span>
      </div>
    </div>
    <button id="exportGraphsBtn">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
      updateChartsTheme?.();
    });
  </script>
</body>
</html>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report - SP24 PROD</title>
  <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/28736/w11200hp1200q85_KBClogonieuw.png">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body {
      font-family: "Century Gothic", sans-serif;
      background-color: #f4f4f9;
      font-size: 12px;
      transition: background-color 0.2s, color 0s;
    }

    table {
      border-collapse: collapse;
      width: 30%;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    th, td {
      padding: 10px;
      text-align: center;
      border: 1px solid #b3e0ff;
      transition: background-color 0.2s, color 0s;
    }

    th {
      background-color: #b3e0ff;
      color: black;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    tr:nth-child(odd) {
      background-color: #ffffff;
    }

    .rounded {
      border-radius: 10px;
    }

    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }

    .dark-mode th {
      border-color: #e0e0e0;
    }

    .dark-mode table,
    .dark-mode td {
      background-color: #1f1f1f;
      color: #e0e0e0;
    }

    .dark-mode tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    .dark-mode tr:nth-child(odd) {
      background-color: #222222;
    }

    .dark-mode canvas {
      background-color: #1f1f1f;
    }

    #buttonPanel {
      text-align: center;
      margin-top: 10px;
    }

    .rounded {
      border-radius: 10px;
    }

    .chart-container {
      width: 100%;
      max-width: 1000px;
      height: 400px;
      margin: auto;
      padding: 10px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* Tools panel */
    #toolsPanel {
      position: fixed;
      top: 110px;
      left: 41px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 10px;
      box-shadow: 2px 6px rgba(0, 0, 0, 0.3);
      z-index: 99999;
      transition: background 0.3s ease;
    }

    body.dark-mode #toolsPanel {
      background: rgba(0, 0, 0, 0.6);
    }

    .tools-title {
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 14px;
      text-align: center;
    }

    #exportGraphsBtn {
      margin-top: 10px;
      padding: 10px 10px;
      border-radius: 20px;
      font-size: 12px;
      cursor: pointer;
      background-color: var(--toggle-bg);
      color: white;
      border: none;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
      transition: background-color 0.3s;
    }

    #darkModeToggle {
      position: relative;
      width: 72px;
      height: 40px;
      border-radius: 20px;
      background-color: var(--toggle-bg);
      box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
      transition: background-color 0.4s ease, box-shadow 0.45s ease;
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 6px;
      overflow: hidden;
      margin: auto;
    }

    #darkModeToggle .toggle-thumb {
      width: 30px;
      height: 30px;
      background-color: var(--thumb-bg);
      border-radius: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    #darkModeToggle .icon {
      width: 25px;
      height: 25px;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.55s ease;
      pointer-events: none;
      font-size: 18px;
      transform-origin: center;
    }

    #darkModeToggle .moon {
      position: absolute;
    }

    #darkModeToggle.active .toggle-thumb {
      transform: translateX(42px);
    }

    #darkModeToggle.active .sun {
      opacity: 0;
      transform: rotate(360deg);
    }

    #darkModeToggle.active .moon {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .sun {
      opacity: 1;
      transform: rotate(360deg);
    }

    #darkModeToggle:not(.active) .moon {
      opacity: 0;
      transform: rotate(0deg);
    }

    body:not(.dark-mode) {
      --toggle-bg: #333333;
      --thumb-bg: #676666;
    }

    body.dark-mode {
      --toggle-bg: #fef0f0;
      --thumb-bg: #d7d7d7;
    }
  </style>
</head>

<body>
  <div id="toolsPanel">
    <div class="tools-title">Tools</div>

    <div id="darkModeToggle" title="Switch Dark Mode">
      <span class="toggle-thumb"></span>
      <span class="icon sun">☀️</span>
      <span class="icon moon">🌙</span>
    </div>

    <button id="exportGraphsBtn">Export Graphs</button>
  </div>

  <script>
    const toggleBtn = document.getElementById('darkModeToggle');
    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      toggleBtn.classList.toggle('active');
      updateChartsTheme?.();
    });
  </script>
</body>
</html>



#darkModeToggle {
  position: relative;
  width: 72px;
  height: 40px;
  border-radius: 20px;
  background-color: var(--toggle-bg);
  box-shadow: 2px 8px 9px rgba(0, 0, 0, 0.2);
  transition: background-color 0.4s ease, box-shadow 0.45s ease;
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 6px;
  overflow: hidden;
}

#darkModeToggle .toggle-thumb {
  width: 30px;
  height: 30px;
  background-color: var(--thumb-bg);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.3s ease;
  transform: translateX(0);
}

#darkModeToggle .icon {
  width: 25px;
  height: 25px;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.55s ease;
  pointer-events: none;
  font-size: 18px;
  transform-origin: center;
}

#darkModeToggle .moon {
  position: absolute;
}

#darkModeToggle.active .toggle-thumb {
  transform: translateX(42px);
}

#darkModeToggle.active .sun {
  opacity: 0;
  transform: rotate(360deg);
}

#darkModeToggle.active .moon {
  opacity: 1;
  transform: rotate(360deg);
}

#darkModeToggle:not(.active) .sun {
  opacity: 1;
  transform: rotate(360deg);
}

#darkModeToggle:not(.active) .moon {
  opacity: 0;
  transform: rotate(0deg);
}



<div id="toolsPanel">
  <div class="tools-title">Tools</div>

  <div id="darkModeToggle" title="Switch Dark Mode">
    <span class="toggle-thumb"></span>
    <span class="icon sun">🌞</span>
    <span class="icon moon">🌜</span>
  </div>

  <button id="exportGraphsBtn">Export Graphs</button>
</div>




<div id="toolsPanel">
  <div class="tools-title">Tools</div>
  
  <div id="darkModeToggle" title="Switch Dark Mode">
    <span class="toggle-thumb"></span>
    <span class="icon sun">☀️</span>
    <span class="icon moon">🌙</span>
  </div>

  <button id="exportGraphsBtn" title="Export selected graphs as images">Export Graphs</button>
</div>



#toolsPanel {
  position: absolute;
  left: 20px;
  top: 120px;
  transition: top 0.3s ease;
  z-index: 10000;
}



const toolsPanel = document.getElementById('toolsPanel');

window.addEventListener('load', () => {
  toolsPanel.style.top = `${window.scrollY + 120}px`;
});

window.addEventListener('scroll', () => {
  const scrollTop = window.scrollY + 120;
  toolsPanel.style.top = `${scrollTop}px`;
});





<div id="toolsPanel">
  <div class="tools-title">Tools</div>
  
  <div id="darkModeToggle" title="Switch Dark Mode">
    <span class="toggle-thumb"></span>
    <span class="icon sun">🌞</span>
    <span class="icon moon">🌜</span>
  </div>

  <button id="exportGraphsBtn" class="toggle-button">Export Graphs</button>
</div>



#toolsPanel {
  position: fixed;
  top: 50px;
  left: 10px;
  background: rgba(255, 255, 255, 0.85);
  padding: 15px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
  z-index: 9999;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
body.dark-mode #toolsPanel {
  background: rgba(0, 0, 0, 0.6);
}

.toggle-button {
  width: 100%;
  padding: 8px 12px;
  background: var(--toggle-bg, #f0f0f0);
  color: #333;
  border: none;
  border-radius: 20px;
  font-weight: bold;
  font-size: 13px;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  transition: background 0.3s ease, color 0.3s ease;
}
body.dark-mode .toggle-button {
  background: #444;
  color: #eee;
}


document.getElementById("exportGraphsBtn").addEventListener("click", () => {
  const options = ["recordChart", "timingChart", "elapsedChart", "cpuChart"];
  const selected = confirm("Export all graphs as images?");

  if (selected) {
    options.forEach(id => {
      const canvas = document.getElementById(id);
      if (canvas) {
        html2canvas(canvas.parentElement).then(canvasImg => {
          const link = document.createElement("a");
          link.download = `${id}.png`;
          link.href = canvasImg.toDataURL();
          link.click();
        });
      }
    });
  }
});

#toolsPanel {
  position: fixed;
  top: 50px;
  left: 10px;
  background: rgba(255,255,255,0.85);
  padding: 10px;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  z-index: 9999;
  transition: background 0.3s ease;
}
body.dark-mode #toolsPanel {
  background: rgba(0,0,0,0.6);
}
.tools-title {
  font-weight: bold;
  margin-bottom: 10px;
  font-size: 14px;
  text-align: center;
}
#exportGraphsBtn {
  margin-top: 10px;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
}

<div id="toolsPanel">
  <div class="tools-title">Tools</div>
  <div id="darkModeToggle" title="Switch Dark Mode">
    <span class="toggle-thumb"></span>
    <span class="icon sun">🌞</span>
    <span class="icon moon">🌜</span>
  </div>
  <button id="exportGraphsBtn">Export Graphs</button>
</div>



function updateChartsTheme() {
    const dark = document.body.classList.contains('dark-mode');
    const charts = Chart.instances;

    Object.values(charts).forEach(chart => {
        chart.options.plugins.title.color = dark ? '#ffffff' : '#222222';
        chart.options.plugins.legend.labels.color = dark ? '#f0f0f0' : '#444444';

        chart.options.scales.x.ticks.color = dark ? '#ffffff' : '#333333';
        chart.options.scales.y.ticks.color = dark ? '#ffffff' : '#333333';

        chart.options.scales.x.grid.color = dark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
        chart.options.scales.y.grid.color = dark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
        
        chart.update();
    });
}




<script>
  const darkToggle = document.getElementById('darkModeToggle');

  // Задаваме начална позиция при зареждане
  window.addEventListener('load', () => {
    darkToggle.style.top = `${window.scrollY + 120}px`;
  });

  // Анимирано следване при скрол
  window.addEventListener('scroll', () => {
    const scrollTop = window.scrollY + 120;
    darkToggle.style.top = `${scrollTop}px`;
  });
</script>


#darkModeToggle {
  position: absolute;
  top: 120px;
  left: 20px;
  width: 120px;
  height: 48px;
  border-radius: 20px;
  background-color: var(--toggle-bg);
  box-shadow: 2px 8px 20px rgba(0, 0, 0, 0.2);
  transition: top 0.6s ease-in-out;
  z-index: 9999;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}


<script>
  const darkToggle = document.getElementById('darkModeToggle');

  window.addEventListener('scroll', () => {
    const scrollTop = window.scrollY + 120; // 120px от горе
    darkToggle.style.top = `${scrollTop}px`;
  });
</script>



const toggle = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggle.addEventListener('click', () => {
  icon.style.opacity = 0;
  setTimeout(() => {
    document.body.classList.toggle('dark-mode');
    const isDark = document.body.classList.contains('dark-mode');
    icon.textContent = isDark ? '🌙' : '🌞';
    icon.style.opacity = 1;
  }, 200); // смяна на иконата след кратък fade-out
});

#darkModeContainer {
  position: fixed;
  top: 90px;
  left: 20px;
  z-index: 999;
  text-align: center;
  font-family: sans-serif;
  color: var(--label-color);
}

#darkModeLabel {
  margin-bottom: 6px;
  font-size: 13px;
  font-weight: bold;
  transition: color 0.3s;
}

#darkModeToggle {
  background-color: var(--toggle-bg);
  border: 2px solid var(--toggle-border);
  border-radius: 30px;
  width: 70px;
  height: 36px;
  cursor: pointer;
  transition: background-color 0.3s, border-color 0.3s;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  overflow: hidden;
  display: flex;
  align-items: center;
}

#darkModeToggle .icon {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background-color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  transform: translateX(4px) rotate(0deg);
  transition: transform 0.6s ease, opacity 0.4s ease;
  opacity: 1;
  font-size: 18px;
}

body.dark-mode #darkModeToggle .icon {
  transform: translateX(36px) rotate(360deg);
}

body.dark-mode {
  --toggle-bg: #222;
  --toggle-border: #aaa;
  --label-color: #eee;
}

body:not(.dark-mode) {
  --toggle-bg: #eee;
  --toggle-border: #444;
  --label-color: #111;
}


const toggle = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggle.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');

  const isDark = document.body.classList.contains('dark-mode');
  icon.textContent = isDark ? '🌙' : '🌞';

  // Променяме и позиция и фон автоматично чрез CSS класовете
});

<div id="darkModeToggle">
  <div class="icon" id="themeIcon">🌞</div>
</div>

#darkModeToggle {
  position: fixed;
  top: 90px; /* Местим надолу, за да не покрива снимката */
  left: 20px;
  z-index: 999;
  background-color: var(--toggle-bg);
  border: 2px solid var(--toggle-border);
  border-radius: 30px;
  width: 70px;
  height: 36px;
  cursor: pointer;
  transition: background-color 0.3s, border-color 0.3s;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

#darkModeToggle .icon {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background-color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease;
  transform: translateX(4px);
}

body.dark-mode #darkModeToggle {
  --toggle-bg: #222;
  --toggle-border: #ccc;
}

body:not(.dark-mode) #darkModeToggle {
  --toggle-bg: #eee;
  --toggle-border: #444;
}

body.dark-mode #darkModeToggle .icon {
  transform: translateX(36px); /* по-центрирано спрямо края */
}



#darkModeToggle {
  position: fixed;
  top: 80px;
  left: 20px;
  width: 72px;
  height: 40px;
  border-radius: 20px;
  background-color: var(--toggle-bg);
  transition: background-color 0.4s ease, box-shadow 0.4s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  z-index: 9999;
  overflow: hidden;
  display: flex;
  align-items: center;
  padding: 0 6px;
  cursor: pointer;
}

#darkModeToggle .toggle-thumb {
  width: 30px;
  height: 30px;
  background-color: var(--thumb-bg);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease;
  transform: translateX(0);
}

#darkModeToggle .icon {
  width: 22px;
  height: 22px;
  opacity: 1;
  transition: opacity 0.4s ease;
  pointer-events: none;
  font-size: 18px;
}

#darkModeToggle .moon {
  opacity: 0;
  position: absolute;
}

#darkModeToggle.active .toggle-thumb {
  transform: translateX(32px);
}

#darkModeToggle.active .sun {
  opacity: 0;
}

#darkModeToggle.active .moon {
  opacity: 1;
}

body:not(.dark-mode) {
  --toggle-bg: #f0f0f0;
  --thumb-bg: #ffffff;
}

body.dark-mode {
  --toggle-bg: #333333;
  --thumb-bg: #000000;
}

const toggleBtn = document.getElementById('darkModeToggle');
toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  toggleBtn.classList.toggle('active');
  updateChartsTheme?.();
});


<div id="darkModeToggle">
  <div class="toggle-thumb">
    <span class="icon sun">☀️</span>
    <span class="icon moon">🌙</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
let isDark = false;

toggleBtn.addEventListener('click', () => {
  isDark = !isDark;
  document.body.classList.toggle('dark-mode');
  toggleBtn.classList.toggle('active');
  updateChartsTheme?.(); // извикваш твоята функция при нужда
});


#darkModeToggle {
  position: fixed;
  top: 80px;
  left: 20px;
  width: 70px;
  height: 40px;
  background-color: #e0e0e0;
  border-radius: 20px;
  cursor: pointer;
  z-index: 9999;
  transition: background-color 0.4s ease;
  overflow: hidden;
  display: flex;
  align-items: center;
  padding: 0 5px;
}

#darkModeToggle .toggle-thumb {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background-color: #ffffff;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

#darkModeToggle .icon {
  width: 24px;
  height: 24px;
  pointer-events: none;
}

#darkModeToggle .moon {
  display: none;
}

#darkModeToggle.active {
  background-color: #222;
}

#darkModeToggle.active .toggle-thumb {
  transform: translateX(30px);
  background-color: #333;
}

#darkModeToggle.active .sun {
  display: none;
}

#darkModeToggle.active .moon {
  display: block;
}


<div id="darkModeToggle" class="dark-toggle" title="Toggle Dark Mode">
  <div class="toggle-thumb">
    <svg class="icon sun" viewBox="0 0 24 24"><text x="4" y="17" font-size="18">☀️</text></svg>
    <svg class="icon moon" viewBox="0 0 24 24"><text x="4" y="17" font-size="18">🌙</text></svg>
  </div>
</div>



const toggleBtn = document.getElementById('darkModeToggle');
const emoji = toggleBtn.querySelector('.emoji');
let isDark = false;

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  toggleBtn.classList.toggle('active');

  emoji.style.opacity = 0;
  setTimeout(() => {
    emoji.textContent = isDark ? '☀️' : '🌙';
    emoji.style.opacity = 1;
  }, 200);

  isDark = !isDark;

  updateChartsTheme?.(); // ако ползваш chart update
});




<div id="darkModeToggle" class="dark-toggle" title="Toggle Dark Mode">
  <span class="emoji">☀️</span>
</div>



<script>
  const toggleBtn = document.getElementById('darkModeToggle');
  const emoji = toggleBtn.querySelector('.emoji');
  let isDark = false;

  toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    toggleBtn.classList.toggle('active');

    // Смяна на емоджи
    emoji.textContent = isDark ? '☀️' : '🌙';
    isDark = !isDark;

    updateChartsTheme(); // ако имаш функция за смяна на цветове на chart
  });
</script>


.dark-toggle {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 60px;
  height: 30px;
  background-color: #444;
  border-radius: 30px;
  cursor: pointer;
  z-index: 9999;
  display: flex;
  align-items: center;
  padding: 5px;
  transition: background-color 0.3s;
  overflow: hidden;
}

.dark-toggle .emoji {
  font-size: 22px;
  transition: transform 0.5s ease;
  transform: translateX(0);
}

.dark-toggle.active .emoji {
  transform: translateX(30px) rotate(360deg);
}





document.getElementById('darkModeToggle').addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  document.getElementById('darkModeToggle').classList.toggle('active');
  updateChartsTheme();
});


#darkModeToggle {
  position: fixed;
  top: 100px;
  left: 20px;
  width: 50px;
  height: 25px;
  background-color: #ccc;
  border-radius: 25px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  transition: background-color 0.3s;
  z-index: 999;
}

#darkModeToggle .icon {
  width: 25px;
  height: 25px;
  text-align: center;
  line-height: 25px;
  font-size: 14px;
  transition: transform 0.3s;
}

#darkModeToggle.active {
  background-color: #333;
  justify-content: flex-end;
}

#darkModeToggle.active .sun {
  transform: translateX(-100%);
  opacity: 0;
}

#darkModeToggle:not(.active) .moon {
  transform: translateX(100%);
  opacity: 0;
}


<div id="darkModeToggle">
  <div class="icon sun">☀️</div>
  <div class="icon moon">🌙</div>
</div>




plugins: [{
  id: 'customLabels',
  afterDatasetsDraw(chart) {
    const { ctx, chartArea, data, scales } = chart;
    const cobMeta = chart.getDatasetMeta(0);
    const rrMeta = chart.getDatasetMeta(1);
    const y = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';

    // Вземаме цвета на фона на канваса
    const canvasBackgroundColor = getComputedStyle(ctx.canvas).backgroundColor;

    // Преобразуваме RGB към HEX
    function rgbToHex(rgb) {
      const result = rgb.match(/\d+/g).map((c) => {
        const hex = parseInt(c).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      });
      return `#${result.join('')}`;
    }

    const canvasHexColor = rgbToHex(canvasBackgroundColor);

    // Функция за избор на подходящ текстов цвят спрямо фона
    function getTextColor(backgroundColor) {
      if (backgroundColor.startsWith('#')) {
        backgroundColor = backgroundColor.substring(1);
      }
      const r = parseInt(backgroundColor.substring(0, 2), 16);
      const g = parseInt(backgroundColor.substring(2, 4), 16);
      const b = parseInt(backgroundColor.substring(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 125 ? '#000000' : '#ffffff';
    }

    ctx.fillStyle = getTextColor(canvasHexColor);

    data.labels.forEach((label, i) => {
      const cob = data.datasets[0].data[i];
      const rr = data.datasets[1].data[i];
      const total = cob + rr;

      const x = cobMeta.data[i].x;
      const cobTop = y.getPixelForValue(cob);
      const rrTop = y.getPixelForValue(total);

      if (cob > 0) {
        const cobCenterY = (y.getPixelForValue(0) + cobTop) / 2;
        ctx.fillText(formatHHMM(cob), x, cobCenterY);
      }

      if (rr > 0) {
        const rrCenterY = (cobTop + rrTop) / 2;
        ctx.fillText(formatHHMM(rr), x, rrCenterY);
      }

      if (total > 0) {
        ctx.fillText(formatHHMM(total), x, rrTop - 6);
      }
    });

    ctx.restore();
  }
}]



const canvasBackgroundColor = getComputedStyle(ctx.canvas).backgroundColor;

function rgbToHex(rgb) {
  const result = rgb.match(/\d+/g).map((c) => {
    const hex = parseInt(c).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  });
  return `#${result.join('')}`;
}

const canvasHexColor = rgbToHex(canvasBackgroundColor);
ctx.fillStyle = getTextColor(canvasHexColor);





<button id="toggleDarkMode">Toggle Dark Mode</button>

<script>
document.getElementById('toggleDarkMode').addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    updateChartsTheme();
});

function updateChartsTheme() {
    const dark = document.body.classList.contains('dark-mode');
    const charts = Chart.instances;
    Object.values(charts).forEach(chart => {
        // Заглавие и легенда
        if (chart.options.plugins?.title) {
            chart.options.plugins.title.color = dark ? '#ffffff' : '#222222';
        }
        if (chart.options.plugins?.legend?.labels) {
            chart.options.plugins.legend.labels.color = dark ? '#ffffff' : '#444444';
        }
        // Скали
        if (chart.options.scales?.x?.ticks) {
            chart.options.scales.x.ticks.color = dark ? '#ffffff' : '#333333';
        }
        if (chart.options.scales?.y?.ticks) {
            chart.options.scales.y.ticks.color = dark ? '#ffffff' : '#333333';
        }
        // Cutoff линии (само ако има)
        chart.data.datasets.forEach(dataset => {
            if (dataset.label?.includes('Cutoff')) {
                dataset.borderColor = dark ? '#ffffff' : '#000000'; // Бяло в Dark Mode, Черно в Normal
            }
        });
        chart.update();
    });
}
</script>



label: 'ILC03 Cutoff (22:30)',
data: Array(dates.length).fill(2.5),
borderColor: document.body.classList.contains('dark-mode') ? 'white' : 'black',
borderDash: [10, 5],
pointRadius: 0,
borderWidth: 2



afterDatasetsDraw(chart) {
    const { ctx, chartArea, data, scales } = chart;
    const cobMeta = chart.getDatasetMeta(0);
    const rrMeta = chart.getDatasetMeta(1);
    const y = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';

    // Вземаме фона на канваса
    const canvasBackgroundColor = getComputedStyle(ctx.canvas).backgroundColor;

    // Преобразуваме RGB към HEX
    function rgbToHex(rgb) {
        const result = rgb.match(/\d+/g).map(x => {
            const hex = parseInt(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        });
        return `#${result.join('')}`;
    }

    const canvasHexColor = rgbToHex(canvasBackgroundColor);

    // Настройваме цвета спрямо фона
    ctx.fillStyle = getTextColor(canvasHexColor);

    data.labels.forEach((label, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const x = cobMeta.data[i].x;
        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(total);

        if (cob > 0) {
            const cobCenterY = (y.getPixelForValue(0) + cobTop) / 2;
            ctx.fillText(formatHHMM(cob), x, cobCenterY);
        }
        if (rr > 0) {
            const rrCenterY = (cobTop + rrTop) / 2;
            ctx.fillText(formatHHMM(rr), x, rrCenterY);
        }
        if (total > 0) {
            ctx.fillText(formatHHMM(total), x, rrTop - 6);
        }
    });

    ctx.restore();
}




function getTextColor(backgroundColor) {
    if (backgroundColor.startsWith('#')) {
        backgroundColor = backgroundColor.substring(1);
    }

    const r = parseInt(backgroundColor.substring(0, 2), 16);
    const g = parseInt(backgroundColor.substring(2, 4), 16);
    const b = parseInt(backgroundColor.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;

    return brightness > 125 ? '#000000' : '#ffffff';
}



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dark Mode Example</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body, table, th, td {
            transition: background-color 0.5s, color 0.5s;
        }

        table {
            width: 80%;
            margin: 20px auto;
            border-collapse: collapse;
        }

        th, td {
            padding: 10px;
            border: 1px solid #ccc;
            text-align: center;
        }

        #darkModeToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            background-color: #444;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 9999;
        }

        /* DARK MODE СТИЛОВЕ */
        body.dark-mode {
            background-color: #121212;
            color: white;
        }

        body.dark-mode table {
            background-color: #1e1e1e;
            color: white;
        }

        body.dark-mode th {
            background-color: #333;
            color: #fff;
        }

        body.dark-mode td {
            background-color: #1e1e1e;
            color: #ddd;
        }

        body.dark-mode canvas {
            background-color: #1e1e1e;
        }
    </style>
</head>
<body>

<button id="darkModeToggle">🌙 Dark Mode</button>

<h1 style="text-align: center;">Example Table and Chart</h1>

<table>
    <thead>
        <tr>
            <th>Day</th>
            <th>Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Monday</td>
            <td>10</td>
        </tr>
        <tr>
            <td>Tuesday</td>
            <td>20</td>
        </tr>
    </tbody>
</table>

<div style="width: 60%; margin: 30px auto;">
    <canvas id="myChart"></canvas>
</div>

<script>
    // Chart
    const ctx = document.getElementById('myChart').getContext('2d');
    let myChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Monday', 'Tuesday'],
            datasets: [{
                label: 'Values',
                data: [10, 20],
                backgroundColor: 'rgba(75, 192, 192, 0.6)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });

    // Dark Mode Toggle
    document.getElementById('darkModeToggle').addEventListener('click', function() {
        document.body.classList.toggle('dark-mode');

        if (document.body.classList.contains('dark-mode')) {
            this.innerHTML = '☀️ Light Mode';
        } else {
            this.innerHTML = '🌙 Dark Mode';
        }

        // Презареждане на графиката
        myChart.destroy();
        myChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Monday', 'Tuesday'],
                datasets: [{
                    label: 'Values',
                    data: [10, 20],
                    backgroundColor: document.body.classList.contains('dark-mode') 
                        ? 'rgba(255, 99, 132, 0.6)' 
                        : 'rgba(75, 192, 192, 0.6)',
                    borderColor: document.body.classList.contains('dark-mode') 
                        ? 'rgba(255, 99, 132, 1)' 
                        : 'rgba(75, 192, 192, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });
    });
</script>

</body>
</html>




function getTextColor() {
    return document.body.classList.contains('dark-mode') ? 'white' : 'black';
}



body {
    transition: background-color 0.5s, color 0.5s;
}

.dark-mode {
    background-color: #121212;
    color: #e0e0e0;
}

/* Таблиците */
.dark-mode table, .dark-mode td, .dark-mode th {
    background-color: #1f1f1f;
    color: #e0e0e0;
    border-color: #333;
}

/* Оставяме заглавията светли */
table th {
    background-color: #b3e0ff;
    color: black;
}

/* Графиките */
.dark-mode canvas {
    background-color: #1f1f1f;
}

/* Плавна промяна за таблици също */
table, th, td {
    transition: background-color 0.5s, color 0.5s;
}




.dark-mode table {
    background-color: #1e1e1e;
    color: #ffffff;
}
.dark-mode th, .dark-mode td {
    background-color: #2c2c2c;
    color: #ffffff;
    border-color: #444;
}
.dark-mode tr:nth-child(even) {
    background-color: #2a2a2a;
}
.dark-mode tr:nth-child(odd) {
    background-color: #222222;
}



<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <title>COB Analyser Report - SP24 PROD</title>
    <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/28736/w11200hp1200g5S_KBClogonieu.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        body {
            font-family: "Century Gothic", sans-serif;
            background-color: #f4f4f9;
            font-size: 12px;
        }
        table {
            border-collapse: collapse;
            width: 30%;
            margin: 20px auto;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #b3e0ff;
        }
        th {
            background-color: #b3e0ff;
            color: black;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:nth-child(odd) {
            background-color: #ffffff;
        }
        .rounded {
            border-radius: 10px;
        }
        .dark-mode {
            background-color: #121212;
            color: #ffffff;
        }
        .dark-mode table {
            background-color: #1e1e1e;
            color: #ffffff;
        }
        .dark-mode th, .dark-mode td {
            border-color: #444;
        }
        #buttonPanel {
            text-align: center;
            margin-top: 10px;
        }
        #buttonPanel button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
        }
    </style>
</head>

<body>

<div id="buttonPanel">
    <button id="toggleDarkMode">Toggle Dark Mode</button>
    <button id="exportPdf">Export to PDF</button>
</div>

<h2 style="text-align:center;">SP24 PROD COB Analyser Report</h2>

<!-- Тук си е твоето съдържание с таблици, графики и т.н. -->

<table id="recordsTable" class="rounded">
    <tr><th colspan="10">COB last 10 Elapsed Time & Transactions</th></tr>
</table>

<div class="chart-container" style="max-width: 800px; margin: auto;">
    <canvas id="elapsedChart"></canvas>
</div>

<!-- JavaScript за Charts, Buttons -->

<script>
function renderElapsedChart() {
    const ctx = document.getElementById('elapsedChart').getContext('2d');
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Sample 1', 'Sample 2', 'Sample 3'],
            datasets: [{
                label: 'Records Per Minute',
                data: [10, 20, 15],
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 2,
                borderRadius: 15,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        color: '#333'
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time vs Transactions',
                    color: '#222',
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    labels: {
                        color: '#444',
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}
renderElapsedChart();

// Toggle Dark Mode
document.getElementById('toggleDarkMode').addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    updateChartsTheme();
});

function updateChartsTheme() {
    const dark = document.body.classList.contains('dark-mode');
    const charts = Chart.instances;
    Object.values(charts).forEach(chart => {
        chart.options.plugins.title.color = dark ? '#ffffff' : '#222222';
        chart.options.plugins.legend.labels.color = dark ? '#ffffff' : '#444444';
        chart.options.scales.x.ticks.color = dark ? '#ffffff' : '#333333';
        chart.options.scales.y.ticks.color = dark ? '#ffffff' : '#333333';
        chart.update();
    });
}

// Export to PDF
document.getElementById('exportPdf').addEventListener('click', () => {
    html2canvas(document.body).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
        pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
        pdf.save('COB_Report.pdf');
    });
});
</script>

</body>
</html>





while true; do
  while true; do
    exec 3>&1
    MASK=$(dialog --nocancel --inputbox "Enter search mask for $SEARCH_TYPE:" 8 50 2>&1 1>&3)
    exec 3>&-
    [[ -n "$MASK" ]] && break
    dialog --msgbox "Mask cannot be empty!" 6 40
  done
  logger "INFO" "Mask entered: $MASK"

  TMP_OUT=$(mktemp)

  ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"
dzdo bash -o vi <<'INNER'
$(cat ./lib/functions)

cd /opt/t24/tafj/bin
echo "[Switched to user \$(whoami)]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"
sql_query "${SEARCH_TYPE}" "${MASK}" "$dbtools"
INNER
EOF

  clear && clear

  TMP_OUT_COLOR=$(grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -F'|' '{printf "'"\${SEARCH_TYPE}"' \Zb\Z1%s\Zn is installed on \Zb\Z4%s\Zn\n", $1, $2}')
  grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -F'|' -v type="$SEARCH_TYPE" '{print type, $1, "is installed on", $2}' > ./debug_log.tmp

  while read -r line; do
    logger "DEBUG" "$line"
  done < ./debug_log.tmp

  dialog_window=$(wc -l ./debug_log.tmp | awk '{print $1}')
  dialog_window=$((dialog_window + 5))

  dialog --colors \
    --title "Results for '$MASK'" \
    --yes-label "Search again" \
    --no-label "Exit" \
    --yesno "$TMP_OUT_COLOR" $dialog_window 90

  RESPONSE=$?
  logger "INFO" "SSH execution complete"

  if [[ "$RESPONSE" -ne 0 ]]; then
    break
  fi
done







TMP_OUT_COLOR=$(grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -v type="$SEARCH_TYPE" -F '|' '{printf type " \Zb\Z1%s\Zn is installed on \Zb\Z4%s\Zn\n", $1, $2}')



ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"

dzdo su - je35696 -s /bin/bash <<'INNER'
$(cat ./lib/sql_query.sh)

echo "[Switched to user \$(whoami)]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"

sql_query "${SEARCH_TYPE}" "${MASK}"
INNER
EOF





ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"

dzdo su - je35696 -c "$(cat <<EOF_INNER
$(declare -f sql_query)

echo "[Switched to user \`whoami\`]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"
sql_query "${SEARCH_TYPE}" "${MASK}"
EOF_INNER
)"
EOF





# Зареждаме функцията локално
source ./lib/sql_query.sh

# Инжектираме функцията и променливите в SSH + dzdo
ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"

dzdo su - je35696 -c "$(cat <<'INNER'
$(declare -f sql_query)

echo "[Switched to user \$(whoami)]"
echo "You selected: $SEARCH_TYPE"
echo "Searching for: $MASK"

sql_query "$SEARCH_TYPE" "$MASK"
INNER
)"
EOF




ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"
dzdo su - je35696 -c '
  $(declare -f sql_query)
  echo "[Switched to user \$(whoami)]"
  echo "You selected: ${SEARCH_TYPE}"
  echo "Searching for: ${MASK}"
  sql_query "${SEARCH_TYPE}" "${MASK}"
'
EOF





ssh "${USER}@${HOSTNAME}" 'bash -s' -- "$SEARCH_TYPE" "$MASK" < ./lib/sql_query.sh > "$TMP_OUT" 2>&1




<script>
function parseTimeToMinutes(timeStr) {
  const parts = timeStr.split(":");
  if (parts.length === 3) {
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 60 + minutes + seconds / 60;
  }
  return null;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const cobStart = [], cobStop = [], rrStart = [], rrStop = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 7) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10); // банков ден като число

    // референтен час – използваме го за откриване на време след полунощ
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t; // добави 24 часа ако е след полунощ
    }

    dates.push(date);
    cobStart.push(adjustTime(cells[1].innerText));
    cobStop.push(adjustTime(cells[2].innerText));
    rrStart.push(adjustTime(cells[5].innerText));
    rrStop.push(adjustTime(cells[6].innerText));
  }

  return { dates, cobStart, cobStop, rrStart, rrStop };
}

function renderTimingChart() {
  const ctx = document.getElementById("timingChart").getContext("2d");
  const { dates, cobStart, cobStop, rrStart, rrStop } = getTimingChartData();

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Start Time",
          data: cobStart,
          borderColor: 'rgba(255, 99, 132, 1)',
          tension: 0.3
        },
        {
          label: "COB End Time",
          data: cobStop,
          borderColor: 'rgba(54, 162, 235, 1)',
          tension: 0.3
        },
        {
          label: "RR Start Time",
          data: rrStart,
          borderColor: 'rgba(75, 192, 192, 1)',
          tension: 0.3
        },
        {
          label: "RR Stop Time",
          data: rrStop,
          borderColor: 'rgba(153, 102, 255, 1)',
          tension: 0.3
        },
        {
          label: "RR Cutoff (04:48)",
          data: Array(dates.length).fill(1728), // 4*60 + 48 = 288 + 1440
          borderColor: 'orange',
          borderDash: [10, 5],
          pointRadius: 0,
          borderWidth: 2
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          min: 1260,  // 21:00
          max: 1800,  // 06:00
          ticks: {
            callback: function(value) {
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          },
          title: {
            display: true,
            text: 'Time (HH:mm)'
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB & RR Times vs Cutoff Threshold',
          color: '#222',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          display: true
        }
      }
    }
  });
}
</script>




<script>
function parseTimeToMinutes(timeStr, reference = null) {
  const parts = timeStr.split(":");
  if (parts.length !== 3) return 0;

  let hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  const seconds = parseInt(parts[2], 10);

  let totalMinutes = hours * 60 + minutes + seconds / 60;

  if (reference !== null && totalMinutes < reference - 300) {
    totalMinutes += 1440; // преминаване след полунощ
  }

  return totalMinutes;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const cobStart = [], cobStop = [], rrStart = [], rrStop = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText;
    const startTime = parseTimeToMinutes(cells[1].innerText); // COB Start е референцията

    const stopTime = parseTimeToMinutes(cells[2].innerText, startTime);
    const rrStartTime = parseTimeToMinutes(cells[3].innerText, startTime);
    const rrStopTime = parseTimeToMinutes(cells[4].innerText, startTime);

    dates.push(date);
    cobStart.push(startTime);
    cobStop.push(stopTime);
    rrStart.push(rrStartTime);
    rrStop.push(rrStopTime);
  }

  return { dates, cobStart, cobStop, rrStart, rrStop };
}

function renderTimingChart() {
  const ctx = document.getElementById("timingChart").getContext("2d");
  const { dates, cobStart, cobStop, rrStart, rrStop } = getTimingChartData();

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: dates,
      datasets: [
        {
          label: 'COB Start Time',
          data: cobStart,
          borderColor: 'rgba(255, 99, 132, 1)',
          tension: 0.3
        },
        {
          label: 'COB End Time',
          data: cobStop,
          borderColor: 'rgba(54, 162, 235, 1)',
          tension: 0.3
        },
        {
          label: 'RR Start Time',
          data: rrStart,
          borderColor: 'rgba(75, 192, 192, 1)',
          tension: 0.3
        },
        {
          label: 'RR Stop Time',
          data: rrStop,
          borderColor: 'rgba(153, 102, 255, 1)',
          tension: 0.3
        },
        {
          label: 'RR Cutoff (04:48)',
          data: Array(dates.length).fill(1728),
          borderColor: 'orange',
          borderDash: [10, 5],
          pointRadius: 0,
          borderWidth: 2
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          min: 1260,
          max: 1780,
          ticks: {
            callback: function(value) {
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          },
          title: {
            display: true,
            text: 'Time (HH:mm)'
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB & RR Times vs Cutoff Threshold',
          color: '#222',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          display: true
        }
      }
    }
  });
}
</script>



function parseTimeToMinutes(timeStr) {
  const parts = timeStr.split(":");
  if (parts.length === 3) {
    let hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 60 + minutes + seconds / 60;
  }
  return null;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10); // банков ден

    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t; // ако е след полунощ – добави 24 часа
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time };
}



<script>
function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return null;

    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);

    let total = h * 60 + m + s / 60;

    if (reference !== null && total < reference - 300) {
        total += 1440; // След полунощ
    }

    return total;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const refTime = parseTimeToMinutes(cells[2].innerText); // COB Start

        if (refTime === null) continue;

        dates.push(date);
        cobStart.push(refTime);
        ilc03time.push(parseTimeToMinutes(cells[1].innerText, refTime));
        cobStop.push(parseTimeToMinutes(cells[3].innerText, refTime));
        rrStart.push(parseTimeToMinutes(cells[6].innerText, refTime));
        rrStop.push(parseTimeToMinutes(cells[7].innerText, refTime));
        a77Time.push(parseTimeToMinutes(cells[9].innerText, refTime));
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                { label: 'ILC03 Time', data: ilc03time, borderColor: 'rgba(155, 99, 132, 1)', tension: 0.3 },
                { label: 'COB Start Time', data: cobStart, borderColor: 'rgba(255, 99, 132, 1)', tension: 0.3 },
                { label: 'COB End Time', data: cobStop, borderColor: 'rgba(54, 162, 235, 1)', tension: 0.3 },
                { label: 'RR Start Time', data: rrStart, borderColor: 'rgba(75, 192, 192, 1)', tension: 0.3 },
                { label: 'RR Stop Time', data: rrStop, borderColor: 'rgba(175, 92, 192, 1)', tension: 0.3 },
                { label: 'A77 Time', data: a77Time, borderColor: 'rgba(54, 113, 35, 1)', tension: 0.3 },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: 'black',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(90),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: 'Time (HH:mm)'
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60) % 24;
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB & RR Times vs Cutoff Threshold',
                    color: '#222',
                    font: { size: 13, weight: 'bold' }
                },
                legend: { display: true }
            }
        }
    });
}
</script>




callback: {
    label: function(context) {
        const value = context.raw;
        const h = Math.floor(value / 60);
        const m = Math.floor(value % 60);
        return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    }
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const refTime = parseTimeToMinutes(cells[2].innerText); // COB Start

        if (refTime === null) continue;

        dates.push(date);
        cobStart.push(refTime);
        ilc03time.push(parseTimeToMinutes(cells[1].innerText, refTime));
        cobStop.push(parseTimeToMinutes(cells[3].innerText, refTime));
        rrStart.push(parseTimeToMinutes(cells[6].innerText, refTime));
        rrStop.push(parseTimeToMinutes(cells[7].innerText, refTime));
        a77Time.push(parseTimeToMinutes(cells[9].innerText, refTime));
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}


function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return null;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return null;

    let total = hours * 60 + minutes + seconds / 60;

    // Shift next-day entries over 24h window
    if (reference !== null && total < reference - 300) {
        total += 1440;
    }

    return total;
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const cobStartText = cells[2].innerText;
        const cobStartMinutes = parseTimeToMinutes(cobStartText);  // без reference, това Е reference

        // Парсваме останалите с тази стойност като reference
        const ilc03Minutes = parseTimeToMinutes(cells[1].innerText, cobStartMinutes);
        const cobStopMinutes = parseTimeToMinutes(cells[3].innerText, cobStartMinutes);
        const rrStartMinutes = parseTimeToMinutes(cells[6].innerText, cobStartMinutes);
        const rrStopMinutes = parseTimeToMinutes(cells[7].innerText, cobStartMinutes);
        const a77Minutes = parseTimeToMinutes(cells[9].innerText, cobStartMinutes);

        dates.push(date);
        cobStart.push(cobStartMinutes);
        ilc03time.push(ilc03Minutes);
        cobStop.push(cobStopMinutes);
        rrStart.push(rrStartMinutes);
        rrStop.push(rrStopMinutes);
        a77Time.push(a77Minutes);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}






function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);

    let totalMinutes = hours * 60 + minutes + seconds / 60;

    // Ако времето е след полунощ и по-малко от reference, премести с +1440 минути
    if (reference !== null && totalMinutes < reference - 300) {
        totalMinutes += 1440;
    }

    return totalMinutes;
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;

        // 1. COB Start as reference
        const cobStartText = cells[2].innerText;
        const cobStartMin = parseTimeToMinutes(cobStartText);
        cobStart.push(cobStartMin);

        // 2. Parse rest with reference
        const ilcTime = parseTimeToMinutes(cells[1].innerText, cobStartMin);
        const cobStopTime = parseTimeToMinutes(cells[3].innerText, cobStartMin);
        const rrStartTime = parseTimeToMinutes(cells[6].innerText, cobStartMin);
        const rrStopTime = parseTimeToMinutes(cells[7].innerText, cobStartMin);
        const a77_Time = parseTimeToMinutes(cells[9].innerText, cobStartMin);

        dates.push(date);
        ilc03time.push(ilcTime);
        cobStop.push(cobStopTime);
        rrStart.push(rrStartTime);
        rrStop.push(rrStopTime);
        a77Time.push(a77_Time);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}




<script>
function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        const hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        if (reference !== null && totalMinutes < reference - 300) {
            totalMinutes += 1440; // добави 24 часа ако е след полунощ
        }

        return totalMinutes;
    }
    return 0;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const reference = parseTimeToMinutes(cells[2].innerText); // COB Start

        const startTime = reference;

        const ilcTime = parseTimeToMinutes(cells[1].innerText, startTime);
        const cobStartTime = parseTimeToMinutes(cells[2].innerText, startTime);
        const cobStopTime = parseTimeToMinutes(cells[3].innerText, startTime);
        const rrStartTime = parseTimeToMinutes(cells[6].innerText, startTime);
        const rrStopTime = parseTimeToMinutes(cells[7].innerText, startTime);
        const a77_Time = parseTimeToMinutes(cells[9].innerText, startTime);

        dates.push(date);
        ilc03time.push(ilcTime);
        cobStart.push(cobStartTime);
        cobStop.push(cobStopTime);
        rrStart.push(rrStartTime);
        rrStop.push(rrStopTime);
        a77Time.push(a77_Time);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 122, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A77 Time',
                    data: a77Time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: 'black',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(90),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200, // 20:00
                    max: 1680, // 04:00
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60) % 24;
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB & RR Times vs Cutoff Threshold',
                    color: '#222',
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}
</script>


<script>
function parseTimeToMinutes(timeString, referenceMinutes = null) {
    const parts = timeString.split(":");
    if (parts.length !== 3) return 0;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    let totalMinutes = hours * 60 + minutes + seconds / 60;

    if (referenceMinutes !== null && totalMinutes < referenceMinutes) {
        totalMinutes += 1440; // означава, че времето е на следващия ден
    }

    return totalMinutes;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobstart = [], cobstop = [], rrstart = [], rrstop = [], a77time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const cobStartText = cells[2].innerText;

        const cobStartMinutes = parseTimeToMinutes(cobStartText); // базово
        const ilc03Minutes = parseTimeToMinutes(cells[1].innerText, cobStartMinutes);
        const cobStopMinutes = parseTimeToMinutes(cells[3].innerText, cobStartMinutes);
        const rrStartMinutes = parseTimeToMinutes(cells[6].innerText, cobStartMinutes);
        const rrStopMinutes = parseTimeToMinutes(cells[7].innerText, cobStartMinutes);
        const a77Minutes = parseTimeToMinutes(cells[9].innerText, cobStartMinutes);

        dates.push(date);
        ilc03time.push(ilc03Minutes);
        cobstart.push(cobStartMinutes);
        cobstop.push(cobStopMinutes);
        rrstart.push(rrStartMinutes);
        rrstop.push(rrStopMinutes);
        a77time.push(a77Minutes);
    }

    return { dates, ilc03time, cobstart, cobstop, rrstart, rrstop, a77time };
}
</script>



function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440;
        }

        return totalMinutes;
    }
    return 0;
}




function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        // Shift if after midnight and earlier than the reference (like COB Start)
        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440;
        }

        return totalMinutes;
    }
    return 0;
}



const startTime = parseTimeToMinutes(cells[2].innerText); // COB Start

const stopTime = parseTimeToMinutes(cells[3].innerText, startTime);  // COB Stop
const rrStartTime = parseTimeToMinutes(cells[6].innerText, startTime);
const rrStopTime = parseTimeToMinutes(cells[7].innerText, startTime);
const a77Time = parseTimeToMinutes(cells[9].innerText, startTime);
const ilc03Process = parseTimeToMinutes(cells[1].innerText, startTime);




function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        // Ако reference е под 300 мин (5ч), и времето е < reference => преминаване след полунощ
        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440; // добавя 24ч
        }

        return totalMinutes;
    }
    return 0;
}






awk -F '|' '
  /Package/ && $1 ~ /^Package / && NF >= 2 {
    printf "\\Z1%s\\Zn\\Z2 is installed on \\Zn\\Z1%s\\Zn\n", $1, $2
  }
'



awk -F '|' '
  /Package/ && $1 ~ /^Package / && NF >= 2 {
    printf "\Z1%s \Zn\Z2%s\Zn\n", $1, $2
  }
'



output=$(ssh user@host '
  SQL="SELECT RECID, SAVED_DATE FROM V_F_T24_MODEL_PACKAGES WHERE RECID LIKE '\''R20_KHP%'\'' ORDER BY SAVED_DATE"
  echo "$SQL" | /path/to/sqlcli | grep -v "RECID\|rows selected\|Transaction committed" | awk -F"|" '\''{
    printf "\\Zb\\Z2Package %s\\Zn is installed on \\Zb\\Z4%s\\Zn\n", $1, $2
  }'\'
')

dialog --colors --title "Installed Packages" --msgbox "$output" 20 70




awk -F"|" '!/RECID|rows selected|Transaction committed/ && NF >= 2 {
    print "\\Zb\\Z1" $1 "\\Zn"
    print "\\Zb\\Z2" $2 "\\Zn"
}'




awk -F"|" '!/RECID|rows selected|Transaction committed/ && NF >= 2 {
    printf "\\\\Zb\\\\Z1%s\\\\Zn\\\\n\\\\Zb\\\\Z2%s\\\\Zn", $1, $2
}'




# 1. Въвеждане на маска след избора на Package/Update
while true; do
    exec 3>&1
    MASK=$(dialog --nocancel --inputbox "Enter search mask for $SEARCH_TYPE:" 8 50 2>&1 1>&3)
    exec 3>&-
    [[ -n "$MASK" ]] && break
    dialog --msgbox "Mask cannot be empty!" 6 40
done
logger "INFO" "Mask entered: $MASK"

# 2. Създаваме временно файлче за резултата
TMP_OUT=$(mktemp)

# 3. SSH с dzdo + вътрешна логика
ssh "$HOSTNAME" bash <<EOF > "$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"
dzdo su user <<INNER
echo "[Switched to user]"
echo "You selected: $SEARCH_TYPE"
echo "Searching for: $MASK"
# Примерна симулация:
echo "Found entry matching mask: $MASK"
exit
INNER
EOF

# 4. Показване на изхода от SSH в dialog
dialog --title "Results for '$MASK'" --textbox "$TMP_OUT" 20 70
rm -f "$TMP_OUT"
logger "INFO" "SSH execution complete"




# Създаваме временен файл за изхода
TMP_OUT=$(mktemp)

# SSH с dzdo + вътрешни команди
ssh "$HOSTNAME" bash <<EOF > "$TMP_OUT" 2>&1
echo "[CONNECTED as \$(whoami)]"
dzdo su user <<INNER
echo "[SWITCHED to user]"
echo "Searching for $SEARCH_TYPE with mask: $MASK"
# Тук може да добавиш реална команда по-късно
echo "Result for: $MASK"
exit
INNER
EOF

# Показване на резултата в диалог
dialog --title "SSH Output ($SEARCH_TYPE)" --textbox "$TMP_OUT" 20 80
rm -f "$TMP_OUT"




#!/bin/bash

CONFIG_FILE="./conf/dev.conf"
LOG_DIR="./log"
LOGLEVEL="DEBUG"
mkdir -p "$LOG_DIR"
LOGFILE="$LOG_DIR/dialog_$(date +%Y%m%d_%H%M%S).log"

# Logger function
logger() {
    local level=$1
    local message=$2
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOGLEVEL" == "DEBUG" && "$level" =~ ^(DEBUG|INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "INFO"  && "$level" =~ ^(INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "ERROR" && "$level" == "ERROR" ]]; then
        echo "$timestamp [$level] $message" >> "$LOGFILE"
    fi
}

# Validate non-empty input
validate_input() {
    if [[ -z "$1" ]]; then
        dialog --title "Error" --msgbox "Field cannot be empty. Please try again." 6 50
        return 1
    fi
    return 0
}

# Ask for hostname
while true; do
    exec 3>&1
    HOSTNAME=$(dialog --nocancel --inputbox "Enter Hostname:" 8 50 2>&1 1>&3)
    exec 3>&-
    validate_input "$HOSTNAME" && break
done
logger "INFO" "User entered hostname: $HOSTNAME"

# Check for SP/TPH if hostname matches pattern
if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    exec 3>&1
    ENV_SELECTED=$(dialog --nocancel --menu "Select Environment:" 10 40 2 \
        "SP24" "Service Pack 24" \
        "TPH"  "TPH Environment" 2>&1 1>&3)
    exec 3>&-
    logger "INFO" "Environment selected: $ENV_SELECTED"
else
    ENV_SELECTED="N/A"
    logger "DEBUG" "Hostname doesn't match .hu.srv.dev. Skipping env select."
fi

# Ask what to search
exec 3>&1
SEARCH_TYPE=$(dialog --nocancel --menu "What do you want to search?" 10 40 2 \
    "Package" "Search for a package" \
    "Update"  "Search for an update" 2>&1 1>&3)
exec 3>&-
logger "INFO" "Search type selected: $SEARCH_TYPE"

# Confirm and execute SSH (placeholder for now)
dialog --title "SSH Execution" --infobox "Connecting to $HOSTNAME..." 5 40
logger "DEBUG" "Executing SSH to $HOSTNAME"
ssh "$HOSTNAME" "echo Hello from $HOSTNAME" >> "$LOGFILE" 2>&1
logger "INFO" "SSH command executed"

dialog --title "Done" --msgbox "SSH command executed. Check $LOGFILE for output." 6 50
clear





#!/bin/bash

CONFIG_FILE="./conf/dev.conf"
LOG_DIR="./log"
LOGLEVEL="DEBUG"
mkdir -p "$LOG_DIR"
LOGFILE="$LOG_DIR/dialog_$(date +%Y%m%d_%H%M%S).log"

# Logger function
logger() {
    local level=$1
    local message=$2
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOGLEVEL" == "DEBUG" && "$level" =~ ^(DEBUG|INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "INFO"  && "$level" =~ ^(INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "ERROR" && "$level" == "ERROR" ]]; then
        echo "$timestamp [$level] $message" >> "$LOGFILE"
    fi
}

# Validate non-empty input
validate_input() {
    if [[ -z "$1" ]]; then
        dialog --title "Error" --msgbox "Field cannot be empty. Please try again." 6 50
        return 1
    fi
    return 0
}

# Ask for hostname
while true; do
    exec 3>&1
    HOSTNAME=$(dialog --nocancel --inputbox "Enter Hostname:" 8 50 2>&1 1>&3)
    exec 3>&-
    validate_input "$HOSTNAME" && break
done
logger "INFO" "User entered hostname: $HOSTNAME"

# Check for SP/TPH if hostname matches pattern
if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    exec 3>&1
    ENV_SELECTED=$(dialog --nocancel --menu "Select Environment:" 10 40 2 \
        "SP24" "Service Pack 24" \
        "TPH"  "TPH Environment" 2>&1 1>&3)
    exec 3>&-
    logger "INFO" "Environment selected: $ENV_SELECTED"
else
    ENV_SELECTED="N/A"
    logger "DEBUG" "Hostname doesn't match .hu.srv.dev. Skipping env select."
fi

# Ask what to search
exec 3>&1
SEARCH_TYPE=$(dialog --nocancel --menu "What do you want to search?" 10 40 2 \
    "Package" "Search for a package" \
    "Update"  "Search for an update" 2>&1 1>&3)
exec 3>&-
logger "INFO" "Search type selected: $SEARCH_TYPE"

# Confirm and execute SSH (placeholder for now)
dialog --title "SSH Execution" --infobox "Connecting to $HOSTNAME..." 5 40
logger "DEBUG" "Executing SSH to $HOSTNAME"
ssh "$HOSTNAME" "echo Hello from $HOSTNAME" >> "$LOGFILE" 2>&1
logger "INFO" "SSH command executed"

dialog --title "Done" --msgbox "SSH command executed. Check $LOGFILE for output." 6 50
clear




#!/bin/bash

CONF_DIR="./conf"
LOG_DIR="./log"
mkdir -p "$LOG_DIR"

LOG_FILE="${LOG_DIR}/log_$(date +%Y%m%d_%H%M%S).log"
touch "$LOG_FILE"

log() {
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

get_input() {
    local prompt=$1
    local result_var=$2
    while true; do
        exec 3>&1
        value=$(dialog --clear --backtitle "Host Configuration" \
            --inputbox "$prompt" 8 50 2>&1 1>&3)
        exec 3>&-
        if [[ -z "$value" ]]; then
            dialog --msgbox "Value cannot be empty." 6 40
        else
            eval "$result_var=\"$value\""
            log "$prompt: $value"
            break
        fi
    done
}

select_environment() {
    exec 3>&1
    env_choice=$(dialog --clear --backtitle "Environment Choice" \
        --menu "Hostname matches .hu.srv.dev. Choose environment:" 10 50 2 \
        1 "SP24" \
        2 "TPH" \
        2>&1 1>&3)
    exec 3>&-

    case $env_choice in
        1) ENV_NAME="SP24";;
        2) ENV_NAME="TPH";;
        *) ENV_NAME="UNKNOWN";;
    esac

    log "Selected ENV: $ENV_NAME"
}

# Main
get_input "Enter Hostname:" HOSTNAME

if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    select_environment
else
    ENV_NAME="Unknown"
    log "Hostname does not match .hu.srv.dev. Skipping ENV selection."
fi

dialog --msgbox "Hostname: $HOSTNAME\nEnvironment: $ENV_NAME\nLog saved to $LOG_FILE" 10 60
clear




#!/bin/bash

CONFIG_FILE="./conf/config.conf"
source "$CONFIG_FILE"

# Проверка за наличен dialog
if ! command -v dialog &>/dev/null; then
    echo "dialog is not installed!"
    exit 1
fi

# Избор на хост
dialog --inputbox "Enter Hostname:" 10 60 2>temp_hostname
HOSTNAME=$(<temp_hostname)
rm -f temp_hostname

# Проверка за .hu.srv.dev или .hu.srv.acc
if [[ "$HOSTNAME" == *".hu.srv.dev"* || "$HOSTNAME" == *".hu.srv.acc"* ]]; then
    dialog --menu "Environment Detected. Select:" 10 50 2 \
        "SP24" "Service Pack 24" \
        "TPH" "TPH Environment" 2>temp_env
    ENV_SELECTED=$(<temp_env)
    rm -f temp_env
else
    ENV_SELECTED="UNKNOWN"
fi

# Потвърждение
dialog --msgbox "Hostname: $HOSTNAME\nDetected Env: $ENV_SELECTED" 10 50
clear





use_shadow = OFF
use_colors = ON

screen_color = (BLACK,BLACK,OFF)
shadow_color = (BLACK,BLACK,OFF)
dialog_color = (BLACK,BLACK,OFF)
title_color = (GREEN,BLACK,OFF)
border_color = (GREEN,BLACK,OFF)
button_active_color = (GREEN,BLACK,OFF)
button_inactive_color = (GREEN,BLACK,OFF)
button_key_active_color = (GREEN,BLACK,OFF)
button_key_inactive_color = (GREEN,BLACK,OFF)
button_label_active_color = (GREEN,BLACK,OFF)
button_label_inactive_color = (GREEN,BLACK,OFF)
inputbox_color = (GREEN,BLACK,OFF)
searchbox_color = (GREEN,BLACK,OFF)





aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = OFF
use_colors = ON

screen_color = (GREEN,BLACK,OFF)
shadow_color = (GREEN,BLACK,OFF)
dialog_color = (GREEN,BLACK,OFF)
title_color = (GREEN,BLACK,OFF)
border_color = (GREEN,BLACK,OFF)
button_active_color = (GREEN,BLACK,OFF)
button_inactive_color = (GREEN,BLACK,OFF)
button_key_active_color = (GREEN,BLACK,OFF)
button_key_inactive_color = (GREEN,BLACK,OFF)
button_label_active_color = (GREEN,BLACK,OFF)
button_label_inactive_color = (GREEN,BLACK,OFF)
inputbox_color = (GREEN,BLACK,OFF)
inputbox_border_color = (GREEN,BLACK,OFF)
searchbox_color = (GREEN,BLACK,OFF)
searchbox_title_color = (GREEN,BLACK,OFF)
searchbox_border_color = (GREEN,BLACK,OFF)
position_indicator_color = (GREEN,BLACK,OFF)
uarrow_color = (GREEN,BLACK,OFF)
darrow_color = (GREEN,BLACK,OFF)
itemhelp_color = (GREEN,BLACK,OFF)
form_active_text_color = (GREEN,BLACK,OFF)
form_text_color = (GREEN,BLACK,OFF)
form_item_readonly_color = (GREEN,BLACK,OFF)
menubox_color = (GREEN,BLACK,OFF)
menubox_border_color = (GREEN,BLACK,OFF)
item_color = (GREEN,BLACK,OFF)
item_selected_color = (GREEN,BLACK,OFF)
tag_color = (GREEN,BLACK,OFF)
tag_selected_color = (GREEN,BLACK,OFF)
tag_key_color = (GREEN,BLACK,OFF)
tag_key_selected_color = (GREEN,BLACK,OFF)
check_color = (GREEN,BLACK,OFF)
check_selected_color = (GREEN,BLACK,OFF)
gauge_color = (GREEN,BLACK,OFF)






aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = OFF
use_colors = ON

screen_color             = (BLACK,DEFAULT,OFF)
shadow_color             = (BLACK,GREEN,OFF)
dialog_color             = (BLACK,BLACK,OFF)
title_color              = (GREEN,BLACK,OFF)
border_color             = (BLACK,BLACK,OFF)

button_active_color      = (BLACK,GREEN,OFF)
button_inactive_color    = (BLACK,BLACK,OFF)
button_key_active_color  = (BLACK,GREEN,OFF)
button_key_inactive_color= (RED,BLACK,OFF)
button_label_active_color= (BLACK,GREEN,OFF)
button_label_inactive_color= (BLACK,BLACK,OFF)




# ~/.mydialogrc

# Черен фон и зелен текст
use_shadow = NO
screen_color = BLACK
title_color = GREEN
border_color = GREEN
dialog_color = BLACK
inputbox_color = GREEN
textbox_color = GREEN
button_active_color = GREEN
button_inactive_color = GREEN






dialog --colors --title "Error" --msgbox "You have entered GLOW J*******: \Zb\Z1${curr_user}\Zn" 6 50





import os
import shutil
import datetime
import Tkinter as tk
import tkMessageBox
import tkFileDialog

CONFIG_FILE = "transfer_tool.conf"

def read_config(path):
    config = {}
    if not os.path.exists(path):
        return config
    for line in open(path):
        if "=" in line:
            k, v = line.strip().split("=", 1)
            config[k.strip()] = v.strip().strip('"')
    return config

config = read_config(CONFIG_FILE)
VERSION = config.get("VERSION", "1.0")
USER = config.get("USER", "defaultuser")
UPDATE_SOURCE = config.get("UPDATE_SOURCE", "")
LOG_DIR = config.get("LOG_DIR", "C:/Users/{}/OneDrive/Logs".format(USER))

def get_transfer_dir():
    now = datetime.datetime.now()
    folder = "C:/Users/{}/OneDrive/file_transfer_{}/{}".format(USER, now.year, now.strftime("%Y%m%d"))
    if not os.path.exists(folder):
        os.makedirs(folder)
    return folder

def run_scp_download():
    host = host_entry.get()
    remote = remote_entry.get()
    if not host or not remote:
        tkMessageBox.showerror("Error", "Enter host and remote path.")
        return
    filename = os.path.basename(remote)
    local_path = os.path.join(get_transfer_dir(), filename)
    result = os.system('scp {}:"{}" "{}"'.format(host, remote, local_path))
    if result == 0:
        tkMessageBox.showinfo("Downloaded", "Saved to:\n{}".format(local_path))
    else:
        tkMessageBox.showerror("Error", "Download failed.")

def run_scp_upload():
    host = host_entry.get()
    if not host:
        tkMessageBox.showerror("Error", "Enter host.")
        return
    local = tkFileDialog.askopenfilename()
    if not local:
        return
    remote = remote_entry.get() or "~/"
    result = os.system('scp "{}" {}:"{}"'.format(local, host, remote))
    if result == 0:
        tkMessageBox.showinfo("Uploaded", "File uploaded to:\n{}:{}".format(host, remote))
    else:
        tkMessageBox.showerror("Error", "Upload failed.")

def check_update():
    if not os.path.exists(UPDATE_SOURCE):
        tkMessageBox.showerror("Update", "Source not found.")
        return
    remote_version = None
    for line in open(UPDATE_SOURCE):
        if line.startswith("VERSION="):
            remote_version = line.split("=")[1].strip().strip('"')
            break
    if remote_version and remote_version > VERSION:
        if tkMessageBox.askyesno("Update", "New version {} available.\nUpdate?".format(remote_version)):
            shutil.copy(UPDATE_SOURCE, os.path.realpath(__file__))
            tkMessageBox.showinfo("Updated", "Script updated. Restart now.")
    else:
        tkMessageBox.showinfo("No Update", "You have the latest version.")

root = tk.Tk()
root.title("File Transfer Tool v{}".format(VERSION))

tk.Label(root, text="Host (user@host):").grid(row=0, column=0, sticky="e")
host_entry = tk.Entry(root, width=40)
host_entry.grid(row=0, column=1)

tk.Label(root, text="Remote Path:").grid(row=1, column=0, sticky="e")
remote_entry = tk.Entry(root, width=40)
remote_entry.grid(row=1, column=1)

tk.Button(root, text="Download", command=run_scp_download).grid(row=2, column=0, pady=10)
tk.Button(root, text="Upload", command=run_scp_upload).grid(row=2, column=1, pady=10)
tk.Button(root, text="Check for Update", command=check_update).grid(row=3, column=0, columnspan=2, pady=5)
tk.Button(root, text="Exit", command=root.quit).grid(row=4, column=0, columnspan=2, pady=10)

root.mainloop()




#!/bin/bash

# === ИНИЦИАЛИЗАЦИЯ ===
script_dir="$(cd "$(dirname "$0")" && pwd)"
script_name="$(basename "$0")"
script_path="$script_dir/$script_name"
conf_path="$script_dir/${script_name%.*}.conf"
SCP_ERR_LOG="/tmp/${script_name}_scp_error.log"

# === ЗАРЕЖДАНЕ НА КОНФИГУРАЦИЯ ===
if [[ ! -f "$conf_path" ]]; then
  dialog --title "Error" --msgbox "Missing config: ${conf_path}" 6 50
  exit 1
fi
. "$conf_path"

# === AUTO-UPDATE ===
if [[ -f "$UPDATE_SOURCE" ]]; then
  remote_conf="${UPDATE_SOURCE%.*}.conf"
  remote_version="$(grep VERSION "$remote_conf" 2>/dev/null | cut -d= -f2 | tr -d '"')"
  local_version="$(echo "$VERSION" | tr -d '"')"

  if [[ "$remote_version" > "$local_version" ]]; then
    dialog --infobox "Updating to version $remote_version..." 3 40
    sleep 1
    cp "$UPDATE_SOURCE" "$script_path.tmp" && chmod +x "$script_path.tmp"
    cp "$remote_conf" "$conf_path.tmp"
    cat > "$script_dir/update_runner.sh" <<EOF
#!/bin/bash
mv "$script_path.tmp" "$script_path"
mv "$conf_path.tmp" "$conf_path"
rm -- "\$0"
exec "$script_path"
EOF
    chmod +x "$script_dir/update_runner.sh"
    exec "$script_dir/update_runner.sh"
    exit
  fi
fi

# === ДАТА + ПАПКИ ===
date_check=$(date +%Y%m%d)
year_check=$(date +%Y)
base_path="/cygdrive/c/Users/$USER/OneDrive/file_transfer_${year_check}/${date_check}"

mkdir -p "$base_path" 2>/dev/null

# === ПРОМПТ ЗА HOST ===
ask_host() {
  host=$(dialog --stdout --title "Enter hostname" --inputbox "Enter SSH hostname (user@host):" 8 50)
  if [[ -z "$host" ]]; then return 1; fi
  return 0
}

# === DOWNLOAD ===
download_file() {
  ask_host || return
  remote_file=$(dialog --stdout --inputbox "Enter full remote file path:" 8 50)
  [ -z "$remote_file" ] && return
  filename=$(basename "$remote_file")
  local_path="$base_path/$filename"

  dialog --infobox "Downloading..." 3 30
  scp "$host:$remote_file" "$local_path" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Downloaded to:\n$local_path" 6 50
  else
    dialog --msgbox "Download failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === UPLOAD ===
upload_file() {
  ask_host || return
  local_file=$(dialog --stdout --fselect "/cygdrive/c/" 14 60)
  [ -z "$local_file" ] && return
  dest_path=$(dialog --stdout --inputbox "Remote destination path:" 8 50 "~")
  [ -z "$dest_path" ] && return

  dialog --infobox "Uploading..." 3 30
  scp "$local_file" "$host:$dest_path" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Uploaded to:\n$host:$dest_path" 6 50
  else
    dialog --msgbox "Upload failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === PSCP (от Windows) ===
pscp_download() {
  remote_file=$(dialog --stdout --inputbox "Enter remote path (PSCP):" 8 50)
  [ -z "$remote_file" ] && return
  file_name=$(basename "$remote_file")
  local_dest="$base_path/$file_name"

  dialog --infobox "Downloading via PSCP..." 3 40
  pscp "$remote_file" "$local_dest" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Saved to $local_dest" 6 50
  else
    dialog --msgbox "PSCP failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === UPDATE CHECK ===
check_update() {
  if [[ -f "$UPDATE_SOURCE" ]]; then
    remote_conf="${UPDATE_SOURCE%.*}.conf"
    remote_version="$(grep VERSION "$remote_conf" | cut -d= -f2 | tr -d '"')"
    if [[ "$remote_version" > "$VERSION" ]]; then
      dialog --msgbox "Update available: $remote_version (you have $VERSION)" 6 50
    else
      dialog --msgbox "You're on the latest version: $VERSION" 5 40
    fi
  else
    dialog --msgbox "Cannot reach update source." 5 40
  fi
}

# === МЕНЮ ===
while true; do
  choice=$(dialog --clear --menu "File Transfer Utility (v$VERSION)" 15 50 6 \
    1 "Download File" \
    2 "Upload File" \
    3 "PSCP Download" \
    4 "Check for Update" \
    5 "Exit" \
    --stdout)

  case "$choice" in
    1) download_file ;;
    2) upload_file ;;
    3) pscp_download ;;
    4) check_update ;;
    5|*) clear; exit 0 ;;
  esac
done










#!/bin/bash

# -------- Load configuration --------
script_dir="$(dirname "$0")"
script_name="$(basename "$0")"
# Convert script_dir to absolute path
script_dir="$(cd "$script_dir" && pwd)"
script_path="$script_dir/$script_name"
conf_file="${script_name%.*}.conf"
conf_path="$script_dir/$conf_file"

if [ ! -f "$conf_path" ]; then
    dialog --title "Error" --msgbox "Configuration file '$conf_file' not found!" 6 50
    clear
    exit 1
fi

# Source config file (expected to define VERSION, UPDATE_SOURCE, LOG_DIR, DEFAULT_HOST, etc.)
. "$conf_path"

# Temporary file for capturing SCP/PSCP error messages
SCP_ERR_LOG="/tmp/${script_name}_scp_error.log"

# -------- Convert Windows path to Cygwin path for UPDATE_SOURCE if needed --------
if [[ -n "$UPDATE_SOURCE" && "$UPDATE_SOURCE" =~ ^[A-Za-z]: ]]; then
    drive_letter="${UPDATE_SOURCE:0:1}"
    drive_lower="$(echo "$drive_letter" | tr '[:upper:]' '[:lower:]')"
    win_path="${UPDATE_SOURCE:2}"    # drop "C:" (drive letter and colon)
    # Replace backslashes with forward slashes
    win_path=$(printf "%s" "$win_path" | tr '\\' '/')
    # Remove leading slash to avoid double slashes
    clean_path="${win_path#/}"
    UPDATE_SOURCE="/cygdrive/${drive_lower}/${clean_path}"
fi

# -------- Auto-update check at startup --------
if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
    remote_conf="${UPDATE_SOURCE%.*}.conf"
    remote_version=""
    if [ -f "$remote_conf" ]; then
        remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
    else
        remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
    fi
    local_version="$(echo "$VERSION" | tr -d '"')"
    if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
        # Compare versions
        newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
        if [ "$newest" != "$local_version" ]; then
            # Newer version available, perform self-update
            dialog --infobox "New version $remote_version is available. Updating now..." 4 50
            sleep 1
            dialog --clear

            # Copy new script and config from update source
            cp -f "$UPDATE_SOURCE" "$script_path.tmp"
            if [ -f "$remote_conf" ]; then
                cp -f "$remote_conf" "$conf_path.tmp"
            fi
            chmod +x "$script_path.tmp"

            # Create an update script to replace the running script safely
            updater="$script_dir/update_temp.sh"
            cat > "$updater" <<EOF
#!/bin/bash
mv -f "$script_path.tmp" "$script_path"
if [ -f "$conf_path.tmp" ]; then
    mv -f "$conf_path.tmp" "$conf_path"
fi
rm -f "\$0"
exec "$script_path" "$@"
EOF
            chmod +x "$updater"
            # Run the update script (this will replace the current process)
            exec "$updater" "$@"
            # If exec fails, exit to avoid continuing old code
            exit 1
        fi
    fi
fi

# -------- Dialog main menu loop --------
while true; do
    CHOICE=$(dialog --clear --title "Main Menu" \
            --menu "Choose an option:" 15 50 5 \
            1 "Download File" \
            2 "Upload File" \
            3 "PSCP Download" \
            4 "Check for Updates" \
            5 "Exit" \
            --stdout)
    STATUS=$?
    if [ $STATUS -ne 0 ]; then
        # User pressed Cancel/ESC
        break
    fi

    case $CHOICE in
        1)  # Download File
            # Prompt for remote file path
            remote_path=$(dialog --title "Download File" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue  # back to menu if canceled or empty
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "Download File" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            # If destination is a directory (ends with /), append file name
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file, please wait..." 3 50
            scp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                # Log the transfer
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        2)  # Upload File
            # File selector for local file to upload
            initial_dir="/"
            if [ -d "/cygdrive" ]; then
                initial_dir="/cygdrive/"
            fi
            local_file=$(dialog --title "Upload File" --fselect "$initial_dir" 15 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$local_file" ]; then
                continue
            fi
            # Prompt for remote destination path
            remote_dest=$(dialog --title "Upload File" --inputbox "Enter remote destination path on $DEFAULT_HOST:\n(directory or filename)" 8 60 "~/" --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_dest" ]; then
                continue
            fi

            dialog --infobox "Uploading file, please wait..." 3 50
            scp -q "$local_file" "$DEFAULT_HOST:$remote_dest" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File uploaded successfully to:\n$DEFAULT_HOST:$remote_dest" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Uploaded $local_file to $DEFAULT_HOST:$remote_dest" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Upload failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR uploading $local_file to $DEFAULT_HOST:$remote_dest. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        3)  # PSCP Download
            if ! command -v pscp >/dev/null 2>&1; then
                dialog --title "Error" --msgbox "PSCP not found. Please ensure PuTTY's pscp is installed and in PATH." 7 60
                continue
            fi
            remote_path=$(dialog --title "PSCP Download" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "PSCP Download" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file (using PSCP), please wait..." 3 60
            pscp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            pscp_status=$?
            dialog --clear

            if [ $pscp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - [PSCP] Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "PSCP download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR [PSCP] downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        4)  # Check for Updates
            if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
                remote_conf="${UPDATE_SOURCE%.*}.conf"
                remote_version=""
                if [ -f "$remote_conf" ]; then
                    remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
                else
                    remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
                fi
                local_version="$(echo "$VERSION" | tr -d '"')"
                if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
                    newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
                    if [ "$newest" != "$local_version" ]; then
                        dialog --title "Update Available" --msgbox "A newer version ($remote_version) is available.\n(Current version: $local_version)\nIt will be downloaded on next script start." 8 60
                    else
                        dialog --title "No Update" --msgbox "You have the latest version ($local_version)." 6 50
                    fi
                else
                    dialog --title "Check Failed" --msgbox "Could not check for updates (source not accessible or version info missing)." 7 60
                fi
            else
                dialog --title "Check for Updates" --msgbox "Update source is not configured or accessible." 6 50
            fi
            ;;
        5)  # Exit
            break
            ;;
    esac
done

# Clean up and exit
dialog --clear
clear
exit 0







#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password below)"

  ssh -q "JF200069@$host" bash <<'EOF' > /tmp/log_buffer
    cd /opt/t24/support_scripts/log_search
    sudo su - $host_user <<EOSU
      (
        spin='|/-\'
        i=0
        echo -n "[ ] Processing logs..."
        ./unique_logs.sh > temp_log &
        pid=$!
        while kill -0 \$pid 2>/dev/null; do
          printf "\r[%c] Processing logs..." "\${spin:\$((i++ % 4)):1}"
          sleep 0.2
        done
        wait \$pid
        printf "\r✓ Logs collected.         \n"
        cat temp_log
        rm -f temp_log
      )
EOSU
EOF

  # Save output to final file
  cat /tmp/log_buffer > "$log_file"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local pid=$1
  local spinstr='|/-\'
  while kill -0 "$pid" 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"

  # Стартираме SSH във фон и пазим PID
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  ssh_pid=$!
  spin "$ssh_pid"
  wait "$ssh_pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local spinstr='|/-\'
  for i in $(seq 1 10); do
    for j in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$j:1}"
      sleep 0.15
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"
  
  ssh -q "JF200069@$host" bash <<EOF > "$log_file"
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  spin
done

echo -e "\nAll logs downloaded to: $full_path"





#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

# Създай основна и поддиректории
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Анимация: въртящ се спинър
spin() {
  local pid=$1
  local env_name=$2
  local spinstr='|/-\'
  echo ""
  echo -e "\n==============================="
  echo -e "  Downloading logs from $env_name"
  echo -e "===============================\n"

  while kill -0 $pid 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Please wait..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\rDone downloading logs from %s\n" "$env_name"
  echo ""
}

# Основен цикъл
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  # Стартирай SSH във фон
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  pid=$!
  spin "$pid" "$env_name"
  wait "$pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория и подпапки
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# ✅ Въвеждане на пароли (без echo)
declare -A passwords
echo "Въведи SSH паролите за средите:"
for env in "${envs[@]}"; do
  read -s -p "Парола за $env: " pass
  echo ""
  passwords["$env"]="$pass"
done

# ✅ Цикъл с expect логика вътре
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  pass="${passwords[$env_name]}"
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  echo "▶ Downloading logs from $env_name..."

  expect <<EOF
  spawn ssh $host
  expect "assword:"
  send "$pass\r"
  expect "\$ "
  send "sudo su - $host_user\r"
  expect "# "
  send "cd /opt/t24/support_scripts/log_search\r"
  expect "# "
  send "./unique_logs.sh > $log_file\r"
  expect "# "
  send "exit\r"
  expect "\$ "
  send "exit\r"
EOF

  echo "✔ Завършено за $env_name → ${env_name}/${env_name}_${dateLogs}_unique.log"
done




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория за дата ако не съществува
if [ ! -d "$full_path" ]; then
  mkdir -p "$full_path"
fi

# Създаване на поддиректории по среди
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Обхождане на сървърите
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo ">> $env_name on $host"

  ssh -q "$host" bash <<EOF > "${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done






#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

cd "/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo "Running on $host for $env_name with user $host_user..."

  ssh -q "$host" bash <<EOF > "${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done




def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    restarted_found = False

    # Заглавен ред
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() != "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            restarted_found = True

    # Ако няма рестартирани — специален ред
    if not restarted_found:
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]






def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    jboss_marker = "FALSE"

    # Добавяме header реда (винаги в началото)
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() == "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: green;'><b>{status}</b></td></tr>\n"
        else:
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            jboss_marker = "TRUE"

    # Ако никой не е рестартирал — пишем само един ред
    if jboss_marker == "FALSE":
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    # Заменяме вътрешността на таблицата
    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]




#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2
            if (log_date >= limit) {
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Хващане на "No such file or directory" като ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                if (key != "" && key != "\\\"") {
                  print key \"|\" \"[\" host \"] [\" file \"] \" \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-



#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          # Проверка за [ERROR] и дължина
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2

            # Сравняваме датата по низ (формат YYYY-MM-DD)
            if (log_date >= limit) {

              # Ограничаваме само до желаните типове
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Ако съдържа "No such file or directory", правим го фиксиран ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                # Само ако имаме key, отпечатваме
                if (key != "" && key != "\"") {
                  print key "|" "[" host "] [" file "] " \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-






#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in \${LOG_DIR}/*mdb.log \${LOG_DIR}/*runtime.log \${LOG_DIR}/*database.log \${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        /\[ERROR\]/ && length(\$0) <= maxlen {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

              # Фиксирана проверка за честа грешка
              if (\$0 ~ /No such file or directory/) {
                key = "No such file or directory"
              } else {
                match(\$0, /\} *(.*)/, arr)
                key = arr[1]
              }

              if (key != "" && key != "\"") {
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
  match($0, /No such file or directory/, nsf)
  if (nsf[0] != "") {
    key = "No such file or directory"
  } else {
    match($0, /\} *(.*)/, arr)
    key = arr[1]
  }
  if (key != "" && key != "\"") {
    print key "|" "[" host "] [" file "] " $0
  }
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Responsive Chart & Table</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html {
      font-size: 16px;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }

    .container {
      max-width: 90vw;
      margin: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 2rem;
    }

    th, td {
      border: 1px solid #aaa;
      padding: 0.5rem;
      font-size: 0.9rem;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>

<div class="container">
  <h2>Sample Table</h2>
  <table>
    <tr>
      <th>Date</th>
      <th>COB Elapsed</th>
    </tr>
    <tr>
      <td>2025-04-01</td>
      <td>01:23:00</td>
    </tr>
    <tr>
      <td>2025-04-02</td>
      <td>00:45:00</td>
    </tr>
    <tr>
      <td>2025-04-03</td>
      <td>01:10:00</td>
    </tr>
  </table>

  <h2>Responsive Chart</h2>
  <canvas id="cobChart"></canvas>
</div>

<script>
function parseHMS(str) {
  const [h, m, s] = str.split(':').map(Number);
  return h * 3600 + m * 60 + s;
}

function formatSecondsToHMS(totalSec) {
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function fixCanvasResolution(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return ctx;
}

window.onload = function () {
  const canvas = document.getElementById("cobChart");
  const ctx = fixCanvasResolution(canvas);

  const labels = ['2025-04-01', '2025-04-02', '2025-04-03'];
  const rawTimes = ['01:23:00', '00:45:00', '01:10:00'];
  const values = rawTimes.map(parseHMS);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'COB Elapsed',
        data: values,
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        },
        legend: {
          display: true
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: value => formatSecondsToHMS(value)
          },
          title: {
            display: true,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    }
  });
};
</script>

</body>
</html>







#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" -v host="${server}" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-









#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" '
    LIMIT_DATE='"$LIMIT_DATE"'
    LOG_DIR='"$LOG_DIR"'

    for f in ${LOG_DIR}/*.log; do
      awk -v limit="$LIMIT_DATE" -v file="$f" '
      /\[ERROR\]/ && length($0) <= 600 {
          log_date = $2
          if (log_date >= limit) {
              if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
                  match($0, /\} *(.*)/, arr)
                  if (arr[1] != "" && arr[1] != "\"") {
                      key = arr[1]
                      print key "|" "[" file "] " $0
                  }
              }
          }
      }' "$f"
    done
  ' 
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-








#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|" "[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-







#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|||___LINE___|||[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -u -t'|||___LINE___|||' -k1,1 | cut -d'|||___LINE___|||' -f2




for f in *.log; do
  awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '
  /\[ERROR\]/ && length($0) <= 100 {
      date_str = $2
      if (date_str >= limit) print FILENAME ": " $0
  }' "$f"
done



awk -v limit="$(date -d '7 days ago' +%Y-%m-%dT%H:%M:%S)" '
$0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/ && 
/ERROR/ && 
length($0) <= 100 {
    gsub(",", "", $2); # премахва ,111 от часа
    ts = $1 "T" $2;
    if (ts >= limit) print
}' файл.log




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Export Example</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    body { font-family: Arial; padding: 20px; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
    }
    th, td {
      border: 1px solid #333;
      padding: 6px 10px;
      font-size: 12px;
    }
    canvas {
      max-width: 100%;
      margin-bottom: 40px;
    }
    @media print {
      .pagebreak {
        page-break-before: always;
      }
    }
  </style>
</head>
<body>

<button onclick="exportToPDF()" style="margin-bottom: 20px;">Export Full Page to PDF</button>

<div id="exportArea">
  <h2>Sample Report</h2>

  <!-- Table -->
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>COB Elapsed</th>
        <th>RR Elapsed</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>2025-03-01</td><td>01:30:00</td><td>00:45:00</td></tr>
      <tr><td>2025-03-02</td><td>01:45:00</td><td>01:15:00</td></tr>
      <tr><td>2025-03-03</td><td>02:00:00</td><td>00:50:00</td></tr>
    </tbody>
  </table>

  <!-- Chart -->
  <canvas id="sampleChart" width="800" height="300"></canvas>

  <div class="pagebreak"></div>

  <!-- More content if needed -->
  <h3>Summary</h3>
  <p>This report was generated to show performance across multiple days...</p>
</div>

<script>
function exportToPDF() {
  const element = document.getElementById('exportArea');
  const opt = {
    margin: [0.5, 0.5, 0.5, 0.5],
    filename: 'report-export.pdf',
    image: { type: 'jpeg', quality: 1 },
    html2canvas: { scale: 3, useCORS: true, scrollX: 0, scrollY: 0 },
    jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
    pagebreak: { mode: ['css', 'legacy'] }
  };
  html2pdf().set(opt).from(element).save();
}

// Simple bar chart
window.onload = function () {
  const ctx = document.getElementById('sampleChart').getContext('2d');
  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['2025-03-01', '2025-03-02', '2025-03-03'],
      datasets: [{
        label: 'COB Elapsed (
min)',
        data: [90, 105, 120],
        backgroundColor: 'orange'
      }]
    },
    options: {




awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '/ERROR/ && $0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ && substr($0, 1, 10) >= limit && length($0) <= 100' файл.log
      responsive: false,
      scales: {
        y: { beginAtZero: true }
      }
    }
  });
};
</script>

</body>
</html>
