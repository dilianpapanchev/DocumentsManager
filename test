<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>Stacked Bar Chart</title>
  <!-- Включване на Chart.js (версия 3+) от CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <style>
    /* Стил за размера на графиката (по желание) */
    #myChart {
      max-width: 600px;
      max-height: 400px;
    }
  </style>
</head>
<body>
  <!-- Таблица с данни (примерни стойности) -->
  <table id="recordsTable" border="1" cellpadding="4" cellspacing="0">
    <thead>
      <tr>
        <th>Record</th>
        <th>Data2</th>
        <th>Data3</th>
        <th>COB Elapsed</th>
        <th>Data5</th>
        <th>Data6</th>
        <th>RR Elapsed</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Record 1</td><td>xyz</td><td>abc</td><td>01:48:00</td><td>n/a</td><td>n/a</td><td>00:42:30</td>
      </tr>
      <tr>
        <td>Record 2</td><td>xyz</td><td>abc</td><td>02:15:45</td><td>n/a</td><td>n/a</td><td>01:05:15</td>
      </tr>
      <tr>
        <td>Record 3</td><td>xyz</td><td>abc</td><td>00:30:00</td><td>n/a</td><td>n/a</td><td>01:45:00</td>
      </tr>
    </tbody>
  </table>

  <!-- Canvas елемент за графиката -->
  <canvas id="myChart" width="600" height="400"></canvas>

  <script>
    // Функция за конвертиране на "HH:mm:ss" в общ брой секунди
    function parseTimeToSeconds(timeStr) {
      const parts = timeStr.split(':').map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return NaN;
      const [hours, minutes, seconds] = parts;
      return hours * 3600 + minutes * 60 + seconds;
    }

    // Извличане на данните от таблицата
    const table = document.getElementById('recordsTable');
    const labels = [];
    const cobData = [];
    const rrData = [];

    let rows = table.querySelectorAll('tbody tr');
    if (rows.length === 0) {
      rows = table.querySelectorAll('tr'); // ако няма <tbody>
    }
    rows.forEach((row, index) => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 7) {
        const cobStr = cells[3].textContent.trim();
        const rrStr = cells[6].textContent.trim();
        const cobSec = parseTimeToSeconds(cobStr);
        const rrSec = parseTimeToSeconds(rrStr);
        if (!isNaN(cobSec) && !isNaN(rrSec)) {
          // Първата клетка се използва за етикет (име) на записа
          labels.push(cells[0].textContent.trim() || 'Record ' + (index + 1));
          cobData.push(cobSec);
          rrData.push(rrSec);
        }
      }
    });

    // Подготовка на datasets за Chart.js
    const data = {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: cobData,
          backgroundColor: '#2e59d9'  // син цвят за COB секцията
        },
        {
          label: 'RR Elapsed',
          data: rrData,
          backgroundColor: '#17a673'  // зелен цвят за RR секцията
        }
      ]
    };

    // Изчисляване на максимума за Y оста, така че да включва линията 2:30 часа
    const thresholdSeconds = 2.5 * 3600;  // 2.5 часа (2:30:00) в секунди
    const totalTimes = cobData.map((c, i) => c + rrData[i]);
    const maxDataSeconds = totalTimes.length ? Math.max(...totalTimes) : 0;
    const upperBound = Math.max(maxDataSeconds, thresholdSeconds);
    const stepSize = 1800;  // стъпка 1800 секунди = 30 минути
    let maxSec = Math.ceil(upperBound / stepSize) * stepSize;
    if (upperBound === thresholdSeconds) {
      // Ако лимитът 2:30ч е най-голямата стойност, добавяме още една стъпка за видимост
      maxSec += stepSize;
    }

    // Конфигурация на графиката
    const config = {
      type: 'bar',
      data: data,
      options: {
        responsive: false, // по избор: фиксиран размер на canvas (изкл. responsive)
        scales: {
          x: {
            stacked: true  // активиране на стека по хоризонталната ос (групиране на баровете)
          },
          y: {
            stacked: true, 
            beginAtZero: true,
            max: maxSec,
            ticks: {
              stepSize: stepSize,
              // Форматиране на деленията по Y като HH:mm
              callback: function(value) {
                const hours = Math.floor(value / 3600);
                const minutes = Math.floor((value % 3600) / 60);
                return hours + ':' + (minutes < 10 ? '0' : '') + minutes;
              }
            }
          }
        },
        plugins: {
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              // Форматиране на tooltip: "Име: HH:mm"
              label: function(context) {
                const datasetLabel = context.dataset.label || '';
                const value = context.parsed.y;
                const hours = Math.floor(value / 3600);
                const minutes = Math.floor((value % 3600) / 60);
                const formatted = hours + ':' + (minutes < 10 ? '0' : '') + minutes;
                return datasetLabel + ': ' + formatted;
              }
            }
          }
        }
      },
      plugins: [{
        id: 'stackedBarLabels',
        afterDatasetsDraw(chart, args, options) {
          const ctx = chart.ctx;
          const yScale = chart.scales.y;
          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = '12px sans-serif';
          ctx.fillStyle = '#fff';  // бял текст за вътрешните надписи

          // Обхождане на всяка лента (запис)
          chart.data.labels.forEach((label, i) => {
            const cobVal = chart.data.datasets[0].data[i];   // секуни за COB
            const rrVal = chart.data.datasets[1].data[i];    // секунди за RR
            const total = cobVal + rrVal;
            const x = chart.getDatasetMeta(0).data[i].x;     // x-координата на центъра на бара

            // Надпис в средата на COB секцията (ако стойността > 0)
            if (cobVal > 0) {
              const cobCenterY = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cobVal)) / 2;
              const hours = Math.floor(cobVal / 3600);
              const minutes = Math.floor((cobVal % 3600) / 60);
              const labelText = hours + ':' + (minutes < 10 ? '0' : '') + minutes;
              ctx.fillText(labelText, x, cobCenterY);
            }

            // Надпис в средата на RR секцията (ако стойността > 0)
            if (rrVal > 0) {
              const rrCenterY = (yScale.getPixelForValue(cobVal) + yScale.getPixelForValue(total)) / 2;
              const hours = Math.floor(rrVal / 3600);
              const minutes = Math.floor((rrVal % 3600) / 60);
              const labelText = hours + ':' + (minutes < 10 ? '0' : '') + minutes;
              ctx.fillText(labelText, x, rrCenterY);
            }

            // Надпис над целия стак (тотал COB+RR) – общо време
            if (total > 0) {
              ctx.fillStyle = '#000';  // черен текст за общото време (над бара)
              ctx.textBaseline = 'bottom';
              ctx.font = 'bold 12px sans-serif';
              const hours = Math.floor(total / 3600);
              const minutes = Math.floor((total % 3600) / 60);
              const totalText = hours + ':' + (minutes < 10 ? '0' : '') + minutes;
              // малко отместване (2px) над върха на бара
              ctx.fillText(totalText, x, yScale.getPixelForValue(total) - 2);
              // Възстановяване на стила за следващата итерация (вътрешни надписи)
              ctx.fillStyle = '#fff';
              ctx.textBaseline = 'middle';
              ctx.font = '12px sans-serif';
            }
          });

          // Червена хоризонтална линия за лимита (Duration Limit = 2:30 часа)
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'red';
          const yPos = yScale.getPixelForValue(thresholdSeconds);
          ctx.moveTo(chart.chartArea.left, yPos);
          ctx.lineTo(chart.chartArea.right, yPos);
          ctx.stroke();
          ctx.restore();
        }
      }]
    };

    // Рендиране на графиката
    const myChart = new Chart(
      document.getElementById('myChart').getContext('2d'),
      config
    );
  </script>
</body>
</html>
