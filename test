<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // Извличаме месец и година от датата (формат YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (“Close-Of-Business” or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	•	Start & Stop Times for each day’s batch run
	•	Elapsed Duration (how long the entire COB took)
	•	Throughput (records or transactions processed per minute)
	•	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	•	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	•	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	•	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	•	Bar charts for throughput (records per minute) and COB durations
	•	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	•	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	•	Automatic warnings for missing batches, slow batches, and restarts during COB
	•	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues—without manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # определяме списък от файлове
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # определяме списък от отдалечени файлове
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh — Secure Upload/Download/Cleanup wrapper with –all & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we’re in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} — Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * Променя ширината на контейнера на графиките
 * спрямо броя дни:
 *   3–10  дни → клас w-0-10
 *  11–20  дни → клас w-11-20
 *  21–31+ дни → клас w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // махаме всички предишни
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // слагаме новия
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // ограничаваме 3–31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) скриваме/показваме редове
    updateTableRows(v);
    // 2) преизчертаваме графиките
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) настройваме ширината
    updateContainerWidth(v);
  }

  // слушаме промени и от двата контрола
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // първоначално – 10 дни
  syncSliderAndInput(10);
});




// 1) Взимаме само видимите (нескрити) данни от таблцата
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите 2 header-реда и филтрираме само нескритите
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) Рендерираме (или пре-рендерираме) COB-графиката
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // ако вече имаме Chart, първо го унищожаваме
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // само видимите редове

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропусни заглавката
    const visibleRows = rows.filter(row => !row.hidden); // ВЗИМАШ САМО ВИДИМИТЕ редове

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // Пропускаме заглавието
    const selectedRows = dataRows.slice(-maxDays); // Вземаме последните N реда

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // Последните "days" реда
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // Дата
            values.push(parseElapsedTime(cells[1].innerText.trim())); // Време в секунди
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // Взимаме данните от таблицата
    const trend = calculateTrendline(values);         // Изчисляваме тренд линията
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // унищожаваме старата графика ако има
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // Вземаме последните N реда

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // Стартово състояние - 10 дни
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // При движение на слайдъра
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // При промяна на инпут
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper за стойност на слайдъра с default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- за Records per Minute графиката ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip заглавия
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice последните N елемента
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* останалите настройки по твой вкус */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- за COB elapsed графиката ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip заглавния ред
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// при всяка промяна на слайдъра
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... евентуално и другите графики
});

// при зареждане по подразбиране
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-и, ако вече нямаш такива:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // Пропускаме първите 2 (header-и)
    return getAllRows().slice(2);
  }

  // Точно твоето почистване на редовете
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // брой, който искаме да показваме
    const count = Math.max(minRows, Math.min(days, total));
    // индекс в dataRows, от който започваме да показваме
    const firstToShow = total - count;

    // винаги показваме заглавните 2 реда
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // Синхронизация slider ↔ input и initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // По подразбиране 10 дни
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // когато мърдаме слайдера
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // ако искаш да презареждаш и графиките:
      renderIDsChart();
      renderCOBChart();
    });

    // когато променим ръчно в полето
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // Слагаме по подразбиране 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // Връзка между слайдера и инпута
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // Функция, която връща всички <tr>
    const dataRows = getDataRows(); // Функция, която връща само валидните редове (без хедъра)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // Показва заглавията
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // НЕ повече от редовете
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // без заглавията
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // Първоначално показваме 10 дни
  updateTableRows(10);

  // Закачаме слушатели за промяна
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const visibleCount = Math.max(days, 3); // Минимум 3 дена
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// При зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропускаме header-ите
  const visibleCount = Math.max(days, 3); // минимум 3 дена видими
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper за да вземем стойността на слайдера (и да имаме винаги поне 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) адаптирана getRecordsData(), връща само последните N дни
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите два <tr> (header-ите)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // взимаме последните maxDays реда (обратен ред за удобно попълване)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) адаптирана getCOBDataFromTable(), връща само последните N дни
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме само заглавния <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // взимаме последните maxDays реда
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() – вече ползва dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* … */],
        borderColor:     ['rgba(255,99,132,1)',   /* … */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() – вече ползва dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) биндираме към slider-а да ре-рисува и двете
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// готово — само тези 5 блока добавяш/заместваш, останалото не се променя. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// Взимане на всички редове от таблицата
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// Обновяване на видимите редове според избраните дни
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // пропускаме заглавните редове

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Извличане на данни за COB графиката
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// Извличане на данни за ID графиката
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// Помощна функция за парсване на време
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// Рендериране на новата COB графика
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// Рендериране на новата ID графика
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Форматиране на секунди към HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Функция за синхронизация на слайдера
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Функция за синхронизация от input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Добавяне на слушатели
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// Стартиране първоначално
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // Прескачаме заглавния ред
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // Вземаме последните N дни
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // Добавяме име на таблицата
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // Празен ред между таблиците
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
  <button id="exportAllBtn" class="small-button">⬇️ Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // празен ред между таблиците
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* под "Export CSV" бутона */
  left: 180px; /* изнася се вдясно */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- Ако искаш може да добавиш още чекбоксове -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">✅ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">❌ Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- Ако имаш още таблици добавяш тук -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // Създаване на чекбокс прозорец
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // По подразбиране всички са маркирани

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Затваряне на модал прозореца
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* За светъл фон */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* За тъмен фон */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* Слайдър цветът */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // тук извикваш каквото още искаш като update на графики, таблици и т.н.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // за да се инициализира правилно при зареждане
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* Преместване заедно с текста */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = '🌙';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = '🌞';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">🌞</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // всички <tr>
  const dataRows = getDataRows();  // само <tr> за данни
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // показваме винаги header-ите
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // всички tr (вкл. th + tr)
  const dataRows = getDataRows(); // само данните
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // първите два (header) винаги да са видими
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // Обръщаме реда на масивите
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // Пропускаме първите 2 реда с <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // Пропускаме 2 заглавни реда
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // пропускаме 2 заглавни реда

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // минимум 3 дни, не 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // Минимум 3 дни
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // ако искаш и CPU графиката да се адаптира!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // Първоначално зареждане
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // За да се рендерират правилно при зареждане
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // Минимум 3 дни
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // Пропускаме заглавията

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // Минимум 3 реда
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // Първоначално показваме избрания брой дни
    daysValue.textContent = `${daysRange.value} days`;

    // Рендерираме графиките още при зареждане
    renderIDsChart();
    renderTimingChart();

    // Слушаме за промяна на плъзгача
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // Изтриваме старите графики преди да рендерираме нови
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // Рендерираме графиките отново според новата стойност
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

