# -*- coding: utf-8 -*-
"""
COB HTML Reports Comparator
---------------------------
–°–∫—Ä–∏–ø—Ç—ä—Ç —Å—Ä–∞–≤–Ω—è–≤–∞ –Ω—è–∫–æ–ª–∫–æ HTML —Ä–µ–ø–æ—Ä—Ç–∞ (–∫–∞—Ç–æ —Ç–µ–∑–∏ –æ—Ç COB Analyser)
–∏ –ø—Ä–∞–≤–∏ –∫—Ä–∞—Ç–∫–∏ –æ—Ç—á–µ—Ç–∏ –∑–∞ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏—Ç–µ: "–≤—ä—Ä–≤–∏ –¥–æ–±—Ä–µ / —Å—Ä–µ–¥–Ω–æ / –∑–∞–±–∞–≤—è —Å–µ".

‚úÖ –ë–µ–∑ –≤—ä–Ω—à–Ω–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.
‚úÖ –†–∞–±–æ—Ç–∏ —Å python script.py (Python 2/3 —Å—ä–≤–º–µ—Å—Ç–∏–º).
‚úÖ –ò–º–∞ –ø—Ä–æ—Å—Ç GUI –∑–∞ –∏–∑–±–æ—Ä –Ω–∞ —Ñ–∞–π–ª–æ–≤–µ (tkinter).
‚úÖ –†–µ–∑—É–ª—Ç–∞—Ç: .txt –∏ .csv —Ä–µ–∑—é–º–µ + –ø–µ—á–∞—Ç –≤ –∫–æ–Ω–∑–æ–ª–∞—Ç–∞.

–ö–∞–∫–≤–æ –∏–∑–≤–ª–∏—á–∞ –æ—Ç HTML:
- –î–∞—Ç–∞ –Ω–∞ —Ä–µ–ø–æ—Ä—Ç–∞: –æ—Ç <h2> ... - YYYYMMDD
- –û—Ç —Ç–∞–±–ª–∏—Ü–∞ #recordsTable:
  * –¥–∞—Ç–∞ (–ø—ä—Ä–≤–∞ –∫–æ–ª–æ–Ω–∞)
  * COB Elapsed (HH:MM:SS) ‚Äì 4-—Ç–∞ –∫–æ–ª–æ–Ω–∞
  * Transactions ‚Äì 5-—Ç–∞ –∫–æ–ª–æ–Ω–∞
  * RR Elapsed (HH:MM:SS) ‚Äì 8-–º–∞ –∫–æ–ª–æ–Ω–∞
- –ò–∑—á–∏—Å–ª—è–≤–∞:
  * —Å—Ä–µ–¥–Ω–æ COB elapsed (—á–∞—Å–æ–≤–µ)
  * —Å—Ä–µ–¥–Ω–æ RR elapsed (—á–∞—Å–æ–≤–µ)
  * —Å—Ä–µ–¥–Ω–∏ records/minute (RPM) = Transactions / Elapsed(h)*60
  * –±—Ä–æ–π –¥–Ω–∏
- –¢—Ä–µ–Ω–¥ –º–µ–∂–¥—É —Ä–µ–ø–æ—Ä—Ç–∏ –ø–æ –¥–∞—Ç–∞:
  * % –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å—Ä–µ–¥–Ω–∏—Ç–µ COB/RR/RPM
  * —Ç–µ–∫—Å—Ç–æ–≤ —Å—Ç–∞—Ç—É—Å: "–≤—ä—Ä–≤–∏ –¥–æ–±—Ä–µ" / "—Å—Ä–µ–¥–Ω–æ" / "–∑–∞–±–∞–≤—è —Å–µ"

–ó–∞–±–µ–ª–µ–∂–∫–∞: –ü–∞—Ä—Å–≤–∞–Ω–µ—Ç–æ –µ —É—Å—Ç–æ–π—á–∏–≤–æ –∫—ä–º <span style="...">, –∫–æ–º–µ–Ω—Ç–∞—Ä–∏, –ø—Ä–∞–∑–Ω–∏ –∫–ª–µ—Ç–∫–∏.
"""

from __future__ import print_function
import os
import re
import csv
import sys
import datetime

# --- Tkinter cross-version import ---
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox
except Exception:
    try:
        import Tkinter as tk
        import tkFileDialog as filedialog
        import tkMessageBox as messagebox
    except Exception:
        tk = None
        filedialog = None
        messagebox = None

# ========== Helpers ==========

def read_text(path):
    with open(path, 'rb') as f:
        data = f.read()
    # –æ–ø–∏—Ç–∞–π –¥–∞ –¥–µ—à–∏—Ñ—Ä–∏—Ä–∞—à –∫–∞—Ç–æ utf-8, –∏–Ω–∞—á–µ –æ—Å—Ç–∞–≤–∏ raw
    try:
        return data.decode('utf-8', 'ignore')
    except Exception:
        try:
            return data.decode('cp1251', 'ignore')
        except Exception:
            try:
                return data.decode('latin-1', 'ignore')
            except Exception:
                return data if isinstance(data, str) else data.decode('utf-8', 'ignore')

def strip_html(text):
    """–º–∞—Ö–Ω–∏ —Ç–∞–≥–æ–≤–µ, –∫–æ–º–µ–Ω—Ç–∞—Ä–∏, —Å–≤–∏–π whitespace"""
    if not text:
        return u""
    # –º–∞—Ö–Ω–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏—Ç–µ
    text = re.sub(r'<!--.*?-->', u' ', text, flags=re.S)
    # —Å–º–µ–Ω–∏ <br> —Å –ø—Ä–æ–±–µ–ª
    text = re.sub(r'<br\s*/?>', u' ', text, flags=re.I)
    # –º–∞—Ö–Ω–∏ –≤—Å–∏—á–∫–∏ —Ç–∞–≥–æ–≤–µ
    text = re.sub(r'<[^>]+>', u' ', text)
    # nbsp -> space
    text = text.replace(u'\xa0', u' ')
    # —Å–≤–∏–π whitespace
    return re.sub(r'\s+', u' ', text).strip()

def parse_hms_to_hours(s):
    """'HH:MM:SS' -> —á–∞—Å–æ–≤–µ(float)"""
    if not s:
        return None
    parts = s.split(':')
    if len(parts) < 2:
        return None
    h = int(parts[0] or 0)
    m = int(parts[1] or 0)
    s2 = int(parts[2] or 0) if len(parts) > 2 else 0
    return h + m/60.0 + s2/3600.0

def safe_float(s):
    if s is None:
        return None
    m = re.findall(r'[-+]?\d+(?:\.\d+)?', s)
    if not m:
        return None
    try:
        return float(m[0])
    except Exception:
        return None

def avg(values):
    values = [v for v in values if v is not None]
    return sum(values)/float(len(values)) if values else None

def pct_change(old, new):
    if old in (None, 0):
        return None
    return (new - old) * 100.0 / float(old)

def status_from_metrics(avg_cob_h, avg_rr_h, avg_rpm, cob_delta=None):
    """
    –ü—Ä–æ—Å—Ç–∞ –∫–ª–∞—Å–∏—Ñ–∏–∫–∞—Ü–∏—è:
    - "–≤—ä—Ä–≤–∏ –¥–æ–±—Ä–µ" –∞–∫–æ avg_cob <= 2.5h –∏ –Ω—è–º–∞ –ø–æ–∫–∞—á–≤–∞–Ω–µ > 8%
    - "—Å—Ä–µ–¥–Ω–æ" –∞–∫–æ 2.5 < avg_cob <= 3.0h –∏–ª–∏ –∏–º–∞ –º–∞–ª–∫–∞ –ø—Ä–æ–º—è–Ω–∞
    - "–∑–∞–±–∞–≤—è —Å–µ" –∞–∫–æ avg_cob > 3.0h –∏–ª–∏ –ø–æ–∫–∞—á–≤–∞–Ω–µ > 8%
    """
    if avg_cob_h is None:
        return u"–Ω–µ–¥–æ—Å—Ç–∞—Ç—ä—á–Ω–∏ –¥–∞–Ω–Ω–∏"
    if cob_delta is not None and cob_delta > 8:
        return u"–∑–∞–±–∞–≤—è —Å–µ"
    if avg_cob_h <= 2.5:
        return u"–≤—ä—Ä–≤–∏ –¥–æ–±—Ä–µ"
    if avg_cob_h <= 3.0:
        return u"—Å—Ä–µ–¥–Ω–æ"
    return u"–∑–∞–±–∞–≤—è —Å–µ"

# ========== HTML parsers ==========

def extract_report_date(html_text):
    """
    –¢—ä—Ä—Å–∏ <h2> ... - YYYYMMDD
    –í—Ä—ä—â–∞ (date_str 'YYYYMMDD', datetime.date) –∏–ª–∏ (None, None)
    """
    m = re.search(r'<h2[^>]*>.*?(\d{8}).*?</h2>', html_text, flags=re.S|re.I)
    if not m:
        return None, None
    ymd = m.group(1)
    try:
        dt = datetime.datetime.strptime(ymd, "%Y%m%d").date()
    except Exception:
        dt = None
    return ymd, dt

def extract_table_block(html_text, table_id):
    """–í–∞–¥–∏ —Å—É—Ä–æ–≤–∏—è HTML –Ω–∞ <table id="...">...</table> (–≥—Ä—É–±–æ, –Ω–æ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ)"""
    # —Ç–æ–ª–µ—Ä–∞–Ω—Ç–µ–Ω regex: —Ö–≤–∞—â–∞ –æ—Ç –æ—Ç–≤–∞—Ä—è—â–∏—è <table ... id="table_id" ...> –¥–æ </table>
    pat = r'<table[^>]*\bid\s*=\s*["\']%s["\'][^>]*>(.*?)</table>' % re.escape(table_id)
    m = re.search(pat, html_text, flags=re.S|re.I)
    return m.group(1) if m else None

def parse_records_table(html_text):
    """
    –ß–µ—Ç–µ #recordsTable:
      –∫–æ–ª–æ–Ω–∏ (–æ—á–∞–∫–≤–∞–Ω–∏):
        0: Date (–¥–¥/–º–º/–≥–≥–≥–≥ –∏–ª–∏ –ø–æ–¥–æ–±–Ω–æ)
        1: COB Start
        2: COB Stop
        3: COB Elapsed (HH:MM:SS)
        4: Transactions (int)
        5: RR Start
        6: RR Stop
        7: RR Elapsed (HH:MM:SS)
    –í—Ä—ä—â–∞ —Å–ø–∏—Å—ä–∫ –æ—Ç dict.
    """
    block = extract_table_block(html_text, "recordsTable")
    if not block:
        return []
    # —Ä–µ–¥–æ–≤–µ
    rows = re.findall(r'<tr[^>]*>(.*?)</tr>', block, flags=re.S|re.I)
    out = []
    for i, row in enumerate(rows):
        # –ø—Ä–æ–ø—É—Å–Ω–∏ header (–ø—ä—Ä–≤–∏—è —Ä–µ–¥)
        if i == 0:
            continue
        cells = re.findall(r'<t[dh][^>]*>(.*?)</t[dh]>', row, flags=re.S|re.I)
        if len(cells) < 5:
            continue
        # —Ç–µ–∫—Å—Ç –±–µ–∑ —Ç–∞–≥–æ–≤–µ
        cells = [strip_html(c) for c in cells]
        date_txt     = cells[0] if len(cells) > 0 else ""
        cob_elapsed  = cells[3] if len(cells) > 3 else ""
        tx_txt       = cells[4] if len(cells) > 4 else ""
        rr_elapsed   = cells[7] if len(cells) > 7 else ""

        # —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        tx = None
        try:
            tx = int(re.sub(r'[^\d]', '', tx_txt)) if tx_txt else None
        except Exception:
            tx = safe_float(tx_txt)
            if tx is not None:
                tx = int(tx)

        out.append({
            "date": date_txt,
            "cob_elapsed_h": parse_hms_to_hours(cob_elapsed),
            "rr_elapsed_h": parse_hms_to_hours(rr_elapsed),
            "transactions": tx
        })
    return out

# ========== Metrics per report ==========

def compute_metrics_for_report(html_text):
    """
    –í—Ä—ä—â–∞ dict:
      {
        "report_date": "YYYYMMDD",
        "date_obj": datetime.date,
        "avg_cob_h": float or None,
        "avg_rr_h": float or None,
        "avg_rpm": float or None,
        "days": int
      }
    """
    ymd, date_obj = extract_report_date(html_text)
    rows = parse_records_table(html_text)

    cob_h = [r["cob_elapsed_h"] for r in rows if r.get("cob_elapsed_h") is not None]
    rr_h  = [r["rr_elapsed_h"] for r in rows if r.get("rr_elapsed_h") is not None]

    # RPM –ø–æ —Ä–µ–¥ (–∞–∫–æ –∏–º–∞ –∏ elapsed –∏ transactions)
    rpm_vals = []
    for r in rows:
        h = r.get("cob_elapsed_h")
        tx = r.get("transactions")
        if h and tx and h > 0:
            rpm_vals.append((tx / (h * 60.0)))

    metrics = {
        "report_date": ymd or "",
        "date_obj": date_obj,
        "avg_cob_h": avg(cob_h),
        "avg_rr_h": avg(rr_h),
        "avg_rpm": avg(rpm_vals),
        "days": len(rows)
    }
    return metrics

# ========== Formatting ==========

def fmt(v, unit=""):
    if v is None:
        return "-"
    if unit == "h":
        return "%.2fh" % v
    if unit == "rpm":
        return "%.0f rpm" % v
    return "%.2f" % v

def short_summary_line(m, prev=None):
    """–ï–¥–Ω–∞ –∫—Ä–∞—Ç–∫–∞ –ª–∏–Ω–∏—è —Ç–µ–∫—Å—Ç –∑–∞ –¥–∞–¥–µ–Ω —Ä–µ–ø–æ—Ä—Ç"""
    cob_delta = pct_change(prev["avg_cob_h"], m["avg_cob_h"]) if prev else None
    rr_delta  = pct_change(prev["avg_rr_h"], m["avg_rr_h"]) if prev else None
    rpm_delta = pct_change(prev["avg_rpm"], m["avg_rpm"]) if prev else None

    status = status_from_metrics(m["avg_cob_h"], m["avg_rr_h"], m["avg_rpm"], cob_delta)

    parts = [
        u"üìÖ %s" % (m["report_date"] or "unknown"),
        u"COB —Å—Ä–µ–¥–Ω–æ: %s" % fmt(m["avg_cob_h"], "h"),
        u"RR —Å—Ä–µ–¥–Ω–æ: %s" % fmt(m["avg_rr_h"], "h"),
        u"RPM —Å—Ä–µ–¥–Ω–æ: %s" % fmt(m["avg_rpm"], "rpm"),
        u"–¥–Ω–∏: %s" % m["days"],
        u"—Å—Ç–∞—Ç—É—Å: %s" % status
    ]
    if prev:
        if cob_delta is not None:
            parts.append(u"ŒîCOB: %+0.1f%%" % cob_delta)
        if rr_delta is not None:
            parts.append(u"ŒîRR: %+0.1f%%" % rr_delta)
        if rpm_delta is not None:
            parts.append(u"ŒîRPM: %+0.1f%%" % rpm_delta)
    return u" | ".join(parts)

# ========== Main ==========

def pick_files():
    if filedialog is None:
        print("–ú–æ–ª—è, –ø–æ–¥–∞–π—Ç–µ —Ñ–∞–π–ª–æ–≤–µ –∫–∞—Ç–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∏: python script.py report1.html report2.html ...")
        return sys.argv[1:]
    root = tk.Tk()
    root.withdraw()
    paths = filedialog.askopenfilenames(
        title="–ò–∑–±–µ—Ä–∏ COB HTML –æ—Ç—á–µ—Ç–∏",
        filetypes=[("HTML files","*.html;*.htm"), ("All files","*.*")]
    )
    root.update()
    root.destroy()
    return list(paths)

def main(paths):
    if not paths:
        print("–ù—è–º–∞ –∏–∑–±—Ä–∞–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ.")
        return

    # –ü—Ä–æ—á–µ—Ç–∏ –∏ –∏–∑—á–∏—Å–ª–∏ –º–µ—Ç—Ä–∏–∫–∏—Ç–µ –∑–∞ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª
    items = []
    for p in paths:
        try:
            html = read_text(p)
            m = compute_metrics_for_report(html)
            m["file"] = os.path.basename(p)
            items.append(m)
        except Exception as e:
            print("–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ %s: %s" % (p, e))

    # —Å–æ—Ä—Ç–∏—Ä–∞–π –ø–æ –¥–∞—Ç–∞ (–∞–∫–æ –ª–∏–ø—Å–≤–∞ –¥–∞—Ç–∞ ‚Äì –ø–æ –∏–º–µ)
    def sort_key(m):
        return (m["date_obj"] or datetime.date(1970,1,1), m["file"])
    items.sort(key=sort_key)

    # –ò–∑–≤–µ–¥–∏ –∫—Ä–∞—Ç–∫–∏ —Ä–µ–¥–æ–≤–µ + CSV
    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    txt_name = "summary_%s.txt" % ts
    csv_name = "summary_%s.csv" % ts

    lines = []
    csv_rows = [["report_date","file","avg_cob_h","avg_rr_h","avg_rpm","days",
                 "delta_cob_pct_vs_prev","delta_rr_pct_vs_prev","delta_rpm_pct_vs_prev","status"]]

    prev = None
    for m in items:
        line = short_summary_line(m, prev)
        print(line)
        lines.append(line)

        cob_delta = pct_change(prev["avg_cob_h"], m["avg_cob_h"]) if prev else None
        rr_delta  = pct_change(prev["avg_rr_h"],  m["avg_rr_h"])  if prev else None
        rpm_delta = pct_change(prev["avg_rpm"],   m["avg_rpm"])   if prev else None
        status = status_from_metrics(m["avg_cob_h"], m["avg_rr_h"], m["avg_rpm"], cob_delta)

        csv_rows.append([
            m["report_date"], m["file"],
            "%.4f" % m["avg_cob_h"] if m["avg_cob_h"] is not None else "",
            "%.4f" % m["avg_rr_h"]  if m["avg_rr_h"]  is not None else "",
            "%.4f" % m["avg_rpm"]   if m["avg_rpm"]   is not None else "",
            m["days"],
            "%.2f" % cob_delta if cob_delta is not None else "",
            "%.2f" % rr_delta  if rr_delta  is not None else "",
            "%.2f" % rpm_delta if rpm_delta is not None else "",
            status
        ])
        prev = m

    # –∑–∞–ø–∏—à–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ
    with open(txt_name, 'wb') as f:
        data = (u"\n".join(lines) + u"\n").encode('utf-8')
        f.write(data)
    with open(csv_name, 'wb') as f:
        w = csv.writer(f)
        for r in csv_rows:
            # –∑–∞–ø–∞–∑–∏ –∫–∏—Ä–∏–ª–∏—Ü–∞
            row = [s.encode('utf-8') if isinstance(s, unicode) if sys.version_info[0] == 2 else s for s in r] if sys.version_info[0]==2 else r
            w.writerow(row)

    print("\n–ó–∞–ø–∏—Å–∞—Ö –æ—Ç—á–µ—Ç–∏—Ç–µ:")
    print(" -", txt_name)
    print(" -", csv_name)

if __name__ == "__main__":
    # —Å—ä–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç –∑–∞ Python 2 (unicode)
    if sys.version_info[0] == 2:
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout)

    paths = [p for p in sys.argv[1:] if os.path.isfile(p)]
    if not paths:
        paths = pick_files()
    main(paths)






// compare_pct_autocol.c
// Build:  gcc -std=c11 -O2 -o compare_pct compare_pct_autocol.c -lm
// Usage:  ./compare_pct BGN_FILE EUR_FILE [--col N]
// - –°—Ä–∞–≤–Ω—è–≤–∞ –ø–æ –ù–û–ú–ï–† –Ω–∞ –∞–∫–∞—É–Ω—Ç (—Å–∞–º–æ —Ü–∏—Ñ—Ä–∏; –±–µ–∑ –≤–æ–¥–µ—â–∏ –Ω—É–ª–∏).
// - –í EUR —Å–ª–µ–¥ –∞–∫–∞—É–Ω—Ç–∞ –º–æ–∂–µ –¥–∞ –∏–º–∞ ";<—á–∏—Å–ª–æ>" (–Ω–∞–ø—Ä. ;1) ‚Äì –∏–≥–Ω–æ—Ä–∏—Ä–∞ —Å–µ.
// - –ö–æ–ª–æ–Ω–∞—Ç–∞ —Å % —Å–µ –æ—Ç–∫—Ä–∏–≤–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ. –ü–æ –∂–µ–ª–∞–Ω–∏–µ –º–æ–∂–µ –¥–∞ override-–Ω–µ—à —Å --col N.
// - –ó–∞–∫—Ä—ä–≥–ª—è –¥–æ 2 –∑–Ω–∞–∫–∞ (5.665‚Üí5.67; 5.663‚Üí5.66).
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

typedef struct { char *acct_norm; size_t acct_len; double pct; } Row;

static int numstr_cmp(const char *a, size_t la, const char *b, size_t lb){
    if (la!=lb) return (la<lb)?-1:1; return strcmp(a,b);
}
static int cmp_row(const void *x,const void*y){
    const Row *ra=x,*rb=y; return numstr_cmp(ra->acct_norm,ra->acct_len,rb->acct_norm,rb->acct_len);
}
static double round2(double v){ return (v>=0.0)? floor(v*100.0+0.5)/100.0 : ceil(v*100.0-0.5)/100.0; }
static char* strndup_safe(const char*s,size_t n){ char*p=malloc(n+1); if(!p){perror("malloc"); exit(1);} memcpy(p,s,n); p[n]='\0'; return p; }
static char* trim_ws(char*s){ while(*s&&isspace((unsigned char)*s)) s++; char*e=s+strlen(s); while(e>s&&isspace((unsigned char)e[-1])) --e; *e='\0'; return s; }
static void normalize_digits(char **ps,size_t *plen){
    char*s=*ps; size_t n=*plen,i=0; while(i<n&&s[i]=='0') i++; if(i==n){ free(s); s=strndup_safe("0",1); n=1; }
    else if(i>0){ char*t=strndup_safe(s+i,n-i); free(s); s=t; n-=i; } *ps=s; *plen=n;
}
static int is_all_digits(const char*s,size_t n){ if(n==0) return 0; for(size_t i=0;i<n;i++) if(!isdigit((unsigned char)s[i])) return 0; return 1; }

typedef struct { int found; int col; } AutoCol;

// –æ–ø–∏—Ç 1: —Ö–µ–¥—ä—Ä —Ä–µ–¥ —Å –µ—Ç–∏–∫–µ—Ç '%' / 'PCT'
static AutoCol detect_from_header(FILE *fp, int skip_numeric_after_acct){
    const char *TAG="ACCOUNTS:"; char *line=NULL; size_t len=0; long pos=ftell(fp);
    AutoCol res={0,0};
    while(1){
        long here=ftell(fp); ssize_t r=getline(&line,&len,fp); if(r==-1) break;
        char *L=trim_ws(line); if(!*L) continue;
        if(strncmp(L,"#",1)==0 || strncasecmp(L,"HEADER",6)==0 || strncasecmp(L,"COLUMNS",7)==0){
            // –ø—Ä–∏–µ–º–∞–º–µ, —á–µ –µ —Ö–µ–¥—ä—Ä —Å ';'
            // –Ω–∞–º–µ—Ä–∏ –ø–æ–∑–∏—Ü–∏—è—Ç–∞ —Å–ª–µ–¥ –ø—ä—Ä–≤–∞—Ç–∞ –ø–æ—è–≤–∞ –Ω–∞ TAG –∏–ª–∏ —Å–ª–µ–¥ –ø—ä—Ä–≤–∏—è ';' (–∞–∫–æ –Ω—è–º–∞ TAG)
            char *p = strstr(L,TAG); char *fields=NULL;
            if(p){ p+=strlen(TAG); char *semi=strchr(p,';'); fields = semi? semi+1 : NULL; }
            else { char *semi=strchr(L,';'); fields = semi? semi+1 : NULL; }
            if(!fields) continue;

            if(skip_numeric_after_acct){
                char *e=strchr(fields,';'); size_t toklen=e? (size_t)(e-fields):strlen(fields);
                if(is_all_digits(fields,toklen)) fields = e? e+1 : NULL;
                if(!fields) continue;
            }
            // –æ–±—Ö–æ–∂–¥–∞–º–µ –ø–æ–ª–µ—Ç–∞—Ç–∞ –∏ —Ç—ä—Ä—Å–∏–º —Ç–æ—á–Ω–æ "%" –∏–ª–∏ —Å—ä–¥—ä—Ä–∂–∞ "PCT"/"PERCENT"
            int col=1; char *start=fields;
            while(start){
                char *e=strchr(start,';'); size_t Lf = e? (size_t)(e-start):strlen(start);
                char *name=strndup_safe(start,Lf); char *nm=trim_ws(name);
                for(char*t=nm;*t;++t) *t=toupper((unsigned char)*t);
                if(strcmp(nm,"%")==0 || strstr(nm,"PCT") || strstr(nm,"PERCENT")){
                    res.found=1; res.col=col; free(name); goto done;
                }
                free(name);
                if(!e) break; start=e+1; col++;
            }
        }
        // —Å—Ä–µ—â–Ω–µ–º –ª–∏ –ø—ä—Ä–≤–∏—è —Ä–µ–¥ —Å ACCOUNTS:, —Å–ø–∏—Ä–∞–º–µ —Ö–µ–¥—ä—Ä —Ç—ä—Ä—Å–µ–Ω–µ—Ç–æ
        if(strstr(L,TAG)) break;
        (void)here;
    }
done:
    if(line) free(line);
    fseek(fp,pos,SEEK_SET);
    return res;
}

// –æ–ø–∏—Ç 2: –µ–≤—Ä–∏—Å—Ç–∏–∫–∞ –≤—ä—Ä—Ö—É –¥–æ 200 —Ä–µ–¥–∞ - —Ç—ä—Ä—Å–∏ –∫–æ–ª–æ–Ω–∞, –∫–æ—è—Ç–æ –∏–∑–≥–ª–µ–∂–¥–∞ –∫–∞—Ç–æ –ø—Ä–æ—Ü–µ–Ω—Ç (—Ä–µ–∞–ª–Ω–æ —á–∏—Å–ª–æ) –≤ >=80% –æ—Ç —Ä–µ–¥–æ–≤–µ—Ç–µ
static AutoCol detect_by_sampling(FILE *fp, int skip_numeric_after_acct){
    const char *TAG="ACCOUNTS:"; char *line=NULL; size_t len=0; long pos=ftell(fp);
    AutoCol res={0,0};
    // –Ω–∞–º–µ—Ä–∏ –ø—ä—Ä–≤–∏—è —Ä–µ–¥ —Å –¥–∞–Ω–Ω–∏
    while(1){ ssize_t r=getline(&line,&len,fp); if(r==-1) break; char *L=trim_ws(line); if(strstr(L,TAG)) { fseek(fp, -(long)r, SEEK_CUR); break; } }
    if(!line){ fseek(fp,pos,SEEK_SET); return res; }

    // –ø—ä—Ä–≤–æ –ø—Ä–µ–±—Ä–æ–π –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –±—Ä–æ–π –∫–æ–ª–æ–Ω–∏ –ø–æ –ø—ä—Ä–≤–∏—Ç–µ –Ω—è–∫–æ–ª–∫–æ —Ä–µ–¥–∞
    int maxcols=0; int samples=0;
    long pos2=ftell(fp);
    for(int s=0;s<20;s++){
        ssize_t r=getline(&line,&len,fp); if(r==-1) break; char *L=trim_ws(line); if(!strstr(L,TAG)) continue;
        char *p=strstr(L,TAG)+9; while(*p && isdigit((unsigned char)*p)) p++; if(*p!=';') continue; char *fields=p+1;
        if(skip_numeric_after_acct){
            char *e=strchr(fields,';'); size_t toklen=e? (size_t)(e-fields):strlen(fields);
            if(is_all_digits(fields,toklen)) fields = e? e+1 : NULL; if(!fields) continue;
        }
        int c=1; for(char *t=fields;;){ char*e=strchr(t,';'); c++; if(!e) break; t=e+1; }
        if(c-1>maxcols) maxcols=c-1; samples++;
    }
    fseek(fp,pos2,SEEK_SET);
    if(maxcols==0){ free(line); fseek(fp,pos,SEEK_SET); return res; }

    int *ok = calloc((size_t)maxcols+1,sizeof(int));
    int counted=0;

    for(int s=0;s<200;s++){
        ssize_t r=getline(&line,&len,fp); if(r==-1) break; char *L=trim_ws(line); if(!strstr(L,TAG)) continue;
        // parse
        char *p=strstr(L,TAG)+9; while(*p && isdigit((unsigned char)*p)) p++; if(*p!=';') continue; char *fields=p+1;
        if(skip_numeric_after_acct){
            char *e=strchr(fields,';'); size_t toklen=e? (size_t)(e-fields):strlen(fields);
            if(is_all_digits(fields,toklen)) fields = e? e+1 : NULL; if(!fields) continue;
        }
        // –∑–∞ –≤—Å—è–∫–∞ –∫–æ–ª–æ–Ω–∞ ‚Äì –∞–∫–æ –µ –≤–∞–ª–∏–¥–Ω–æ —á–∏—Å–ª–æ —Å –¥–µ—Å–µ—Ç–∏—á–Ω–∞ —Ç–æ—á–∫–∞/–∑–∞–ø–µ—Ç–∞—è –∏ |v|<=1000 -> –∑–∞—á–∏—Ç–∞ —Å–µ
        int col=1; char *start=fields;
        while(start && col<=maxcols){
            char *e=strchr(start,';'); size_t fl = e? (size_t)(e-start):strlen(start);
            char *val=strndup_safe(start,fl); char *vt=trim_ws(val);
            for(char*t=vt;*t;++t) if(*t==',') *t='.';
            char *ep=NULL; double v=strtod(vt,&ep);
            int is_real = (ep!=vt) && (strchr(vt,'.')!=NULL); // —Ç—ä—Ä—Å–∏–º —Ä–µ–∞–ª–Ω–∏, –Ω–µ —Ü–µ–ª–∏ —á–∏—Å–ª–∞
            if(is_real && fabs(v)<=1000.0) ok[col]++; // –ø—Ä–∞–≥ —à–∏—Ä–æ–∫; –ø–æ—Å–ª–µ —â–µ –∏–∑–±–µ—Ä–µ–º –Ω–∞–π-–¥–æ–±—Ä–æ—Ç–æ
            free(val);
            if(!e) break; start=e+1; col++;
        }
        counted++;
    }
    // –∏–∑–±–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∞ —Å –Ω–∞–π-–º–Ω–æ–≥–æ –ø–æ–ø–∞–¥–µ–Ω–∏—è; –∏–∑–∏—Å–∫–≤–∞–º–µ >=80% –æ—Ç –∏–∑–≤–∞–¥–∫–∞—Ç–∞
    int best_col=0, best_score=0, threshold = (int)(counted*0.8);
    for(int c=1;c<=maxcols;c++){ if(ok[c]>best_score){ best_score=ok[c]; best_col=c; } }
    free(ok);
    if(best_col>0 && best_score>=threshold){ res.found=1; res.col=best_col; }
    free(line); fseek(fp,pos,SEEK_SET); return res;
}

static Row* parse_file(const char *path, int pct_col_1based, int skip_numeric_after_acct, size_t *out_n){
    FILE *fp=fopen(path,"r"); if(!fp){ perror(path); exit(1); }

    // –∞–∫–æ pct_col_1based==0 ‚Üí –∞–≤—Ç–æ
    if(pct_col_1based==0){
        AutoCol h = detect_from_header(fp, skip_numeric_after_acct);
        if(!h.found) h = detect_by_sampling(fp, skip_numeric_after_acct);
        if(!h.found){ fprintf(stderr,"[%s] –ù–µ —É—Å–ø—è—Ö –¥–∞ –Ω–∞–º–µ—Ä—è % –∫–æ–ª–æ–Ω–∞. –ú–æ–∂–µ—à –¥–∞ –ø–æ–¥–∞–¥–µ—à —Ä—ä—á–Ω–æ —Å --col N.\n", path); }
        pct_col_1based = h.col; // –º–æ–∂–µ –¥–∞ –æ—Å—Ç–∞–Ω–µ 0 ‚Üí —â–µ –æ—Ç—Ö–≤—ä—Ä–ª—è–º–µ —Ä–µ–¥–æ–≤–µ—Ç–µ –ø–æ-–¥–æ–ª—É
    }

    size_t cap=1024,n=0; Row *rows=malloc(cap*sizeof(Row)); if(!rows){perror("malloc"); exit(1);}
    char *line=NULL; size_t len=0; ssize_t r; const char *TAG="ACCOUNTS:";

    while((r=getline(&line,&len,fp))!=-1){
        char *L=trim_ws(line); if(!*L) continue; char *p=strstr(L,TAG); if(!p) continue; p+=strlen(TAG);
        char *q=p; while(*q && isdigit((unsigned char)*q)) q++; if(q==p||*q!=';') continue;
        char *acct=strndup_safe(p,(size_t)(q-p)); size_t acct_len=(size_t)(q-p); normalize_digits(&acct,&acct_len);
        char *fields=q+1; if(skip_numeric_after_acct){
            char *e=strchr(fields,';'); size_t toklen=e?(size_t)(e-fields):strlen(fields);
            if(is_all_digits(fields,toklen)) fields = e? e+1 : NULL; if(!fields){ free(acct); continue; }
        }
        if(pct_col_1based<=0){ free(acct); continue; } // –Ω—è–º–∞ –æ—Ç–∫—Ä–∏—Ç–∞ % –∫–æ–ª–æ–Ω–∞

        int col=1; char *start=fields,*end=NULL; while(col<pct_col_1based && start){
            end=strchr(start,';'); if(!end){ start=NULL; break; } start=end+1; col++;
        }
        if(!start){ free(acct); continue; }
        end=strchr(start,';'); size_t fl=end?(size_t)(end-start):strlen(start);
        char *val=strndup_safe(start,fl); char*vt=trim_ws(val);
        for(char*t=vt;*t;++t) if(*t==',') *t='.';
        char *ep=NULL; double v=strtod(vt,&ep); free(val); if(ep==vt){ free(acct); continue; }
        v=round2(v);

        if(n==cap){ cap*=2; rows=realloc(rows,cap*sizeof(Row)); if(!rows){perror("realloc"); exit(1);} }
        rows[n].acct_norm=acct; rows[n].acct_len=acct_len; rows[n].pct=v; n++;
    }
    free(line); fclose(fp);
    qsort(rows,n,sizeof(Row),cmp_row); *out_n=n; return rows;
}

static void free_rows(Row *rows,size_t n){ for(size_t i=0;i<n;i++) free(rows[i].acct_norm); free(rows); }

int main(int argc,char**argv){
    if(argc<3){ fprintf(stderr,"Usage: %s BGN_FILE EUR_FILE [--col N]\n", argv[0]); return 1; }
    const char *bgn_path=argv[1], *eur_path=argv[2]; int override_col=0;
    if(argc>=5 && strcmp(argv[3],"--col")==0) override_col=atoi(argv[4]);

    size_t nb=0, ne=0;
    Row *B=parse_file(bgn_path, override_col, 0, &nb);
    Row *E=parse_file(eur_path, override_col, 1, &ne);

    printf("account\tbgn_pct\teur_pct\tdiff\n");
    size_t i=0,j=0;
    while(i<nb && j<ne){
        int c=numstr_cmp(B[i].acct_norm,B[i].acct_len,E[j].acct_norm,E[j].acct_len);
        if(c==0){ double diff=round2(B[i].pct - E[j].pct);
            printf("%s\t%.2f\t%.2f\t%.2f\n", B[i].acct_norm, B[i].pct, E[j].pct, diff); i++; j++; }
        else if(c<0) i++; else j++;
    }
    free_rows(B,nb); free_rows(E,ne); return 0;
}






// compare_pct_numacct.c
// Build:  gcc -std=c11 -O2 -o compare_pct compare_pct_numacct.c -lm
// Usage:  ./compare_pct BGN_FILE EUR_FILE PCT_COL
// - –°—Ä–∞–≤–Ω—è–≤–∞ –ø–æ –ù–û–ú–ï–† –Ω–∞ –∞–∫–∞—É–Ω—Ç (–¥–µ—Å–µ—Ç–∏—á–Ω–∏ —Ü–∏—Ñ—Ä–∏ —Å–∞–º–æ, –±–µ–∑ –≤–æ–¥–µ—â–∏ –Ω—É–ª–∏).
// - –í EUR —Ñ–∞–π–ª —Å–ª–µ–¥ –∞–∫–∞—É–Ω—Ç–∞ –∏–º–∞ –æ–ø—Ü–∏–æ–Ω–∞–ª–Ω–æ –ø–æ–ª–µ ";<—á–∏—Å–ª–æ>" (–Ω–∞–ø—Ä. ;1) -> –∏–≥–Ω–æ—Ä–∏—Ä–∞ —Å–µ.
// - PCT_COL –µ 1-–±–∞–∑–∏—Ä–∞–Ω –∏–Ω–¥–µ–∫—Å –Ω–∞ –ø–æ–ª–µ—Ç–æ (—Å–ª–µ–¥ –∞–∫–∞—É–Ω—Ç–∞ –∏ –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ—Ç–æ ;<—á–∏—Å–ª–æ>).
// - –ó–∞–∫—Ä—ä–≥–ª—è–Ω–µ –¥–æ 2 –∑–Ω–∞–∫–∞ (5.665‚Üí5.67; 5.663‚Üí5.66).
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

typedef struct {
    char *acct_norm;      // –∞–∫–∞—É–Ω—Ç –∫–∞—Ç–æ —á–∏—Å—Ç–∏ —Ü–∏—Ñ—Ä–∏, –±–µ–∑ –≤–æ–¥–µ—â–∏ –Ω—É–ª–∏ (0 –∞–∫–æ –≤—Å–∏—á–∫–∏ —Å–∞ 0)
    size_t acct_len;      // –¥—ä–ª–∂–∏–Ω–∞ —Å–ª–µ–¥ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    double pct;
} Row;

static int numstr_cmp(const char *a, size_t la, const char *b, size_t lb) {
    // —á–∏—Å–ª–æ–≤–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ –¥—ä–ª–∂–∏–Ω–∞, –ø–æ—Å–ª–µ –ª–µ–∫—Å–∏–∫–∞–ª–Ω–æ
    if (la != lb) return (la < lb) ? -1 : 1;
    return strcmp(a, b);
}

static int cmp_row(const void *x, const void *y) {
    const Row *ra = (const Row*)x, *rb = (const Row*)y;
    return numstr_cmp(ra->acct_norm, ra->acct_len, rb->acct_norm, rb->acct_len);
}

static double round2(double v) {
    if (v >= 0.0) return floor(v*100.0 + 0.5) / 100.0;
    else          return ceil (v*100.0 - 0.5) / 100.0;
}

static char* strndup_safe(const char *s, size_t n) {
    char *p = (char*)malloc(n+1);
    if (!p) { perror("malloc"); exit(1); }
    memcpy(p, s, n);
    p[n] = '\0';
    return p;
}

static char* trim_ws(char *s) {
    while (*s && isspace((unsigned char)*s)) s++;
    char *e = s + strlen(s);
    while (e > s && isspace((unsigned char)e[-1])) --e;
    *e = '\0';
    return s;
}

static void normalize_digits(char **ps, size_t *plen) {
    // –º–∞—Ö–Ω–∏ –≤–æ–¥–µ—â–∏—Ç–µ –Ω—É–ª–∏; –∞–∫–æ –≤—Å–∏—á–∫–æ –µ –Ω—É–ª–∏ -> "0"
    char *s = *ps;
    size_t n = *plen;
    size_t i = 0;
    while (i < n && s[i] == '0') i++;
    if (i == n) { free(s); s = strndup_safe("0", 1); n = 1; }
    else {
        if (i > 0) {
            char *t = strndup_safe(s + i, n - i);
            free(s); s = t; n = n - i;
        }
    }
    *ps = s; *plen = n;
}

static int is_all_digits(const char *s, size_t n) {
    for (size_t i=0;i<n;i++) if (!isdigit((unsigned char)s[i])) return 0;
    return n > 0;
}

// –≤—Ä—ä—â–∞ –º–∞—Å–∏–≤ {–∞–∫–∞—É–Ω—Ç, pct}
static Row* parse_file(const char *path, int pct_col_1based, int skip_numeric_after_acct, size_t *out_n) {
    FILE *fp = fopen(path, "r");
    if (!fp) { perror(path); exit(1); }

    size_t cap = 1024, n = 0;
    Row *rows = (Row*)malloc(cap * sizeof(Row));
    if (!rows) { perror("malloc"); exit(1); }

    char *line = NULL;
    size_t len = 0;
    ssize_t r;

    const char *TAG = "ACCOUNTS:";

    while ((r = getline(&line, &len, fp)) != -1) {
        char *L = trim_ws(line);
        if (!*L) continue;

        char *p = strstr(L, TAG);
        if (!p) continue;
        p += strlen(TAG);

        // –≤–∑–µ–º–∏ –°–ê–ú–û —Ü–∏—Ñ—Ä–∏—Ç–µ –Ω–∞ –∞–∫–∞—É–Ω—Ç–∞
        char *q = p;
        while (*q && isdigit((unsigned char)*q)) q++;
        if (q == p) continue; // –Ω—è–º–∞ —Ü–∏—Ñ—Ä–∏
        char *acct = strndup_safe(p, (size_t)(q - p));
        size_t acct_len = (size_t)(q - p);

        // –Ω–æ—Ä–º–∞–ª–∏–∑–∏—Ä–∞–π (–±–µ–∑ –≤–æ–¥–µ—â–∏ –Ω—É–ª–∏)
        normalize_digits(&acct, &acct_len);

        // —Å–ª–µ–¥ –∞–∫–∞—É–Ω—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–º–∞ ';' –ø—Ä–µ–¥–∏ –ø–æ–ª–µ—Ç–∞—Ç–∞
        if (*q != ';') { free(acct); continue; }
        char *fields = q + 1;

        // EUR: –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ –ø—ä—Ä–≤–æ—Ç–æ –ø–æ–ª–µ –µ —á–∏—Å—Ç–æ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä. 1) -> –∏–≥–Ω–æ—Ä–∏—Ä–∞–π
        if (skip_numeric_after_acct) {
            char *e = strchr(fields, ';');
            size_t toklen = e ? (size_t)(e - fields) : strlen(fields);
            if (is_all_digits(fields, toklen)) {
                fields = e ? e + 1 : NULL;
                if (!fields) { free(acct); continue; }
            }
        }

        // –Ω–∞–º–µ—Ä–∏ pct_col_1based
        int col = 1;
        char *start = fields;
        char *end = NULL;
        while (col < pct_col_1based && start) {
            end = strchr(start, ';');
            if (!end) { start = NULL; break; }
            start = end + 1;
            col++;
        }
        if (!start) { free(acct); continue; }

        end = strchr(start, ';');
        size_t f_len = end ? (size_t)(end - start) : strlen(start);

        char *val = strndup_safe(start, f_len);
        char *valt = trim_ws(val);
        for (char *t = valt; *t; ++t) if (*t == ',') *t = '.';

        char *ep = NULL;
        double v = strtod(valt, &ep);
        free(val);
        if (ep == valt) { free(acct); continue; }

        v = round2(v);

        if (n == cap) {
            cap *= 2;
            rows = (Row*)realloc(rows, cap * sizeof(Row));
            if (!rows) { perror("realloc"); exit(1); }
        }
        rows[n].acct_norm = acct;
        rows[n].acct_len  = acct_len;
        rows[n].pct       = v;
        n++;
    }

    free(line);
    fclose(fp);

    qsort(rows, n, sizeof(Row), cmp_row);
    *out_n = n;
    return rows;
}

static void free_rows(Row *rows, size_t n) {
    for (size_t i=0;i<n;i++) free(rows[i].acct_norm);
    free(rows);
}

int main(int argc, char **argv) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s BGN_FILE EUR_FILE PCT_COL\n", argv[0]);
        return 1;
    }
    const char *bgn_path = argv[1];
    const char *eur_path = argv[2];
    int pct_col = atoi(argv[3]);
    if (pct_col <= 0) {
        fprintf(stderr, "PCT_COL must be >= 1\n");
        return 1;
    }

    size_t nb=0, ne=0;
    Row *B = parse_file(bgn_path, pct_col, 0, &nb);
    Row *E = parse_file(eur_path, pct_col, 1, &ne);

    // merge-join –ø–æ –ù–û–ú–ï–† –Ω–∞ –∞–∫–∞—É–Ω—Ç (—á–∏—Å–ª–æ–≤–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ)
    size_t i=0, j=0;
    printf("account\tbgn_pct\teur_pct\tdiff\n");
    while (i<nb && j<ne) {
        int c = numstr_cmp(B[i].acct_norm, B[i].acct_len, E[j].acct_norm, E[j].acct_len);
        if (c == 0) {
            double diff = round2(B[i].pct - E[j].pct);
            printf("%s\t%.2f\t%.2f\t%.2f\n", B[i].acct_norm, B[i].pct, E[j].pct, diff);
            i++; j++;
        } else if (c < 0) {
            i++;
        } else {
            j++;
        }
    }

    free_rows(B, nb);
    free_rows(E, ne);
    return 0;
}






// compare_pct.c
// Build:  gcc -std=c11 -O2 -o compare_pct compare_pct.c
// Usage:  ./compare_pct BGN_FILE EUR_FILE PCT_COL
// Notes:
//  - Lines contain "ACCOUNTS:<account>...".
//  - In EUR file there may be an extra numeric field immediately after <account> like ";1" ‚Äî it is ignored.
//  - PCT_COL is 1-based index of the ';'-separated field to use as % value,
//    counting fields AFTER the <account> (and AFTER the optional ";<digits>" suffix in EUR).
//  - Values are rounded to 2 decimals (e.g., 5.665 -> 5.67; 5.663 -> 5.66).
//  - Output: tab-separated lines: account \t pct_bgn \t pct_eur \t diff (only for accounts present in both).

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
    char *acct;
    double pct;
} Row;

static int cmp_row(const void *a, const void *b) {
    const Row *ra = (const Row*)a, *rb = (const Row*)b;
    return strcmp(ra->acct, rb->acct);
}

static int is_number_str(const char *s) {
    if (!s || !*s) return 0;
    while (*s) {
        if (!isdigit((unsigned char)*s)) return 0;
        s++;
    }
    return 1;
}

static double round2(double x) {
    if (x >= 0.0) return floor(x*100.0 + 0.5) / 100.0;
    else          return ceil (x*100.0 - 0.5) / 100.0;
}

static char* strndup_safe(const char *s, size_t n) {
    char *p = (char*)malloc(n+1);
    if (!p) { perror("malloc"); exit(1); }
    memcpy(p, s, n);
    p[n] = '\0';
    return p;
}

static char* trim(char *s) {
    if (!s) return s;
    // left
    while (*s && (*s==' ' || *s=='\t' || *s=='\r' || *s=='\n')) s++;
    // right
    char *e = s + strlen(s);
    while (e > s && (e[-1]==' ' || e[-1]=='\t' || e[-1]=='\r' || e[-1]=='\n')) --e;
    *e = '\0';
    return s;
}

// Parse one file into dynamic array of {account, pct}
static Row* parse_file(const char *path, int pct_col_1based, int skip_numeric_field_after_acct, size_t *out_n) {
    FILE *fp = fopen(path, "r");
    if (!fp) { perror(path); exit(1); }

    size_t cap = 1024, n = 0;
    Row *rows = (Row*)malloc(cap * sizeof(Row));
    if (!rows) { perror("malloc"); exit(1); }

    char *line = NULL;
    size_t len = 0;
    ssize_t r;

    while ((r = getline(&line, &len, fp)) != -1) {
        char *L = trim(line);
        if (!*L) continue;

        // find "ACCOUNTS:"
        const char *tag = "ACCOUNTS:";
        char *p = strstr(L, tag);
        if (!p) continue;
        p += strlen(tag);

        // account is up to next ';' or end
        char *semi = strchr(p, ';');
        char *acct_end = semi ? semi : (p + strlen(p));
        char *acct = strndup_safe(p, (size_t)(acct_end - p));

        // move cursor to fields after account
        char *fields = semi ? semi + 1 : NULL;
        if (!fields) { free(acct); continue; }

        // If requested, ignore a purely numeric field immediately after account (e.g., ";1")
        if (skip_numeric_field_after_acct) {
            // peek next token
            char *tok_end = strchr(fields, ';');
            size_t tok_len = tok_end ? (size_t)(tok_end - fields) : strlen(fields);
            char *tok = strndup_safe(fields, tok_len);
            int skip = is_number_str(trim(tok));
            free(tok);
            if (skip) {
                fields = tok_end ? (tok_end + 1) : NULL;
                if (!fields) { free(acct); continue; }
            }
        }

        // Iterate fields to reach pct_col_1based
        char *q = fields;
        int col = 1;
        char *start = q;
        char *end = NULL;
        while (col < pct_col_1based && q) {
            end = strchr(q, ';');
            if (!end) { start = NULL; break; }
            q = end + 1;
            col++;
            start = q;
        }
        if (!start) { free(acct); continue; }

        // Extract field value (until next ';' or end)
        end = strchr(start, ';');
        size_t f_len = end ? (size_t)(end - start) : strlen(start);

        char *val_str = strndup_safe(start, f_len);
        char *val_trim = trim(val_str);

        // Replace possible commas with dots, strip spaces
        for (char *t = val_trim; *t; ++t) if (*t == ',') *t = '.';

        char *endptr = NULL;
        double v = strtod(val_trim, &endptr);
        if (endptr == val_trim) { // not a number -> skip
            free(acct); free(val_str);
            continue;
        }

        v = round2(v);

        if (n == cap) {
            cap *= 2;
            rows = (Row*)realloc(rows, cap * sizeof(Row));
            if (!rows) { perror("realloc"); exit(1); }
        }
        rows[n].acct = acct;
        rows[n].pct  = v;
        n++;
        free(val_str);
    }

    free(line);
    fclose(fp);

    // sort by account for fast merge/join
    qsort(rows, n, sizeof(Row), cmp_row);

    *out_n = n;
    return rows;
}

static void free_rows(Row *rows, size_t n) {
    if (!rows) return;
    for (size_t i=0;i<n;i++) free(rows[i].acct);
    free(rows);
}

int main(int argc, char **argv) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s BGN_FILE EUR_FILE PCT_COL\n", argv[0]);
        return 1;
    }
    const char *bgn_path = argv[1];
    const char *eur_path = argv[2];
    int pct_col = atoi(argv[3]);
    if (pct_col <= 0) {
        fprintf(stderr, "PCT_COL must be >= 1\n");
        return 1;
    }

    size_t nb=0, ne=0;
    Row *B = parse_file(bgn_path, pct_col, /*skip_numeric_field_after_acct=*/0, &nb);
    Row *E = parse_file(eur_path, pct_col, /*skip_numeric_field_after_acct=*/1, &ne);

    // Merge-join by account and print differences (or matches)
    size_t i=0, j=0;
    printf("account\tbgn_pct\teur_pct\tdiff\n");
    while (i<nb && j<ne) {
        int c = strcmp(B[i].acct, E[j].acct);
        if (c == 0) {
            double diff = round2(B[i].pct - E[j].pct);
            printf("%s\t%.2f\t%.2f\t%.2f\n", B[i].acct, B[i].pct, E[j].pct, diff);
            i++; j++;
        } else if (c < 0) {
            // present only in BGN (skip printing if not needed)
            i++;
        } else {
            // present only in EUR (skip printing if not needed)
            j++;
        }
    }

    free_rows(B, nb);
    free_rows(E, ne);
    return 0;
}






// compare_fx.c
// Build: gcc -std=c11 -O2 -Wall -Wextra -o compare_fx compare_fx.c
// Usage: ./compare_fx <bgn_file> <eur_file> <log_file> [exchange_rate]
// Notes:
// - Expects '|' delimited lines. Field[0] = account, Field[3] = amount.
// - Rounds to 2 decimals and compares with a tolerance of 0.01.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <errno.h>

#define LINE_MAX_LEN 4096
#define SEP "|"
#define AMOUNT_FIELD_INDEX 3
#define ACCOUNT_FIELD_INDEX 0
#define CMP_EPS 0.01

typedef struct {
    char *account;
    double amount;
    int has_amount; // 1 if amount present, 0 if missing/empty
} EurRow;

typedef struct {
    EurRow *rows;
    size_t len;
    size_t cap;
} EurTable;

static void die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

static char *strdup_safe(const char *s) {
    size_t n = strlen(s) + 1;
    char *p = (char *)malloc(n);
    if (!p) die("malloc");
    memcpy(p, s, n);
    return p;
}

static char *trim(char *s) {
    if (!s) return s;
    char *start = s;
    while (*start==' '||*start=='\t'||*start=='\r'||*start=='\n') start++;
    char *end = start + strlen(start);
    while (end>start && (end[-1]==' '||end[-1]=='\t'||end[-1]=='\r'||end[-1]=='\n')) --end;
    *end = '\0';
    return start;
}

static int split_get_field(const char *line, int wanted_index, char *out, size_t out_sz) {
    // returns 1 if found, 0 otherwise
    int idx = 0;
    const char *p = line;
    const char *field_start = p;
    size_t len = strlen(line);
    for (size_t i = 0; i <= len; ++i) {
        if (line[i] == '|' || line[i] == '\0') {
            if (idx == wanted_index) {
                size_t copy_len = (size_t)(&line[i] - field_start);
                if (copy_len >= out_sz) copy_len = out_sz - 1;
                memcpy(out, field_start, copy_len);
                out[copy_len] = '\0';
                return 1;
            }
            idx++;
            field_start = &line[i + 1];
        }
    }
    return 0;
}

static int parse_amount_field(const char *s, double *out) {
    // empty or "-" or whitespace -> no amount
    char buf[128];
    size_t n = 0;
    for (const char *p = s; *p && n < sizeof(buf) - 1; ++p) {
        if (*p != ' ' && *p != '\t') buf[n++] = *p;
    }
    buf[n] = '\0';
    if (buf[0] == '\0' || strcmp(buf, "-") == 0) return 0;

    char *end = NULL;
    errno = 0;
    double v = strtod(buf, &end);
    if (errno != 0 || end == buf) return -1; // invalid
    *out = v;
    return 1; // has amount
}

static double round2(double v) {
    return llround(v * 100.0) / 100.0;
}

static void table_init(EurTable *t) {
    t->rows = NULL; t->len = 0; t->cap = 0;
}
static void table_push(EurTable *t, EurRow row) {
    if (t->len == t->cap) {
        size_t ncap = t->cap ? t->cap * 2 : 128;
        EurRow *nr = (EurRow *)realloc(t->rows, ncap * sizeof(EurRow));
        if (!nr) die("realloc");
        t->rows = nr; t->cap = ncap;
    }
    t->rows[t->len++] = row;
}
static void table_free(EurTable *t) {
    for (size_t i = 0; i < t->len; ++i) free(t->rows[i].account);
    free(t->rows);
}

static int table_find(const EurTable *t, const char *account, EurRow *out) {
    for (size_t i = 0; i < t->len; ++i) {
        if (strcmp(t->rows[i].account, account) == 0) {
            if (out) *out = t->rows[i];
            return 1;
        }
    }
    return 0;
}

static void load_eur_table(const char *eur_path, EurTable *table) {
    FILE *f = fopen(eur_path, "r");
    if (!f) die("fopen EUR file");
    table_init(table);
    char line[LINE_MAX_LEN];

    while (fgets(line, sizeof(line), f)) {
        char account[256] = {0};
        char amount_txt[256] = {0};
        if (!split_get_field(line, ACCOUNT_FIELD_INDEX, account, sizeof(account))) continue;
        if (!split_get_field(line, AMOUNT_FIELD_INDEX, amount_txt, sizeof(amount_txt))) continue;

        double amt = 0.0;
        int res = parse_amount_field(trim(amount_txt), &amt);
        EurRow row;
        row.account = strdup_safe(trim(account));
        if (res == 1) { row.amount = amt; row.has_amount = 1; }
        else if (res == 0) { row.amount = 0.0; row.has_amount = 0; }
        else { // invalid number -> treat as missing
            row.amount = 0.0; row.has_amount = 0;
        }
        table_push(table, row);
    }
    fclose(f);
}

int main(int argc, char **argv) {
    if (argc < 4 || argc > 5) {
        fprintf(stderr, "Usage: %s <bgn_file> <eur_file> <log_file> [exchange_rate]\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *bgn_path = argv[1];
    const char *eur_path = argv[2];
    const char *log_path = argv[3];
    double rate = (argc == 5) ? atof(argv[4]) : 2.0;

    FILE *bgn = fopen(bgn_path, "r");
    if (!bgn) die("fopen BGN file");
    FILE *logf = fopen(log_path, "w");
    if (!logf) die("fopen log file");

    EurTable et;
    load_eur_table(eur_path, &et);

    char line[LINE_MAX_LEN];
    while (fgets(line, sizeof(line), bgn)) {
        char account[256] = {0};
        char amount_txt[256] = {0};
        if (!split_get_field(line, ACCOUNT_FIELD_INDEX, account, sizeof(account))) continue;
        if (!split_get_field(line, AMOUNT_FIELD_INDEX, amount_txt, sizeof(amount_txt))) continue;

        double bgn_amount = 0.0;
        int ok = parse_amount_field(trim(amount_txt), &bgn_amount);
        if (ok != 1) continue; // skip BGN rows with no amount

        EurRow eur_row;
        if (!table_find(&et, trim(account), &eur_row)) {
            fprintf(logf,
                    "Account(%s) missing in EUR file. BGN: %.2f EUR: - Rate: %.6f ExpectedEUR: %.2f\n",
                    trim(account), round2(bgn_amount), rate, round2(bgn_amount / rate));
            continue;
        }

        if (!eur_row.has_amount) {
            fprintf(logf,
                    "Account(%s) EUR amount missing. BGN: %.2f EUR: - Rate: %.6f ExpectedEUR: %.2f\n",
                    eur_row.account, round2(bgn_amount), rate, round2(bgn_amount / rate));
            continue;
        }

        double expected_eur = round2(bgn_amount / rate);
        double eur_amount = round2(eur_row.amount);

        if (fabs(eur_amount - expected_eur) > CMP_EPS) {
            fprintf(logf,
                    "Account(%s) mismatch. BGN: %.2f EUR: %.2f Rate: %.6f ExpectedEUR: %.2f\n",
                    eur_row.account, round2(bgn_amount), eur_amount, rate, expected_eur);
        }
        // else: match -> no log (same behavior as the Python version‚Äôs intent)
    }

    fclose(bgn);
    fclose(logf);
    table_free(&et);
    return EXIT_SUCCESS;
}


gcc -std=c11 -O2 -Wall -Wextra -o compare_fx compare_fx.c





print_jar_conflict_box() {
  local new_path="$1"
  local old_path="$2"

  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–≤–∞—Ç–∞ —Ñ–∞–π–ª–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—Ç
  if [[ ! -f "$new_path" || ! -f "$old_path" ]]; then
    echo "Error: file(s) not found" >&2
    return 1
  fi

  # ANSI —Ü–≤–µ—Ç–æ–≤–µ (–∞–∫–æ —Å–∞ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –æ—Ç–≤—ä–Ω ‚Äì —â–µ –≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞, –∏–Ω–∞—á–µ fallback –∫—ä–º tput)
  : "${GREEN:=$(tput setaf 2)}"
  : "${RED:=$(tput setaf 1)}"
  : "${NC:=$(tput sgr0)}"

  # –ò–∑–≤–ª–∏—á–∞–º–µ —Å–∞–º–æ –∏–º–µ–Ω–∞—Ç–∞ –∏ —Ö–µ—à–æ–≤–µ—Ç–µ
  local new_name=$(basename "$new_path")
  local old_name=$(basename "$old_path")
  local new_hash=$(shasum "$new_path" | awk '{print $1}')
  local old_hash=$(shasum "$old_path" | awk '{print $1}')

  # –ü–æ–¥–≥–æ—Ç–≤—è–º–µ ‚Äûplain‚Äù —Ä–µ–¥–æ–≤–µ—Ç–µ –±–µ–∑ —Ü–≤–µ—Ç–æ–≤–µ
  local lines=(
    "+ New JAR   | $new_name"
    "            | $new_hash"
    "- Old JAR   | $old_name"
    "            | $old_hash"
  )

  # –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞—Ç–∞ –¥—ä–ª–∂–∏–Ω–∞ –Ω–∞ —Ä–µ–¥
  local max_len=0
  for l in "${lines[@]}"; do
    (( ${#l} > max_len )) && max_len=${#l}
  done

  # –ó–∞ –±–æ—Ä–¥—ä—Ä –∏–∑–ø–æ–ª–∑–≤–∞–º–µ (max_len + 2) —Ç–∏—Ä–µ—Ç–∞, –∑–∞ –¥–∞ –ø–æ–∫—Ä–∏–µ–º–µ
  # –∏ –¥–≤–µ—Ç–µ ‚Äû—Å–ø–µ–π—Å—á–µ—Ç–∞‚Äù –æ—Ç –ª—è–≤–æ/–¥—è—Å–Ω–æ –ø—Ä–∏ printf  "| %-*s |"
  local d=$((max_len + 2))
  local border_top="+$(printf '%*s' "$d" '' | tr ' ' -)+"
  local border_mid="+$(printf '%*s' "$d" '' | tr ' ' =)+"

  # 1) –ì–æ—Ä–Ω–∞ —Ä–∞–º–∫–∞
  printf "%s\n" "$border_top"
  # 2) –ù–æ–≤ JAR (–¥–≤–µ –ª–∏–Ω–∏–∏ –≤ –∑–µ–ª–µ–Ω–æ)
  printf "| %s%-*s%s |\n" "$GREEN" "$max_len" "${lines[0]}" "$NC"
  printf "| %s%-*s%s |\n" "$GREEN" "$max_len" "${lines[1]}" "$NC"
  # 3) –°—Ä–µ–¥–Ω–∞ —Ä–∞–º–∫–∞
  printf "%s\n" "$border_mid"
  # 4) –°—Ç–∞—Ä JAR (–¥–≤–µ –ª–∏–Ω–∏–∏ –≤ —á–µ—Ä–≤–µ–Ω–æ)
  printf "| %s%-*s%s |\n" "$RED" "$max_len" "${lines[2]}" "$NC"
  printf "| %s%-*s%s |\n" "$RED" "$max_len" "${lines[3]}" "$NC"
  # 5) –î–æ–ª–Ω–∞ —Ä–∞–º–∫–∞
  printf "%s\n" "$border_top"
}






#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#            Configuration                #
############################################
BACKUP_DIR="/opt/backups/myapp"
LOGFILE="/var/log/deploy.log"

############################################
#  Logging function: timestamp ‚Üí screen+log
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  Cleanup on exit
############################################
cleanup() {
  [[ -n "${WORKDIR:-}" && -d "$WORKDIR" ]] && rm -rf "$WORKDIR"
}
trap cleanup EXIT

############################################
#  1) Prompt for WAR file & JAR directory
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
if [[ ! -f "$WAR_PATH" ]]; then
  echo "ERROR: WAR file not found at $WAR_PATH" >&2
  exit 1
fi

read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR
mapfile -t ALL_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)
if (( ${#ALL_JARS[@]} == 0 )); then
  echo "ERROR: No .jar files found in $NEW_JAR_DIR" >&2
  exit 1
fi

############################################
#  2) Handle multi‚Äêjar selection
############################################
if (( ${#ALL_JARS[@]} == 1 )); then
  SELECTED_JARS=("${ALL_JARS[0]}")
  echo "Single JAR found: $(basename "${ALL_JARS[0]}"), proceeding."
else
  echo "Found ${#ALL_JARS[@]} JARs:"
  for i in "${!ALL_JARS[@]}"; do
    idx=$((i+1))
    echo "  [$idx] $(basename "${ALL_JARS[i]}")"
  done
  echo
  read -r -p "Enter numbers of JARs to deploy (e.g. 1 3 5): " sel_line
  IFS=' ' read -r -a sel_array <<<"$sel_line"
  SELECTED_JARS=()
  for sel in "${sel_array[@]}"; do
    if [[ "$sel" =~ ^[0-9]+$ ]] && (( sel >= 1 && sel <= ${#ALL_JARS[@]} )); then
      SELECTED_JARS+=("${ALL_JARS[sel-1]}")
    else
      echo "Ignoring invalid selection: $sel"
    fi
  done
  if (( ${#SELECTED_JARS[@]} == 0 )); then
    echo "No valid selections made; aborting." >&2
    exit 1
  fi
fi

############################################
#  Prepare dirs & log
############################################
APP_NAME="$(basename "${WAR_PATH%.*}")"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"
WORKDIR="$(mktemp -d /tmp/${APP_NAME}_deploy.XXXXXX)"
mkdir -p "$BACKUP_DIR" "$(dirname "$LOGFILE")"
touch "$LOGFILE"

info "Starting deploy for ${APP_NAME}"
info "WAR path: $WAR_PATH"
info "Selected JAR(s):"
for j in "${SELECTED_JARS[@]}"; do
  info "  ‚Ä¢ $(basename "$j")"
done

############################################
#  3) Backup the WAR
############################################
cp -- "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  4) Unpack WAR into workdir
############################################
unzip -q -- "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  5) Index existing service paths
############################################
declare -A service_index
info "Indexing existing JARs for service paths‚Ä¶"
for jar in "$LIB_DIR"/*.jar; do
  jarname="$(basename "$jar")"
  info "  Processing $jarname"
  # Temporarily disable pipefail so unzip errors don't abort the script
  set +o pipefail
  unzip -p -- "$jar" 'services/*' 2>/dev/null \
    | grep -aF 'rest path="' \
    | sed -nE 's/.*rest path="([^"]+)".*/\1/p' \
    | sort -u \
    | while read -r path; do
        service_index["$path"]+="${jarname} "
      done
  set -o pipefail
done
info "Indexed ${#service_index[@]} distinct service paths."

############################################
#  6) Scan each new JAR and resolve conflicts
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Scanning $JAR_NAME for conflicts‚Ä¶"

  mapfile -t new_paths < <(
    unzip -p -- "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -aF 'rest path="' \
      | sed -nE 's/.*rest path="([^"]+)".*/\1/p' \
      | sort -u
  )

  for np in "${new_paths[@]}"; do
    if [[ -n "${service_index[$np]:-}" ]]; then
      old_jars="${service_index[$np]}"
      info "Conflict on path '$np' found in: $old_jars"
      read -r -p "Remove old JAR(s) [$old_jars] and keep $JAR_NAME? [y/N] " resp
      if [[ "$resp" =~ ^[Yy]$ ]]; then
        for old in $old_jars; do
          rm -f -- "$LIB_DIR/$old"
          info "  Removed $old"
        done
      else
        info "  Kept existing JAR(s): $old_jars"
      fi
      unset service_index["$np"]
    fi
  done
done

############################################
#  7) Copy new JARs into WEB-INF/lib
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  cp -- "$NEW_JAR" "$LIB_DIR"/
  info "Copied $(basename "$NEW_JAR") ‚Üí WEB-INF/lib/"
done

############################################
#  8) Repack WAR and replace original
############################################
pushd "$WORKDIR" > /dev/null
zip -qr -- "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv -- "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

info "Deploy completed successfully"







#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#            Configuration                #
############################################
BACKUP_DIR="/opt/backups/myapp"
LOGFILE="/var/log/deploy.log"

############################################
#  Logging function: timestamp ‚Üí screen+log
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  Cleanup on exit
############################################
cleanup() {
  [[ -n "${WORKDIR:-}" && -d "$WORKDIR" ]] && rm -rf "$WORKDIR"
}
trap cleanup EXIT

############################################
#  1) Prompt for WAR file & JAR directory
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
if [[ ! -f "$WAR_PATH" ]]; then
  echo "ERROR: WAR file not found at $WAR_PATH" >&2
  exit 1
fi

read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR
mapfile -t ALL_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)
if (( ${#ALL_JARS[@]} == 0 )); then
  echo "ERROR: No .jar files found in $NEW_JAR_DIR" >&2
  exit 1
fi

############################################
#  2) Handle multi‚Äêjar selection
############################################
if (( ${#ALL_JARS[@]} == 1 )); then
  SELECTED_JARS=("${ALL_JARS[0]}")
  echo "Single JAR found: $(basename "${ALL_JARS[0]}"), proceeding."
else
  echo "Found ${#ALL_JARS[@]} JARs:"
  for i in "${!ALL_JARS[@]}"; do
    idx=$((i+1))
    echo "  [$idx] $(basename "${ALL_JARS[i]}")"
  done
  echo
  read -r -p "Enter numbers of JARs to deploy (e.g. 1 3 5): " sel_line
  IFS=' ' read -r -a sel_array <<<"$sel_line"
  SELECTED_JARS=()
  for sel in "${sel_array[@]}"; do
    if [[ "$sel" =~ ^[0-9]+$ ]] && (( sel >= 1 && sel <= ${#ALL_JARS[@]} )); then
      SELECTED_JARS+=("${ALL_JARS[sel-1]}")
    else
      echo "Ignoring invalid selection: $sel"
    fi
  done
  if (( ${#SELECTED_JARS[@]} == 0 )); then
    echo "No valid selections made; aborting." >&2
    exit 1
  fi
fi

############################################
#  Prepare directories and log file
############################################
APP_NAME="$(basename "${WAR_PATH%.*}")"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"
WORKDIR="$(mktemp -d /tmp/${APP_NAME}_deploy.XXXXXX)"
mkdir -p "$BACKUP_DIR" "$(dirname "$LOGFILE")"
touch "$LOGFILE"

info "Starting deploy for ${APP_NAME}"
info "WAR path: $WAR_PATH"
info "Selected JAR(s):"
for j in "${SELECTED_JARS[@]}"; do
  info "  ‚Ä¢ $(basename "$j")"
done

############################################
#  3) Backup the WAR
############################################
cp -- "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  4) Unpack WAR into workdir
############################################
unzip -q -- "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  5) Index existing service paths
############################################
declare -A service_index
info "Indexing existing JARs for service paths‚Ä¶"
for jar in "$LIB_DIR"/*.jar; do
  jarname="$(basename "$jar")"
  unzip -p -- "$jar" 'services/*' 2>/dev/null \
    | grep -aF 'rest path="' \
    | sed -nE 's/.*rest path="([^"]+)".*/\1/p' \
    | sort -u \
    | while read -r path; do
        service_index["$path"]+="${jarname} "
      done
done
info "Indexed ${#service_index[@]} distinct service paths."

############################################
#  6) Scan each new JAR and resolve conflicts
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Scanning $JAR_NAME for conflicts‚Ä¶"

  mapfile -t new_paths < <(
    unzip -p -- "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -aF 'rest path="' \
      | sed -nE 's/.*rest path="([^"]+)".*/\1/p' \
      | sort -u
  )

  for np in "${new_paths[@]}"; do
    if [[ -n "${service_index[$np]:-}" ]]; then
      old_jars="${service_index[$np]}"
      info "Conflict on path '$np' found in: $old_jars"
      read -r -p "Remove old JAR(s) [$old_jars] and keep $JAR_NAME? [y/N] " resp
      if [[ "$resp" =~ ^[Yy]$ ]]; then
        for old in $old_jars; do
          rm -f -- "$LIB_DIR/$old"
          info "  Removed $old"
        done
      else
        info "  Kept existing JAR(s): $old_jars"
      fi
      unset service_index["$np"]
    fi
  done
done

############################################
#  7) Copy new JARs into WEB-INF/lib
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  cp -- "$NEW_JAR" "$LIB_DIR"/
  info "Copied $(basename "$NEW_JAR") ‚Üí WEB-INF/lib/"
done

############################################
#  8) Repack WAR and replace original
############################################
pushd "$WORKDIR" > /dev/null
zip -qr -- "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv -- "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

info "Deploy completed successfully"







#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt for WAR file & JAR directory  #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR

APP_NAME="$(basename "${WAR_PATH%.*}")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Gather all jars in the directory
mapfile -t ALL_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)

if (( ${#ALL_JARS[@]} == 0 )); then
  info "ERROR: No .jar files found in $NEW_JAR_DIR"
  exit 1
elif (( ${#ALL_JARS[@]} == 1 )); then
  SELECTED_JARS=("${ALL_JARS[0]}")
  info "Single JAR found: $(basename "${ALL_JARS[0]}"), proceeding automatically"
else
  info "Found ${#ALL_JARS[@]} JARs in $NEW_JAR_DIR:"
  for i in "${!ALL_JARS[@]}"; do
    idx=$((i + 1))
    echo "  [$idx] $(basename "${ALL_JARS[i]}")"
  done
  echo
  read -r -p "Enter numbers of JARs to deploy (e.g. 1 2 5): " sel_line
  # temporarily let IFS include space so read -a splits on spaces
  IFS=' ' read -r -a sel_array <<< "$sel_line"
  SELECTED_JARS=()
  for sel in "${sel_array[@]}"; do
    if [[ "$sel" =~ ^[0-9]+$ ]] && (( sel >= 1 && sel <= ${#ALL_JARS[@]} )); then
      SELECTED_JARS+=("${ALL_JARS[sel-1]}")
    else
      info "Invalid selection ignored: $sel"
    fi
  done
  if (( ${#SELECTED_JARS[@]} == 0 )); then
    info "No valid selections made; exiting."
    exit 1
  fi
  info "You selected ${#SELECTED_JARS[@]} JAR(s):"
  for jar in "${SELECTED_JARS[@]}"; do
    info "  ‚Ä¢ $(basename "$jar")"
  done
fi

############################################
#  Prepare backup, workdir & log file     #
############################################
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path      : $WAR_PATH"

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  4) For each selected JAR: scan & resolve#
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Processing new JAR: $JAR_NAME"

  # extract service paths from new JAR
  mapfile -t new_paths < <(
    unzip -p "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  info "  Found ${#new_paths[@]} <rest path=> entries in $JAR_NAME"

  # check each existing JAR for conflicts
  for EXIST in "$LIB_DIR"/*.jar; do
    EXIST_NAME="$(basename "$EXIST")"
    [[ "$EXIST_NAME" == "$JAR_NAME" ]] && continue

    mapfile -t exist_paths < <(
      unzip -p "$EXIST" 'services/*' 2>/dev/null \
        | grep -a 'rest path="' \
        | sed -E 's/.*rest path="([^"]+)".*/\1/' \
        | sort -u
    )

    for np in "${new_paths[@]}"; do
      for ep in "${exist_paths[@]}"; do
        if [[ "$np" == "$ep" ]]; then
          info "  Conflict: $JAR_NAME ‚Üî $EXIST_NAME on path '$np'"
          read -r -p "    Remove old JAR $EXIST_NAME and keep $JAR_NAME? [y/N] " resp
          if [[ "$resp" =~ ^[Yy]$ ]]; then
            rm "$EXIST"
            info "    Removed $EXIST_NAME"
          else
            info "    Kept    $EXIST_NAME"
          fi
          break 2
        fi
      done
    done
  done
done

############################################
#  5) Copy selected JARs into WEB-INF/lib  #
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  cp "$NEW_JAR" "$LIB_DIR"/
  info "Copied new JAR ‚Üí WEB-INF/lib/$(basename "$NEW_JAR")"
done

############################################
#  6) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  7) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temp workdir $WORKDIR"
info "----- Deploy completed successfully -----"







#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt for WAR file & JAR directory  #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR

APP_NAME="$(basename "${WAR_PATH%.*}")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Gather all jars in the directory
mapfile -t ALL_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)

if (( ${#ALL_JARS[@]} == 0 )); then
  info "ERROR: No .jar files found in $NEW_JAR_DIR"
  exit 1
elif (( ${#ALL_JARS[@]} == 1 )); then
  SELECTED_JARS=("${ALL_JARS[0]}")
  info "Single JAR found: $(basename "${ALL_JARS[0]}"), proceeding automatically"
else
  info "Found ${#ALL_JARS[@]} JARs in $NEW_JAR_DIR:"
  for i in "${!ALL_JARS[@]}"; do
    idx=$((i + 1))
    echo "  [$idx] $(basename "${ALL_JARS[i]}")"
  done
  echo
  read -r -p "Enter numbers of JARs to deploy (e.g. 1 2 5): " sel_line
  # split the line into an array on whitespace
  read -r -a sel_array <<< "$sel_line"
  SELECTED_JARS=()
  for sel in "${sel_array[@]}"; do
    if [[ "$sel" =~ ^[0-9]+$ ]] && (( sel >= 1 && sel <= ${#ALL_JARS[@]} )); then
      SELECTED_JARS+=("${ALL_JARS[sel-1]}")
    else
      info "Invalid selection ignored: $sel"
    fi
  done
  if (( ${#SELECTED_JARS[@]} == 0 )); then
    info "No valid selections made; exiting."
    exit 1
  fi
  info "You selected ${#SELECTED_JARS[@]} JAR(s):"
  for jar in "${SELECTED_JARS[@]}"; do
    info "  ‚Ä¢ $(basename "$jar")"
  done
fi

############################################
#  Prepare backup, workdir & log file     #
############################################
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path      : $WAR_PATH"

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  4) For each selected JAR: scan & resolve#
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Processing new JAR: $JAR_NAME"

  # extract service paths from new JAR
  mapfile -t new_paths < <(
    unzip -p "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  info "  Found ${#new_paths[@]} <rest path=> entries in $JAR_NAME"

  # check each existing JAR for conflicts
  for EXIST in "$LIB_DIR"/*.jar; do
    EXIST_NAME="$(basename "$EXIST")"
    [[ "$EXIST_NAME" == "$JAR_NAME" ]] && continue

    mapfile -t exist_paths < <(
      unzip -p "$EXIST" 'services/*' 2>/dev/null \
        | grep -a 'rest path="' \
        | sed -E 's/.*rest path="([^"]+)".*/\1/' \
        | sort -u
    )

    for np in "${new_paths[@]}"; do
      for ep in "${exist_paths[@]}"; do
        if [[ "$np" == "$ep" ]]; then
          info "  Conflict: $JAR_NAME ‚Üî $EXIST_NAME on path '$np'"
          read -r -p "    Remove old JAR $EXIST_NAME and keep $JAR_NAME? [y/N] " resp
          if [[ "$resp" =~ ^[Yy]$ ]]; then
            rm "$EXIST"
            info "    Removed $EXIST_NAME"
          else
            info "    Kept    $EXIST_NAME"
          fi
          # once we handle this conflict, stop scanning this existing JAR
          break 2
        fi
      done
    done
  done
done

############################################
#  5) Copy selected JARs into WEB-INF/lib  #
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  cp "$NEW_JAR" "$LIB_DIR"/
  info "Copied new JAR ‚Üí WEB-INF/lib/$(basename "$NEW_JAR")"
done

############################################
#  6) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  7) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temp workdir $WORKDIR"
info "----- Deploy completed successfully -----"







#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt for WAR file & JAR directory  #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR

APP_NAME="$(basename "${WAR_PATH%.*}")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Gather all jars in the directory
mapfile -t ALL_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)

if (( ${#ALL_JARS[@]} == 0 )); then
  info "ERROR: No .jar files found in $NEW_JAR_DIR"
  exit 1
elif (( ${#ALL_JARS[@]} == 1 )); then
  SELECTED_JARS=("${ALL_JARS[0]}")
  info "Single JAR found: $(basename "${ALL_JARS[0]}"), proceeding automatically"
else
  info "Found ${#ALL_JARS[@]} JARs in $NEW_JAR_DIR:"
  for i in "${!ALL_JARS[@]}"; do
    idx=$((i+1))
    echo "  [$idx] $(basename "${ALL_JARS[i]}")"
  done
  echo
  read -r -p "Enter numbers of JARs to deploy (e.g. 1 2 5): " sel_line
  SELECTED_JARS=()
  for sel in $sel_line; do
    if [[ "$sel" =~ ^[0-9]+$ ]] && (( sel >= 1 && sel <= ${#ALL_JARS[@]} )); then
      SELECTED_JARS+=("${ALL_JARS[sel-1]}")
    else
      info "Invalid selection ignored: $sel"
    fi
  done
  if (( ${#SELECTED_JARS[@]} == 0 )); then
    info "No valid selections made; exiting."
    exit 1
  fi
  info "You selected ${#SELECTED_JARS[@]} JAR(s):"
  for jar in "${SELECTED_JARS[@]}"; do
    info "  ‚Ä¢ $(basename "$jar")"
  done
fi

# Prepare filesystem
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path      : $WAR_PATH"

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  4) For each selected JAR: scan & resolve#
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Processing new JAR: $JAR_NAME"

  # extract service paths from new JAR
  mapfile -t new_paths < <(
    unzip -p "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  info "  Found ${#new_paths[@]} <rest path=> entries in $JAR_NAME"

  # check each existing JAR for conflicts
  for EXIST in "$LIB_DIR"/*.jar; do
    EXIST_NAME="$(basename "$EXIST")"
    [[ "$EXIST_NAME" == "$JAR_NAME" ]] && continue

    mapfile -t exist_paths < <(
      unzip -p "$EXIST" 'services/*' 2>/dev/null \
        | grep -a 'rest path="' \
        | sed -E 's/.*rest path="([^"]+)".*/\1/' \
        | sort -u
    )

    for np in "${new_paths[@]}"; do
      for ep in "${exist_paths[@]}"; do
        if [[ "$np" == "$ep" ]]; then
          info "  Conflict: $JAR_NAME ‚Üî $EXIST_NAME on path '$np'"
          read -r -p "    Remove old JAR $EXIST_NAME and keep $JAR_NAME? [y/N] " resp
          if [[ "$resp" =~ ^[Yy]$ ]]; then
            rm "$EXIST"
            info "    Removed $EXIST_NAME"
          else
            info "    Kept    $EXIST_NAME"
          fi
          # stop scanning this existing JAR after first conflict
          break 2
        fi
      done
    done
  done
done

############################################
#  5) Copy selected JARs into WEB-INF/lib  #
############################################
for NEW_JAR in "${SELECTED_JARS[@]}"; do
  cp "$NEW_JAR" "$LIB_DIR"/
  info "Copied new JAR ‚Üí WEB-INF/lib/$(basename "$NEW_JAR")"
done

############################################
#  6) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  7) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temp workdir $WORKDIR"
info "----- Deploy completed successfully -----"





#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt for WAR file & JAR directory  #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the directory of new JAR files: " NEW_JAR_DIR

APP_NAME="$(basename "${WAR_PATH%.*}")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Gather new jars
mapfile -t NEW_JARS < <(printf '%s\n' "$NEW_JAR_DIR"/*.jar)
if (( ${#NEW_JARS[@]} == 0 )); then
  info "ERROR: No .jar files found in $NEW_JAR_DIR"
  exit 1
fi

# Prepare filesystem
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path      : $WAR_PATH"
info "New JARs dir  : $NEW_JAR_DIR"
info "Found ${#NEW_JARS[@]} new JAR(s):"
for j in "${NEW_JARS[@]}"; do info "  ‚Ä¢ $(basename "$j")"; done

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

############################################
#  4) For each new JAR: scan & resolve     #
############################################
for NEW_JAR in "${NEW_JARS[@]}"; do
  JAR_NAME="$(basename "$NEW_JAR")"
  info "Processing new JAR: $JAR_NAME"

  # extract service paths from new JAR
  mapfile -t new_paths < <(
    unzip -p "$NEW_JAR" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  info "  Found ${#new_paths[@]} path(s) in $JAR_NAME"

  # check each existing JAR for conflicts
  for EXIST in "$LIB_DIR"/*.jar; do
    EXIST_NAME="$(basename "$EXIST")"
    # skip comparing to itself if names collide
    [[ "$EXIST_NAME" == "$JAR_NAME" ]] && continue

    mapfile -t exist_paths < <(
      unzip -p "$EXIST" 'services/*' 2>/dev/null \
        | grep -a 'rest path="' \
        | sed -E 's/.*rest path="([^"]+)".*/\1/' \
        | sort -u
    )

    # compare lists
    for np in "${new_paths[@]}"; do
      for ep in "${exist_paths[@]}"; do
        if [[ "$np" == "$ep" ]]; then
          info "  Conflict: $JAR_NAME ‚Üî $EXIST_NAME on path '$np'"
          # ask to remove old JAR
          read -r -p "    Remove old JAR $EXIST_NAME and keep $JAR_NAME? [y/N] " resp
          if [[ "$resp" =~ ^[Yy]$ ]]; then
            rm "$EXIST"
            info "    Removed $EXIST_NAME"
          else
            info "    Kept    $EXIST_NAME"
          fi
          # once we handle this conflict, stop comparing this existing JAR
          break 2
        fi
      done
    done
  done
done

############################################
#  5) Copy all new JARs into WEB-INF/lib   #
############################################
for NEW_JAR in "${NEW_JARS[@]}"; do
  cp "$NEW_JAR" "$LIB_DIR"/
  info "Copied new JAR ‚Üí WEB-INF/lib/$(basename "$NEW_JAR")"
done

############################################
#  6) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  7) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temp workdir $WORKDIR"
info "----- Deploy completed successfully -----"






#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt only for WAR and JAR paths    #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the new JAR file: " JAR_SOURCE

APP_NAME="$(basename "${WAR_PATH%.*}")"
JAR_NAME="$(basename "$JAR_SOURCE")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Prepare filesystem
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path : $WAR_PATH"
info "JAR path : $JAR_SOURCE"

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

############################################
#  4) Scan new JAR for service paths       #
############################################
info "Scanning new JAR for <rest path=> under services/‚Ä¶"
mapfile -t new_paths < <(
  unzip -p "$JAR_SOURCE" 'services/*' 2>/dev/null \
    | grep -a 'rest path="' \
    | sed -E 's/.*rest path="([^"]+)".*/\1/' \
    | sort -u
)
info "Found ${#new_paths[@]} distinct path(s) in new JAR"

############################################
#  5) Scan existing JARs for same paths    #
############################################
LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

conflict_report=""
for existing in "$LIB_DIR"/*.jar; do
  [[ "$(basename "$existing")" == "$JAR_NAME" ]] && continue
  mapfile -t exist_paths < <(
    unzip -p "$existing" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  for np in "${new_paths[@]}"; do
    for ep in "${exist_paths[@]}"; do
      if [[ "$np" == "$ep" ]]; then
        conflict_report+="$(basename "$existing"): $np"$'\n'
      fi
    done
  done
done

if [[ -n "$conflict_report" ]]; then
  info "Detected service-path conflicts:"
  while IFS= read -r line; do
    info "  $line"
  done <<<"$conflict_report"

  read -r -p "Continue deploy anyway? [y/N] " reply
  if [[ ! "$reply" =~ ^[Yy]$ ]]; then
    info "Aborted by user due to service-path conflicts"
    exit 0
  fi
  info "User chose to proceed despite conflicts"
else
  info "No service-path conflicts detected; proceeding"
fi

############################################
#  6) Copy new JAR into WEB-INF/lib        #
############################################
cp "$JAR_SOURCE" "$LIB_DIR/"
info "Copied new JAR ‚Üí WEB-INF/lib/$JAR_NAME"

############################################
#  7) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  8) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temporary workdir $WORKDIR"
info "----- Deploy completed successfully -----"






#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Info fn: echo + timestamp ‚Üí screen+log #
############################################
info() {
  ts="[$(date +'%Y-%m-%d %H:%M:%S')]"
  echo "$ts $*" | tee -a "$LOGFILE"
}

############################################
#  1) Prompt only for WAR and JAR paths    #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the new JAR file: " JAR_SOURCE

APP_NAME="$(basename "${WAR_PATH%.*}")"
JAR_NAME="$(basename "$JAR_SOURCE")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Prepare filesystem
mkdir -p "$BACKUP_DIR" "$WORKDIR" "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

info "----- Starting deploy for $APP_NAME -----"
info "WAR path : $WAR_PATH"
info "JAR path : $JAR_SOURCE"

############################################
#  2) Verify & backup the WAR              #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  info "ERROR: WAR file not found at $WAR_PATH"
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
info "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temp workdir         #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
info "Unpacked WAR into $WORKDIR"

############################################
#  4) Scan new JAR for service paths       #
############################################
info "Scanning new JAR for <rest path=> under services/‚Ä¶"
mapfile -t new_paths < <(
  unzip -p "$JAR_SOURCE" 'services/*' 2>/dev/null \
    | grep -a 'rest path="' \
    | sed -E 's/.*rest path="([^"]+)".*/\1/' \
    | sort -u
)
info "Found ${#new_paths[@]} distinct path(s) in new JAR"

############################################
#  5) Scan existing JARs for same paths    #
############################################
LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  info "ERROR: WEB-INF/lib not found under $WORKDIR"
  exit 1
fi

declare -A conflicts
for existing in "$LIB_DIR"/*.jar; do
  [[ "$(basename "$existing")" == "$JAR_NAME" ]] && continue
  mapfile -t exist_paths < <(
    unzip -p "$existing" 'services/*' 2>/dev/null \
      | grep -a 'rest path="' \
      | sed -E 's/.*rest path="([^"]+)".*/\1/' \
      | sort -u
  )
  for np in "${new_paths[@]}"; do
    for ep in "${exist_paths[@]}"; do
      if [[ "$np" == "$ep" ]]; then
        conflicts["$existing"]+="$np"$'\n'
      fi
    done
  done
done

if (( ${#conflicts[@]} )); then
  info "Detected service-path conflicts with existing JAR(s):"
  for jar in "${!conflicts[@]}"; do
    info " - $(basename "$jar"):"
    while read -r p; do
      [[ -n "$p" ]] && info "     $p"
    done <<<"${conflicts[$jar]}"
  done

  read -r -p "Continue deploy anyway? [y/N] " reply
  if [[ ! "$reply" =~ ^[Yy]$ ]]; then
    info "Aborted by user due to service-path conflicts"
    exit 0
  fi
  info "User chose to proceed despite conflicts"
else
  info "No service-path conflicts detected; proceeding"
fi

############################################
#  6) Copy new JAR into WEB-INF/lib        #
############################################
cp "$JAR_SOURCE" "$LIB_DIR/"
info "Copied new JAR ‚Üí WEB-INF/lib/$JAR_NAME"

############################################
#  7) Repack WAR & replace original       #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
info "Repacked and replaced WAR at $WAR_PATH"

############################################
#  8) Cleanup                              #
############################################
rm -rf "$WORKDIR"
info "Removed temporary workdir $WORKDIR"
info "----- Deploy completed successfully -----"






#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

############################################
#  Fixed internal settings (no prompts)    #
############################################
BACKUP_DIR="/opt/backups/myapp"
BASE_TMP_DIR="/tmp"
LOGFILE="/var/log/deploy.log"

############################################
#  Logging function: timestamps to log     #
############################################
log() {
  echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >> "$LOGFILE"
}

############################################
#  1) Prompt only for WAR and JAR paths    #
############################################
read -e -p "Enter full path to the WAR file: " WAR_PATH
read -e -p "Enter full path to the new JAR file: " JAR_SOURCE

# Derive working names
JAR_NAME="$(basename "$JAR_SOURCE")"
APP_NAME="$(basename "${WAR_PATH%.*}")"
WORKDIR="${BASE_TMP_DIR}/${APP_NAME}_deploy_$$"
TIMESTAMP="$(date +'%Y%m%d_%H%M%S')"

# Prepare filesystem
mkdir -p "$BACKUP_DIR"
mkdir -p "$WORKDIR"
mkdir -p "$(dirname "$LOGFILE")"
touch   "$LOGFILE"

log "----- Starting deploy for $APP_NAME -----"
log "WAR path : $WAR_PATH"
log "JAR path : $JAR_SOURCE"

############################################
#  2) Verify WAR exists and back it up     #
############################################
if [[ ! -f "$WAR_PATH" ]]; then
  log "ERROR: WAR file not found at $WAR_PATH"
  echo "Error: see $LOGFILE for details."
  exit 1
fi

cp "$WAR_PATH" "$BACKUP_DIR/${APP_NAME}_$TIMESTAMP.war"
log "Backed up WAR ‚Üí ${BACKUP_DIR}/${APP_NAME}_$TIMESTAMP.war"

############################################
#  3) Unpack WAR into temporary directory  #
############################################
unzip -q "$WAR_PATH" -d "$WORKDIR"
log "Unzipped WAR into $WORKDIR"

############################################
#  4) Extract Implementation-Title from    #
#     new JAR‚Äôs MANIFEST.MF via unzip -p   #
############################################
NEW_MANIFEST="$(unzip -p "$JAR_SOURCE" META-INF/MANIFEST.MF 2>/dev/null || true)"
NEW_TITLE="$(echo "$NEW_MANIFEST" | grep -i '^Implementation-Title:' | sed -E 's/Implementation-Title:[[:space:]]*//I' || true)"

if [[ -z "$NEW_TITLE" ]]; then
  log "WARNING: No Implementation-Title found in new JAR manifest"
else
  log "New JAR Implementation-Title: $NEW_TITLE"
fi

############################################
#  5) Scan existing JARs for same title    #
############################################
LIB_DIR="$WORKDIR/WEB-INF/lib"
if [[ ! -d "$LIB_DIR" ]]; then
  log "ERROR: WEB-INF/lib not found under $WORKDIR"
  echo "Error: see $LOGFILE for details."
  exit 1
fi

FOUND_CONFLICT=0
for EXISTING in "$LIB_DIR"/*.jar; do
  # Skip if it's the same file
  [[ "$(basename "$EXISTING")" == "$JAR_NAME" ]] && continue
  EXIST_MANIFEST="$(unzip -p "$EXISTING" META-INF/MANIFEST.MF 2>/dev/null || true)"
  EXIST_TITLE="$(echo "$EXIST_MANIFEST" | grep -i '^Implementation-Title:' | sed -E 's/Implementation-Title:[[:space:]]*//I' || true)"
  if [[ -n "$NEW_TITLE" && "$EXIST_TITLE" == "$NEW_TITLE" ]]; then
    log "Conflict: existing JAR $(basename "$EXISTING") has same Title: $EXIST_TITLE"
    FOUND_CONFLICT=1
  fi
done

if (( FOUND_CONFLICT )); then
  echo
  echo "One or more existing JARs in WEB-INF/lib share the same Implementation-Title ('$NEW_TITLE')."
  read -r -p "Do you want to remove those and continue? [y/N] " REPLY
  if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
    log "User aborted due to manifest title conflict."
    echo "Aborted: see $LOGFILE for details."
    exit 0
  fi
  # Remove conflicting jars
  for EXISTING in "$LIB_DIR"/*.jar; do
    EXIST_MANIFEST="$(unzip -p "$EXISTING" META-INF/MANIFEST.MF 2>/dev/null || true)"
    EXIST_TITLE="$(echo "$EXIST_MANIFEST" | grep -i '^Implementation-Title:' | sed -E 's/Implementation-Title:[[:space:]]*//I' || true)"
    if [[ "$EXIST_TITLE" == "$NEW_TITLE" ]]; then
      rm "$EXISTING"
      log "Removed conflicting JAR: $(basename "$EXISTING")"
    fi
  done
  log "User chose to remove conflicts and proceed."
else
  log "No manifest-title conflicts detected; proceeding."
fi

############################################
#  6) Copy new JAR into WEB-INF/lib        #
############################################
cp "$JAR_SOURCE" "$LIB_DIR/"
log "Copied new JAR: $JAR_NAME ‚Üí WEB-INF/lib/"

############################################
#  7) Repack WAR and replace original      #
############################################
pushd "$WORKDIR" > /dev/null
zip -qr "../${APP_NAME}_updated_$TIMESTAMP.war" .
popd > /dev/null

mv "$WORKDIR/../${APP_NAME}_updated_$TIMESTAMP.war" "$WAR_PATH"
log "Repacked and replaced WAR: $WAR_PATH"

############################################
#  8) Cleanup                              #
############################################
rm -rf "$WORKDIR"
log "Removed work directory: $WORKDIR"
log "----- Deploy completed successfully -----"





.toolbar {
  position: relative; /* –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞ absolutely positioned –ø—Å–µ–≤–¥–æ–µ–ª–µ–º–µ–Ω—Ç */
  z-index: 1;
}

.toolbar::before {
  content: "";
  position: absolute;
  inset: -4px; /* border-—ä—Ç –¥–∞ –µ –º–∞–ª–∫–æ –∏–∑–≤—ä–Ω –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
  border-radius: 10px;
  padding: 0;
  pointer-events: none;
  z-index: 2;
  background: linear-gradient(270deg, #3be0ff, #66afe9, #f3ffcd, #3be0ff);
  background-size: 400% 400%;
  width: calc(100% + 8px);
  height: calc(100% + 8px);
  border: 3px solid transparent; /* –∑–∞ fallback */
  box-sizing: border-box;
  animation: borderAnim 4s linear infinite;
  mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  -webkit-mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  mask-composite: exclude;
  -webkit-mask-composite: xor;
}

@keyframes borderAnim {
  0% {
    background-position: 0% 50%;
  }
  100% {
    background-position: 400% 50%;
  }
}






#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import csv
import sys
import codecs


def read_csv_pairs(csv_path):
    """
    –ß–µ—Ç–µ CSV —Å –∫–æ–ª–æ–Ω–∏ filename,id (UTF-8)
    –∏ –≤—Ä—ä—â–∞ —Å–ø–∏—Å—ä–∫ –æ—Ç tuple-–æ–≤–µ (filename, id) –∫–∞—Ç–æ unicode,
    –∫–∞—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç–∫—Ä–∏–≤–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ –ø–æ –∏–º–µ (case-insensitive) –∏–ª–∏ –ø–æ –ø–æ–∑–∏—Ü–∏—è.
    """
    with codecs.open(csv_path, 'r', 'utf-8') as f:
        reader = csv.reader(f)
        try:
            header = next(reader)
        except StopIteration:
            return []
        # –ø–æ—á–∏—Å—Ç–≤–∞ –∏–º–µ–Ω–∞—Ç–∞ –Ω–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ: –º–∞—Ö–∞ BOM, —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è –∏ –∫–∞—Ä–∞ –Ω–∞ lowercase
        clean = [h.strip().lower().lstrip(u'\ufeff') for h in header]
        # –æ–ø—Ä–µ–¥–µ–ª—è –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –∑–∞ filename –∏ id
        filename_idx = clean.index('filename') if 'filename' in clean else 0
        id_idx = clean.index('id') if 'id' in clean else 1
        pairs = []
        for row in reader:
            if len(row) <= max(filename_idx, id_idx):
                continue
            fn = row[filename_idx].strip()
            id_ = row[id_idx].strip()
            pairs.append((fn, id_))
        return pairs


def read_report_ids(report_path):
    """
    –ß–µ—Ç–µ —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª–∞ (UTF-8) —Ä–µ–¥ –ø–æ —Ä–µ–¥,
    —Ä–∞–∑–¥–µ–ª—è –≤—Å–µ–∫–∏ —Ä–µ–¥ –ø–æ '|' –∏ –≤–∑–∏–º–∞ –ø—ä—Ä–≤–æ—Ç–æ –ø–æ–ª–µ –∫–∞—Ç–æ id.
    """
    ids = set()
    with codecs.open(report_path, 'r', 'utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            parts = line.split('|')
            token = parts[0].strip()
            if token:
                ids.add(token)
    return ids


def write_missing(output_path, missing_pairs):
    """
    –ó–∞–ø–∏—Å–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∫–∞—Ç–æ CSV —Å header filename,id –≤ UTF-8.
    """
    with codecs.open(output_path, 'w', 'utf-8') as out:
        writer = csv.writer(out)
        # –∑–∞–ø–∏—Å–≤–∞ header
        writer.writerow([u'filename'.encode('utf-8'), u'id'.encode('utf-8')])
        for fn, id_ in missing_pairs:
            writer.writerow([fn.encode('utf-8'), id_.encode('utf-8')])


def main(csv_path, report_path, output_path=None):
    csv_pairs = read_csv_pairs(csv_path)
    report_ids = read_report_ids(report_path)

    missing = [(fn, id_) for fn, id_ in csv_pairs if id_ not in report_ids]

    if output_path:
        write_missing(output_path, missing)
        print "–ó–∞–ø–∏—Å–∞—Ö –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –≤ '{}'.".format(output_path)
    else:
        # –ø–µ—á–∞—Ç–∞–º–µ header –∏ —Ä–µ–¥–æ–≤–µ—Ç–µ –Ω–∞ stdout
        sys.stdout.write(u"filename,id\n".encode('utf-8'))
        for fn, id_ in missing:
            line = u"{},{}\n".format(fn, id_)
            sys.stdout.write(line.encode('utf-8'))

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.stderr.write("Usage: python2 compare_ids.py <input.csv> <report.txt> [output.csv]\n")
        sys.exit(1)
    csv_file = sys.argv[1]
    report_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) >= 4 else None
    main(csv_file, report_file, output_file)








#

!/usr/bin/env python2
# -*- coding: utf-8 -*-

import csv
import sys
import codecs

def read_csv_pairs(csv_path):
    """
    –ß–µ—Ç–µ CSV —Å –∫–æ–ª–æ–Ω–∏ filename,id (UTF-8)
    –∏ –≤—Ä—ä—â–∞ —Å–ø–∏—Å—ä–∫ –æ—Ç tuple-–æ–≤–µ (filename, id) –∫–∞—Ç–æ unicode.
    """
    with codecs.open(csv_path, 'r', 'utf-8') as f:
        reader = csv.DictReader(f)
        pairs = []
        for row in reader:
            fn = row['filename']
            id_ = row['id']
            pairs.append((fn, id_))
        return pairs


def read_report_ids(report_path):
    """
    –ß–µ—Ç–µ —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª–∞ (UTF-8) —Ä–µ–¥ –ø–æ —Ä–µ–¥,
    —Ä–∞–∑–¥–µ–ª—è –≤—Å–µ–∫–∏ —Ä–µ–¥ –ø–æ '|' –∏ –≤–∑–∏–º–∞ –ø—ä—Ä–≤–æ—Ç–æ –ø–æ–ª–µ –∫–∞—Ç–æ id.
    """
    ids = set()
    with codecs.open(report_path, 'r', 'utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            parts = line.split('|')
            token = parts[0].strip()
            if token:
                ids.add(token)
    return ids


def write_missing(output_path, missing_pairs):
    """
    –ó–∞–ø–∏—Å–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∫–∞—Ç–æ CSV —Å header filename,id –≤ UTF-8.
    """
    with codecs.open(output_path, 'w', 'utf-8') as out:
        writer = csv.writer(out)
        writer.writerow(['filename'.encode('utf-8'), 'id'.encode('utf-8')])
        for fn, id_ in missing_pairs:
            writer.writerow([fn.encode('utf-8'), id_.encode('utf-8')])


def main(csv_path, report_path, output_path=None):
    csv_pairs  = read_csv_pairs(csv_path)
    report_ids = read_report_ids(report_path)

    missing = [(fn, id_) for fn, id_ in csv_pairs if id_ not in report_ids]

    if output_path:
        write_missing(output_path, missing)
        print "–ó–∞–ø–∏—Å–∞—Ö –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –≤ '{}'.".format(output_path)
    else:
        sys.stdout.write(u"filename,id\n".encode('utf-8'))
        for fn, id_ in missing:
            line = u"{},{\n}".format(fn, id_)
            sys.stdout.write(line.encode('utf-8'))

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.stderr.write("Usage: python2 compare_ids.py <input.csv> <report.txt> [output.csv]\n")
        sys.exit(1)
    csv_file    = sys.argv[1]
    report_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) >= 4 else None
    main(csv_file, report_file, output_file)






#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import csv
import sys
import codecs

def read_csv_pairs(csv_path):
    """
    –í—Ä—ä—â–∞ tuple (pairs, fn_field, id_field):
      pairs = [(filename, id), ...] –∫–∞—Ç–æ unicode
      fn_field = –∏–º–µ—Ç–æ –Ω–∞ –∫–æ–ª–æ–Ω–∞—Ç–∞ –∑–∞ filename
      id_field = –∏–º–µ—Ç–æ –Ω–∞ –∫–æ–ª–æ–Ω–∞—Ç–∞ –∑–∞ id
    """
    with codecs.open(csv_path, 'r', 'utf-8') as f:
        reader = csv.DictReader(f)
        fields = reader.fieldnames

        # –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∞—Ç–∞ –∑–∞ filename
        if 'filename' in fields:
            fn_field = 'filename'
        else:
            fn_field = fields[0]

        # –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∞—Ç–∞, —Å—ä–¥—ä—Ä–∂–∞—â–∞ 'id' (–æ—Å–≤–µ–Ω filename)
        id_candidates = [h for h in fields if h.lower().endswith('id') and h != fn_field]
        if 'id' in fields:
            id_field = 'id'
        elif id_candidates:
            id_field = id_candidates[0]
        else:
            sys.stderr.write(u"–ù—è–º–∞ –ø–æ–¥—Ö–æ–¥—è—â–∞ –∫–æ–ª–æ–Ω–∞ –∑–∞ ID –≤ %s\n" % csv_path.encode('utf-8'))
            sys.exit(1)

        pairs = []
        for row in reader:
            fn = row[fn_field]
            id_ = row[id_field]
            pairs.append((fn, id_))
        return pairs, fn_field, id_field

def read_report_ids(report_path):
    """
    –ß–µ—Ç–µ report.txt –∫–∞—Ç–æ UTF-8, –ø—Ä–æ–ø—É—Å–∫–∞ –ø—ä—Ä–≤–∏—è —Ä–µ–¥ (—Ö–µ–¥—ä—Ä),
    –ø–∞—Ä—Å–≤–∞ –≤—Å—è–∫–∞ –ª–∏–Ω–∏—è –ø–æ '|' –∏ –≤–∑–µ–º–∞ –ø–æ–ª–µ—Ç–æ –≤ –∫–æ–ª–æ–Ω–∞—Ç–∞ 'ID'.
    """
    ids = set()
    with codecs.open(report_path, 'r', 'utf-8') as f:
        header = f.readline().rstrip('\n')
        cols = header.split('|')
        try:
            id_idx = cols.index('ID')
        except ValueError:
            id_idx = None

        for line in f:
            parts = line.rstrip('\n').split('|')
            if id_idx is not None and id_idx < len(parts):
                token = parts[id_idx]
            else:
                token = line.strip()
            if token:
                ids.add(token)
    return ids

def write_missing(output_path, missing_pairs, fn_field, id_field):
    """
    –ó–∞–ø–∏—Å–≤–∞ –Ω–æ–≤ CSV —Å header fn_field,id_field –∏ –≤—Å–∏—á–∫–∏ missing_pairs.
    """
    with codecs.open(output_path, 'w', 'utf-8') as out:
        writer = csv.writer(out)
        writer.writerow([fn_field.encode('utf-8'), id_field.encode('utf-8')])
        for fn, id_ in missing_pairs:
            writer.writerow([fn.encode('utf-8'), id_.encode('utf-8')])

def main(csv_path, report_path, output_path=None):
    csv_pairs, fn_field, id_field = read_csv_pairs(csv_path)
    report_ids = read_report_ids(report_path)

    missing = [(fn, id_) for fn, id_ in csv_pairs if id_ not in report_ids]

    if output_path:
        write_missing(output_path, missing, fn_field, id_field)
        print "–ó–∞–ø–∏—Å–∞—Ö –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –≤ '{}'.".format(output_path)
    else:
        # –ø–µ—á–∞—Ç—è–º–µ –Ω–∞ stdout
        sys.stdout.write((u"{},{}\n".format(fn_field, id_field)).encode('utf-8'))
        for fn, id_ in missing:
            sys.stdout.write((u"{},{}\n".format(fn, id_)).encode('utf-8'))

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.stderr.write("Usage: python2 compare_ids.py <input.csv> <report.txt> [output.csv]\n")
        sys.exit(1)

    csv_file    = sys.argv[1]
    report_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) >= 4 else None
    main(csv_file, report_file, output_file)






#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import csv
import sys
import codecs

def read_csv_pairs(csv_path):
    """
    –ß–µ—Ç–µ CSV —Å –∫–æ–ª–æ–Ω–∏ filename,id (UTF-8)
    –∏ –≤—Ä—ä—â–∞ —Å–ø–∏—Å—ä–∫ –æ—Ç tuple-–æ–≤–µ (filename, id) –∫–∞—Ç–æ unicode.
    """
    with codecs.open(csv_path, 'r', 'utf-8') as f:
        reader = csv.DictReader(f)
        pairs = []
        for row in reader:
            # row['filename'] –∏ row['id'] —Å–∞ byte-—Å—Ç—Ä–∏–Ω–≥–æ–≤–µ, –¥–µ–∫–æ–¥–∏—Ä–∞–Ω–∏ –≤ unicode
            fn = row['filename']
            id_ = row['id']
            pairs.append((fn, id_))
        return pairs

def read_report_ids(report_path):
    """
    –ß–µ—Ç–µ —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª–∞ (UTF-8) —Ä–µ–¥ –ø–æ —Ä–µ–¥, –≤–∑–∏–º–∞ strip() –Ω–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥
    –∏ –≥–æ –¥–æ–±–∞–≤—è –≤ set() –∫–∞—Ç–æ unicode.
    """
    ids = set()
    with codecs.open(report_path, 'r', 'utf-8') as f:
        for line in f:
            token = line.strip()
            if token:
                ids.add(token)
    return ids

def write_missing(output_path, missing_pairs):
    """
    –ó–∞–ø–∏—Å–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∫–∞—Ç–æ CSV —Å header filename,id –≤ UTF-8.
    """
    with codecs.open(output_path, 'w', 'utf-8') as out:
        writer = csv.writer(out)
        # –ó–∞–ø–∏—Å–≤–∞–º–µ header –∫–∞—Ç–æ UTF-8 byte-—Å—Ç—Ä–∏–Ω–≥–æ–≤–µ
        writer.writerow(['filename'.encode('utf-8'), 'id'.encode('utf-8')])
        for fn, id_ in missing_pairs:
            writer.writerow([fn.encode('utf-8'), id_.encode('utf-8')])

def main(csv_path, report_path, output_path=None):
    csv_pairs  = read_csv_pairs(csv_path)
    report_ids = read_report_ids(report_path)

    missing = [(fn, id_) for fn, id_ in csv_pairs if id_ not in report_ids]

    if output_path:
        write_missing(output_path, missing)
        print "–ó–∞–ø–∏—Å–∞—Ö –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –≤ '{}'.".format(output_path)
    else:
        # –ø—Ä–∏–Ω—Ç–∏—Ä–∞–º–µ –Ω–∞ stdout
        # –ø—ä—Ä–≤–æ header
        sys.stdout.write(u"filename,id\n".encode('utf-8'))
        for fn, id_ in missing:
            line = u"{},{}\n".format(fn, id_)
            sys.stdout.write(line.encode('utf-8'))

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.stderr.write("Usage: python2 compare_ids.py <input.csv> <report.txt> [output.csv]\n")
        sys.exit(1)
    csv_file    = sys.argv[1]
    report_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) >= 4 else None
    main(csv_file, report_file, output_file)






#!/usr/bin/env python3
import csv
import sys

def read_csv_pairs(csv_path):
    """
    –ß–µ—Ç–µ CSV —Å –∫–æ–ª–æ–Ω–∏ filename,id
    –∏ –≤—Ä—ä—â–∞ —Å–ø–∏—Å—ä–∫ –æ—Ç tuple-–æ–≤–µ (filename, id).
    """
    with open(csv_path, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        return [(row['filename'], row['id']) for row in reader]

def read_report_ids(report_path):
    """
    –ß–µ—Ç–µ —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª–∞ —Ä–µ–¥ –ø–æ —Ä–µ–¥, 
    –≤–∑–µ–º–∞ –≤—Å–µ–∫–∏ —Ç–æ–∫–µ–Ω (—Ä–∞–∑–¥–µ–ª–µ–Ω –ø–æ whitespace) –∏ –≥–æ –¥–æ–±–∞–≤—è –≤ set.
    –ê–∫–æ –≤–∞—à–∏—è—Ç report —Ñ–∞–π–ª —Å—ä–¥—ä—Ä–∂–∞ —Å–∞–º–æ —Å–∞–º–∏ id-—Ç–∞ –Ω–∞ —Ä–µ–¥,
    –º–æ–∂–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –¥–∞ –≤–∑–µ–º–µ—Ç–µ line.strip().
    """
    ids = set()
    with open(report_path, encoding='utf-8') as f:
        for line in f:
            # –∞–∫–æ —Ä–µ–¥—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ —Å–∞–º–æ id:
            token = line.strip()
            if token:
                ids.add(token)
            # –∞–∫–æ –≤ —Ä–µ–¥–∞ –∏–º–∞ —Ç–µ–∫—Å—Ç –∏ id-—Ç–∞ –≤ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∞ –ø–æ–∑–∏—Ü–∏—è:
            # for token in line.split():
            #     ids.add(token)
    return ids

def write_missing(output, missing_pairs):
    """
    –ó–∞–ø–∏—Å–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∫–∞—Ç–æ CSV —Å header filename,id
    """
    writer = csv.writer(output)
    writer.writerow(['filename', 'id'])
    for fn, id_ in missing_pairs:
        writer.writerow([fn, id_])

def main(csv_path, report_path, output_path=None):
    # –ø—Ä–æ—á–∏—Ç–∞–º–µ –¥–≤–∞—Ç–∞ —Ñ–∞–π–ª–∞
    csv_pairs   = read_csv_pairs(csv_path)
    report_ids  = read_report_ids(report_path)

    # —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ –∫–æ–∏ id-—Ç–∞ –æ—Ç CSV-—Ç–æ –ª–∏–ø—Å–≤–∞—Ç –≤ —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª–∞
    missing = [(fn, id_) for fn, id_ in csv_pairs if id_ not in report_ids]

    # –∑–∞–ø–∏—Å–≤–∞–º–µ –∏–ª–∏ –ø–µ—á–∞—Ç–∞–º–µ –Ω–∞ stdout
    if output_path:
        with open(output_path, 'w', newline='', encoding='utf-8') as out:
            write_missing(out, missing)
        print(f"–ó–∞–ø–∏—Å–∞—Ö –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –≤ '{output_path}'.")
    else:
        write_missing(sys.stdout, missing)

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: python compare_ids.py <input.csv> <report.txt> [output.csv]")
        sys.exit(1)
    csv_file    = sys.argv[1]
    report_file = sys.argv[2]
    output_file = sys.argv[3] if len(sys.argv) >= 4 else None
    main(csv_file, report_file, output_file)






#!/usr/bin/env python2
# coding: utf-8
"""
extract_missing_way4book_ids.py

–¢–æ–∑–∏ —Å–∫—Ä–∏–ø—Ç —Å—Ä–∞–≤–Ω—è–≤–∞ WAY4BOOK IDs –æ—Ç –Ω–∞—à–∏—è CSV —Ñ–∞–π–ª —Å –≤—ä–Ω—à–µ–Ω —Ä–µ–ø–æ—Ä—Ç –∏ –∏–∑–≤–ª–∏—á–∞
—Å–∞–º–æ —Ç–µ–∑–∏, –∫–æ–∏—Ç–æ –ù–ï –ø—Ä–∏—Å—ä—Å—Ç–≤–∞—Ç –≤ —Ä–µ–ø–æ—Ä—Ç–∞, –∫–∞—Ç–æ –∑–∞–ø–∞–∑–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –ª–æ–≥ —Ñ–∞–π–ª.

–í—Ö–æ–¥:
  - way4book_ids.csv  (–∫–æ–ª–æ–Ω–∏: filename,way4book_id)
  - report_ids.txt    (–µ–¥–∏–Ω ID –Ω–∞ —Ä–µ–¥)

–ò–∑—Ö–æ–¥:
  - missing_way4book_ids.csv  (—Å–∞–º–æ —Ä–µ–¥–æ–≤–µ—Ç–µ –æ—Ç way4book_ids.csv, —á–∏–∏—Ç–æ IDs –ù–ï —Å–∞ –≤ report_ids.txt)
"""

import csv

# –ü—ä—Ç–∏—â–∞ –¥–æ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ ‚Äì –∫–æ—Ä–∏–≥–∏—Ä–∞–π—Ç–µ –ø—Ä–∏ –Ω—É–∂–¥–∞
WAY4_FILE   = 'way4book_ids.csv'
REPORT_FILE = 'report_ids.txt'
OUTPUT_FILE = 'missing_way4book_ids.csv'

# 1. –ü—Ä–æ—á–∏—Ç–∞–º–µ –≤—Å–∏—á–∫–∏ ID-—Ç–∞ –æ—Ç —Ä–µ–ø–æ—Ä—Ç-—Ñ–∞–π–ª–∞ –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–æ
report_ids = set()
with open(REPORT_FILE, 'r') as rf:
    for line in rf:
        id_str = line.strip()
        if id_str:
            report_ids.add(id_str)

# 2. –ß–µ—Ç–µ–º –Ω–∞—à–∏—è CSV –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å–∞–º–æ —Ç–µ–∑–∏ –∑–∞–ø–∏—Å–∏, —á–∏–∏—Ç–æ WAY4BOOK ID –ù–ï –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ report_ids
with open(WAY4_FILE, 'r') as wf, open(OUTPUT_FILE, 'w') as out:
    reader = csv.reader(wf)
    writer = csv.writer(out)

    # –ü—Ä–æ—á–∏—Ç–∞–º–µ –∏ –ø—Ä–µ–Ω–∞–ø–∏—Å–≤–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    headers = next(reader)
    writer.writerow(headers)

    # –û–ø—Ä–µ–¥–µ–ª—è–º–µ –Ω–∞ –∫–æ–∏ –∏–Ω–¥–µ–∫—Å–∏ —Å–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ filename –∏ way4book_id
    try:
        idx_filename = headers.index('filename')
        idx_id       = headers.index('way4book_id')
    except ValueError:
        # –ê–∫–æ –∏–º–µ–Ω–∞—Ç–∞ –Ω–µ —Å—ä–≤–ø–∞–¥–∞—Ç, –ø—Ä–∏–µ–º–∞–º–µ, —á–µ —Å–∞ –ø—ä—Ä–≤–∏—Ç–µ –¥–≤–µ –∫–æ–ª–æ–Ω–∏
        idx_filename, idx_id = 0, 1

    # –ò—Ç–µ—Ä–∏—Ä–∞–º–µ –∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ
    for row in reader:
        filename = row[idx_filename].strip()
        wid      = row[idx_id].strip()
        # –ó–∞–ø–∏—Å–≤–∞–º–µ —Å–∞–º–æ –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ ID-—Ç–∞
        if wid and wid not in report_ids:
            writer.writerow([filename, wid])

print("–ì–æ—Ç–æ–≤–æ! –õ–∏–ø—Å–≤–∞—â–∏—Ç–µ WAY4BOOK IDs —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(OUTPUT_FILE))






#!/usr/bin/env python2
# coding: utf-8
"""
extract_missing_way4book_ids.py

–°—Ä–∞–≤–Ω—è–≤–∞ WAY4BOOK IDs –æ—Ç –Ω–∞—à–∏—è CSV —Ñ–∞–π–ª —Å –≤—ä–Ω—à–µ–Ω —Ä–µ–ø–æ—Ä—Ç –∏ –∏–∑–≤–ª–∏—á–∞ —Å–∞–º–æ
—Ç–µ–∑–∏, –∫–æ–∏—Ç–æ –ª–∏–ø—Å–≤–∞—Ç –≤ —Ä–µ–ø–æ—Ä—Ç–∞, –∫–∞—Ç–æ –∑–∞–ø–∞–∑–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –ª–æ–≥ —Ñ–∞–π–ª.
"""

import csv

# –ü—ä—Ç–∏—â–∞ –¥–æ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ ‚Äì –ø—Ä–∏ –Ω—É–∂–¥–∞ –≥–∏ –∫–æ—Ä–∏–≥–∏—Ä–∞–π—Ç–µ
WAY4_FILE   = 'way4book_ids.csv'       # CSV —Å –∫–æ–ª–æ–Ω–∏: filename,way4book_id
REPORT_FILE = 'report_ids.txt'         # –¢–µ–∫—Å—Ç–æ–≤ —Ñ–∞–π–ª: –µ–¥–∏–Ω ID –Ω–∞ —Ä–µ–¥
OUTPUT_FILE = 'missing_way4book_ids.csv'

# –ü—Ä–æ—á–∏—Ç–∞–º–µ –≤—Å–∏—á–∫–∏ ID-—Ç–∞ –æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞ (report) –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–æ
report_ids = set()
with open(REPORT_FILE, 'r') as rf:
    for line in rf:
        id_str = line.strip()
        if id_str:
            report_ids.add(id_str)

# –û—Ç–∫—Ä–∏–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å–∞–º–æ —Ç–µ–∑–∏ ID-—Ç–∞, –∫–æ–∏—Ç–æ –ù–ï —Å–∞ –≤ report_ids
with open(WAY4_FILE, 'r') as wf, open(OUTPUT_FILE, 'w') as out:
    reader = csv.DictReader(wf)
    writer = csv.writer(out)
    # –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    writer.writerow(['filename', 'way4book_id'])

    for row in reader:
        wid = row.get('way4book_id', '').strip()
        if wid and wid not in report_ids:
            writer.writerow([row.get('filename', '').strip(), wid])

print("–ì–æ—Ç–æ–≤–æ! –°–∞–º–æ –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ IDs —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(OUTPUT_FILE))




#!/usr/bin/env python2
# coding: utf-8
"""
compare_missing_way4book_ids.py

–°—Ä–∞–≤–Ω—è–≤–∞ WAY4BOOK IDs –æ—Ç –Ω–∞—à–∏—è CSV —Ñ–∞–π–ª —Å –≤—ä–Ω—à–µ–Ω —Ä–µ–ø–æ—Ä—Ç —Ñ–∞–π–ª –∏ –∏–∑–≤–ª–∏—á–∞ —Å–∞–º–æ
—Ç–µ–∑–∏, –∫–æ–∏—Ç–æ –ª–∏–ø—Å–≤–∞—Ç –≤ —Ä–µ–ø–æ—Ä—Ç–∞, –∫–∞—Ç–æ –∑–∞–ø–∞–∑–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –ª–æ–≥ —Ñ–∞–π–ª.

–ù–∞—Å—Ç—Ä–æ–π–∫–∏:
  way4_file   ‚Äì CSV —Ñ–∞–π–ª —Å –¥–≤–µ –∫–æ–ª–æ–Ω–∏: filename,way4book_id
  report_file ‚Äì –¢–µ–∫—Å—Ç–æ–≤ —Ñ–∞–π–ª —Å –ø–æ –µ–¥–∏–Ω ID –Ω–∞ —Ä–µ–¥ (–∏–ª–∏ CSV/TSV —Å –µ–¥–Ω–∞ –∫–æ–ª–æ–Ω–∞)
  output_file ‚Äì CSV —Ñ–∞–π–ª, –≤ –∫–æ–π—Ç–æ —â–µ –∑–∞–ø–∏—à–µ–º —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
"""

import csv

# –ü—ä—Ç–∏—â–∞ –¥–æ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ ‚Äì –∫–æ—Ä–∏–≥–∏—Ä–∞–π—Ç–µ –∞–∫–æ –µ –Ω—É–∂–Ω–æ
way4_file   = 'way4book_ids.csv'
report_file = 'report_ids.txt'
output_file = 'missing_way4book_ids.csv'

# –ü—Ä–æ—á–∏—Ç–∞–º–µ –≤—Å–∏—á–∫–∏ ID-—Ç–∞ –æ—Ç –≤—ä–Ω—à–Ω–∏—è —Ä–µ–ø–æ—Ä—Ç –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∑–∞ –±—ä—Ä–∑–æ —Ç—ä—Ä—Å–µ–Ω–µ
report_ids = set()
with open(report_file, 'r') as rf:
    for line in rf:
        id_str = line.strip()
        if id_str:
            report_ids.add(id_str)

# –°—Ä–∞–≤–Ω—è–≤–∞–º–µ –∏ –∑–∞–ø–∏—Å–≤–∞–º–µ —Å–∞–º–æ –ª–∏–ø—Å–≤–∞—â–∏—Ç–µ –∑–∞–ø–∏—Å–∏
with open(way4_file, 'r') as wf, open(output_file, 'w') as out:
    reader = csv.DictReader(wf)
    writer = csv.writer(out)
    # –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    writer.writerow(['filename', 'way4book_id'])
    for row in reader:
        wid = row.get('way4book_id') or row.get('WAY4BOOK_ID') or ''
        if wid and wid not in report_ids:
            writer.writerow([row.get('filename', ''), wid])

print("–ì–æ—Ç–æ–≤–æ! –õ–∏–ø—Å–≤–∞—â–∏—Ç–µ WAY4BOOK IDs —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_file))






#!/usr/bin/env python2
# coding: utf-8
# –°–∫—Ä–∏–ø—Ç –∑–∞ –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ ID-—Ç–∞, –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Å "WAY4BOOK-",
# –æ—Ç –≤—Å–∏—á–∫–∏ —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ /cygrive/c/INC –∏ –Ω–µ–π–Ω–∏—Ç–µ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.
# –ó–∞ –≤—Å–µ–∫–∏ –Ω–∞–º–µ—Ä–µ–Ω ID —Å–µ –∑–∞–ø–∏—Å–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ —Ñ–∞–π–ª–∞ –∏ —Å–∞–º–æ—Ç–æ ID, —Ä–∞–∑–¥–µ–ª–µ–Ω–∏ —Å—ä—Å –∑–∞–ø–µ—Ç–∞—è.

import os
import re

# –†–µ–≥—É–ª—è—Ä–Ω–∏—è—Ç –∏–∑—Ä–∞–∑ –∑–∞ ID-—Ç–∞, –∑–∞–ø–æ—á–≤–∞—â–∏ —Å "WAY4BOOK-"
pattern = re.compile(r'WAY4BOOK-[A-Za-z0-9_-]+')

# –ò–∑—Ö–æ–¥–µ–Ω CSV —Ñ–∞–π–ª
output_path = 'way4book_ids.csv'
out_file = open(output_path, 'w')

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
out_file.write("filename,way4book_id\n")

# –ö–æ—Ä–µ–Ω–æ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
root_dir = '/cygrive/c/INC'

for root, dirs, files in os.walk(root_dir):
    for filename in files:
        full_path = os.path.join(root, filename)
        try:
            with open(full_path, 'r') as infile:
                for line in infile:
                    for match in pattern.findall(line):
                        # –ó–∞–ø–∏—Å–≤–∞–º–µ: –∏–º–µ –Ω–∞ —Ñ–∞–π–ª–∞, –∑–∞–ø–µ—Ç–∞—è, –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ ID
                        out_file.write("{},{}\n".format(filename, match))
        except (IOError, UnicodeDecodeError):
            # –ü—Ä–æ–ø—É—Å–∫–∞–º–µ —Ñ–∞–π–ª–æ–≤–µ, –∫–æ–∏—Ç–æ –Ω–µ –º–æ–∂–µ –¥–∞ —Å–µ –æ—Ç–≤–æ—Ä—è—Ç –∏–ª–∏ –ø—Ä–æ—á–µ—Ç–∞—Ç –∫–∞—Ç–æ —Ç–µ–∫—Å—Ç
            continue

out_file.close()
print("–ì–æ—Ç–æ–≤–æ! –í—Å–∏—á–∫–∏ ID-—Ç–∞ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_path))






#!/usr/bin/env python2
# coding: utf-8
import os
import re
import csv

# –†–µ–≥–µ–∫—Å –∑–∞ ID-—Ç–∞, –∑–∞–ø–æ—á–≤–∞—â–∏ —Å "WAY4BOOK-"
pattern = re.compile(r'WAY4BOOK-[A-Za-z0-9_-]+')

# –ò–∑—Ö–æ–¥–µ–Ω CSV —Ñ–∞–π–ª
output_path = 'way4book_ids.csv'

# –ö–æ—Ä–µ–Ω–æ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
root_dir = '/cygrive/c/INC'

with open(output_path, 'wb') as out_file:
    writer = csv.writer(out_file)
    # –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    writer.writerow(['file', 'id'])
    # –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ .log —Ñ–∞–π–ª–æ–≤–µ
    for root, dirs, files in os.walk(root_dir):
        for filename in files:
            if filename.lower().endswith('.log'):
                full_path = os.path.join(root, filename)
                try:
                    with open(full_path, 'r') as infile:
                        for line in infile:
                            for match in pattern.findall(line):
                                writer.writerow([filename, match])
                except IOError:
                    # –∞–∫–æ –Ω—è–º–∞ –ø—Ä–∞–≤–∞ –∑–∞ —á–µ—Ç–µ–Ω–µ ‚Äì –ø—Ä–æ–ø—É—Å–∫–∞–º–µ
                    continue

print "–ì–æ—Ç–æ–≤–æ! –í—Å–∏—á–∫–∏ ID-—Ç–∞ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_path)






#!/usr/bin/env python2
# coding: utf-8
# –°–∫—Ä–∏–ø—Ç –∑–∞ –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ ID-—Ç–∞, –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Å "WAY4BOOK-",
# –æ—Ç –≤—Å–∏—á–∫–∏ —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ /cygrive/c/INC –∏ –Ω–µ–π–Ω–∏—Ç–µ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.
# –ó–∞ –≤—Å–µ–∫–∏ –Ω–∞–º–µ—Ä–µ–Ω ID —Å–µ –∑–∞–ø–∏—Å–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ —Ñ–∞–π–ª–∞ –∏ —Å–∞–º–æ—Ç–æ ID.

import os
import re

# –†–µ–≥—É–ª—è—Ä–Ω–∏—è—Ç –∏–∑—Ä–∞–∑ –∑–∞ ID-—Ç–∞, –∑–∞–ø–æ—á–≤–∞—â–∏ —Å "WAY4BOOK-"
pattern = re.compile(r'WAY4BOOK-[A-Za-z0-9_-]+')

# –ò–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª, –≤ –∫–æ–π—Ç–æ —â–µ –∑–∞–ø–∏—à–µ–º —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
output_path = 'way4book_ids.txt'
out_file = open(output_path, 'w')

# –ö–æ—Ä–µ–Ω–æ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
root_dir = '/cygrive/c/INC'

for root, dirs, files in os.walk(root_dir):
    for filename in files:
        full_path = os.path.join(root, filename)
        try:
            with open(full_path, 'r') as infile:
                for line in infile:
                    for match in pattern.findall(line):
                        # –ó–∞–ø–∏—Å–≤–∞–º–µ: –∏–º–µ –Ω–∞ —Ñ–∞–π–ª–∞, —Ç–∞–±—É–ª–∞—Ü–∏—è, –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ ID
                        out_file.write(filename + '\t' + match + '\n')
        except Exception:
            # –ü—Ä–æ–ø—É—Å–∫–∞–º–µ —Ñ–∞–π–ª–æ–≤–µ, –∫–æ–∏—Ç–æ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –æ—Ç–≤–æ—Ä—è—Ç –∏–ª–∏ –ø—Ä–æ—á–µ—Ç–∞—Ç (–Ω–∞–ø—Ä. –¥–≤–æ–∏—á–Ω–∏)
            continue

out_file.close()
print("–ì–æ—Ç–æ–≤–æ! –í—Å–∏—á–∫–∏ ID-—Ç–∞ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_path))






#!/usr/bin/env python2
# coding: utf-8
# –°–∫—Ä–∏–ø—Ç –∑–∞ –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ ID-—Ç–∞, –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Å "WAY4BOOK-",
# –æ—Ç –≤—Å–∏—á–∫–∏ .log —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ /cygrive/c/INC –∏ –Ω–µ–π–Ω–∏—Ç–µ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.
# –ó–∞ –≤—Å–µ–∫–∏ –Ω–∞–º–µ—Ä–µ–Ω ID —Å–µ –∑–∞–ø–∏—Å–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ –ª–æ–≥ —Ñ–∞–π–ª–∞ –∏ —Å–∞–º–æ—Ç–æ ID.

import os
import re

# –†–µ–≥—É–ª—è—Ä–Ω–∏—è—Ç –∏–∑—Ä–∞–∑ –∑–∞ ID-—Ç–∞, –∑–∞–ø–æ—á–≤–∞—â–∏ —Å "WAY4BOOK-"
pattern = re.compile(r'WAY4BOOK-[A-Za-z0-9_-]+')

# –ò–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª, –≤ –∫–æ–π—Ç–æ —â–µ –∑–∞–ø–∏—à–µ–º —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
output_path = 'way4book_ids.txt'
out_file = open(output_path, 'w')

# –ö–æ—Ä–µ–Ω–æ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
root_dir = '/cygrive/c/INC'

for root, dirs, files in os.walk(root_dir):
    for filename in files:
        # –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ —Å–∞–º–æ —Ñ–∞–π–ª–æ–≤–µ —Å —Ä–∞–∑—à–∏—Ä–µ–Ω–∏–µ .log
        if filename.lower().endswith('.log'):
            full_path = os.path.join(root, filename)
            try:
                with open(full_path, 'r') as infile:
                    for line in infile:
                        for match in pattern.findall(line):
                            # –ó–∞–ø–∏—Å–≤–∞–º–µ: –∏–º–µ –Ω–∞ –ª–æ–≥ —Ñ–∞–π–ª–∞, —Ç–∞–±—É–ª–∞—Ü–∏—è, –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ ID
                            out_file.write(filename + '\t' + match + '\n')
            except IOError:
                # –ê–∫–æ –Ω–µ –º–æ–∂–µ–º –¥–∞ –æ—Ç–≤–æ—Ä–∏–º —Ñ–∞–π–ª–∞ (–ª–∏–ø—Å–≤–∞—â–∏ –ø—Ä–∞–≤–∞ –∏ —Ç.–Ω.), –ø—Ä–æ–ø—É—Å–∫–∞–º–µ
                continue

out_file.close()
print("–ì–æ—Ç–æ–≤–æ! –í—Å–∏—á–∫–∏ ID-—Ç–∞ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_path))





#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# –°–∫—Ä–∏–ø—Ç –∑–∞ –∏–∑–∫–∞—Ä–≤–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ ID-—Ç–∞, –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Å "WAY4BOOK-",
# –æ—Ç –≤—Å–∏—á–∫–∏ .log —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ /cygrive/c/INC –∏ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏—Ç–µ —ù.
# –ó–∞ –≤—Å–µ–∫–∏ –Ω–∞–º–µ—Ä–µ–Ω ID —Å–µ –∑–∞–ø–∏—Å–≤–∞ –∏–º–µ—Ç–æ –Ω–∞ –ª–æ–≥ —Ñ–∞–π–ª–∞ –∏ —Å–∞–º–æ—Ç–æ ID –≤ –∏–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª.

import os
import re

# –†–µ–≥—É–ª—è—Ä–Ω–∏—è—Ç –∏–∑—Ä–∞–∑ –∑–∞ ID-—Ç–∞, –∑–∞–ø–æ—á–≤–∞—â–∏ —Å "WAY4BOOK-"
pattern = re.compile(r'WAY4BOOK-[A-Za-z0-9_-]+')

# –ò–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª, –≤ –∫–æ–π—Ç–æ —â–µ –∑–∞–ø–∏—à–µ–º —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
output_path = 'way4book_ids.txt'
out_file = open(output_path, 'w')

# –ö–æ—Ä–µ–Ω–æ–≤–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è, –∑–∞–ø–æ—á–≤–∞–º–µ –æ—Ç –Ω–µ—è
root_dir = '/cygrive/c/INC'

for root, dirs, files in os.walk(root_dir):
    for filename in files:
        # –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ —Å–∞–º–æ —Ñ–∞–π–ª–æ–≤–µ —Å —Ä–∞–∑—à–∏—Ä–µ–Ω–∏–µ .log
        if filename.lower().endswith('.log'):
            full_path = os.path.join(root, filename)
            try:
                with open(full_path, 'r') as infile:
                    for line in infile:
                        for match in pattern.findall(line):
                            # –ó–∞–ø–∏—Å–≤–∞–º–µ: –∏–º–µ –Ω–∞ –ª–æ–≥ —Ñ–∞–π–ª–∞, —Ç–∞–±—É–ª–∞—Ü–∏—è, –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ ID, –Ω–æ–≤ —Ä–µ–¥
                            out_file.write(filename + '\t' + match + '\n')
            except IOError:
                # –ê–∫–æ –Ω–µ –º–æ–∂–µ–º –¥–∞ –æ—Ç–≤–æ—Ä–∏–º —Ñ–∞–π–ª–∞ (–ª–∏–ø—Å–≤–∞—â–∏ –ø—Ä–∞–≤–∞ –∏ —Ç.–Ω.), –ø—Ä–æ–ø—É—Å–∫–∞–º–µ
                continue

out_file.close()
print("–ì–æ—Ç–æ–≤–æ! –í—Å–∏—á–∫–∏ ID-—Ç–∞ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏ –≤ '{}'.".format(output_path))





import os
import re

# –û—Å–Ω–æ–≤–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å –ª–æ–≥–æ–≤–µ—Ç–µ
SOURCE_DIR = "C:/Path/To/Your/Logs"  # <-- —Å–º–µ–Ω–∏ —Å —Ç–≤–æ—è –ø—ä—Ç
OUTPUT_FILE = "all_ids_with_logs.txt"

# –†–µ–≥—É–ª—è—Ä–Ω–æ –∏–∑—Ä–∞–∂–µ–Ω–∏–µ –∑–∞ WAY4BOOK-xxxxx
pattern = re.compile(r"(WAY4BOOK-\d{5})")

results = []

for root, dirs, files in os.walk(SOURCE_DIR):
    for filename in files:
        if filename.lower().endswith(".log"):
            file_path = os.path.join(root, filename)
            try:
                with open(file_path, "r") as f:
                    for line in f:
                        matches = pattern.findall(line)
                        for match in matches:
                            results.append("{} | {}".format(match, filename))
            except Exception as e:
                print("[–ì—Ä–µ—à–∫–∞] {}: {}".format(file_path, e))

# –ó–∞–ø–∏—Å –≤—ä–≤ —Ñ–∞–π–ª
with open(OUTPUT_FILE, "w") as out_file:
    out_file.write("\n".join(results))

print("[OK] –ò–∑–≤–ª–µ—á–µ–Ω–∏ {} ID-—Ç–∞. –ó–∞–ø–∏—Å–∞–Ω–∏ –≤: {}".format(len(results), OUTPUT_FILE))






import os
import re

# –ó–∞–¥–∞–π —Ç—É–∫ –æ—Å–Ω–æ–≤–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å –ª–æ–≥–æ–≤–∏—Ç–µ –ø–æ–¥–ø–∞–ø–∫–∏
SOURCE_DIR = "C:/Path/To/Your/Logs"  # <-- –ø—Ä–æ–º–µ–Ω–∏ —Ç–æ–≤–∞
OUTPUT_FILE = "all_ids_with_logs.txt"

# –†–µ–≥—É–ª—è—Ä–Ω–æ –∏–∑—Ä–∞–∂–µ–Ω–∏–µ –∑–∞ ID
pattern = re.compile(r"(WAY4BOOK-\d{5})")

results = []

for root, _, files in os.walk(SOURCE_DIR):
    for filename in files:
        if filename.lower().endswith(".log"):
            file_path = os.path.join(root, filename)
            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    for line in f:
                        for match in pattern.findall(line):
                            results.append(f"{match} | {filename}")
            except Exception as e:
                print(f"[–ì—Ä–µ—à–∫–∞] {file_path}: {e}")

# –ó–∞–ø–∏—Å –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞
with open(OUTPUT_FILE, "w", encoding="utf-8") as out_file:
    out_file.write("\n".join(results))

print(f"[OK] –ò–∑–≤–ª–µ—á–µ–Ω–∏ {len(results)} ID-—Ç–∞. –ó–∞–ø–∏—Å–∞–Ω–∏ –≤: {OUTPUT_FILE}")





# merge_replacements.py

def load_mapping(filepath):
    mapping = {}
    with open(filepath, 'r') as f:
        next(f)  # skip header
        for line in f:
            parts = line.strip().split('|')
            if len(parts) == 2:
                recid, arr_id = parts
                mapping[arr_id] = recid
    return mapping

def update_file(input_file, output_file, mapping):
    with open(input_file, 'r') as fin, open(output_file, 'w') as fout:
        header = fin.readline()
        fout.write(header)
        for line in fin:
            parts = line.strip().split('|')
            if len(parts) == 3:
                _, arr_id, status = parts
                new_recid = mapping.get(arr_id, arr_id)
                fout.write(f"{new_recid}|{arr_id}|{status}\n")

if __name__ == "__main__":
    id4_map = load_mapping("id4.txt")
    update_file("id3.txt", "id3_updated.txt", id4_map)




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

#define MAX_ENTRIES 10000
#define MAX_PATH 4096

typedef struct {
    char path[MAX_PATH];
    off_t size;
    int is_dir;
} Entry;

Entry entries[MAX_ENTRIES];
int entry_count = 0;
int dirs_only = 0;
int files_only = 0;
int top_n = 10;

void format_size(off_t size, char *buf, size_t buflen) {
    const char *units[] = {"B", "K", "M", "G", "T"};
    int i = 0;
    double sz = size;
    while (sz >= 1024 && i < 4) {
        sz /= 1024;
        i++;
    }
    snprintf(buf, buflen, "%.1f%s", sz, units[i]);
}

off_t scan(const char *path) {
    struct stat st;
    if (lstat(path, &st) != 0) return 0;

    if (S_ISLNK(st.st_mode)) return 0;

    if (S_ISREG(st.st_mode)) {
        if (!dirs_only && entry_count < MAX_ENTRIES) {
            strncpy(entries[entry_count].path, path, MAX_PATH - 1);
            entries[entry_count].size = st.st_size;
            entries[entry_count].is_dir = 0;
            entry_count++;
        }
        return st.st_size;
    }

    if (S_ISDIR(st.st_mode)) {
        off_t total = 0;
        DIR *dir = opendir(path);
        if (!dir) return 0;
        struct dirent *entry;
        char subpath[MAX_PATH];

        while ((entry = readdir(dir))) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            snprintf(subpath, MAX_PATH, "%s/%s", path, entry->d_name);
            total += scan(subpath);
        }

        closedir(dir);

        if (!files_only && entry_count < MAX_ENTRIES) {
            strncpy(entries[entry_count].path, path, MAX_PATH - 1);
            entries[entry_count].size = total;
            entries[entry_count].is_dir = 1;
            entry_count++;
        }

        return total;
    }

    return 0;
}

int compare(const void *a, const void *b) {
    off_t size_a = ((Entry *)a)->size;
    off_t size_b = ((Entry *)b)->size;
    return (size_b > size_a) - (size_b < size_a);
}

int main(int argc, char *argv[]) {
    const char *target = ".";
    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "--dirs-only") == 0) dirs_only = 1;
        else if (strcmp(argv[i], "--files-only") == 0) files_only = 1;
        else if (strcmp(argv[i], "--top") == 0 && i + 1 < argc) {
            top_n = atoi(argv[++i]);
        } else if (argv[i][0] != '-') {
            target = argv[i];
        }
    }

    scan(target);

    qsort(entries, entry_count, sizeof(Entry), compare);

    printf("\nTop %d largest %s under '%s':\n\n", top_n,
           dirs_only ? "directories" : (files_only ? "files" : "items"), target);
    printf("%-6s  %-10s  Path\n", "Type", "Size");
    printf("%-6s  %-10s  %-60s\n", "------", "----------", "------------------------------------------------------------");

    char size_buf[20];
    for (int i = 0; i < entry_count && i < top_n; i++) {
        format_size(entries[i].size, size_buf, sizeof(size_buf));
        printf("%-6s  %10s  %s\n", entries[i].is_dir ? "DIR" : "FILE", size_buf, entries[i].path);
    }

    return 0;
}






#define _XOPEN_SOURCE 500
#include <ftw.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <sys/stat.h>

#define MAX_ENTRIES 10000
#define MAX_PATH 4096

typedef struct {
    char path[MAX_PATH];
    off_t size;
    int is_dir;
} Entry;

Entry entries[MAX_ENTRIES];
int entry_count = 0;
int dirs_only = 0;
int files_only = 0;

off_t add_entry(const char *path, off_t size, int is_dir) {
    if (entry_count >= MAX_ENTRIES) return size;

    strcpy(entries[entry_count].path, path);
    entries[entry_count].size = size;
    entries[entry_count].is_dir = is_dir;
    entry_count++;
    return size;
}

int compare_entries(const void *a, const void *b) {
    Entry *ea = (Entry *)a;
    Entry *eb = (Entry *)b;
    return (eb->size > ea->size) - (eb->size < ea->size);
}

off_t walk_directory(const char *path);

int process_entry(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {
    if (typeflag == FTW_F && !dirs_only) {
        add_entry(fpath, sb->st_size, 0);
    } else if (typeflag == FTW_D && !files_only) {
        off_t dir_size = walk_directory(fpath);
        add_entry(fpath, dir_size, 1);
    }
    return 0;
}

off_t walk_directory(const char *path) {
    off_t total_size = 0;
    struct stat sb;
    if (stat(path, &sb) == -1) return 0;
    total_size += sb.st_size;

    DIR *dir = opendir(path);
    if (!dir) return total_size;

    struct dirent *entry;
    char fullpath[MAX_PATH];

    while ((entry = readdir(dir))) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);
        if (stat(fullpath, &sb) == -1) continue;

        if (S_ISDIR(sb.st_mode)) {
            total_size += walk_directory(fullpath);
        } else if (S_ISREG(sb.st_mode)) {
            total_size += sb.st_size;
        }
    }

    closedir(dir);
    return total_size;
}

void format_size(off_t size, char *buf, size_t buflen) {
    const char *units[] = {"B", "K", "M", "G", "T", "P"};
    int i = 0;
    double sz = size;
    while (sz >= 1024 && i < 5) {
        sz /= 1024;
        i++;
    }
    snprintf(buf, buflen, "%.1f%s", sz, units[i]);
}

int main(int argc, char *argv[]) {
    const char *target_dir = ".";
    int top_n = 10;

    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "--dirs-only")) dirs_only = 1;
        else if (!strcmp(argv[i], "--files-only")) files_only = 1;
        else if (!strcmp(argv[i], "--top") && i + 1 < argc) {
            top_n = atoi(argv[++i]);
        } else if (argv[i][0] != '-') {
            target_dir = argv[i];
        }
    }

    if (nftw(target_dir, process_entry, 10, FTW_PHYS | FTW_ACTIONRETVAL) == -1) {
        perror("nftw");
        return 1;
    }

    qsort(entries, entry_count, sizeof(Entry), compare_entries);

    printf("\nTop %d largest %s under '%s':\n\n", top_n,
           dirs_only ? "directories" : (files_only ? "files" : "items"), target_dir);
    printf("%-6s  %-10s  Path\n", "Type", "Size");
    printf("%-6s  %-10s  %-60s\n", "------", "----------", "------------------------------------------------------------");

    char size_buf[20];
    for (int i = 0; i < entry_count && i < top_n; i++) {
        format_size(entries[i].size, size_buf, sizeof(size_buf));
        printf("%-6s  %10s  %s\n", entries[i].is_dir ? "DIR" : "FILE", size_buf, entries[i].path);
    }

    return 0;
}







#define _XOPEN_SOURCE 500
#include <ftw.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <sys/stat.h>

#define MAX_ENTRIES 10000
#define MAX_PATH 4096

typedef struct {
    char path[MAX_PATH];
    off_t size;
    int is_dir;
} Entry;

Entry entries[MAX_ENTRIES];
int entry_count = 0;
int dirs_only = 0;
int files_only = 0;

off_t add_entry(const char *path, off_t size, int is_dir) {
    if (entry_count >= MAX_ENTRIES) return size;

    strcpy(entries[entry_count].path, path);
    entries[entry_count].size = size;
    entries[entry_count].is_dir = is_dir;
    entry_count++;
    return size;
}

int compare_entries(const void *a, const void *b) {
    Entry *ea = (Entry *)a;
    Entry *eb = (Entry *)b;
    return (eb->size > ea->size) - (eb->size < ea->size);
}

off_t walk_directory(const char *path);

int process_entry(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {
    if (typeflag == FTW_F && !dirs_only) {
        add_entry(fpath, sb->st_size, 0);
    } else if (typeflag == FTW_D && !files_only) {
        off_t dir_size = walk_directory(fpath);
        add_entry(fpath, dir_size, 1);
    }
    return 0;
}

off_t walk_directory(const char *path) {
    off_t total_size = 0;
    struct stat sb;
    if (stat(path, &sb) == -1) return 0;
    total_size += sb.st_size;

    DIR *dir = opendir(path);
    if (!dir) return total_size;

    struct dirent *entry;
    char fullpath[MAX_PATH];

    while ((entry = readdir(dir))) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);
        if (stat(fullpath, &sb) == -1) continue;

        if (S_ISDIR(sb.st_mode)) {
            total_size += walk_directory(fullpath);
        } else if (S_ISREG(sb.st_mode)) {
            total_size += sb.st_size;
        }
    }

    closedir(dir);
    return total_size;
}

void format_size(off_t size, char *buf, size_t buflen) {
    const char *units[] = {"B", "K", "M", "G", "T", "P"};
    int i = 0;
    double sz = size;
    while (sz >= 1024 && i < 5) {
        sz /= 1024;
        i++;
    }
    snprintf(buf, buflen, "%.1f%s", sz, units[i]);
}

int main(int argc, char *argv[]) {
    const char *target_dir = ".";
    int top_n = 10;

    for (int i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "--dirs-only")) dirs_only = 1;
        else if (!strcmp(argv[i], "--files-only")) files_only = 1;
        else if (!strcmp(argv[i], "--top") && i + 1 < argc) {
            top_n = atoi(argv[++i]);
        } else if (argv[i][0] != '-') {
            target_dir = argv[i];
        }
    }

    if (nftw(target_dir, process_entry, 10, FTW_PHYS | FTW_ACTIONRETVAL) == -1) {
        perror("nftw");
        return 1;
    }

    qsort(entries, entry_count, sizeof(Entry), compare_entries);

    printf("\nTop %d largest %s under '%s':\n\n", top_n,
           dirs_only ? "directories" : (files_only ? "files" : "items"), target_dir);
    printf("%-6s  %-10s  Path\n", "Type", "Size");
    printf("%-6s  %-10s  %-60s\n", "------", "----------", "------------------------------------------------------------");

    char size_buf[20];
    for (int i = 0; i < entry_count && i < top_n; i++) {
        format_size(entries[i].size, size_buf, sizeof(size_buf));
        printf("%-6s  %10s  %s\n", entries[i].is_dir ? "DIR" : "FILE", size_buf, entries[i].path);
    }

    return 0;
}






use std::env;
use std::fs::{self, DirEntry, Metadata};
use std::io;
use std::path::{Path, PathBuf};
use std::time::Instant;

fn get_size(path: &Path) -> u64 {
    match fs::metadata(path) {
        Ok(metadata) => {
            if metadata.is_file() {
                metadata.len()
            } else if metadata.is_dir() {
                let mut size = 0;
                if let Ok(entries) = fs::read_dir(path) {
                    for entry in entries.filter_map(Result::ok) {
                        let entry_path = entry.path();
                        size += get_size(&entry_path);
                    }
                }
                size
            } else {
                0
            }
        }
        Err(_) => 0,
    }
}

fn collect_entries(path: &Path, results: &mut Vec<(PathBuf, u64)>) {
    if let Ok(entries) = fs::read_dir(path) {
        for entry in entries.filter_map(Result::ok) {
            let entry_path = entry.path();
            let size = get_size(&entry_path);
            results.push((entry_path.clone(), size));
            if entry_path.is_dir() {
                collect_entries(&entry_path, results);
            }
        }
    }
}

fn main() -> io::Result<()> {
    let start = Instant::now();

    let args: Vec<String> = env::args().collect();
    let root_path = if args.len() > 1 {
        PathBuf::from(&args[1])
    } else {
        env::current_dir()?
    };

    println!("Analyzing: {}", root_path.display());

    let mut results = Vec::new();
    collect_entries(&root_path, &mut results);

    results.sort_by(|a, b| b.1.cmp(&a.1)); // —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø–æ –≥–æ–ª–µ–º–∏–Ω–∞ (–Ω–∞–º–∞–ª—è–≤–∞—â–æ)

    println!("\nTop 20 biggest files/directories:");
    for (path, size) in results.iter().take(20) {
        println!("{:<10} {}", format_size(*size), path.display());
    }

    println!("\nDone in {:.2?}", start.elapsed());
    Ok(())
}

fn format_size(size: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if size >= GB {
        format!("{:.2} GB", size as f64 / GB as f64)
    } else if size >= MB {
        format!("{:.2} MB", size as f64 / MB as f64)
    } else if size >= KB {
        format!("{:.2} KB", size as f64 / KB as f64)
    } else {
        format!("{} B", size)
    }
}








#!/usr/bin/env python3
"""
disk_analyser.py

Recursively walks through a directory tree on a Linux system,
calculates total sizes for each directory (including its children),
and prints the top-N largest directories/files in human-readable form.

Usage:
    python3 disk_analyser.py /path/to/scan --top 10

If --top is omitted, it defaults to 10. If no path is given, it uses the current directory.
"""

import os
import argparse
import sys
from collections import defaultdict

def parse_args():
    parser = argparse.ArgumentParser(
        description="Scan a directory recursively and report the largest directories or files."
    )
    parser.add_argument(
        "root_path",
        nargs="?",
        default=".",
        help="Path to the directory you want to analyze (default: current directory)."
    )
    parser.add_argument(
        "--top",
        "-t",
        type=int,
        default=10,
        help="Number of top entries to display (default: 10)."
    )
    parser.add_argument(
        "--dirs-only",
        action="store_true",
        help="Show only directories (skip individual files)."
    )
    parser.add_argument(
        "--files-only",
        action="store_true",
        help="Show only files (skip aggregating directory totals)."
    )
    return parser.parse_args()

def sizeof_fmt(num_bytes, suffix="B"):
    """
    Convert a size in bytes to a human-readable string.
    e.g. 1024 -> "1.0KB", 1048576 -> "1.0MB"
    """
    for unit in ["", "K", "M", "G", "T", "P", "E"]:
        if abs(num_bytes) < 1024.0:
            return f"{num_bytes:.1f}{unit}{suffix}"
        num_bytes /= 1024.0
    return f"{num_bytes:.1f}Z{suffix}"

def accumulate_sizes(root):
    """
    Walk through the directory tree starting at `root`.
    Returns two mappings:
      1) dir_size_map: maps each directory path to the total size (in bytes) of all files under it.
      2) file_size_map: maps each file path to its size in bytes.
    """
    dir_size_map = defaultdict(int)
    file_size_map = {}

    # os.walk yields (dirpath, dirnames, filenames)
    for dirpath, dirnames, filenames in os.walk(root, onerror=_walk_error, followlinks=False):
        total_size_in_dir = 0
        for fname in filenames:
            fpath = os.path.join(dirpath, fname)
            try:
                stat = os.stat(fpath, follow_symlinks=False)
                size = stat.st_size
            except (OSError, PermissionError):
                # Skip files we can't access
                continue

            file_size_map[fpath] = size
            total_size_in_dir += size

        # Add this directory's own files to its entry
        dir_size_map[dirpath] += total_size_in_dir

        # Propagate size upward: every parent directory gets this total
        parent = dirpath
        while True:
            parent = os.path.dirname(parent.rstrip(os.sep))
            if not parent or parent == dirpath:
                break
            dir_size_map[parent] += total_size_in_dir
            dirpath = parent

    return dir_size_map, file_size_map

def _walk_error(err):
    """
    Handler for os.walk errors (e.g., permission issues).
    Just print a warning to stderr and continue.
    """
    sys.stderr.write(f"Warning: cannot access {err.filename}: {err.strerror}\n")

def main():
    args = parse_args()
    root = os.path.abspath(args.root_path)

    if not os.path.exists(root):
        print(f"Error: The path '{root}' does not exist.")
        sys.exit(1)

    # Build maps of sizes
    dir_size_map, file_size_map = accumulate_sizes(root)

    items = []
    if not args.files_only:
        # Include directories (with aggregated sizes)
        for dpath, total in dir_size_map.items():
            items.append((total, dpath, "dir"))
    if not args.dirs_only:
        # Include individual files
        for fpath, size in file_size_map.items():
            items.append((size, fpath, "file"))

    # Sort by size descending
    items.sort(key=lambda x: x[0], reverse=True)

    # Print header
    print(f"\nTop {args.top} largest {'directories and files' if not (args.files_only or args.dirs_only) else ('directories' if args.dirs_only else 'files')} under '{root}':\n")
    print(f"{'Type':<6}  {'Size':>10}  Path")
    print(f"{'-'*6}  {'-'*10}  {'-'*60}")

    count = 0
    for total, path, kind in items:
        human = sizeof_fmt(total)
        label = "DIR" if kind == "dir" else "FILE"
        print(f"{label:<6}  {human:>10}  {path}")
        count += 1
        if count >= args.top:
            break

    print()

if __name__ == "__main__":
    main()






// disk_usage_html.cpp
// ==============
// Compile with:
//   g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html
// If you see ‚Äúundefined reference to `std::filesystem::‚Ä¶‚Äô‚Äù errors, add ‚Äú-lstdc++fs‚Äù at the end:
//   g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html -lstdc++fs

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <string>

namespace fs = std::filesystem;

struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte count into a human-readable string (e.g. "1.23 MB")
static std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024.0 && unitIndex < 4) {
        readableSize /= 1024.0;
        ++unitIndex;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// URL‚Äêencode a few characters so <a href="file://‚Ä¶"> works
static std::string urlEncode(const std::string& path) {
    std::ostringstream oss;
    for (char c : path) {
        switch (c) {
            case ' ' : oss << "%20"; break;
            case '"' : oss << "%22"; break;
            case '#' : oss << "%23"; break;
            case '%' : oss << "%25"; break;
            case '&' : oss << "%26"; break;
            case '\'' : oss << "%27"; break;
            case '+' : oss << "%2B"; break;
            case ',' : oss << "%2C"; break;
            case '/' : oss << "/";   break; // leave slash as-is
            case ':' : oss << "%3A"; break;
            case ';' : oss << "%3B"; break;
            case '<' : oss << "%3C"; break;
            case '=' : oss << "%3D"; break;
            case '>' : oss << "%3E"; break;
            case '?' : oss << "%3F"; break;
            case '[' : oss << "%5B"; break;
            case '\\': oss << "%5C"; break;
            case ']' : oss << "%5D"; break;
            case '^' : oss << "%5E"; break;
            case '`' : oss << "%60"; break;
            case '{' : oss << "%7B"; break;
            case '|' : oss << "%7C"; break;
            case '}' : oss << "%7D"; break;
            case '~' : oss << "%7E"; break;
            default:
                if (static_cast<unsigned char>(c) >= 0x20 && static_cast<unsigned char>(c) <= 0x7E) {
                    oss << c;
                } else {
                    oss << "%"
                        << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                        << (static_cast<int>(static_cast<unsigned char>(c)))
                        << std::dec << std::nouppercase;
                }
        }
    }
    return oss.str();
}

// Collect files in dirPath up to two levels deep
static void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath
static void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Write out a complete HTML report called ‚Äúdisk_usage.html‚Äù
static void generateHtmlReport(const std::vector<FileEntry>& files, uintmax_t totalSize) {
    std::ofstream html("disk_usage.html");
    if (!html.is_open()) {
        std::cerr << "Error: could not open disk_usage.html for writing.\n";
        return;
    }

    // Use a raw‚Äêstring literal with custom delimiter R"HTML(... )HTML"
    html << R"HTML(<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disk Usage Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 8px 12px; border: 1px solid #ccc; }
    th { background-color: #f2f2f2; cursor: pointer; }
    tr:nth-child(even) { background-color: #fafafa; }
    tr:hover { background-color: #f1f1f1; }
    caption { font-size: 1.2em; margin-bottom: 10px; font-weight: bold; }
    .total-row { font-weight: bold; background-color: #e8e8e8; }
  </style>
</head>
<body>

<h2>Disk Usage Report</h2>
<p>Generated by <code>disk_usage_html</code>. Click on a column header to sort. Click a file path to open (in your file‚Äêmanager or default handler).</p>

<table id="usageTable">
  <caption>Files and Sizes</caption>
  <thead>
    <tr>
      <th onclick="sortTable(0)">Size</th>
      <th onclick="sortTable(1)">Path</th>
    </tr>
  </thead>
  <tbody>
)HTML";

    // One HTML row per file entry
    for (auto const& fe : files) {
        std::string hrSize = humanReadableSize(fe.size);
        std::string filePath = fe.path.string();
        std::string url = std::string("file://") + urlEncode(filePath);

        html << "    <tr>\n";
        html << "      <td>" << hrSize << "</td>\n";
        html << "      <td><a href=\"" << url << "\">" << filePath << "</a></td>\n";
        html << "    </tr>\n";
    }

    // Close out the table and insert a ‚ÄúTotal‚Äù footer row
    html << R"HTML(  </tbody>
  <tfoot>
    <tr class="total-row">
      <td colspan="2">Total disk usage: )HTML"
         << humanReadableSize(totalSize)
         << R"HTML(</td>
    </tr>
  </tfoot>
</table>

<script>
// Simple table‚Äêsorting script (sort strings or human‚Äêreadable sizes).
function sortTable(colIndex) {
  var table = document.getElementById("usageTable");
  var tbody = table.tBodies[0];
  var rows = Array.from(tbody.querySelectorAll("tr"));

  // If we clicked the same column twice, reverse
  if (tbody.getAttribute("data-sort-col") == colIndex) {
    rows.reverse();
    tbody.setAttribute("data-sort-col", -1);
  } else {
    rows.sort(function(a, b) {
      var aText = a.cells[colIndex].innerText.trim();
      var bText = b.cells[colIndex].innerText.trim();

      if (colIndex === 0) {
        // Column 0 is ‚ÄúSize‚Äù (like ‚Äú1.23 MB‚Äù). Convert to bytes:
        function parseHR(s) {
          var parts = s.split(" ");
          var num = parseFloat(parts[0]);
          var unit = parts[1];
          var factor = 1;
          switch (unit) {
            case "TB": factor = 1024 * 1024 * 1024 * 1024; break;
            case "GB": factor = 1024 * 1024 * 1024; break;
            case "MB": factor = 1024 * 1024; break;
            case "KB": factor = 1024; break;
            default:   factor = 1; break;
          }
          return num * factor;
        }
        return parseHR(aText) - parseHR(bText);
      } else {
        // Column 1 is ‚ÄúPath,‚Äù do a string compare
        return aText.localeCompare(bText);
      }
    });
    tbody.setAttribute("data-sort-col", colIndex);
  }

  // Re-attach sorted rows
  rows.forEach(function(r) {
    tbody.appendChild(r);
  });
}
</script>

</body>
</html>
)HTML";

    html.close();
    std::cout << "HTML report written to disk_usage.html\n"
              << "Open it in your web browser to view.\n";
}

// Scans directory (two levels or recursive) and builds the HTML report
static void analyzeAndGenerate(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << "\n";
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        } else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort descending by size
        std::sort(files.begin(), files.end(),
            [](auto const& a, auto const& b) {
                return a.size > b.size;
            });

        // Sum up total sizes
        for (auto const& fe : files) {
            totalSize += fe.size;
        }

        // Finally, write the HTML
        generateHtmlReport(files, totalSize);
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << "\n";
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "\n=== Disk Usage (HTML report) ===\n\n";
    std::cout << "Enter directory path: ";
    std::getline(std::cin, pathInput);
    if (pathInput.empty()) {
        std::cerr << "No path entered. Exiting.\n";
        return 1;
    }

    std::cout << "Recursive scan? (y/n): ";
    std::cin >> recursiveChoice;
    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');

    analyzeAndGenerate(pathInput, recursive);
    return 0;
}








// disk_usage_html.cpp
// Compile with: g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html
// (If you get undefined-reference errors on std::filesystem, add -lstdc++fs at the end.)

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <string>

namespace fs = std::filesystem;

// Simple struct to hold (path, size).
struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte count into a human-readable string (e.g. "1.23 MB").
static std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024.0 && unitIndex < 4) {
        readableSize /= 1024.0;
        ++unitIndex;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// URL-encode spaces and a few other characters so that <a href="file://..."> links work in the browser.
static std::string urlEncode(const std::string& path) {
    std::ostringstream oss;
    for (char c : path) {
        switch (c) {
            case ' ' : oss << "%20"; break;
            case '"' : oss << "%22"; break;
            case '#' : oss << "%23"; break;
            case '%' : oss << "%25"; break;
            case '&' : oss << "%26"; break;
            case '\'' : oss << "%27"; break;
            case '+' : oss << "%2B"; break;
            case ',' : oss << "%2C"; break;
            case '/' : oss << "/";   break; // keep forward slash as is
            case ':' : oss << "%3A"; break;
            case ';' : oss << "%3B"; break;
            case '<' : oss << "%3C"; break;
            case '=' : oss << "%3D"; break;
            case '>' : oss << "%3E"; break;
            case '?' : oss << "%3F"; break;
            case '[' : oss << "%5B"; break;
            case '\\': oss << "%5C"; break;
            case ']' : oss << "%5D"; break;
            case '^' : oss << "%5E"; break;
            case '`' : oss << "%60"; break;
            case '{' : oss << "%7B"; break;
            case '|' : oss << "%7C"; break;
            case '}' : oss << "%7D"; break;
            case '~' : oss << "%7E"; break;
            default:
                // For any character in the ASCII printable range, leave as-is.
                if (static_cast<unsigned char>(c) >= 0x20 && static_cast<unsigned char>(c) <= 0x7E) {
                    oss << c;
                } else {
                    // Percent-encode anything outside that range:
                    oss << "%" << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                        << (static_cast<int>(static_cast<unsigned char>(c))) 
                        << std::dec << std::nouppercase;
                }
                break;
        }
    }
    return oss.str();
}

// Collect files in dirPath up to two levels deep (no recursion beyond grandchildren).
static void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            // One level deeper
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath.
static void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Generate a simple HTML report named "disk_usage.html" in the current directory.
static void generateHtmlReport(const std::vector<FileEntry>& files, uintmax_t totalSize) {
    std::ofstream html("disk_usage.html");
    if (!html.is_open()) {
        std::cerr << "Error: could not open disk_usage.html for writing.\n";
        return;
    }

    // Basic HTML + inline CSS for a clean table.
    html << R"(<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disk Usage Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 8px 12px; border: 1px solid #ccc; }
    th { background-color: #f2f2f2; cursor: pointer; }
    tr:nth-child(even) { background-color: #fafafa; }
    tr:hover { background-color: #f1f1f1; }
    caption { font-size: 1.2em; margin-bottom: 10px; font-weight: bold; }
    .total-row { font-weight: bold; background-color: #e8e8e8; }
  </style>
</head>
<body>

<h2>Disk Usage Report</h2>
<p>Generated by <code>disk_usage_html</code>. Click on a column header to sort. Click a file path to open (in your file-manager or default handler).</p>

<table id="usageTable">
  <caption>Files and Sizes</caption>
  <thead>
    <tr>
      <th onclick="sortTable(0)">Size</th>
      <th onclick="sortTable(1)">Path</th>
    </tr>
  </thead>
  <tbody>
)";

    // Write one row per file
    for (auto const& fe : files) {
        std::string hrSize = humanReadableSize(fe.size);
        std::string filePath = fe.path.string();
        // Make a file:// URL. On Linux, "file:///home/..." is typical.
        // We'll percent-encode the path so spaces/characters work.
        std::string url = std::string("file://") + urlEncode(filePath);

        html << "    <tr>\n";
        html << "      <td>" << hrSize << "</td>\n";
        html << "      <td><a href=\"" << url << "\">" << filePath << "</a></td>\n";
        html << "    </tr>\n";
    }

    // Final ‚ÄúTotal‚Äù row (spanning both columns)
    html << R"(  </tbody>
  <tfoot>
    <tr class="total-row">
      <td colspan="2">Total disk usage: )"
         << humanReadableSize(totalSize) 
         << R"(</td>
    </tr>
  </tfoot>
</table>

<script>
// Simple table-sorting script (sorts strings or human-readable sizes).
function sortTable(colIndex) {
  var table = document.getElementById("usageTable");
  var tbody = table.tBodies[0];
  var rows = Array.from(tbody.querySelectorAll("tr"));

  // If we clicked the same column twice, reverse order.
  if (tbody.getAttribute("data-sort-col") == colIndex) {
    rows.reverse();
    tbody.setAttribute("data-sort-col", -1);
  } else {
    // Sort ascending by default
    rows.sort(function(a, b) {
      var aText = a.cells[colIndex].innerText.trim();
      var bText = b.cells[colIndex].innerText.trim();

      if (colIndex === 0) {
        // Column 0 is "Size" which is in ‚Äú1.23 MB‚Äù human-readable. Convert to bytes:
        function parseHR(s) {
          var parts = s.split(" ");
          var num = parseFloat(parts[0]);
          var unit = parts[1];
          var factor = 1;
          switch (unit) {
            case "TB": factor = 1024 * 1024 * 1024 * 1024; break;
            case "GB": factor = 1024 * 1024 * 1024; break;
            case "MB": factor = 1024 * 1024; break;
            case "KB": factor = 1024; break;
            default:   factor = 1; break;
          }
          return num * factor;
        }
        return parseHR(aText) - parseHR(bText);
      } else {
        // Column 1 is ‚ÄúPath,‚Äù so string compare
        return aText.localeCompare(bText);
      }
    });
    tbody.setAttribute("data-sort-col", colIndex);
  }

  // Re-attach rows in new order
  rows.forEach(function(r) {
    tbody.appendChild(r);
  });
}
</script>

</body>
</html>)";

    html.close();
    std::cout << "HTML report written to disk_usage.html\n"
              << "Open it in your web browser to view.\n";
}

// Scan directory (two levels) or recursively based on 'recursive', then produce HTML table.
static void analyzeAndGenerate(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << "\n";
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        } else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort descending by size so largest files appear first
        std::sort(files.begin(), files.end(),
            [](auto const& a, auto const& b) {
                return a.size > b.size;
            });

        // Compute total size
        for (auto const& fe : files) {
            totalSize += fe.size;
        }

        // Generate HTML
        generateHtmlReport(files, totalSize);
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << "\n";
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "\n=== Disk Usage (HTML report) ===\n\n";
    std::cout << "Enter directory path: ";
    std::getline(std::cin, pathInput);
    if (pathInput.empty()) {
        std::cerr << "No path entered. Exiting.\n";
        return 1;
    }

    std::cout << "Recursive scan? (y/n): ";
    std::cin >> recursiveChoice;
    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');

    analyzeAndGenerate(pathInput, recursive);
    return 0;
}





// disk_usage.cpp
// Compile with: g++ -std=c++17 disk_usage.cpp -o disk_usage [-lstdc++fs]

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>

namespace fs = std::filesystem;

struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte‚Äêcount into a human‚Äêreadable string (e.g. "1.23 MB")
std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024 && unitIndex < 4) {
        readableSize /= 1024;
        ++unitIndex;
    }

    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// Collect files in dirPath up to two levels deep (no recursion beyond grandchildren)
void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            // Now iterate one level deeper
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath
void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Analyze disk usage, either two‚Äêlevels deep or fully recursive based on 'recursive'
void analyzeDiskUsage(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << std::endl;
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        }
        else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort files descending by size
        std::sort(files.begin(), files.end(),
                  [](const FileEntry& a, const FileEntry& b) {
                      return a.size > b.size; 
                  });

        // Print each file's size and path
        for (auto const& file : files) {
            totalSize += file.size;
            std::cout 
                << std::setw(10) << humanReadableSize(file.size) 
                << "\t" 
                << file.path 
                << std::endl;
        }

        std::cout << "\nTotal disk usage: " << humanReadableSize(totalSize) << std::endl;
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << std::endl;
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "Enter directory path: ";
    std::cin  >> pathInput;

    std::cout << "Recursive scan? (y/n): ";
    std::cin  >> recursiveChoice;

    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');
    analyzeDiskUsage(pathInput, recursive);

    return 0;
}





#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    if (depth > max_depth) return 0;
    std::uintmax_t size = 0;
    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir, int max_depth, std::uintmax_t min_size_bytes) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    try {
        for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
            if (fs::is_directory(entry)) {
                std::uintmax_t total = get_size(entry.path(), 1, max_depth);
                if (total >= min_size_bytes)
                    raw_data.emplace_back(entry.path().string(), total);
            }
        }
    } catch (...) {
        return {};
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::string current_path = fs::current_path().string();

    while (true) {
        std::vector<std::string> entries;
        entries.push_back(".. (Back)");

        try {
            for (const auto& entry : fs::directory_iterator(current_path, fs::directory_options::skip_permission_denied)) {
                if (fs::is_directory(entry))
                    entries.push_back(entry.path().string());
            }
        } catch (...) {
            entries.clear();
        }

        if (entries.size() <= 1) {
            clear();
            mvprintw(0, 0, "No accessible subdirectories. Press any key to go back.");
            getch();
            current_path = fs::path(current_path).parent_path().string();
            continue;
        }

        std::sort(entries.begin() + 1, entries.end());
        int highlight = 0, start = 0;

        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter = open, q = quit)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);
                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";
                mvprintw(i + 1, 0, "%s", display.c_str());
                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {
                if (highlight == 0) {
                    current_path = fs::path(current_path).parent_path().string();
                    break;
                } else if (highlight > 0 && highlight < (int)entries.size()) {
                    current_path = entries[highlight];
                    break;
                }
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }

        clear();
        mvprintw(0, 0, "Use this directory? %s [y/n]", current_path.c_str());
        int ch = getch();
        if (ch == 'y' || ch == 'Y')
            return current_path;
    }
}

int choose_depth() {
    int depth = 2;
    while (true) {
        clear();
        mvprintw(0, 0, "Select analysis depth (1‚Äì5): Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current depth: %d", depth);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') depth = std::min(depth + 1, 5);
        else if (ch == '-') depth = std::max(depth - 1, 1);
    }
    return depth;
}

int choose_min_size() {
    int size_mb = 0;
    while (true) {
        clear();
        mvprintw(0, 0, "Filter out directories smaller than X MB. Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current minimum size: %d MB", size_mb);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') size_mb = std::min(size_mb + 10, 10000);
        else if (ch == '-') size_mb = std::max(size_mb - 10, 0);
    }
    return size_mb;
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Results (press q to quit)");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;
            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        int depth = choose_depth();
        int min_mb = choose_min_size();
        auto data = analyze_dir(selected, depth, static_cast<std::uintmax_t>(min_mb) * 1024 * 1024);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No directories matched the criteria. Press any key to exit.");
            getch();
        }
    }

    endwin();
    return 0;
}








g++ -std=c++17 -o disk_usage_ui_enhanced disk_usage_ui_enhanced.cpp -lncurses -lstdc++fs





#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    if (depth > max_depth) return 0;
    std::uintmax_t size = 0;
    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir, int max_depth, std::uintmax_t min_size_bytes) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, max_depth);
            if (total >= min_size_bytes)
                raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::string current_path = fs::current_path().string();

    while (true) {
        std::vector<std::string> entries;
        entries.push_back(".. (Back)");
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin() + 1, entries.end());

        int highlight = 0, start = 0;
        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter = open)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);
                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";
                mvprintw(i + 1, 0, "%s", display.c_str());
                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {
                if (highlight == 0) {
                    current_path = fs::path(current_path).parent_path().string();
                    break;
                } else {
                    current_path = entries[highlight];
                    break;
                }
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }

        // Confirm selection
        clear();
        mvprintw(0, 0, "Use this directory? %s [y/n]", current_path.c_str());
        int ch = getch();
        if (ch == 'y' || ch == 'Y')
            return current_path;
    }
}

int choose_depth() {
    int depth = 2;
    while (true) {
        clear();
        mvprintw(0, 0, "Select analysis depth (1‚Äì5): Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current depth: %d", depth);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') depth = std::min(depth + 1, 5);
        else if (ch == '-') depth = std::max(depth - 1, 1);
    }
    return depth;
}

int choose_min_size() {
    int size_mb = 0;
    while (true) {
        clear();
        mvprintw(0, 0, "Filter directories smaller than X MB. Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current minimum size: %d MB", size_mb);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') size_mb = std::min(size_mb + 10, 10000);
        else if (ch == '-') size_mb = std::max(size_mb - 10, 0);
    }
    return size_mb;
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Results (press q to quit)");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;
            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        int depth = choose_depth();
        int min_mb = choose_min_size();
        auto data = analyze_dir(selected, depth, static_cast<std::uintmax_t>(min_mb) * 1024 * 1024);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No directories matched the criteria.");
            getch();
        }
    }

    endwin();
    return 0;
}







#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    std::uintmax_t size = 0;
    if (depth > max_depth) return 0;

    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, 2);
            raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::vector<std::string> entries;
    std::string current_path = ".";

    while (true) {
        entries.clear();
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin(), entries.end());
        int highlight = 0, start = 0;

        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter to select, q to quit)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);

                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";

                mvprintw(i + 1, 0, "%s", display.c_str());

                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {  // Enter
                current_path = entries[highlight];
                return current_path;
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }
    }
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Linux Disk Usage - q to quit");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        auto data = analyze_dir(selected);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No subdirectories found.");
            getch();
        }
    }

    endwin();
    return 0;
}





g++ -std=c++17 -o disk_usage file.cpp -lncurses -lstdc++fs






#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = { "B", "KB", "MB", "GB", "TB" };
    double readable_size = static_cast<double>(size);
    int i = 0;

    while (readable_size >= 1024 && i < 4) {
        readable_size /= 1024;
        ++i;
    }

    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable_size << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_directory_size(const fs::path& dir_path) {
    std::uintmax_t size = 0;

    for (const auto& entry : fs::recursive_directory_iterator(dir_path, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_regular_file(entry.status()))
                size += fs::file_size(entry.path());
        } catch (...) {}
    }

    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_usage(const fs::path& root) {
    std::vector<std::pair<std::string, std::uintmax_t>> dir_sizes;

    for (const auto& entry : fs::directory_iterator(root, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            auto size = get_directory_size(entry.path());
            dir_sizes.emplace_back(entry.path().string(), size);
        }
    }

    std::sort(dir_sizes.begin(), dir_sizes.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : dir_sizes)
        result.emplace_back(path, human_readable(size));

    return result;
}

void draw_ui(const std::vector<std::pair<std::string, std::string>>& data) {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    int height, width;
    getmaxyx(stdscr, height, width);

    int start = 0;
    int highlight = 0;

    while (true) {
        clear();
        mvprintw(0, 0, "Linux Disk Usage Analyzer - Press 'q' to Quit");
        mvhline(1, 0, '-', width);

        int visible_lines = height - 3;
        for (int i = 0; i < visible_lines && (start + i) < (int)data.size(); ++i) {
            if (highlight == (start + i)) {
                attron(A_REVERSE);
            }

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > width - 15)
                name = name.substr(0, width - 18) + "...";

            mvprintw(i + 2, 0, "%-*s %12s", width - 15, name.c_str(), size.c_str());

            if (highlight == (start + i)) {
                attroff(A_REVERSE);
            }
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + visible_lines) start = highlight - visible_lines + 1;
    }

    endwin();
}

int main(int argc, char* argv[]) {
    fs::path target_dir = ".";

    if (argc > 1)
        target_dir = argv[1];

    if (!fs::exists(target_dir) || !fs::is_directory(target_dir)) {
        std::cerr << "Invalid directory: " << target_dir << "\n";
        return 1;
    }

    auto data = analyze_usage(target_dir);
    draw_ui(data);
    return 0;
}






body {
    font-family: 'Segoe UI', sans-serif;
    margin: 0;
    padding: 20px;
    background: #f4f469;
    color: #333;
    transition: background 0.3s ease;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    font-size: 2.2em;
    text-shadow: 1px 1px 2px #ccc;
}

.toolbar {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}

.toolbar input[type="text"],
.toolbar input[type="date"] {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    width: 200px;
    background: #fff;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    transition: all 0.2s ease-in-out;
}

.toolbar input[type="text"]:focus,
.toolbar input[type="date"]:focus {
    outline: none;
    border-color: #b3e0ff;
    box-shadow: 0 0 5px #b3e0ff;
}

.toolbar label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
}

.toolbar input[type="checkbox"] {
    transform: scale(1.2);
    transition: transform 0.2s ease-in-out;
}

table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    border: 1px solid #b3e0ff;
    overflow: hidden;
    transition: box-shadow 0.3s ease;
}

th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #b3e0ff;
    border-right: 1px solid #b3e0ff;
}

th {
    background-color: #b3e0ff;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: background 0.2s ease;
    white-space: nowrap;
}

th:hover {
    background-color: #e9f0f9;
}

th.sorted-asc::after,
th.sorted-desc::after {
    content: ' ‚ñº';
    font-weight: bold;
    font-size: 12px;
    margin-left: 4px;
    vertical-align: middle;
    line-height: 1;
}

th.sorted-desc::after {
    content: ' ‚ñ≤';
}

td.diff-positive {
    background-color: #daedda;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.diff-negative {
    background-color: #e8d7da;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.max-elapsed {
    background-color: #fff3cd;
    font-weight: bold;
}

.page-title {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
}

.page-title .title-icon {
    width: 30px;
    height: 30px;
    position: absolute;
    left: 20px;
    top: 10px;
}

.page-title h1 {
    margin: 0;
    font-size: 28px;
}

/* Responsive */
@media (max-width: 769px) {
    .toolbar {
        flex-direction: column;
        align-items: center;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
    }
}





#!/usr/bin/env bash
set -euo pipefail

HTML_FILE="${1:-interactive_report.html}"

if [[ ! -f "$HTML_FILE" ]]; then
  echo "‚ùå HTML —Ñ–∞–π–ª—ä—Ç –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: $HTML_FILE" >&2
  exit 1
fi

# –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç HTML-–∞
csv=$(awk '/^const rawCSV = `$/,/^`;$/' "$HTML_FILE" | sed '1d;$d')

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –∏–º–∞ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ
if [[ -z "$csv" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV –¥–∞–Ω–Ω–∏ –≤—ä–≤ —Ñ–∞–π–ª–∞." >&2
  exit 1
fi

# –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–Ω–µ –≤ –º–∞—Å–∏–≤
IFS=$'\n' read -rd '' -a lines <<< "$csv"

# –ó–∞–≥–ª–∞–≤–∏—è
IFS=',' read -r -a headers <<< "${lines[0]}"
N_HEADERS=${#headers[@]}
N_JOBS=$(( ${#lines[@]} - 1 ))
N_DATES=$(( (N_HEADERS - 4) / 2 ))

echo "üìä Summary –∑–∞: $HTML_FILE"
echo "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
echo "–û–±—â–æ jobs:         $N_JOBS"
echo "–ë—Ä–æ–π –¥–∞—Ç–∏:         $N_DATES"
echo "–ö–æ–ª–æ–Ω–∏ (–æ–±—â–æ):     $N_HEADERS"
echo

# –°—É–º–∞—Ä–Ω–∏ –≤—Ä–µ–º–µ–Ω–∞ –ø–æ DateX
for ((d=0; d<N_DATES; d++)); do
  elapsed_idx=$((4 + 2*d + 1))
  total_sec=0
  count=0

  for ((i=1; i<=N_JOBS; i++)); do
    line="${lines[i]}"
    IFS=',' read -r -a fields <<< "$line"
    time="${fields[elapsed_idx]}"
    if [[ "$time" =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
      IFS=: read -r h m s <<< "$time"
      total_sec=$(( total_sec + h*3600 + m*60 + s ))
      ((count++))
    fi
  done

  if (( count > 0 )); then
    avg_sec=$(( total_sec / count ))
    hh=$(( avg_sec / 3600 ))
    mm=$(( (avg_sec % 3600) / 60 ))
    ss=$(( avg_sec % 60 ))
    printf "Date %d average:   %02d:%02d:%02d\n" "$((d+1))" "$hh" "$mm" "$ss"
  fi
done





#!/bin/bash

CONFIG_FILE="./config/hosts.list"
LOG_DIR="./logs/$(date +%F)"
USER="your_ssh_user"  # –ó–∞–º–µ–Ω–∏ —Å —Ä–µ–∞–ª–µ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∑–∞ SSH

mkdir -p "$LOG_DIR"

if [ ! -f "$CONFIG_FILE" ]; then
  echo "‚õî –ù–µ –µ –Ω–∞–º–µ—Ä–µ–Ω —Ñ–∞–π–ª: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  # –ü—Ä–æ–ø—É—Å–∫–∞ –ø—Ä–∞–∑–Ω–∏ —Ä–µ–¥–æ–≤–µ –∏ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏
  [[ -z "$HOST" || "$HOST" =~ ^# ]] && continue

  echo "üëâ –°–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST..."
  OUTPUT=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "–£—Å–ø–µ—à–Ω–æ –í–ª–∏–∑–∞–Ω–µ"' 2>&1)

  if [[ $? -eq 0 ]]; then
    echo "$HOST: ‚úÖ $OUTPUT"
    echo "$OUTPUT" > "$LOG_DIR/$HOST.log"
  else
    echo "$HOST: ‚ùå –ù–µ—É—Å–ø–µ—à–Ω–æ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ"
    echo "–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ: $OUTPUT" > "$LOG_DIR/$HOST.log"
  fi

done < "$CONFIG_FILE"






#!/bin/bash

CONFIG_FILE="./config/hosts.list"
USER="your_ssh_user"  # –°–º–µ–Ω–∏ —Ç–æ–≤–∞ —Å –≤–∞–ª–∏–¥–Ω–æ SSH –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –∏–º–µ

if [ ! -f "$CONFIG_FILE" ]; then
  echo "‚õî –ù–µ –µ –Ω–∞–º–µ—Ä–µ–Ω —Ñ–∞–π–ª: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  if [ -z "$HOST" ]; then continue; fi
  echo "üëâ –°–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST..."

  ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "–£—Å–ø–µ—à–Ω–æ –í–ª–∏–∑–∞–Ω–µ"' 2>/dev/null

  if [ $? -ne 0 ]; then
    echo "‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST"
  fi

done < "$CONFIG_FILE"





# –°—ä–∑–¥–∞–π –≥–ª–∞–≤–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
mkdir -p monitoring/{config,logs,tmp,scripts,results}

# –°—ä–∑–¥–∞–π –ø—Ä–∏–º–µ—Ä–Ω–∞ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ç–µ–∫—É—â–∞—Ç–∞ –¥–∞—Ç–∞ (–∑–∞ –ª–æ–≥–æ–≤–µ –∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏)
TODAY=$(date +%F)
mkdir -p monitoring/logs/$TODAY
mkdir -p monitoring/results/$TODAY

# –°—ä–∑–¥–∞–π –ø—Ä–∏–º–µ—Ä–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ config
touch monitoring/config/{main.conf,hosts.list,keywords.conf,env.properties}

# –°—ä–∑–¥–∞–π –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç–æ–≤–∏ —Ñ–∞–π–ª–æ–≤–µ
touch monitoring/scripts/{monitor_main.sh,ssh_runner.sh,check_disk.sh,check_memory.sh,check_services.sh,report_generator.sh}

# –°—ä–∑–¥–∞–π README —Ñ–∞–π–ª
touch monitoring/README.md

# –î–æ–±–∞–≤–∏ –ø—Ä–∞–≤–∞ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤–µ—Ç–µ
chmod +x monitoring/scripts/*.sh

# –ü–æ—Ç–≤—ä—Ä–∂–¥–µ–Ω–∏–µ
echo "‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ –Ω–∞ monitoring –µ —Å—ä–∑–¥–∞–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ."





const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

let fromx = null;
let tox = null;

for (let j = 1; j <= 35; j++) {
    const idx = headers.indexOf(`DateS${j}`);
    if (idx === -1) continue;

    if (fromx === null && row[idx] && parseInt(row[idx]) === fromval) fromx = j;
    if (tox === null && row[idx] && parseInt(row[idx]) === toval) tox = j;
    if (fromx !== null && tox !== null) break;
}

if (fromx !== null && tox !== null) {
    visibleCols.push(
        `DateS${fromx}`, `StartS${fromx}`, `StopS${fromx}`, `ElapsedS${fromx}`,
        `DateS${tox}`, `StartS${tox}`, `StopS${tox}`, `ElapsedS${tox}`
    );
    insertDiffAfter = headers.indexOf(`ElapsedS${tox}`);
}






function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromRaw = datefrom.value;
    const toRaw = dateto.value;
    const compare = compareCheckbox.checked;

    let filtered = csvData.filter(row =>
        row.join(" ").toLowerCase().includes(keyword)
    );

    const baseCols = headers.slice(0, 5);
    let visibleCols = [...baseCols];
    let insertDiffAfter = null;

    if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        let fromIdx = -1;
        let toIdx = -1;

        for (let i = 0; i < 35; i++) {
            const idx = headers.indexOf(`DateS${i}`);
            if (idx === -1) continue;

            if (fromIdx === -1 && filtered.some(row => parseInt(row[idx]) === fromval)) fromIdx = i;
            if (toIdx === -1 && filtered.some(row => parseInt(row[idx]) === toval)) toIdx = i;
            if (fromIdx !== -1 && toIdx !== -1) break;
        }

        if (fromIdx !== -1 && toIdx !== -1) {
            visibleCols.push(
                `DateS${fromIdx}`, `StartS${fromIdx}`, `StopS${fromIdx}`, `ElapsedS${fromIdx}`,
                `DateS${toIdx}`, `StartS${toIdx}`, `StopS${toIdx}`, `ElapsedS${toIdx}`
            );
            insertDiffAfter = headers.indexOf(`ElapsedS${toIdx}`);
        }
    } else if (fromRaw || toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10) || null;
        const toval = parseInt(toRaw.replaceAll("-", ""), 10) || null;

        for (let i = 0; i < 35; i++) {
            const dateKey = `DateS${i}`;
            const idx = headers.indexOf(dateKey);
            if (idx === -1) continue;

            const col = dateKey;
            const rowVal = row => parseInt(row[idx]);

            let hasMatch = false;

            if (fromval && toval) {
                hasMatch = row => {
                    const val = rowVal(row);
                    return val >= fromval && val <= toval;
                };
            } else if (fromval) {
                hasMatch = row => rowVal(row) === fromval;
            } else if (toval) {
                hasMatch = row => rowVal(row) === toval;
            }

            if (hasMatch && filtered.some(hasMatch)) {
                visibleCols.push(`DateS${i}`, `StartS${i}`, `StopS${i}`, `ElapsedS${i}`);
            }
        }
    } else {
        visibleCols = headers;
    }

    if (currentSort.index >= 0) {
        filtered.sort((a, b) => {
            const valA = a[currentSort.index] || "";
            const valB = b[currentSort.index] || "";
            return currentSort.direction === 1
                ? valA.localeCompare(valB)
                : valB.localeCompare(valA);
        });
    } else if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        const idx = headers.indexOf("DateS3");
        if (idx === -1) return;

        for (let i = 0; i < 35; i++) {
            const testIdx = headers.indexOf(`DateS${i}`);
            if (testIdx === -1) continue;

            filtered = filtered.map(row => {
                const fromIdx = headers.indexOf(`ElapsedS${from}`);
                const toIdx = headers.indexOf(`ElapsedS${to}`);
                const fromElapsed = row[fromIdx] || null;
                const toElapsed = row[toIdx] || null;

                let diff = null;
                if (fromElapsed && toElapsed) {
                    diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                }

                return {
                    row,
                    diff
                };
            });

            filtered.sort((a, b) =>
                currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff
            );

            filtered = filtered.map(obj => obj.row);
        }
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}






const valFrom = parseInt(datefrom.value.replaceAll("-", ""), 10);
const valTo = parseInt(dateto.value.replaceAll("-", ""), 10);

// –û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
let fromval = valFrom;
let toval = valTo;

// –ó–∞ –¥–∞ —Ä–∞–±–æ—Ç–∏ range –ø—Ä–∞–≤–∏–ª–Ω–æ
const from = Math.min(valFrom, valTo);
const to = Math.max(valFrom, valTo);





let fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
let toval = parseInt(dateto.value.replaceAll("-", ""), 10);

if (fromval > toval) {
    [fromval, toval] = [toval, fromval];
}







<script>



const csvData = 'UI_DATA';

let data = [];
let headers = [];
let currentSort = {
    index: -1,
    direction: 1
};

const textFilter = document.getElementById("textFilter");
const datefrom = document.getElementById("datefrom");
const dateto = document.getElementById("dateto");
const compareCheckbox = document.getElementById("compareCheckbox");
const dataTable = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function msToSeconds(ms) {
    const [h, m, s] = ms.split(':').map(Number);
    return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
    const negative = sec < 0;
    sec = Math.abs(sec);
    const h = String(Math.floor(sec / 3600)).padStart(2, '0');
    const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
    const s = String(sec % 60).padStart(2, '0');
    return (negative ? '-' : '') + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
    const fromval = datefrom.value;
    const toval = dateto.value;
    const enabled = !!(fromval && toval);
    compareCheckbox.disabled = !enabled;

    if (!enabled) {
        compareCheckbox.checked = false;
        currentSort.index = -1;
        direction = 1;
    }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
    dataTable.innerHTML = "";
    headerRow.innerHTML = "";

    const visibleIndexes = visibleCols.map(col => headers.indexOf(col));

    visibleCols.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;
        const idx = headers.indexOf(col);
        th.classList.add("sortable");
        if (idx === currentSort.index) {
            th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        }
        th.onclick = () => {
            if (idx === currentSort.index) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = idx;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(th);
    });

    if (compareCheckbox.checked && currentSort.index === -1) {
        const thDiff = document.createElement("th");
        thDiff.textContent = "Difference";
        thDiff.classList.add("sortable");
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        thDiff.onclick = () => {
            if (currentSort.index === -1) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = -1;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(thDiff);
    }

    rows.forEach(row => {
        const tr = document.createElement("tr");

        let maxElapsed = 0;
        let maxIndexes = [];

        headers.forEach((head, i) => {
            if (/Elapsed\d+/.test(head) && row[i]) {
                const sec = msToSeconds(row[i]);
                if (sec > maxElapsed) {
                    maxElapsed = sec;
                    maxIndexes = [i];
                } else if (sec === maxElapsed) {
                    maxIndexes.push(i);
                }
            }
        });

        visibleIndexes.forEach(i => {
            const td = document.createElement("td");
            td.textContent = row[i];
            if (maxIndexes.includes(i)) {
                td.classList.add("max-elapsed");
            }
            tr.appendChild(td);
        });

        if (compareCheckbox.checked && diffAfterIndex) {
            const idx = headers.indexOf("DateS(3)");
            if (idx === -1) return;

            const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
            const toval = parseInt(dateto.value.replaceAll("-", ""), 10);
            const dateval = parseInt(row[idx].replaceAll("-", ""), 10);
            if (isNaN(dateval) || dateval < fromval || dateval > toval) return;

            const fromIdx = headers.indexOf(`Elapsed${fromval}`);
            const toIdx = headers.indexOf(`Elapsed${toval}`);
            const fromElapsed = fromIdx >= 0 ? row[fromIdx] : null;
            const toElapsed = toIdx >= 0 ? row[toIdx] : null;

            const tdDiff = document.createElement("td");
            if (fromElapsed && toElapsed) {
                const diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                tdDiff.textContent = secondsToHMS(diff);
                tdDiff.classList.add(diff < 0 ? "diff-negative" : "diff-positive");
            }
            tr.appendChild(tdDiff);
        }

        dataTable.appendChild(tr);
    });
}

function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
    const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

    let from = Math.min(fromval, toval);
    let to = Math.max(fromval, toval);

    let visibleCols = headers.slice(0, 5); // –ø—ä—Ä–≤–∏—Ç–µ 5 (DateS, Start, Stop, Elapsed)

    const dateIndexes = [];
    for (let i = 0; i < 35; i++) {
        const colDate = new Date();
        colDate.setDate(colDate.getDate() - i);
        const dateStr = colDate.toISOString().slice(0, 10).replaceAll("-", "");
        dateIndexes.push(dateStr);
    }

    if (compareCheckbox.checked && from && to) {
        const filteredDates = dateIndexes.filter(date => {
            const val = parseInt(date);
            return val >= from && val <= to;
        });

        visibleCols = [];

        filteredDates.forEach(d => {
            visibleCols.push(`DateS(${d})`, `StartS(${d})`, `StopS(${d})`, `ElapsedS(${d})`);
        });
    } else {
        visibleCols = headers;
    }

    const filtered = data.filter(row => {
        const rowStr = row.join(" ").toLowerCase();
        return rowStr.includes(keyword);
    });

    const insertDiffAfter = headers.indexOf(`ElapsedS(${toval})`);

    if (compareCheckbox.checked && from && to) {
        filtered.sort((a, b) => {
            const fromIdx = headers.indexOf(`Elapsed${from}`);
            const toIdx = headers.indexOf(`Elapsed${to}`);
            const aDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(a[toIdx]) - msToSeconds(a[fromIdx]) : 0;
            const bDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(b[toIdx]) - msToSeconds(b[fromIdx]) : 0;
            return (currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff);
        });
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}

function parseCSV(csv) {
    const lines = csv.trim().split('\n');
    headers = lines[0].split(',');
    data = lines.slice(1).map(line => line.split(','));
}

textFilter.addEventListener("input", filterData);
datefrom.addEventListener("input", filterData);
dateto.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
    if (compareCheckbox.checked && currentSort.index === -1) {
        currentSort.direction = 1;
    }
    filterData();
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
parseCSV(csvData);
filterData();
</script>





const row = data[0]; // only the first row
const val = row[dateIndex];
let hasMatch = false;

if (val && /^\d{8}$/.test(val)) {
  const valInt = parseInt(val);
  if (fromInt && toInt) {
    hasMatch = valInt >= fromInt && valInt <= toInt;
  } else if (fromInt) {
    hasMatch = valInt === fromInt;
  } else if (toInt) {
    hasMatch = valInt === toInt;
  }
}





const hasMatch = data.some(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  return (
    (fromInt && !toInt && valInt === fromInt) ||
    (!fromInt && toInt && valInt === toInt) ||
    (fromInt && toInt && valInt >= fromInt && valInt <= toInt)
  );
});




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2
Running,Load,202405,JobA,20250429,10:00,10:30,00:30:00,20250430,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20250429,11:00,11:30,00:30:00,20250430,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20250429,12:00,12:20,00:20:00,20250430,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function buildTable(rows, visibleCols, diffColIndex = null, diffs = []) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const index = headers.indexOf(col);
    if (index === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === index) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (diffColIndex !== null && index === diffColIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");
    visibleCols.forEach((col, colIdx) => {
      const i = headers.indexOf(col);
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      tr.appendChild(td);

      if (diffColIndex !== null && i === diffColIndex) {
        const tdDiff = document.createElement("td");
        const diffVal = diffs[idx];
        if (diffVal !== null) {
          tdDiff.textContent = secondsToHMS(diffVal);
          tdDiff.className = diffVal < 0 ? "diff-negative" : "diff-positive";
        }
        tr.appendChild(tdDiff);
      }
    });
    table.appendChild(tr);
  });
}

function filterData() {
  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;
  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let diffIndex = null;
  let diffs = [];

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const fromDate = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
  const toDate = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

  if (compare && fromDate && toDate) {
    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
    }
    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      diffIndex = headers.indexOf(`Elapsed${toX}`);
      diffs = filtered.map(row => {
        const from = row[headers.indexOf(`Elapsed${fromX}`)];
        const to = row[headers.indexOf(`Elapsed${toX}`)];
        return (from && to) ? hmsToSeconds(to) - hmsToSeconds(from) : null;
      });
    }
  } else if (fromDate || toDate) {
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      const valid = data.every(row => {
        const val = row[idx];
        if (!val) return false;
        const valInt = parseInt(val);
        if (fromDate && !toDate) return valInt === fromDate;
        if (!fromDate && toDate) return valInt === toDate;
        return valInt >= fromDate && valInt <= toDate;
      });
      if (valid) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.index >= 0 && currentSort.direction > 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2 && currentSort.direction > 0) {
    filtered = filtered
      .map((row, i) => ({ row, diff: diffs[i] || 0 }))
      .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
      .map(obj => obj.row);
  }

  buildTable(filtered, visibleCols, diffIndex, diffs);
}

parseCSV(csvData);
textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

filterData();
</script>

</body>
</html>






const valid = data.every(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  if (fromInt && !toInt) return valInt === fromInt;
  if (!fromInt && toInt) return valInt === toInt;
  return valInt >= fromInt && valInt <= toInt;
});






#!/usr/bin/env python3

import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º—è–Ω–∞ –Ω–∞ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# –í–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –¥–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞
all_files = [f for f in glob.glob("JT*.csv") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]

if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# –ü–∞—Ä—Å–≤–∞–º–µ –≤—Å–∏—á–∫–∏ —Ñ–∞–π–ª–æ–≤–µ –∏ –ø—ä–ª–Ω–∏–º data[key][idx]
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue

            stage, batch, job = parts[0], parts[1], parts[2]
            date   = parts[3]
            start  = parts[4]
            stop   = parts[5]
            elapsed = parts[6]

            try:
                secs = parse_time(elapsed)
            except:
                continue

            key = (stage, batch, job)
            d = data.setdefault(key, {})
            d.setdefault(idx, {})["date"] = date
            d[idx]["start"] = start
            d[idx]["stop"] = stop
            d[idx]["elapsed"] = elapsed
            d[idx]["secs"] = secs

            if dates[idx] is None:
                dates[idx] = date

# –ü–∏—à–µ–º –Ω–∞ CSV –Ω–∞ stdout ‚Äî
out = csv.writer(sys.stdout, lineterminator="\n")

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME", "AVERAGE"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Start{i}", f"Stop{i}", f"Elapsed{i}"]
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á –≥–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –ø–æ –µ–¥–∏–Ω —Ä–µ–¥
for key in sorted(data.keys()):
    rec = ["" for _ in range(5)]  # STATUS, STAGE, BATCH, JOB.NAME, AVERAGE
    rec[1:4] = list(key)

    d = data[key]

    # –°—Ç–∞—Ç—É—Å: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–æ (idx=0) –∏ –ø–æ—Å–ª–µ–¥–Ω–æ (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)

    if s1 and sN:
        if sN > s1:
            status = "‚Üë"
        elif sN < s1:
            status = "‚Üì"
        else:
            status = "="
    else:
        status = "-"
    rec[0] = status

    # –°–ø–∏—Å—ä–∫ –∑–∞ –≤—Å–∏—á–∫–∏ secs, –∑–∞ —Å–º—è—Ç–∞–Ω–µ –Ω–∞ —Å—Ä–µ–¥–Ω–æ
    secs_list = []

    # –ü–æ –¥–≤–æ–π–∫–∏ Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["start"])
            rec.append(info["stop"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", "", "", ""]

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh = avg // 3600
        mm = (avg % 3600) // 60
        ss = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""

    rec[4] = avg_str  # –í–º—ä–∫–≤–∞–º–µ —Å–ª–µ–¥ "JOB.NAME"

    out.writerow(rec)






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Viewer</title>
  <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/.2877641!320h320!0853_kbc!openduw_pmF" />
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f4f4f4;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    .table-wrapper {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      border: 1px solid #dee2ff;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border: 1px solid #dee2ff;
    }

    th {
      background-color: #b0c8ff;
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    th.sorted.asc::after,
    th.sorted.desc::after {
      content: "";
      display: inline-block;
      width: 0;
      height: 0;
      margin-left: 10px;
      vertical-align: middle;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
    }

    th.sorted.asc::after {
      border-bottom: 5px solid black;
    }

    th.sorted.desc::after {
      border-top: 5px solid black;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d6f0da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f7d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff6cd;
      font-weight: bold;
      border-radius: 4px;
    }

    /* Sticky column styles */
    th.sticky-col, td.sticky-col {
      position: sticky;
      background: white;
      z-index: 2;
    }

    th.sticky-0, td.sticky-0 { left: 0; }
    th.sticky-1, td.sticky-1 { left: 120px; }
    th.sticky-2, td.sticky-2 { left: 240px; }
    th.sticky-3, td.sticky-3 { left: 360px; }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <h1>JST Advanced Viewer</h1>

  <div class="toolbar">
    <label>
      <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job..." />
    </label>
    <label>
      <input type="date" id="dateFrom" />
    </label>
    <label>
      <input type="checkbox" id="compareCheckbox" /> Compare
    </label>
  </div>

  <div class="table-wrapper">
    <table id="dataTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const csvData = `Status,Stage,Batch,Job.name,Date1,Start1,Stop1,Elapsed1
OK,Stage1,BatchA,JobX,2025-05-20,10:00,10:05,00:05
FAIL,Stage2,BatchB,JobY,2025-05-20,09:00,09:30,00:30
OK,Stage1,BatchA,JobX,2025-05-21,10:00,10:07,00:07
FAIL,Stage2,BatchB,JobY,2025-05-21,09:00,09:20,00:20`;

    let data = [];
    let currentSort = { index: null, direction: 1 };

    const textFilter = document.getElementById("textFilter");
    const dateFrom = document.getElementById("dateFrom");
    const compareCheckbox = document.getElementById("compareCheckbox");
    const table = document.getElementById("dataTable");
    const headerRow = document.getElementById("headerRow");
    const tbody = table.querySelector("tbody");

    function msToSeconds(ms) {
      const [m, s] = ms.split(":").map(Number);
      return m * 60 + s;
    }

    function secondsToHMS(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2, "0")}`;
    }

    function buildTable(headers, visibleRows, diffAfter) {
      headerRow.innerHTML = "";
      tbody.innerHTML = "";

      headers.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;

        if (["Status", "Stage", "Batch", "Job.name"].includes(col)) {
          th.classList.add("sticky-col", `sticky-${i}`);
        }

        if (currentSort.index === i) {
          th.classList.add("sorted", currentSort.direction === 1 ? "asc" : "desc");
        }

        th.onclick = () => {
          if (currentSort.index === i) {
            currentSort.direction *= -1;
          } else {
            currentSort.index = i;
            currentSort.direction = 1;
          }
          filterData();
        };

        headerRow.appendChild(th);
      });

      visibleRows.forEach((row, rIndex) => {
        const tr = document.createElement("tr");

        row.forEach((cell, i) => {
          const td = document.createElement("td");
          td.textContent = cell;

          if (["Status", "Stage", "Batch", "Job.name"].includes(headers[i])) {
            td.classList.add("sticky-col", `sticky-${i}`);
          }

          if (i === diffAfter?.index && diffAfter[rIndex]?.diff != null) {
            td.classList.add(diffAfter[rIndex].diff > 0 ? "diff-positive" : "diff-negative");
          }

          if (diffAfter?.max === msToSeconds(cell)) {
            td.classList.add("max-elapsed");
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });
    }

    function filterData() {
      const keyword = textFilter.value.toLowerCase();
      const from = dateFrom.value;
      const compare = compareCheckbox.checked;

      let filtered = data.filter(row => row.join(",").toLowerCase().includes(keyword));
      if (from) {
        filtered = filtered.filter(row => row[4] >= from);
      }

      let diffAfter = null;
      if (compare) {
        diffAfter = [];
        const grouped = {};
        filtered.forEach(r => {
          const key = `${r[0]}-${r[1]}-${r[2]}-${r[3]}`;
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(r);
        });

        filtered = [];
        for (const key in grouped) {
          const group = grouped[key];
          if (group.length >= 2) {
            const g = group.slice(-2);
            const v1 = msToSeconds(g[0][7]);
            const v2 = msToSeconds(g[1][7]);
            const diff = v2 - v1;

            diffAfter.push({ index: 7, diff, max: Math.max(v1, v2) });
            filtered.push(...g);
          }
        }
      }

      if (currentSort.index !== null) {
        filtered.sort((a, b) => {
          const valA = a[currentSort.index];
          const valB = b[currentSort.index];
          return currentSort.direction * valA.localeCompare(valB);
        });
      }

      buildTable(data[0], filtered, diffAfter);
    }

    function parseCSV(csv) {
      return csv.split("\n").map(row => row.split(","));
    }

    data = parseCSV(csvData);
    buildTable(data[0], data.slice(1));
    
    textFilter.addEventListener("input", filterData);
    dateFrom.addEventListener("input", filterData);
    compareCheckbox.addEventListener("change", filterData);
  </script>
</body>
</html>






csv_file = 'your_file.csv'
html_file = 'your_file.html'
output_file = 'output.html'

# Read the CSV content
with open(csv_file, 'r', encoding='utf-8') as f:
    csv_content = f.read()

# Escape for JavaScript
escaped_csv = csv_content.replace('\\', '\\\\') \
                         .replace('\n', '\\n') \
                         .replace('"', '\\"')

# Read the HTML file
with open(html_file, 'r', encoding='utf-8') as f:
    html_content = f.read()

# Replace fancy quotes with standard and inject CSV
html_content = html_content.replace("‚Äò", "'").replace("‚Äô", "'")
updated_html = html_content.replace("'JT_DATA'", f'"{escaped_csv}"')

# Save to output
with open(output_file, 'w', encoding='utf-8') as f:
    f.write(updated_html)

print(f"Injected CSV data into '{output_file}' successfully.")





#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# Parse arguments
if len(sys.argv) < 4:
    print("Usage: python3 monitor.py <jt_dir> <days> <html_template_file>")
    sys.exit(1)

files_dir = sys.argv[1]
try:
    n = int(sys.argv[2])
except ValueError:
    n = 31
template_path = sys.argv[3]

# Collect .jt files
files = []
if os.path.isdir(files_dir):
    files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
    files = sorted(files, key=os.path.getmtime)[-n:]
    if not files:
        sys.exit("No JT files found.")
else:
    sys.exit("Invalid directory.")

# Extract and collect data
data = {}
dates = [None] * len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            key = (parts[0], parts[1], parts[2])
            date = parts[3]
            start, stop, elapsed = parts[5], parts[6], parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            data.setdefault(key, {})[idx] = {
                "date": date, "start": start, "stop": stop,
                "elapsed": elapsed, "secs": secs
            }
            if dates[idx] is None:
                dates[idx] = date

# Create output lines
out_lines = []

header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

for key in sorted(data.keys()):
    status = "-"
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0: status = "NEW"
    elif s > 0 and e == 0: status = "LOST"
    elif s > 0 and e > s: status = "SLOW"
    elif s == e and s > 0: status = "STABLE"

    rec = [status, *key]
    secs_list = []

    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""),
                    info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    if secs_list:
        total = sum(secs_list)
        avg = total // len(secs_list)
        avg_str = f"{avg//3600:02d}:{(avg%3600)//60:02d}:{avg%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)
    out_lines.append(','.join(str(x) for x in rec))

# Escape lines and join with JS newline
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

# Replace in HTML template
with open(template_path, 'r', encoding='utf-8') as f:
    html_content = f.read()

new_content = html_content.replace(
    "const csvData = '';",
    f"const csvData = '{csv_string}';"
)

with open(template_path, 'w', encoding='utf-8') as f:
    f.write(new_content)

print(f"Injected data into: {template_path}")







#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    """–ü—Ä–µ–æ–±—Ä–∞–∑ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

files_dir = arg1
try:
    n = int(arg2) if arg2 else 31
except ValueError:
    n = 31

# –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ
files = []
if os.path.isdir(files_dir):
    try:
        files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
        files = sorted(files, key=os.path.getmtime)[-n:]
        if not files:
            sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ .JT –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")
    except Exception as e:
        sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è {files_dir}: {e}")
else:
    sys.exit("–ù–µ–≤–∞–ª–∏–¥–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è.")

# –î–∞–Ω–Ω–∏
data = {}
dates = [None] * len(files)

# –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª
for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage_batch_job = (parts[0], parts[1], parts[2])
            date     = parts[3]
            start    = parts[5]
            stop     = parts[6]
            elapsed  = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            key = stage_batch_job
            data.setdefault(key, {})[idx] = {
                "start": start,
                "stop": stop,
                "elapsed": elapsed,
                "secs": secs,
                "date": date
            }

            if dates[idx] is None:
                dates[idx] = date

# --- –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ CSV —Ä–µ–¥–æ–≤–µ ---
out_lines = []

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

# –ü–æ –∫–ª—é—á
for key in sorted(data.keys()):
    status = ""
    secs_list = []

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ STATUS
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0:
        status = "NEW"
    elif s > 0 and e == 0:
        status = "LOST"
    elif s > 0 and e > s:
        status = "SLOW"
    elif s == e and s > 0:
        status = "STABLE"
    else:
        status = "-"

    rec = [status, *key]

    # –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""), info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ AVERAGE
    if secs_list:
        s = sum(secs_list)
        m = s // len(secs_list)
        avg_str = f"{m//3600:02d}:{(m%3600)//60:02d}:{m%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out_lines.append(','.join(str(x) for x in rec))

# --- –ó–∞–ø–∏—Å –∫–∞—Ç–æ JS –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ ---
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

with open("csv_output.js", 'w', encoding='utf-8') as f:
    f.write(f"const csvData = '{csv_string}';\n")

print("–ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω —Ñ–∞–π–ª: csv_output.js")





import os
import csv
import sys
import html

def find_all_files(root_dir):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    try:
        with open(file_path, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile)
            for i, row in enumerate(reader, start=1):
                if i in rows_to_print:
                    line = ','.join(row)
                    output_lines.append(line)
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python csv_to_js_var.py <root_directory> <output_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    output_file = sys.argv[2]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_all_files(root_directory)

    if not files:
        print("No files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"Output written to {output_file}")






import os
import csv
import sys
import html

def find_files_by_date(root_dir, date_mask):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if date_mask in filename:
                matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    with open(file_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        for i, row in enumerate(reader, start=1):
            if i in rows_to_print:
                line = ','.join(row)
                output_lines.append(line)
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python csv_to_js_var.py <root_directory> <date_mask> <output_html_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    date_mask = sys.argv[2]
    output_html_file = sys.argv[3]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_files_by_date(root_directory, date_mask)

    if not files:
        print("No matching files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_html_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"JavaScript CSV data written to {output_html_file}")




.page-title {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 20px;
}

.page-title .title-icon {
  width: 36px;
  height: 36px;
}

.page-title h1 {
  margin: 0;
  font-size: 28px;
  color: #0059b3;
}




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach((col) => {
    const th = document.createElement("th");
    const colIndex = headers.indexOf(col);
    th.textContent = col;
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach(row => {
    const tr = document.createElement("tr");

    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          tdDiff.setAttribute("data-diff", diff);
        }
        tr.appendChild(tdDiff);
      }
    });

    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromVal = parseInt(fromRaw.replaceAll("-", ""));
    const toVal = parseInt(toRaw.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromVal)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toVal)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      const rowsWithDiff = filtered.map(row => {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;
        let diff = 0;
        if (fromElapsed && toElapsed) {
          diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
        }
        return { row, diff };
      });

      filtered = rowsWithDiff
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(obj => obj.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>








} else if (currentSort.index === -2) {
  const diffs = [];
  filtered.forEach(row => {
    const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
    const toDate = parseInt(dateTo.value.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let j = 1; j <= 31; j++) {
      const idx = headers.indexOf(`Date${j}`);
      if (idx === -1) continue;
      if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
      if (toX === null && parseInt(row[idx]) === toDate) toX = j;
    }

    const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
    const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

    let diff = 0;
    if (fromElapsed && toElapsed) {
      diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
    }

    diffs.push({ row, diff });
  });

  filtered = diffs
    .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
    .map(item => item.row);
}






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;
  currentDiffs = [];

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const colIndex = headers.indexOf(col);
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, rowIndex) => {
    const tr = document.createElement("tr");
    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
        const toDate = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;

        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
          if (toX === null && parseInt(row[idx]) === toDate) toX = j;
        }

        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          diffValue = diff;
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[rowIndex] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];
  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromDate = parseInt(fromRaw.replaceAll("-", ""));
    const toDate = parseInt(toRaw.replaceAll("-", ""));

    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      filtered = filtered
        .map((row, i) => ({ row, diff: currentDiffs[i] || 0 }))
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(item => item.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>





const fromDate = parseInt(fromRaw.replaceAll("-", ""));
const toDate = parseInt(toRaw.replaceAll("-", ""));

let fromX = null, toX = null;

for (let i = 1; i <= 31; i++) {
  const idx = headers.indexOf(`Date${i}`);
  if (idx === -1) continue;

  if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) {
    fromX = i;
  }

  if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) {
    toX = i;
  }

  if (fromX !== null && toX !== null) break;
}

if (fromX !== null && toX !== null) {
  visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
  visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
  insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #f4f6f9;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 200px;
      background: #fff;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    th {
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
    }

    th.sorted-asc::after {
      content: " ü°ª";
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-desc::after {
      content: " ü°π";
      font-weight: bold;
      font-size: 12px;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d4edda;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f8d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff3cd;
      font-weight: bold;
    }
    
    th {
        white-space: nowrap;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
        display: inline-block;
        margin-left: 4px;
        vertical-align: middle;
        line-height: 1;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2,Date3,Start3,Stop3,Elapsed3,Date4,Start4,Stop4,Elapsed4,Date5,Start5,Stop5,Elapsed5,Date6,Start6,Stop6,Elapsed6,Date7,Start7,Stop7,Elapsed7,Date8,Start8,Stop8,Elapsed8,Date9,Start9,Stop9,Elapsed9,Date10,Start10,Stop10,Elapsed10,Date11,Start11,Stop11,Elapsed11,Date12,Start12,Stop12,Elapsed12,Date13,Start13,Stop13,Elapsed13,Date14,Start14,Stop14,Elapsed14,Date15,Start15,Stop15,Elapsed15,Date16,Start16,Stop16,Elapsed16,Date17,Start17,Stop17,Elapsed17,Date18,Start18,Stop18,Elapsed18,Date19,Start19,Stop19,Elapsed19,Date20,Start20,Stop20,Elapsed20,Date21,Start21,Stop21,Elapsed21,Date22,Start22,Stop22,Elapsed22,Date23,Start23,Stop23,Elapsed23,Date24,Start24,Stop24,Elapsed24,Date25,Start25,Stop25,Elapsed25,Date26,Start26,Stop26,Elapsed26,Date27,Start27,Stop27,Elapsed27,Date28,Start28,Stop28,Elapsed28,Date29,Start29,Stop29,Elapsed29,Date30,Start30,Stop30,Elapsed30,Date31,Start31,Stop31,Elapsed31,AVERAGE
OK,C,BATCH716,Job_1,20240501,00:00:00,00:01:06,00:01:06,20250502,00:00:00,00:02:18,00:02:18,20250503,00:00:00,00:01:33,00:01:33,20250504,00:00:00,00:01:12,00:01:12,20250505,00:00:00,00:02:05,00:02:05,20250506,00:00:00,00:05:18,00:05:18,20250507,00:00:00,00:01:56,00:01:56,20250508,00:00:00,00:00:38,00:00:38,20250509,00:00:00,00:03:34,00:03:34,20250510,00:00:00,00:02:25,00:02:25,20250511,00:00:00,00:04:14,00:04:14,20250512,00:00:00,00:01:47,00:01:47,20250513,00:00:00,00:00:34,00:00:34,20250514,00:00:00,00:03:33,00:03:33,20250515,00:00:00,00:02:31,00:02:31,20250516,00:00:00,00:02:17,00:02:17,20250517,00:00:00,00:04:46,00:04:46,20250518,00:00:00,00:01:16,00:01:16,20250519,00:00:00,00:00:29,00:00:29,20250520,00:00:00,00:03:53,00:03:53,20250521,00:00:00,00:01:29,00:01:29,20250522,00:00:00,00:03:54,00:03:54,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:03:33,00:03:33,20250525,00:00:00,00:05:42,00:05:42,20250526,00:00:00,00:03:27,00:03:27,20250527,00:00:00,00:05:20,00:05:20,20250528,00:00:00,00:05:14,00:05:14,20250529,00:00:00,00:04:29,00:04:29,20250530,00:00:00,00:02:53,00:02:53,20250531,00:00:00,00:04:30,00:04:30,00:03:00
OK,A,BATCH716,Job_2,20240501,00:00:00,00:01:39,00:01:39,20250502,00:00:00,00:00:55,00:00:55,20250503,00:00:00,00:04:43,00:04:43,20250504,00:00:00,00:01:27,00:01:27,20250505,00:00:00,00:03:26,00:03:26,20250506,00:00:00,00:01:49,00:01:49,20250507,00:00:00,00:05:23,00:05:23,20250508,00:00:00,00:01:54,00:01:54,20250509,00:00:00,00:04:54,00:04:54,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:00:38,00:00:38,20250512,00:00:00,00:02:26,00:02:26,20250513,00:00:00,00:03:01,00:03:01,20250514,00:00:00,00:03:14,00:03:14,20250515,00:00:00,00:02:16,00:02:16,20250516,00:00:00,00:04:06,00:04:06,20250517,00:00:00,00:03:43,00:03:43,20250518,00:00:00,00:01:28,00:01:28,20250519,00:00:00,00:05:20,00:05:20,20250520,00:00:00,00:03:25,00:03:25,20250521,00:00:00,00:05:06,00:05:06,20250522,00:00:00,00:00:08,00:00:08,20250523,00:00:00,00:00:46,00:00:46,20250524,00:00:00,00:05:45,00:05:45,20250525,00:00:00,00:03:55,00:03:55,20250526,00:00:00,00:03:06,00:03:06,20250527,00:00:00,00:03:13,00:03:13,20250528,00:00:00,00:04:13,00:04:13,20250529,00:00:00,00:04:01,00:04:01,20250530,00:00:00,00:00:03,00:00:03,20250531,00:00:00,00:03:44,00:03:44,00:02:58
OK,C,BATCH440,Job_3,20240501,00:00:00,00:02:56,00:02:56,20250502,00:00:00,00:01:19,00:01:19,20250503,00:00:00,00:01:13,00:01:13,20250504,00:00:00,00:05:52,00:05:52,20250505,00:00:00,00:04:46,00:04:46,20250506,00:00:00,00:02:19,00:02:19,20250507,00:00:00,00:02:53,00:02:53,20250508,00:00:00,00:01:43,00:01:43,20250509,00:00:00,00:01:29,00:01:29,20250510,00:00:00,00:01:05,00:01:05,20250511,00:00:00,00:00:56,00:00:56,20250512,00:00:00,00:02:57,00:02:57,20250513,00:00:00,00:04:51,00:04:51,20250514,00:00:00,00:03:42,00:03:42,20250515,00:00:00,00:01:31,00:01:31,20250516,00:00:00,00:01:17,00:01:17,20250517,00:00:00,00:02:17,00:02:17,20250518,00:00:00,00:00:17,00:00:17,20250519,00:00:00,00:00:24,00:00:24,20250520,00:00:00,00:00:31,00:00:31,20250521,00:00:00,00:04:11,00:04:11,20250522,00:00:00,00:04:24,00:04:24,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:04:03,00:04:03,20250525,00:00:00,00:01:59,00:01:59,20250526,00:00:00,00:01:39,00:01:39,20250527,00:00:00,00:00:32,00:00:32,20250528,00:00:00,00:00:32,00:00:32,20250529,00:00:00,00:03:47,00:03:47,20250530,00:00:00,00:03:57,00:03:57,20250531,00:00:00,00:01:43,00:01:43,00:02:28
ERROR,C,BATCH740,Job_4,20240501,00:00:00,00:04:31,00:04:31,20250502,00:00:00,00:00:22,00:00:22,20250503,00:00:00,00:00:33,00:00:33,20250504,00:00:00,00:02:23,00:02:23,20250505,00:00:00,00:02:47,00:02:47,20250506,00:00:00,00:04:11,00:04:11,20250507,00:00:00,00:01:10,00:01:10,20250508,00:00:00,00:03:24,00:03:24,20250509,00:00:00,00:05:35,00:05:35,20250510,00:00:00,00:02:15,00:02:15,20250511,00:00:00,00:03:34,00:03:34,20250512,00:00:00,00:04:42,00:04:42,20250513,00:00:00,00:05:18,00:05:18,20250514,00:00:00,00:05:00,00:05:00,20250515,00:00:00,00:04:12,00:04:12,20250516,00:00:00,00:05:13,00:05:13,20250517,00:00:00,00:01:14,00:01:14,20250518,00:00:00,00:05:05,00:05:05,20250519,00:00:00,00:02:03,00:02:03,20250520,00:00:00,00:05:13,00:05:13,20250521,00:00:00,00:05:00,00:05:00,20250522,00:00:00,00:01:01,00:01:01,20250523,00:00:00,00:01:15,00:01:15,20250524,00:00:00,00:05:27,00:05:27,20250525,00:00:00,00:00:53,00:00:53,20250526,00:00:00,00:03:59,00:03:59,20250527,00:00:00,00:05:55,00:05:55,20250528,00:00:00,00:02:13,00:02:13,20250529,00:00:00,00:00:18,00:00:18,20250530,00:00:00,00:00:12,00:00:12,20250531,00:00:00,00:02:55,00:02:55,00:03:09
OK,C,BATCH966,Job_5,20240501,00:00:00,00:05:44,00:05:44,20250502,00:00:00,00:00:58,00:00:58,20250503,00:00:00,00:03:09,00:03:09,20250504,00:00:00,00:03:53,00:03:53,20250505,00:00:00,00:03:33,00:03:33,20250506,00:00:00,00:02:08,00:02:08,20250507,00:00:00,00:04:22,00:04:22,20250508,00:00:00,00:02:51,00:02:51,20250509,00:00:00,00:04:24,00:04:24,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:03:54,00:03:54,20250512,00:00:00,00:00:46,00:00:46,20250513,00:00:00,00:01:45,00:01:45,20250514,00:00:00,00:00:11,00:00:11,20250515,00:00:00,00:04:58,00:04:58,20250516,00:00:00,00:03:42,00:03:42,20250517,00:00:00,00:03:13,00:03:13,20250518,00:00:00,00:02:05,00:02:05,20250519,00:00:00,00:02:33,00:02:33,20250520,00:00:00,00:00:46,00:00:46,20250521,00:00:00,00:04:58,00:04:58,20250522,00:00:00,00:05:06,00:05:06,20250523,00:00:00,00:02:17,00:02:17,20250524,00:00:00,00:02:47,00:02:47,20250525,00:00:00,00:01:37,00:01:37,20250526,00:00:00,00:04:03,00:04:03,20250527,00:00:00,00:03:57,00:03:57,20250528,00:00:00,00:04:24,00:04:24,20250529,00:00:00,00:05:07,00:05:07,20250530,00:00:00,00:05:52,00:05:52,20250531,00:00:00,00:01:23,00:01:23,00:03:11`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");

const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols = headers, diffAfterIndex = null) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach(col => {
    const th = document.createElement("th");
    th.textContent = col;
    const originalIndex = headers.indexOf(col);
    if (originalIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === originalIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: originalIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && originalIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  const elapsedIndexes = headers
    .map((h, i) => ({ h, i }))
    .filter(obj => /^Elapsed\d+$/.test(obj.h))
    .map(obj => obj.i);

  currentDiffs = [];

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");

    let maxElapsedSec = -1;
    let maxElapsedIndexes = [];

    elapsedIndexes.forEach(i => {
      const val = row[i];
      if (val && /^\d{2}:\d{2}:\d{2}$/.test(val)) {
        const sec = hmsToSeconds(val);
        if (sec > maxElapsedSec) {
          maxElapsedSec = sec;
          maxElapsedIndexes = [i];
        } else if (sec === maxElapsedSec) {
          maxElapsedIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] !== undefined ? row[i] : "";
      if (maxElapsedIndexes.includes(i)) {
        td.style.backgroundColor = "yellow";
        td.style.fontWeight = "bold";
      }
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
        const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
        const fromElapsed = row[headers.indexOf(`Elapsed${fromDay}`)];
        const toElapsed = row[headers.indexOf(`Elapsed${toDay}`)];
        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diffSec = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          diffValue = diffSec;
          tdDiff.textContent = secondsToHMS(diffSec);
          tdDiff.style.backgroundColor = diffSec < 0 ? "#f88" : "#8f8";
          tdDiff.style.fontWeight = "bold";
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[idx] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];

  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromParsed = fromRaw.replaceAll("-", "");
    const toParsed = toRaw.replaceAll("-", "");
    const fromDay = parseInt(fromParsed.slice(-2));
    const toDay = parseInt(toParsed.slice(-2));
    visibleCols.push(...[`Date${fromDay}`, `Start${fromDay}`, `Stop${fromDay}`, `Elapsed${fromDay}`]);
    visibleCols.push(...[`Date${toDay}`, `Start${toDay}`, `Stop${toDay}`, `Elapsed${toDay}`]);
    insertDiffAfter = headers.indexOf(`Elapsed${toDay}`);
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction === 0) {
    filtered = [...filtered];
  } else if (currentSort.index >= 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2) {
    const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
    const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
    const fromIdx = headers.indexOf(`Elapsed${fromDay}`);
    const toIdx = headers.indexOf(`Elapsed${toDay}`);
    filtered.sort((a, b) => {
      const aFrom = a[fromIdx], aTo = a[toIdx];
      const bFrom = b[fromIdx], bTo = b[toIdx];
      const aDiff = (aTo && aFrom) ? hmsToSeconds(aTo) - hmsToSeconds(aFrom) : 0;
      const bDiff = (bTo && bFrom) ? hmsToSeconds(bTo) - hmsToSeconds(bFrom) : 0;
      return currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff;
    });
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>
</body>
</html>








#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ —Å–∫—Ä–∏–ø—Ç—ä—Ç –µ –≤ —Ä–∞–∑–ª–∏—á–Ω–∞ –ø–∞–ø–∫–∞, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç–∏–≤–∞–º–µ —Ç–∞–º
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# Escape-–≤–∞–º–µ —Å–∞–º–æ backticks, –∑–∞ –¥–∞ –≥–∏ –≤–≥—Ä–∞–¥–∏–º –±–µ–∑–æ–ø–∞—Å–Ω–æ –≤ JS template
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .toggles { margin-bottom:10px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

  <div class="controls">
    <input id="search"    placeholder="Global search‚Ä¶"/>
    <input id="start" type="date"/>
    <input id="end"   type="date"/>
    <button id="apply" >Apply Date Filter</button>
    <button id="all"   >All Dates</button>
    <button id="cmp"   >Compare Dates</button>
    <button id="reset" >Reset All</button>
  </div>

  <div class="toggles" id="toggles"></div>

  <table id="report">
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>

  <script>
  // ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_ESCAPED
\`.trim();
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function parseCSV(txt) {
    return txt.split('\\n').map(r => r.split(','));
  }
  function toSec(s) {
    const [h,m,x] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + x;
  }
  function fmt(n){ return (n>=0?'+':'')+n; }

  let header = [],       // —Ñ–∏–Ω–∞–ª–Ω–∏—è—Ç header
      cols   = [],       // {name,hidden}
      rows   = [],       // {vals,hidden,maxIdx,diff}
      sortState={col:null,dir:'asc'},
      cmpDates=[null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    init();
    renderToggles();
    renderTable();

    document.getElementById('search' ).addEventListener('input', filterTable);
    document.getElementById('apply'  ).addEventListener('click', filterTable);
    document.getElementById('all'    ).addEventListener('click', allDates);
    document.getElementById('cmp'    ).addEventListener('click', compareDates);
    document.getElementById('reset'  ).addEventListener('click', resetAll);
    document.getElementById('start'  ).addEventListener('change', ()=>cmpDates[0]=document.getElementById('start').value.replace(/-/g,''));
    document.getElementById('end'    ).addEventListener('change', ()=>cmpDates[1]=document.getElementById('end').value.replace(/-/g,''));
  });

  function init(){
    const arr = parseCSV(rawCSV);
    const origH = arr.shift();   // –æ—Ä–∏–≥–∏–Ω–∞–ª–µ–Ω header: [STATUS,STAGE,BATCH,JOB.NAME,Date1,Elapsed1,...,AVERAGE]
    const dataArr = arr;         // –≤—Å–∏—á–∫–∏ data —Ä–µ–¥–æ–≤–µ
    const staticCnt = 4;
    const summaryCnt = 1;        // —Å–∞–º–æ AVERAGE
    const pairCnt = (origH.length - staticCnt - summaryCnt) / 2;

    // –ü–æ—Å—Ç—Ä–æ—è–≤–∞–º–µ —Ñ–∏–Ω–∞–ª–µ–Ω header:
    header = [
      ...origH.slice(0,staticCnt),
      // –∑–∞ –≤—Å—è–∫–∞ –¥–≤–æ–π–∫–∞ DateX,ElapsedX ‚Äì –≤–∑–∏–º–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç –ø—ä—Ä–≤–∏—è data-—Ä–µ–¥
      ...Array.from({length:pairCnt}, (_,i)=> dataArr[0][ staticCnt + 2*i ]),
      origH[ staticCnt + 2*pairCnt ], // AVERAGE
      'Difference'
    ];

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ cols
    cols = header.map(h=>({name:h, hidden:false}));

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ rows
    rows = dataArr.map(r=>{
      const vals = [];
      // 4 —Å—Ç–∞—Ç–∏—á–Ω–∏
      for(let i=0;i<staticCnt;i++) vals.push(r[i]);
      // N elapsed-–æ–≤–µ
      for(let i=0;i<pairCnt;i++){
        vals.push(r[ staticCnt+2*i+1 ]||'');
      }
      // AVERAGE
      vals.push(r[ staticCnt+2*pairCnt ]||'');
      // –©–µ –¥–æ–±–∞–≤–∏–º Difference –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä
      return { vals, hidden:false, maxIdx:staticCnt, diff:0 };
    });

    // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ maxIdx –∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ diff –∑–∞ –≤—Å–µ–∫–∏ row
    rows.forEach(row=>{
      let maxSec=-1, mi=staticCnt;
      for(let i=0;i<pairCnt;i++){
        const sec = toSec(row.vals[staticCnt+i]);
        if(sec>maxSec){ maxSec=sec; mi=staticCnt+i; }
      }
      row.maxIdx = mi;
      const first = toSec(row.vals[staticCnt+0]);
      const last  = toSec(row.vals[staticCnt+pairCnt-1]);
      row.diff = last-first;
    });
  }

  function renderToggles(){
    const c = document.getElementById('toggles');
    c.innerHTML='';
    cols.forEach((col,i)=>{
      const lbl=document.createElement('label');
      const cb =document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
      lbl.append(cb,' ',col.name);
      c.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML='';
    tbody.innerHTML='';

    // HEADER
    const hr=document.createElement('tr');
    cols.forEach((col,i)=>{
      if(col.hidden) return;
      const th=document.createElement('th');
      th.textContent=col.name;
      th.onclick=()=>sortBy(i);
      if(sortState.col===i)
        th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    thead.append(hr);

    // BODY
    rows.forEach(r=>{
      if(r.hidden) return;
      const tr=document.createElement('tr');
      cols.forEach((col,i)=>{
        if(col.hidden) return;
        const td=document.createElement('td');
        td.textContent = r.vals[i]||'';
        if(i===r.maxIdx) td.classList.add('max');
        if(i===cols.length-1){
          // Difference –∫–æ–ª–æ–Ω–∞
          td.textContent = fmt(r.diff);
          td.classList.add(r.diff>=0?'diff-pos':'diff-neg');
        }
        tr.append(td);
      });
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
    else sortState.dir='asc';
    sortState.col=ci;
    const th=document.querySelectorAll('th')[ci];
    th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    rows.sort((a,b)=>{
      const A=a.vals[ci]||'', B=b.vals[ci]||'';
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return sortState.dir==='asc'? cmp : -cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term=document.getElementById('search').value.toLowerCase();
    const sd=document.getElementById('start').value.replace(/-/g,''), 
          ed=document.getElementById('end').value.replace(/-/g,'');
    rows.forEach(r=>{
      let ok=true;
      if(term) ok = r.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        const d = r.vals[4]; // –¥–∞—Ç–∞—Ç–∞ –µ –Ω–∞ –ø–æ–∑–∏—Ü–∏—è 4
        ok = (!sd||d>=sd) && (!ed||d<=ed);
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function allDates(){
    // –≤–∑–∏–º–∞–º–µ –≤—Å–∏—á–∫–∏ –¥–∞—Ç–∏ –æ—Ç –∫–æ–ª–æ–Ω–∞ 4
    const ds = rows.map(r=>r.vals[4]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end').value   = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeDate(idx){
    // –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ start/end –∑–∞–ø–æ–º–Ω—è–º–µ YYYYMMDD
    cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
  }

  function compareDates(){
    const [d1,d2] = cmpDates;
    if(!d1||!d2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏.');
    const i1 = rows.findIndex(r=>r.vals[4]===d1);
    const i2 = rows.findIndex(r=>r.vals[4]===d2);
    if(i1<0||i2<0) return alert('–ù—è–º–∞ —Ç–∞–∫—ä–≤ —Ä–µ–¥.');
    rows.forEach(r=>{
      const f = toSec(r.vals[4]),
            l = toSec(r.vals[4 + parseInt((header.length-5)/2)]); // –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç elapsed
      r.diff = l - f;
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    cols.forEach(c=>c.hidden=false);
    rows.forEach(r=>{ r.hidden=false; });
    sortState={col:null,dir:'asc'};
    renderToggles();
    renderTable();
  }
  </script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä!"







#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ —Å–∫—Ä–∏–ø—Ç—ä—Ç –µ –≤ –¥—Ä—É–≥–∞ –ø–∞–ø–∫–∞, —Å–µ –º–µ—Å—Ç–∏–º —Ç–∞–º
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# –ß–µ—Ç–µ–º —Ü–µ–ª–∏—è CSV –≤ –º–∞—Å–∏–≤ –æ—Ç —Ä–µ–¥–æ–≤–µ
mapfile -t lines < "$CSV"
# –ü—ä—Ä–≤–∏—è—Ç —Ä–µ–¥ –µ header
IFS=',' read -r -a hdr <<< "${lines[0]}"
# –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ N = –±—Ä–æ–π date/elapsed –¥–≤–æ–π–∫–∏
len=${#hdr[@]}
N=$(( (len - 4 - 2) / 2 ))
# –í–∑–µ–º–∞–º–µ –∏—Å—Ç–∏–Ω—Å–∫–∏—Ç–µ –¥–∞—Ç–∏ –æ—Ç –ø—ä—Ä–≤–∏—è data-—Ä–µ–¥
IFS=',' read -r -a firstRow <<< "${lines[1]}"
dateLabels=()
for i in $(seq 0 $((N-1))); do
  idx=$((4 + 2*i))
  dateLabels+=("${firstRow[idx]}")
done
# –°—Ä–µ–¥–Ω–∏—è—Ç –∏ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ —Å–∞ —Å–ª–µ–¥ —Ç—è—Ö
avgLabel="${hdr[4 + 2*N]}"
diffLabel="${hdr[5 + 2*N]}"
# –ü—ä—Ä–≤–∏—Ç–µ 4 –∫–æ–ª–æ–Ω–∏
staticLabels=( "${hdr[0]}" "${hdr[1]}" "${hdr[2]}" "${hdr[3]}" )
# –§–∏–Ω–∞–ª–µ–Ω header
finalHeader=( "${staticLabels[@]}" "${dateLabels[@]}" "$avgLabel" "$diffLabel" )

# –°–≥–ª–æ–±—è–≤–∞–º–µ data –º–∞—Å–∏–≤: –∑–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥ ‚Äì 4 —Å—Ç–∞—Ç–∏—á–Ω–∏, N elapsed, AVG, DIFF
dataRows=()
for ((r=1; r<${#lines[@]}; r++)); do
  IFS=',' read -r -a row <<< "${lines[r]}"
  # —Å—Ç–∞—Ç–∏—á–Ω–∏
  out=( "${row[0]}" "${row[1]}" "${row[2]}" "${row[3]}" )
  # elapsed
  for i in $(seq 0 $((N-1))); do
    out+=( "${row[4 + 2*i + 1]}" )
  done
  # average & difference
  out+=( "${row[4 + 2*N]}" "${row[5 + 2*N]}" )
  # join —Å—ä—Å ‚Äò|‚Äô (—â–µ split-–Ω–µ–º –≤ JS)
  dataRows+=( "$(IFS='|'; echo "${out[*]}")" )
done

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Report</title>
<style>
  body{margin:0;padding:20px;font-family:sans-serif;overflow-x:auto;}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:15px}
  .controls input,.controls button{padding:6px 10px;}
  .toggles{margin-bottom:15px}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ccc;padding:8px;white-space:nowrap}
  th{background:#f0f0f0;cursor:pointer;position:relative}
  th.sort-asc::after{content:" ‚Üë"} th.sort-desc::after{content:" ‚Üì"}
  td.max{background:#fff9c4} td.diff-pos{background:#e6f4ea}
  td.diff-neg{background:#fce8e6}
</style>
</head>
<body>

<div class="controls">
  <input id="search"    placeholder="Global search‚Ä¶"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply" >Apply Date Filter</button>
  <button id="all"   >All Dates</button>
  <button id="cmp"   >Compare Dates</button>
  <button id="reset" >Reset All</button>
</div>

<div class="toggles" id="toggles"></div>
<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// header –∏ data –≥–∏ –≤–≥—Ä–∞–∂–¥–∞–º–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –æ—Ç bash-–∞
const header = [$(printf '"%s",' "${finalHeader[@]}" )].map(h=>h.replace(/",$/,''));
const rawData = [
$(printf "  '%s',\n" "${dataRows[@]}")
].map(r=>r.split('|'));

let cols = header.map((name,i)=>({name,idx:i,hidden:false}));
let rows = rawData.map(r=>({vals:r,hidden:false}));
let sortState={col:null,dir:'asc'};
let cmpDates=[null,null];

// init
document.addEventListener('DOMContentLoaded',()=>{
  renderToggles();
  renderTable();
  document.getElementById('search').addEventListener('input',filter);
  document.getElementById('apply').addEventListener('click',filter);
  document.getElementById('all').addEventListener('click',allDates);
  document.getElementById('cmp').addEventListener('click',compare);
  document.getElementById('reset').addEventListener('click',resetAll);
  document.getElementById('start').addEventListener('change',()=>cmpDates[0]=this.value.replace(/-/g,''));
  document.getElementById('end').addEventListener('change',()=>cmpDates[1]=this.value.replace(/-/g,''));
});

// —Ä–µ–Ω–¥–µ—Ä —á–µ–∫–±–æ–∫—Å–æ–≤–µ
function renderToggles(){
  const c=document.getElementById('toggles'); c.innerHTML='';
  cols.forEach((cdef,i)=>{
    const lbl=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.checked=!cdef.hidden;
    cb.onchange=()=>{ cdef.hidden=!cb.checked; renderTable(); };
    lbl.append(cb,' ',cdef.name);
    c.append(lbl);
  });
}

// —Ä–µ–Ω–¥–µ—Ä –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞
function renderTable(){
  const thead=document.getElementById('thead'),
        tbody=document.getElementById('tbody');
  thead.innerHTML=''; tbody.innerHTML='';

  // –∑–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
  const trh=document.createElement('tr');
  cols.forEach((cdef,i)=>{
    if(cdef.hidden) return;
    const th=document.createElement('th');
    th.textContent=cdef.name;
    th.onclick=()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    trh.append(th);
  });
  thead.append(trh);

  // –¥–∞–Ω–Ω–∏
  rows.forEach(rdef=>{
    if(rdef.hidden) return;
    const tr=document.createElement('tr');
    cols.forEach((cdef,i)=>{
      if(cdef.hidden) return;
      const td=document.createElement('td');
      td.textContent = rdef.vals[i]||'';
      // mark max (–ø—ä—Ä–≤–∏ –¥–∏–Ω–∞–º–∏—á–µ–Ω >4)
      if(i>=4 && i<4+dateLabels.length && +parseSec(rdef.vals[i])===Math.max(...dateLabels.map((_,j)=>parseSec(rdef.vals[4+j]))))
        td.classList.add('max');
      tr.append(td);
    });
    tbody.append(tr);
  });
}

// —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ toggle asc/desc
function sortBy(ci){
  document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc'; sortState.col=ci;
  const ths=document.querySelectorAll('th')[ci];
  ths.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
  rows.sort((a,b)=>{
    const A=a.vals[ci], B=b.vals[ci];
    const nA=parseFloat(A), nB=parseFloat(B);
    let cmp=!isNaN(nA)&&!isNaN(nB)? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'?cmp:-cmp;
  });
  renderTable();
}

// —Ñ–∏–ª—Ç—ä—Ä
function filter(){
  const term=document.getElementById('search').value.toLowerCase();
  const sd=document.getElementById('start').value.replace(/-/g,''),
        ed=document.getElementById('end'  ).value.replace(/-/g,'');
  rows.forEach(rdef=>{
    let ok=true;
    if(term) ok = rdef.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      const v=rdef.vals[4];
      ok = (!sd||v>=sd) && (!ed||v<=ed);
    }
    rdef.hidden=!ok;
  });
  renderTable();
}

// All Dates
function allDates(){
  const dates = rows.map(r=>r.vals[4]).sort();
  const s=dates[0], e=dates.at(-1);
  document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end')  .value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filter();
}

// Compare Dates
function compare(){
  if(!cmpDates[0]||!cmpDates[1]) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
  const idx1=rows.findIndex(r=>r.vals[4]===cmpDates[0]),
        idx2=rows.findIndex(r=>r.vals[4]===cmpDates[1]);
  if(idx1<0||idx2<0) return alert('–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω —Ä–µ–¥');
  rows.forEach((r,i)=>{
    const v1=parseSec(rows[idx1].vals[5]),
          v2=parseSec(rows[idx2].vals[5]);
    r.diffAll=v2-v1;
    const tdDiff=document.querySelectorAll('tbody tr')[i]
             .appendChild(document.createElement('td'));
    tdDiff.textContent = fmtDiff(r.diffAll);
    tdDiff.classList.add(r.diffAll>=0?'diff-pos':'diff-neg');
  });
}

// reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  cols.forEach(c=>c.hidden=false);
  rows.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  renderToggles();
  renderTable();
}

// parse HH:MM:SS
function parseSec(s){ const [h,m,x]=(s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
function fmtDiff(n){ return (n>=0?'+':'')+n; }

</script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä!"







#!/usr/bin/env bash
set -euo pipefail

# –û—Ç–∏–≤–∞–º–µ –≤ –ø–∞–ø–∫–∞—Ç–∞ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $(pwd):" >&2
  ls -1
  exit 1
fi

# –ï—Å–∫–µ–π–ø –Ω–∞ backticks, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search‚Ä¶"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply">Apply Date Filter</button>
  <button id="all"  >All Dates</button>
  <button id="cmp"  >Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// ‚îÄ‚îÄ‚îÄ –í–ì–†–ê–î–ï–ù–û CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const rawCSV = `
$CSV_ESCAPED
`.trim();
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function parseCSV(txt){
  return txt.split('\n').map(r=>r.split(','));
}
function parseSec(s){
  const [h,m,x] = (s||'00:00:00').split(':').map(Number);
  return h*3600 + m*60 + x;
}
function fmtDiff(n){ return (n>=0?'+':'') + n; }

let header, rows, N;
let columns   = [];    // {name, idx, hidden}
let data      = [];    // {vals, hidden, maxIdx, diffVal}
let sortState = {col:null,dir:'asc'};
let cmpDates  = [null,null];

document.addEventListener('DOMContentLoaded',()=>{
  // Flatpickr –∑–∞–º–µ—Å—Ç–≤–∞–º–µ input[type=date] –∞–∫–æ –µ –Ω—É–∂–Ω–æ, –∏–Ω–∞—á–µ native.
  initData();
  buildToggles();
  renderTable();

  // –°–ª—É—à–∞—Ç–µ–ª–∏
  document.getElementById('search').addEventListener('input', filterTable);
  document.getElementById('apply' ).addEventListener('click', filterTable);
  document.getElementById('all'   ).addEventListener('click', setAllDates);
  document.getElementById('cmp'   ).addEventListener('click', compareDates);
  document.getElementById('reset' ).addEventListener('click', resetAll);
  document.getElementById('start' ).addEventListener('change', ()=>storeDate(0));
  document.getElementById('end'   ).addEventListener('change', ()=>storeDate(1));
});

function initData(){
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;

  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ N = –±—Ä–æ–π –¥–≤–æ–π–∫–∏ Date/Elapsed
  // –ß–∞–∫–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ –∫–æ–ª–æ–Ω–∞ –¥–∞ –µ "AVERAGE" –∏–ª–∏ –Ω—è–º–∞ ‚Äì –∏–≥–Ω–æ—Ä–∏—Ä–∞–º–µ —è
  const totalCols = header.length;
  const hasAvg = header[totalCols-1]==='AVERAGE';
  N = (totalCols - 4 - (hasAvg?1:0)) / 2;

  // –ü—ä—Ä–≤–∏—Ç–µ 4 —Å—Ç–∞—Ç–∏—á–Ω–∏
  columns = [];
  for(let i=0;i<4;i++){
    columns.push({name: header[i], idx:i, hidden:false});
  }
  // –°–ª–µ–¥ —Ç–æ–≤–∞ –≤–∑–µ–º–∞–º–µ —Å–∞–º–æ Elapsed –∫–æ–ª–æ–Ω–∏, –Ω–æ –∏–º–µ–Ω—É–≤–∞–º–µ –ø–æ —Ä–µ–∞–ª–Ω–∏—Ç–µ –¥–∞—Ç–∏
  for(let j=0;j<N;j++){
    const dateIdx    = 4 + 2*j;
    const elapsedIdx = dateIdx + 1;
    const dateLabel  = rows[0][dateIdx];  // –≤–∑–∏–º–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç –ø—ä—Ä–≤–∏—è —Ä–µ–¥
    columns.push({name: dateLabel, idx: elapsedIdx, hidden:false});
  }
  // –ò –Ω–∞–∫—Ä–∞—è Difference
  columns.push({name:'Difference', idx:null, hidden:false});

  // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data[]
  data = rows.map(r=>{
    const vals = [];
    // —Å—Ç–∞—Ç–∏—á–Ω–∏
    for(let i=0;i<4;i++) vals.push(r[i]);
    // Elapsed —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
    for(let j=0;j<N;j++){
      vals.push(r[4 + 2*j + 1] || '');
    }
    // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ maxIdx —Å—Ä–µ–¥ –Ω–æ–≤–∏—Ç–µ –∫–æ–ª–æ–Ω–∏ (0..3 + j)
    let maxIdx = 4, maxSec=-1;
    for(let k=0;k<N;k++){
      const s = parseSec(vals[4+k]);
      if(s>maxSec){ maxSec=s; maxIdx=4+k; }
    }
    return {vals, hidden:false, maxIdx, diffVal:0};
  });
}

function buildToggles(){
  const c = document.getElementById('toggles');
  c.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
    lbl.append(cb,' ',col.name);
    c.append(lbl);
  });
}

function renderTable(){
  const thead = document.getElementById('thead'),
        tbody = document.getElementById('tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // HEADER
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    hr.append(th);
  });
  thead.append(hr);

  // BODY
  data.forEach(row=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,i)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      // –°—Ç–æ–π–Ω–æ—Å—Ç: –∞–∫–æ idx=null (Difference), —â–µ –¥–æ–±–∞–≤–∏–º –ø–æ-–¥–æ–ª—É
      if(col.idx!==null) td.textContent = row.vals[col.idx] || '';
      if(col.idx!==null && col.idx >= 4 && col.idx < 4+N) {
        // highlight max
        if(i===row.maxIdx) td.classList.add('max');
      }
      tr.append(td);
    });
    // Difference = lastElap - firstElap
    const firstSec = parseSec(row.vals[4]);
    const lastSec  = parseSec(row.vals[4+N-1]);
    const d        = lastSec - firstSec;
    const td2      = document.createElement('td');
    td2.textContent = fmtDiff(d);
    td2.classList.add(d>=0?'diff-pos':'diff-neg');
    tr.append(td2);

    tbody.append(tr);
  });
}

function sortBy(ci){
  document.querySelectorAll('#thead th')
    .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc';
  sortState.col=ci;
  const th = document.querySelectorAll('#thead th')[ci];
  th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');

  data.sort((a,b)=>{
    const A = a.vals[ columns[ci].idx ] || '',
          B = b.vals[ columns[ci].idx ] || '';
    const nA = parseFloat(A), nB = parseFloat(B);
    let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'? cmp : -cmp;
  });
  renderTable();
}

function filterTable(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value.replace(/-/g,'');
  const ed   = document.getElementById('end').value.replace(/-/g,'');

  data.forEach(r=>{
    let ok = true;
    if(term) ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      ok = r.vals[4] && (!sd||r.vals[4]>=sd) && (!ed||r.vals[4]<=ed);
    }
    r.hidden = !ok;
  });
  renderTable();
}

// –ó–∞–¥–∞–≤–∞ "All Dates" –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç–∞ YYYY-MM-DD
function setAllDates(){
  if(N<1) return;
  const dates = rows.map(r=>r[4]).sort(); // –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å –¥–∞—Ç–∏
  const s = dates[0], e = dates.at(-1);
  document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filterTable();
}

// –ó–∞–ø–∞–∑–≤–∞ –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞ (YYYY-MM-DD ‚Üí YYYYMMDD)
function storeDate(i){
  const v = document.getElementById(i? 'end':'start').value.replace(/-/g,'');
  cmpDates[i] = v || null;
}

function compareDates(){
  const [d1,d2] = cmpDates;
  if(!d1||!d2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –∏ –¥–≤–µ—Ç–µ –¥–∞—Ç–∏.');
  // –Ω–∞–º–∏—Ä–∞–º–µ —Ä–µ–¥, —á–∏–π—Ç–æ –¥–∞—Ç–∞= d1/d2
  const idx1 = rows.findIndex(r=>r[4]===d1);
  const idx2 = rows.findIndex(r=>r[4]===d2);
  if(idx1<0||idx2<0) return alert('–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ä–µ–¥ –∑–∞ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–∞—Ç–∏.');
  data.forEach((r,i)=>{
    const s1 = parseSec(rows[idx1][5]),  // Elapsed –µ –≤ –∫–æ–ª–æ–Ω–∞ 5 (4+1)
          s2 = parseSec(rows[idx2][5]);
    r.diffAll = s2 - s1;
  });
  renderTable();
}

function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start' ).value='';
  document.getElementById('end'   ).value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  buildToggles();
  renderTable();
}
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä!"






#!/usr/bin/env bash
set -euo pipefail

# –ü—ä—Ä–≤–æ: –º–µ—Å—Ç–∏–º —Å–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å–∞–º–∏—è —Å–∫—Ä–∏–ø—Ç
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ report.csv -> report.html)
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-report.html}"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV_INPUT' –≤ –ø–∞–ø–∫–∞—Ç–∞ $SCRIPT_DIR" >&2
  echo "   (–¢–µ–∫—É—â–∞ –ø–∞–ø–∫–∞: $(pwd))" >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $(pwd):" >&2
  ls -1
  exit 1
fi

# –ü—Ä–æ—á–∏—Ç–∞–º–µ —Ü—è–ª–æ—Ç–æ CSV –∏ –µ—Å–∫–µ–π–ø–≤–∞–º–µ backticks
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // –í–≥—Ä–∞–¥e–Ω–æ CSV
    const rawCSV = \`
$CSV_CONTENT
\`;

    // –ü–∞—Ä—Å–≤–∞–Ω–µ
    function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
    function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
    function fmtDiff(n){ return (n>=0?'+':'') + n; }

    let header=[], rows=[], N;
    let columns=[], dateCols=[], elapsedCols=[];
    let data=[], currentSort={col:null,dir:'asc'};
    let cmpDates=[null,null];

    document.addEventListener('DOMContentLoaded',()=>{
      flatpickr('#start',{dateFormat:'Y-m-d'});
      flatpickr('#end',  {dateFormat:'Y-m-d'});

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search').addEventListener('input',renderFilter);
      document.getElementById('applyDates').addEventListener('click',renderFilter);
      document.getElementById('allDates').addEventListener('click',setAllDates);
      document.getElementById('compare').addEventListener('click',compareDates);
      document.getElementById('reset').addEventListener('click',resetAll);
      document.getElementById('start').addEventListener('change', ()=>storeCompare(0));
      document.getElementById('end').addEventListener('change',   ()=>storeCompare(1));
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/^[0-9]{8}$/.test(h)) dateCols.push(i);
        if(/^Elapsed/i.test(h))   elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          const s=parseSec(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const c=document.getElementById('toggles'); c.innerHTML='';
      columns.forEach((col,i)=>{
        const lbl=document.createElement('label');
        const cb=document.createElement('input');
        cb.type='checkbox'; cb.checked=!col.hidden;
        cb.onchange=()=>{ col.hidden=!cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        c.append(lbl);
      });
    }

    function renderTable(){
      const thead=document.getElementById('thead'),
            tbody=document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // Header
      const hr=document.createElement('tr');
      columns.forEach((col,i)=>{
        if(col.hidden) return;
        const th=document.createElement('th');
        th.textContent=col.name;
        th.onclick=()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // Body
      data.forEach(d=>{
        if(d.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((col,i)=>{
          if(col.hidden) return;
          const td=document.createElement('td');
          td.textContent=d.vals[i]||'';
          if(i===d.maxIdx) td.classList.add('max');
          tr.append(td);
        });
        const val = parseSec(d.vals[elapsedCols.at(-1)]) - parseSec(d.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=fmtDiff(val);
        td2.classList.add(val>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function renderFilter(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd=document.getElementById('start').value.replace(/-/g,''), 
            ed=document.getElementById('end').value.replace(/-/g,'');
      data.forEach(d=>{
        let ok=true;
        if(term)
          ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const v=d.vals[ci]||'';
            return (!sd||v>=sd) && (!ed||v<=ed);
          });
        }
        d.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds=dateCols.map(ci=>header[ci]).sort();
      const s=ds[0], e=ds.at(-1);
      document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
      document.getElementById('end'  ).value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
      renderFilter();
    }

    function storeCompare(idx){
      cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
    }

    function compareDates(){
      const [c1,c2] = cmpDates;
      if(!c1||!c2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
      const ci1 = header.indexOf(c1), ci2 = header.indexOf(c2);
      if(ci1<0||ci2<0) return alert('–î–∞—Ç–∞ –Ω–µ –Ω–∞–º–µ—Ä–µ–Ω–∞ –≤ header');
      const ei1=ci1+1, ei2=ci2+1;
      data.forEach(d=>{
        d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(d=>{d.hidden=false; d.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω \${OUT_HTML} ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä!"






#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT_HTML="\${2:-report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '\$CSV' –≤ \$PWD" >&2
  exit 1
fi

# Escape –Ω–∞ backticks –∑–∞ JS-template
CSV_CONTENT=\$(sed 's/`/\\\\`/g' "\$CSV")

cat >"\$OUT_HTML" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:10px; }
    .columns-toggle label { margin-right:10px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="apply">Apply Date Filter</button>
      <button id="all">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
  function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
  function fmtDiff(n){ return (n>=0?'+':'') + n; }

  let header = [], rows = [], N;
  let columns = [], dateCols = [], elapsedCols = [], data = [];
  let currentSort = {col:null, dir:'asc'};
  let cmpDates = [null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    flatpickr('#start', {dateFormat:'Y-m-d'});
    flatpickr('#end',   {dateFormat:'Y-m-d'});

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('apply' ).addEventListener('click', filterTable);
    document.getElementById('all'   ).addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset' ).addEventListener('click', resetAll);
    document.getElementById('start' ).addEventListener('change', ()=>storeCompare(0));
    document.getElementById('end'   ).addEventListener('change', ()=>storeCompare(1));
  });

  function initData(){
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4)/2;

    // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∏–Ω–¥–µ–∫—Å–∏
    dateCols    = header.map((h,i)=>/^[0-9]{8}\$/.test(h)?i:-1).filter(i=>i>=0);
    elapsedCols = header.map((h,i)=>/^Elapsed/i.test(h)?i:-1).filter(i=>i>=0);
    columns     = header.map(h=>({name:h,hidden:false}));

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data
    data = rows.map(r=>{
      let maxIdx = elapsedCols[0], maxSec=-1;
      elapsedCols.forEach(ci=>{
        let s = parseSec(r[ci]);
        if(s>maxSec){ maxSec=s; maxIdx=ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles(){
    const ctr=document.getElementById('toggles');
    ctr.innerHTML='';
    columns.forEach((c,i)=>{
      const lbl=document.createElement('label');
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=!c.hidden;
      cb.onchange=()=>{ c.hidden=!cb.checked; renderTable(); };
      lbl.append(cb,' ',c.name);
      ctr.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML=''; tbody.innerHTML='';

    // Header + Difference
    const hr=document.createElement('tr');
    columns.forEach((c,i)=>{
      if(c.hidden) return;
      const th=document.createElement('th');
      th.textContent=c.name;
      th.onclick=()=>sortBy(i);
      if(currentSort.col===i) th.classList.add(
        currentSort.dir==='asc'?'sort-asc':'sort-desc'
      );
      hr.append(th);
    });
    const thD=document.createElement('th');
    thD.textContent='Difference';
    hr.append(thD);
    thead.append(hr);

    // Body
    data.forEach((d,ri)=>{
      if(d.hidden) return;
      const tr=document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const td=document.createElement('td');
        td.textContent = d.vals[i]||'';
        if(i===d.maxIdx) td.classList.add('max');
        tr.append(td);
      });
      const diffVal = d.diffAll;
      const td2=document.createElement('td');
      td2.textContent = fmtDiff(diffVal);
      td2.classList.add(diffVal>=0?'diff-pos':'diff-neg');
      tr.append(td2);
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col=ci;
    const th=document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci];
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp =(!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term = document.getElementById('search').value.toLowerCase();
    const sd = document.getElementById('start').value.replace(/-/g,''), 
          ed = document.getElementById('end'  ).value.replace(/-/g,'');
    data.forEach(d=>{
      let ok=true;
      if(term) ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        ok = dateCols.some(ci=>{
          const hv = d.vals[ci];
          return (!sd||hv>=sd) && (!ed||hv<=ed);
        });
      }
      d.hidden=!ok;
    });
    renderTable();
  }

  function setAllDates(){
    if(!dateCols.length) return;
    const ds = dateCols.map(ci=>header[ci]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeCompare(idx){
    const val = (idx===0?document.getElementById('start'):document.getElementById('end')).value.replace(/-/g,'');
    cmpDates[idx]=val;
  }

  function compareDates(){
    if(!cmpDates[0]||!cmpDates[1]) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
    const ci1 = header.indexOf(cmpDates[0]);
    const ci2 = header.indexOf(cmpDates[1]);
    if(ci1<0||ci2<0) return alert('–ù–µ –Ω–∞–º–µ—Ä–∏—Ö –∫–æ–ª–æ–Ω–∞—Ç–∞ –∑–∞ –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞');
    const ei1 = ci1+1, ei2 = ci2+1;
    data.forEach(d=>{
      d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(d=>{d.hidden=false; d.diffAll=0;});
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>
</body>
</html>
EOF

echo "‚úÖ Generated \$OUT_HTML ‚Äì open it in your browser!"






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –í–≥—Ä–∞–∂–¥–∞–º–µ CSV-—Ç–æ –≤ JS template literal (escape –Ω–∞ backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { background:#fff; padding:20px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const rawCSV = \`
$CSV_CONTENT
\`;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // CSV ‚Üí –º–∞—Ç—Ä–∏—Ü–∞
    function parseCSV(txt) {
      return txt.trim().split('\\n').map(r=>r.split(','));
    }
    // HH:MM:SS ‚Üí —Å–µ–∫—É–Ω–¥–∏
    function parseElapsed(s) {
      const [h,m,x] = (s||'00:00:00').split(':').map(Number);
      return h*3600 + m*60 + x;
    }
    function formatDiff(n){ return (n>=0?'+':'') + n; }

    let header, rows, N;
    let columns = [], dateCols = [], elapsedCols = [];
    let data = [], currentSort = {col:null,dir:'asc'};

    document.addEventListener('DOMContentLoaded', () => {
      // –ü–æ–ø—Ä–∞–≤–µ–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ flatpickr:
      flatpickr('#start', { dateFormat: "Y-m-d" });
      flatpickr('#end',   { dateFormat: "Y-m-d" });

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search'     ).addEventListener('input', filterTable);
      document.getElementById('applyDates').addEventListener('click', filterTable);
      document.getElementById('allDates'   ).addEventListener('click', setAllDates);
      document.getElementById('compare'    ).addEventListener('click', compareDates);
      document.getElementById('reset'      ).addEventListener('click', resetAll);
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/date/i.test(h))    dateCols.push(i);
        if(/elapsed/i.test(h)) elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          let s=parseElapsed(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const ct = document.getElementById('toggles');
      ct.innerHTML = '';
      columns.forEach((col,i)=>{
        const lbl = document.createElement('label');
        const cb  = document.createElement('input');
        cb.type='checkbox'; cb.checked = !col.hidden;
        cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        ct.append(lbl);
      });
    }

    function renderTable(){
      const thead = document.getElementById('thead');
      const tbody = document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // HEADER
      const hr = document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const th=document.createElement('th');
        th.textContent=c.name;
        th.onclick = ()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // BODY
      data.forEach((row,ri)=>{
        if(row.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((c,i)=>{
          if(c.hidden) return;
          const td=document.createElement('td');
          td.textContent = row.vals[i]||'';
          if(elapsedCols.includes(i)&&row.maxIdx===i) td.classList.add('max');
          tr.append(td);
        });
        const d = parseElapsed(row.vals[elapsedCols.at(-1)]) - parseElapsed(row.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=formatDiff(d);
        td2.classList.add(d>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function filterTable(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd  =document.getElementById('start').value;
      const ed  =document.getElementById('end').value;
      data.forEach(r=>{
        let ok=true;
        if(term) ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const d=(r.vals[ci]||'').split('T')[0];
            return (!sd||d>=sd) && (!ed||d<=ed);
          });
        }
        r.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds = dateCols.map(ci=>header[ci]).sort();
      document.getElementById('start').value=ds[0];
      document.getElementById('end'  ).value=ds.at(-1);
      filterTable();
    }

    function compareDates(){
      const sd=document.getElementById('start').value;
      const ed=document.getElementById('end').value;
      if(!sd||!ed) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
      const ci1 = header.indexOf(sd);
      const ci2 = header.indexOf(ed);
      if(ci1<0||ci2<0) return alert('–ù—è–º–∞ –∫–æ–ª–æ–Ω–∞ —Å —Ç–∞–∫–∞–≤–∞ –¥–∞—Ç–∞');
      const ei1 = ci1+1, ei2 = ci2+1; 
      data.forEach(r=>{
        const v1=parseElapsed(r.vals[ei1]);
        const v2=parseElapsed(r.vals[ei2]);
        r.diffAll = v2 - v1;
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(r=>{r.hidden=false; r.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –¥–≤–æ–π–Ω–æ –∫–ª–∏–∫ –≤ –±—Ä–∞—É–∑—ä—Ä!"




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# –ï—Å–∫–µ–π–ø–≤–∞–º–µ backticks, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS-template
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; background:#fff; padding:20px; border-radius:6px;
                 box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    .table-wrap { background:#fff; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶" />
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <div class="table-wrap">
      <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ CSV
  function parseCSV(txt) {
    return txt.trim().split('\\n').map(r => r.split(','));
  }
  function parseElapsed(s) {
    const [h,m,sec] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + sec;
  }
  function formatDiff(n) { return (n>=0?'+':'') + n; }

  // –ì–ª–æ–±–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ
  let header, rows, N;
  let columns = [], dateCols = [], elapsedCols = [];
  let data = [], currentSort = { col:null, dir:'asc' };

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  document.addEventListener('DOMContentLoaded', () => {
    flatpickr('#start,{ dateFormat:"Y-m-d" }');
    flatpickr('#end',  { dateFormat:"Y-m-d" });

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('applyDates').addEventListener('click', filterTable);
    document.getElementById('allDates').addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset').addEventListener('click', resetAll);
  });

  function initData() {
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4) / 2;

    // –î–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∏
    header.forEach((h,i) => {
      columns.push({ name:h, hidden:false });
      if (/date/i.test(h))    dateCols.push(i);
      if (/elapsed/i.test(h)) elapsedCols.push(i);
    });

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data[] –æ–±–µ–∫—Ç–∏
    data = rows.map(r => {
      let maxIdx = elapsedCols[0], maxSec = -1;
      elapsedCols.forEach(ci => {
        const s = parseElapsed(r[ci]);
        if (s>maxSec) { maxSec = s; maxIdx = ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles() {
    const ctr = document.getElementById('toggles');
    ctr.innerHTML = '';
    columns.forEach((col,i) => {
      const lbl = document.createElement('label');
      const cb  = document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{
        col.hidden = !cb.checked;
        renderTable();
      };
      lbl.append(cb,' ',col.name);
      ctr.append(lbl);
    });
  }

  function renderTable() {
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    thead.innerHTML = ''; tbody.innerHTML = '';

    // HEADER
    const hr = document.createElement('tr');
    columns.forEach((col,i) => {
      if (col.hidden) return;
      const th = document.createElement('th');
      th.textContent = col.name;
      th.onclick = ()=>sortBy(i);
      if (currentSort.col===i)
        th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    const thD = document.createElement('th');
    thD.textContent = 'Difference';
    hr.append(thD);
    thead.append(hr);

    // BODY
    data.forEach(row=>{
      if (row.hidden) return;
      const tr = document.createElement('tr');
      columns.forEach((col,i)=>{
        if (col.hidden) return;
        const td = document.createElement('td');
        td.textContent = row.vals[i]||'';
        if (elapsedCols.includes(i) && row.maxIdx===i)
          td.classList.add('max');
        tr.append(td);
      });
      // Difference = lastElapsed - firstElapsed
      const d = parseElapsed(row.vals[ elapsedCols[elapsedCols.length-1] ]) -
                parseElapsed(row.vals[ elapsedCols[0] ]);
      const td2 = document.createElement('td');
      td2.textContent = formatDiff(d);
      if (d>0) td2.classList.add('diff-pos');
      if (d<0) td2.classList.add('diff-neg');
      tr.append(td2);

      tbody.append(tr);
    });
  }

  function sortBy(ci) {
    // clear classes
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    // toggle dir
    if (currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col = ci;
    // mark header
    const th = document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    // sort data
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci], cmp;
      const nA=parseFloat(A), nB=parseFloat(B);
      if (!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
      else cmp=A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable() {
    const term = document.getElementById('search').value.toLowerCase();
    const sd   = document.getElementById('start').value;
    const ed   = document.getElementById('end').value;
    data.forEach(r=>{
      let ok = true;
      if (term) {
        ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      }
      if (ok && (sd||ed)) {
        ok = dateCols.some(ci=>{
          const d = (r.vals[ci]||'').split('T')[0];
          return (!sd||d>=sd) && (!ed||d<=ed);
        });
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function setAllDates() {
    if (!dateCols.length) return;
    // –ò–∑–≤–ª–∏—á–∞–º–µ header –¥–∞—Ç–∏—Ç–µ
    const dates = dateCols.map(ci=>header[ci]).sort();
    document.getElementById('start').value = dates[0];
    document.getElementById('end').value   = dates[dates.length-1];
    filterTable();
  }

  function compareDates() {
    const sd = document.getElementById('start').value;
    const ed = document.getElementById('end').value;
    if (!sd||!ed) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
    // –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∏—Ç–µ –ø–æ header
    const ci1 = header.findIndex(h=>h===sd);
    const ci2 = header.findIndex(h=>h===ed);
    if (ci1<0||ci2<0) return alert('–î–∞—Ç–∞ –Ω–µ –Ω–∞–º–µ—Ä–µ–Ω–∞ –≤ –∫–æ–ª–æ–Ω–∏');
    // —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ Elapsed —Å—Ç—ä–ª–±–æ–≤–µ—Ç–µ (—Å–ª–µ–¥ –≤—Å—è–∫–∞ date –∫–æ–ª–æ–Ω–∞)
    const ei1 = dateCols.indexOf(ci1)>=0 ? dateCols.indexOf(ci1)+1 : ci1+1;
    const ei2 = dateCols.indexOf(ci2)>=0 ? dateCols.indexOf(ci2)+1 : ci2+1;
    data.forEach(r=>{
      const v1=parseElapsed(r.vals[ei1]);
      const v2=parseElapsed(r.vals[ei2]);
      r.diffAll = v2 - v1;
    });
    renderTable();
  }

  function resetAll() {
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# Escape –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS
CSV_ESCAPED=$(sed 's/"/\\"/g' "$CSV")

cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Advanced Report</title>
<style>
  body { font-family:sans-serif; padding:20px; background:#f4f4f4; }
  .controls { margin-bottom:15px; display:flex; flex-wrap:wrap; gap:10px; }
  .controls input, .controls button { padding:6px 10px; }
  .columns-toggle { margin-bottom:15px; }
  .columns-toggle label { margin-right:8px; }
  .table-wrap { overflow-x:auto; background:#fff; padding:10px; border:1px solid #ccc; }
  table { border-collapse:collapse; width:100%; }
  th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
  th { background:#eee; cursor:pointer; position:relative; user-select:none; }
  th.sort-asc::after  { content:" ‚Üë"; }
  th.sort-desc::after { content:" ‚Üì"; }
  td.max { background:#fff9c4; }
  .hidden { display:none; }
  .diff-pos { background:#e6f4ea; }
  .diff-neg { background:#fce8e6; }
</style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search‚Ä¶" />
  <input id="start" type="date" />
  <input id="end"   type="date" />
  <button id="applyDates">Apply Date Filter</button>
  <button id="compare">Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<div class="table-wrap">
  <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
</div>

<script>
// –í–≥—Ä–∞–¥–µ–Ω–æ CSV
const rawCSV = \`
$CSV_ESCAPED
\`.trim();

// –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ CSV –≤ –º–∞—Å–∏–≤ –æ—Ç –º–∞—Å–∏–≤–∏
function parseCSV(txt) {
  return txt.split('\\n').map(r => r.split(','));
}

let header, rows, N;
let columns;    // {name,hidden}[]
let dateCols;   // –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ date –∫–æ–ª–æ–Ω–∏
let elapsedCols;// –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ elapsed –∫–æ–ª–æ–Ω–∏
let data;       // {vals,hidden,maxIdx,diff:{}}[]

const thead = document.getElementById('thead');
const tbody = document.getElementById('tbody');
const toggles= document.getElementById('toggles');

function init() {
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;
  N = (header.length - 4)/2;

  // –ö–æ–ª–æ–Ω–∏
  columns = header.map((h,i) => ({
    name: h, hidden: false
  }));
  dateCols    = header.map((h,i)=>/date/i.test(h)?i:-1).filter(i=>i>=0);
  elapsedCols = header.map((h,i)=>/elapsed/i.test(h)?i:-1).filter(i=>i>=0);

  // –î–∞–Ω–Ω–∏
  data = rows.map(r => {
    let maxIdx=elapsedCols[0], maxSec=-1;
    elapsedCols.forEach(ci=>{
      const [h,m,s] = (r[ci]||'00:00:00').split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      if(sec>maxSec){ maxSec=sec; maxIdx=ci; }
    });
    return { vals:r.slice(), hidden:false, maxIdx, diff:{} };
  });

  buildToggles();
  render();
}

// –°—ä–∑–¥–∞–≤–∞ —á–µ–∫–±–æ–∫—Å–æ–≤–µ –∑–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ/–ø–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –∫–æ–ª–æ–Ω–∏
function buildToggles(){
  toggles.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{
      col.hidden = !cb.checked;
      render();
    };
    lbl.append(cb, ' ', col.name);
    toggles.append(lbl);
  });
}

// –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
function render(){
  // Header
  thead.innerHTML = '';
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    hr.append(th);
  });
  const tdiff = document.createElement('th');
  tdiff.textContent = 'Difference';
  hr.append(tdiff);
  thead.append(hr);

  // Body
  tbody.innerHTML = '';
  data.forEach((row,ri)=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,ci)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      td.textContent = row.vals[ci]||'';
      if(elapsedCols.includes(ci) && row.maxIdx===ci) td.classList.add('max');
      // —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      if(row.diff[ci]!=null){
        td.classList.add(row.diff[ci]>=0? 'diff-pos':'diff-neg');
        td.textContent += ' '+row.diff[ci];
      }
      tr.append(td);
    });
    // difference col = lastElapsed-firstElapsed
    const diffAll = elapsedCols.reduce((acc,ci)=>acc + (row.diff[ci]||0), 0);
    const td2 = document.createElement('td');
    td2.textContent = formatDiff(diffAll);
    tr.append(td2);

    tbody.append(tr);
  });
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞ —Ä–∞–∑–ª–∏–∫–∞ —Å–µ–∫—É–Ω–¥–∏ -> +X
function formatDiff(d){ return (d>=0?'+':'')+d; }

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
function sortBy(ci){
  const dir = thead.querySelectorAll('th')[ci].classList.toggle('sort-asc')
             ? 'asc':'desc';
  thead.querySelectorAll('th').forEach((th,i)=>i!==ci && th.classList.remove('sort-asc','sort-desc'));
  if(dir==='desc') thead.querySelectorAll('th')[ci].classList.add('sort-desc');
  data.sort((a,b)=>{
    let A=a.vals[ci], B=b.vals[ci], res=0;
    const nA=parseFloat(A), nB=parseFloat(B);
    if(!isNaN(nA) && !isNaN(nB)) res=nA-nB;
    else res= A.localeCompare(B);
    return dir==='asc'? res : -res;
  });
  render();
}

// –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ
function filter(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value;
  const ed   = document.getElementById('end').value;
  data.forEach(r=>{
    let ok=true;
    if(term){
      ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    }
    if(ok && (sd||ed)){
      ok = dateCols.some(ci=>{
        const d = (r.vals[ci]||'').split('T')[0];
        return (!sd||d>=sd) && (!ed||d<=ed);
      });
    }
    r.hidden = !ok;
  });
  render();
}

// –ó–∞–ø–∞–º–µ—Ç—è–≤–∞ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
let cmpIdx = [];
function pickCompare(){
  const sd = document.getElementById('start').value;
  const ed = document.getElementById('end').value;
  if(sd){
    cmpIdx[0] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(sd));
  }
  if(ed){
    cmpIdx[1] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(ed));
  }
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ
function compare(){
  if(cmpIdx.length<2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
  data.forEach(r=>{
    elapsedCols.forEach(ci=>{
      const v1=parseElapsed(data[cmpIdx[0]].vals[ci]);
      const v2=parseElapsed(data[cmpIdx[1]].vals[ci]);
      r.diff[ci] = v2 - v1;
    });
  });
  render();
}

// –ü–∞—Ä—Å–≤–∞–Ω–µ HH:MM:SS -> —Å–µ–∫—É–Ω–¥–∏
function parseElapsed(s){
  const [h,m,x]= (s||'00:00:00').split(':').map(Number);
  return h*3600+m*60+x;
}

// Reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diff={}; });
  cmpIdx=[];
  init();
}

document.getElementById('search').addEventListener('input',filter);
document.getElementById('applyDates').addEventListener('click',filter);
document.getElementById('compare').addEventListener('click',compare);
document.getElementById('reset').addEventListener('click',resetAll);
document.getElementById('start').addEventListener('change',pickCompare);
document.getElementById('end'  ).addEventListener('change',pickCompare);

init();
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT"






#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –Ω–∞–ª–∏—á–µ–Ω CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV_INPUT' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# –í–≥—Ä–∞–∂–¥–∞–Ω–µ –Ω–∞ CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ (escape –Ω–∞ backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    :root {
      --primary-color: #4285f4;
      --secondary-color: #f1f3f4;
      --hover-color: #e8f0fe;
      --border-color: #dadce0;
      --text-color: #202124;
      --light-text: #5f6368;
      --max-highlight: #fff9c4;
      --diff-positive: #e6f4ea;
      --diff-negative: #fce8e6;
    }
    body {
      font-family: 'Roboto',sans-serif; margin:0; padding:20px; background:#f8f9fa; color:var(--text-color);
    }
    .container {
      background:#fff; border-radius:8px; box-shadow:0 1px 2px rgba(0,0,0,0.1); padding:20px;
    }
    h1 { color:var(--primary-color); font-weight:500; margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:20px; align-items:center }
    .controls input, .controls button { padding:8px 12px; border:1px solid var(--border-color); border-radius:4px; font-family:inherit }
    .controls button { background:var(--primary-color); color:#fff; cursor:pointer; }
    .controls button:hover { background:#3367d6; }
    .table-container { overflow-x:auto; border:1px solid var(--border-color); border-radius:4px }
    table { width:100%; border-collapse:collapse; }
    th,td { padding:12px 15px; text-align:left; border-bottom:1px solid var(--border-color) }
    th { background:var(--secondary-color); color:var(--light-text); position:relative; cursor:pointer }
    tr:hover { background:var(--hover-color) }
    th.sort-asc::after { content:" ‚Üë"; color:var(--primary-color) }
    th.sort-desc::after { content:" ‚Üì"; color:var(--primary-color) }
    td.max { background:var(--max-highlight); font-weight:500 }
    .column-toggle { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:15px }
    .column-toggle label { display:flex; align-items:center; gap:5px; cursor:pointer; font-size:13px; background:var(--secondary-color); padding:5px 8px; border-radius:4px }
    .hidden { display:none!important }
    .diff-positive { background:var(--diff-positive) }
    .diff-negative { background:var(--diff-negative) }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Report</h1>
    <div class="controls">
      <input type="text" id="search" placeholder="Search across all columns..."/>
      <input type="text" id="start-date" class="date-picker" placeholder="From date"/>
      <input type="text" id="end-date" class="date-picker" placeholder="To date"/>
      <button id="apply-dates">Apply</button>
      <button id="compare-dates">Compare Dates</button>
      <button id="reset-all">Reset All</button>
    </div>
    <div class="column-toggle" id="column-toggle-container"></div>
    <div class="table-container">
      <table id="data-table"><thead></thead><tbody></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

  <script>
    // –í–≥—Ä–∞–¥–µ–Ω–æ CSV
    const csvData = \`
$CSV_CONTENT
\`;

    // –ü–æ–º–æ—â–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏
    function parseCSV(text) {
      return text.trim().split('\n').map(r=>r.split(','));
    }
    function parseElapsed(s) {
      const [h,m,sec]=s.split(':').map(Number);
      return h*3600+m*60+sec;
    }
    function formatElapsed(sec) {
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return \`\${String(h).padStart(2,'0')}:\${String(m).padStart(2,'0')}:\${String(s).padStart(2,'0')}\`;
    }

    // –ì–ª–æ–±–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ
    let columns = [], dateCols = [], elapsedCols = [];
    let allData = [], isComparing=false, compareIdx=[];

    // –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    \$(document).ready(function(){
      flatpickr('.date-picker',{dateFormat:'Y-m-d',allowInput:true});
      const rows = parseCSV(csvData);
      const header = rows.shift();
      const N = (header.length-4)/2;
      // –ö–æ–ª–æ–Ω–∏
      header.forEach((h,i)=>{
        const isDate = /date/i.test(h);
        const isElapsed = /elapsed/i.test(h);
        columns.push({name:h,hidden:false});
        if(isDate) dateCols.push(i);
        if(isElapsed) elapsedCols.push(i);
      });
      // –î–∞–Ω–Ω–∏
      rows.forEach(r=>{
        let maxIdx=elapsedCols[0], maxVal=-1;
        r.forEach((v,i)=> {
          if(elapsedCols.includes(i) && v){
            const secs=parseElapsed(v);
            if(secs>maxVal){ maxVal=secs; maxIdx=i; }
          }
        });
        allData.push({values:r,hidden:false,maxIdx,diff:{}}); 
      });
      initToggles();
      renderTable();
      // Events
      \$('#search').on('input',filterData);
      \$('#apply-dates').click(filterData);
      \$('#compare-dates').click(doCompare);
      \$('#reset-all').click(resetAll);
      \$('#start-date, #end-date').change(storeCompareIdx);
    });

    function initToggles(){
      const ct=\$('#column-toggle-container').empty();
      columns.forEach((col,i)=>{
        const chk=\$('<input type="checkbox">').prop('checked',!col.hidden)
          .change(_=>{col.hidden=!chk.prop('checked');renderTable();});
        ct.append(\$('<label>').append(chk,document.createTextNode(col.name)));
      });
    }

    function renderTable(){
      const tbl=\$('#data-table');
      const thead=tbl.find('thead').empty().append('<tr>');
      const tbody=tbl.find('tbody').empty();
      // Header + Difference
      columns.forEach((c,i)=>!c.hidden&& thead.append(\`<th data-col="\${i}">\${c.name}</th>\`));
      thead.append('<th>Difference</th>');
      thead.find('th').click(function(){
        sortBy(+this.dataset.col);
      });
      // Body
      allData.forEach(r=>{
        if(r.hidden) return;
        const tr=\$('<tr>');
        columns.forEach((c,i)=> {
          if(c.hidden) return;
          const v=r.values[i];
          const td=\$('<td>').text(v);
          if(elapsedCols.includes(i)&&i===r.maxIdx) td.addClass('max');
          if(isComparing && r.diff[i]!=null){
            td.addClass(r.diff[i]>=0?'diff-positive':'diff-negative')
              .append(' '+(r.diff[i]>=0?'+':'')+r.diff[i]);
          }
          tr.append(td);
        });
        // difference col
        const dsum = elapsedCols.reduce((acc,i)=>acc+(r.diff[i]||0),0);
        tr.append(\`<td>\${formatElapsed(dsum)}</td>\`);
        tbody.append(tr);
      });
      // DataTable
      tbl.DataTable({destroy:true,paging:false,scrollX:true,searching:true,dom:'Bfrtip',buttons:['colvis'],order:[]});
    }

    function sortBy(col){
      allData.sort((a,b)=>{
        const A=a.values[col], B=b.values[col];
        const nA=parseFloat(A),nB=parseFloat(B);
        let cmp=0;
        if(!isNaN(nA)&&!isNaN(nB)){ cmp=nA-nB; }
        else { cmp=A.localeCompare(B); }
        return cmp;
      });
      renderTable();
    }

    function filterData(){
      const term=\$('#search').val().toLowerCase();
      const sD=\$('#start-date').val(), eD=\$('#end-date').val();
      allData.forEach(r=>{
        const bySearch=term? r.values.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term)) : true;
        const byDate=(sD||eD)? dateCols.some(i=>{
          const d=r.values[i]; if(!d) return false;
          const dd=d.split('T')[0];
          return (!sD||dd>=sD)&&(!eD||dd<=eD);
        }):true;
        r.hidden=!(bySearch&&byDate);
      });
      renderTable();
    }

    function storeCompareIdx(){
      const dval=this.value;
      if(!dval) return;
      const col=dateCols[0];
      const idx=allData.findIndex(r=>r.values[col].startsWith(dval));
      if(this.id==='start-date') compareIdx[0]=idx;
      else compareIdx[1]=idx;
    }

    function doCompare(){
      if(compareIdx.length<2||compareIdx[0]==null||compareIdx[1]==null){
        alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏!');
        return;
      }
      allData.forEach(r=>{
        r.diff={};
        elapsedCols.forEach(i=>{
          const v1=parseElapsed(allData[compareIdx[0]].values[i]);
          const v2=parseElapsed(allData[compareIdx[1]].values[i]);
          r.diff[i]=v2-v1;
        });
      });
      isComparing=true;
      renderTable();
    }

    function resetAll(){
      \$('#search,#start-date,#end-date').val('');
      columns.forEach(c=>c.hidden=false);
      allData.forEach(r=>{r.hidden=false; r.diff={}}); 
      isComparing=false; compareIdx=[];
      initToggles();
      renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –ß–µ—Ç–µ–º —Ü—è–ª–æ—Ç–æ CSV –≤ –µ–¥–Ω–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ (escape –Ω–∞ backticks —Å–∞–º–æ)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    /* ...—Ç–≤–æ—è CSS –æ—Ç –ø—Ä–∏–º–µ—Ä–∞... */
    .dataTables_scrollBody { overflow-x:auto!important; }
    td.max { background: var(--max-highlight) !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  <!-- ... —Ç–≤–æ—è HTML –∑–∞ controls, toggles –∏ —Ç.–Ω. ... -->
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ‚îÄ‚îÄ‚îÄ –í–ì–†–ê–î–ï–ù–û CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const csvData = \`
$CSV_CONTENT
\`;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function parseCSV(text){
  return text.trim().split('\\n').map(r => r.split(','));
}

$(function(){
  const header = parseCSV(csvData).shift();
  const data   = parseCSV(csvData).slice(1);
  const N      = (header.length - 4) / 2;

  // ‚Ä¶ —Ç—É–∫ –ø—ä–ª–Ω–∏—à columns[], dateColumns[], elapsedColumns[] –∫–∞–∫—Ç–æ –ø—Ä–µ–¥–∏ ‚Ä¶

  // –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + Difference
  const thead = $('#data-table thead tr');
  header.forEach(h => thead.append('<th>' + h + '</th>'));
  thead.append('<th>Difference</th>');

  // –†–µ–Ω–¥–µ—Ä –Ω–∞ body
  data.forEach(row => {
    // ‚Ä¶ —Å—ä—â–∞—Ç–∞ –ª–æ–≥–∏–∫–∞ –∑–∞ –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ maxIdx –∏ diffStr ‚Ä¶
    const tr = $('<tr>');
    // –ø—ä—Ä–≤–∏—Ç–µ 4 –ø–æ–ª–∏
    row.slice(0,4).forEach(v => tr.append('<td>'+v+'</td>'));
    // date/elapsed –¥–≤–æ–π–∫–∏ + highlight
    for(let j=0;j<N;j++){
      tr.append('<td>'+row[4+2*j]+'</td>');
      const cls = (j===maxIdx?'max':'');
      tr.append('<td class="'+cls+'">'+row[4+2*j+1]+'</td>');
    }
    tr.append('<td>'+diffStr+'</td>');
    $('#data-table tbody').append(tr);
  });

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ DataTable
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging:   false,
    scrollX:  true,
    searching:true,
    buttons: ['colvis'],
    order:   [],
    columnDefs:[{ targets:[0], orderable:false }]
  });
});
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML —Å –º–æ–¥–µ—Ä–µ–Ω –¥–∏–∑–∞–π–Ω –∏ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç–∏
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Report</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --primary-color: #4285f4;
    --secondary-color: #f1f3f4;
    --hover-color: #e8f0fe;
    --border-color: #dadce0;
    --text-color: #202124;
    --light-text: #5f6368;
    --max-highlight: #fff9c4;
    --diff-positive: #e6f4ea;
    --diff-negative: #fce8e6;
  }
  
  body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 20px;
    color: var(--text-color);
    background-color: #f8f9fa;
  }
  
  .container {
    max-width: 100%;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    padding: 20px;
  }
  
  h1 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 500;
  }
  
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    align-items: center;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--secondary-color);
    padding: 8px 12px;
    border-radius: 4px;
  }
  
  label {
    font-size: 14px;
    color: var(--light-text);
  }
  
  input, button, select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: inherit;
  }
  
  button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background-color: #3367d6;
  }
  
  #search {
    flex-grow: 1;
    min-width: 200px;
  }
  
  .table-container {
    overflow-x: auto;
    margin-top: 20px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }
  
  th {
    background-color: var(--secondary-color);
    color: var(--light-text);
    font-weight: 500;
    position: relative;
    cursor: pointer;
    user-select: none;
  }
  
  th:hover {
    background-color: var(--hover-color);
  }
  
  th.sort-asc::after {
    content: " ‚Üë";
    color: var(--primary-color);
  }
  
  th.sort-desc::after {
    content: " ‚Üì";
    color: var(--primary-color);
  }
  
  tr:hover {
    background-color: var(--hover-color);
  }
  
  .max {
    background-color: var(--max-highlight);
    font-weight: 500;
  }
  
  .column-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 15px;
  }
  
  .column-toggle label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    padding: 5px 8px;
    background: var(--secondary-color);
    border-radius: 4px;
  }
  
  .hidden {
    display: none !important;
  }
  
  .date-range {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .date-range input {
    width: 150px;
  }
  
  .diff-positive {
    background-color: var(--diff-positive);
  }
  
  .diff-negative {
    background-color: var(--diff-negative);
  }
  
  @media (max-width: 768px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
    
    #search {
      width: 100%;
    }
  }
</style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  
  <div class="controls">
    <input type="text" id="search" placeholder="Search across all columns...">
    
    <div class="control-group date-range">
      <label for="start-date">From:</label>
      <input type="text" id="start-date" class="date-picker" placeholder="Start date">
      <label for="end-date">To:</label>
      <input type="text" id="end-date" class="date-picker" placeholder="End date">
      <button id="apply-dates">Apply</button>
    </div>
    
    <button id="compare-dates">Compare Dates</button>
    <button id="reset-all">Reset All</button>
  </div>
  
  <div class="column-toggle" id="column-toggle-container">
    <!-- Column toggles will be inserted here by JavaScript -->
  </div>
  
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
// –ì–ª–æ–±–∞–ª–Ω–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –∑–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
let allData = [];
let columns = [];
let dateColumns = [];
let elapsedColumns = [];
let currentSort = { column: null, direction: 'asc' };
let isComparing = false;
let comparedDateIndices = [];

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–∏—Ç–µ
flatpickr(".date-picker", {
  dateFormat: "Y-m-d",
  allowInput: true
});

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç CSV —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –≤ HTML
function loadData() {
  const table = document.getElementById('data-table');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  // –ò–∑—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ —Ç–µ–∫—É—â–∏—Ç–µ –¥–∞–Ω–Ω–∏
  thead.innerHTML = '';
  tbody.innerHTML = '';
  
  // –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
  const headerRow = document.createElement('tr');
  columns.forEach((col, index) => {
    if (col.hidden) return;
    
    const th = document.createElement('th');
    th.textContent = col.name;
    th.dataset.columnIndex = index;
    th.addEventListener('click', () => sortData(index));
    
    if (currentSort.column === index) {
      th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  
  // –ü–æ–ø—ä–ª–≤–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
  allData.forEach(row => {
    if (row.hidden) return;
    
    const tr = document.createElement('tr');
    columns.forEach((col, colIndex) => {
      if (col.hidden) return;
      
      const td = document.createElement('td');
      td.textContent = row.values[colIndex];
      
      // –ú–∞—Ä–∫–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –≤ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
      if (elapsedColumns.includes(colIndex) && row.maxElapsedIndex === colIndex) {
        td.classList.add('max');
      }
      
      // –ú–∞—Ä–∫–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∏—Ç–µ –ø—Ä–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
      if (isComparing && row.diffValues && row.diffValues[colIndex] !== undefined) {
        const diff = row.diffValues[colIndex];
        if (diff > 0) {
          td.classList.add('diff-positive');
          td.textContent += ` (+${diff})`;
        } else if (diff < 0) {
          td.classList.add('diff-negative');
          td.textContent += ` (${diff})`;
        }
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
function sortData(columnIndex) {
  if (currentSort.column === columnIndex) {
    // –ü—Ä–æ–º—è–Ω–∞ –Ω–∞ –ø–æ—Å–æ–∫–∞—Ç–∞, –∞–∫–æ –≤–µ—á–µ —Å–º–µ —Å–æ—Ä—Ç–∏—Ä–∞–ª–∏ –ø–æ —Ç–∞–∑–∏ –∫–æ–ª–æ–Ω–∞
    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
  } else {
    // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø–æ –Ω–æ–≤–∞ –∫–æ–ª–æ–Ω–∞ –≤—ä–≤ –≤—ä–∑—Ö–æ–¥—è—â —Ä–µ–¥
    currentSort.column = columnIndex;
    currentSort.direction = 'asc';
  }
  
  allData.sort((a, b) => {
    const valA = a.values[columnIndex];
    const valB = b.values[columnIndex];
    
    // –û–ø–∏—Ç –∑–∞ —Ä–∞–∑–ø–æ–∑–Ω–∞–≤–∞–Ω–µ –Ω–∞ —á–∏—Å–ª–∞ –∏ –¥–∞—Ç–∏
    const numA = parseFloat(valA);
    const numB = parseFloat(valB);
    const dateA = new Date(valA);
    const dateB = new Date(valB);
    
    let comparison = 0;
    
    if (!isNaN(numA) {
      // –ß–∏—Å–ª–µ–Ω–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      comparison = numA - numB;
    } else if (dateA instanceof Date && !isNaN(dateA) {
      // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
      comparison = dateA - dateB;
    } else {
      // –¢–µ–∫—Å—Ç–æ–≤–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      comparison = valA.localeCompare(valB);
    }
    
    return currentSort.direction === 'asc' ? comparison : -comparison;
  });
  
  loadData();
}

// –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
function filterData() {
  const searchTerm = document.getElementById('search').value.toLowerCase();
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  
  allData.forEach(row => {
    let matchesSearch = true;
    let matchesDate = true;
    
    // –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø–æ —Ç—ä—Ä—Å–µ–Ω–µ
    if (searchTerm) {
      matchesSearch = columns.some((col, index) => {
        if (col.hidden) return false;
        return row.values[index].toLowerCase().includes(searchTerm);
      });
    }
    
    // –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø–æ –¥–∞—Ç–∏
    if (startDate || endDate) {
      matchesDate = dateColumns.some(dateCol => {
        const dateStr = row.values[dateCol];
        if (!dateStr) return false;
        
        const rowDate = new Date(dateStr);
        if (isNaN(rowDate)) return false;
        
        const compareDate = rowDate.toISOString().split('T')[0];
        
        if (startDate && endDate) {
          return compareDate >= startDate && compareDate <= endDate;
        } else if (startDate) {
          return compareDate >= startDate;
        } else if (endDate) {
          return compareDate <= endDate;
        }
        return true;
      });
    }
    
    row.hidden = !(matchesSearch && matchesDate);
  });
  
  loadData();
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
function compareDates() {
  if (comparedDateIndices.length < 2) {
    alert('Please select two different dates first by using the date filters.');
    return;
  }
  
  const [firstIndex, secondIndex] = comparedDateIndices;
  const firstRow = allData[firstIndex];
  const secondRow = allData[secondIndex];
  
  allData.forEach(row => {
    row.diffValues = [];
    
    columns.forEach((col, colIndex) => {
      if (elapsedColumns.includes(colIndex)) {
        // –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –∑–∞ Elapsed –≤—Ä–µ–º–µ—Ç–æ
        const time1 = parseElapsedTime(firstRow.values[colIndex]);
        const time2 = parseElapsedTime(secondRow.values[colIndex]);
        row.diffValues[colIndex] = time2 - time1;
      } else if (!isNaN(parseFloat(row.values[colIndex]))) {
        // –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –∑–∞ —á–∏—Å–ª–æ–≤–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
        const num1 = parseFloat(firstRow.values[colIndex]);
        const num2 = parseFloat(secondRow.values[colIndex]);
        row.diffValues[colIndex] = num2 - num1;
      }
    });
  });
  
  isComparing = true;
  loadData();
}

// –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ Elapsed –≤—Ä–µ–º–µ –≤—ä–≤ —Å–µ–∫—É–Ω–¥–∏
function parseElapsedTime(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
  }
  return 0;
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–µ–∫—É–Ω–¥–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç HH:MM:SS
function formatElapsedTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ –∑–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ/–ø–æ–∫–∞–∑–≤–∞–Ω–µ
function initColumnToggles() {
  const container = document.getElementById('column-toggle-container');
  container.innerHTML = '';
  
  columns.forEach((col, index) => {
    const checkboxId = `col-toggle-${index}`;
    const label = document.createElement('label');
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.checked = !col.hidden;
    checkbox.addEventListener('change', () => {
      col.hidden = !checkbox.checked;
      loadData();
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(col.name));
    container.appendChild(label);
  });
}

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ
function parseCSV(csv) {
  const lines = csv.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ
  columns = headers.map((header, index) => {
    const isDate = header.toLowerCase().includes('date');
    const isElapsed = header.toLowerCase().includes('elapsed');
    
    if (isDate) dateColumns.push(index);
    if (isElapsed) elapsedColumns.push(index);
    
    return {
      name: header,
      hidden: false,
      isDate,
      isElapsed
    };
  });
  
  // –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
  allData = lines.slice(1).map(line => {
    const values = line.split(',');
    let maxElapsedIndex = -1;
    let maxElapsed = -1;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ Elapsed –≤—Ä–µ–º–µ
    elapsedColumns.forEach(colIndex => {
      if (values[colIndex]) {
        const seconds = parseElapsedTime(values[colIndex]);
        if (seconds > maxElapsed) {
          maxElapsed = seconds;
          maxElapsedIndex = colIndex;
        }
      }
    });
    
    return {
      values,
      hidden: false,
      maxElapsedIndex,
      diffValues: null
    };
  });
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ UI –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ
  initColumnToggles();
  loadData();
}

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ CSV —Ñ–∞–π–ª–∞
function loadCSV() {
  return fetch(window.location.href)
    .then(response => response.text())
    .then(csv => {
      // –ü—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –Ω–∞ BOM —Å–∏–º–≤–æ–ª–∞, –∞–∫–æ –∏–º–∞ —Ç–∞–∫—ä–≤
      if (csv.charCodeAt(0) === 0xFEFF) {
        csv = csv.substring(1);
      }
      parseCSV(csv);
    })
    .catch(error => {
      console.error('Error loading CSV:', error);
      alert('Error loading CSV data. Please check console for details.');
    });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ event listeners
function initEventListeners() {
  document.getElementById('search').addEventListener('input', filterData);
  document.getElementById('apply-dates').addEventListener('click', filterData);
  document.getElementById('compare-dates').addEventListener('click', compareDates);
  
  document.getElementById('reset-all').addEventListener('click', () => {
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ–∏–ª—Ç—Ä–∏
    document.getElementById('search').value = '';
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–∫—Ä–∏—Ç–∏—Ç–µ –∫–æ–ª–æ–Ω–∏
    columns.forEach(col => col.hidden = false);
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ—Ç–æ
    isComparing = false;
    comparedDateIndices = [];
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ
    currentSort = { column: null, direction: 'asc' };
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Ä–µ–¥–æ–≤–µ
    allData.forEach(row => row.hidden = false);
    
    // –ü—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ UI
    initColumnToggles();
    filterData();
  });
  
  // –ó–∞–ø–∞–∑–≤–∞–Ω–µ –Ω–∞ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–∞—Ç–∏
  document.getElementById('start-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø—ä—Ä–≤–∏—è —Ä–µ–¥, –∫–æ–π—Ç–æ —Å—ä–≤–ø–∞–¥–∞ —Å –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[0] = index;
    }
  });
  
  document.getElementById('end-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø—ä—Ä–≤–∏—è —Ä–µ–¥, –∫–æ–π—Ç–æ —Å—ä–≤–ø–∞–¥–∞ —Å –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[1] = index;
    }
  });
}

// –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
document.addEventListener('DOMContentLoaded', () => {
  initEventListeners();
  loadCSV();
});
</script>
</body>
</html>
EOF

# –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ HTML –∫–∞—Ç–æ JavaScript –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞
echo "<script>" >> "$OUT"
echo "// CSV data" >> "$OUT"
echo "const csvData = \`" >> "$OUT"
cat "$CSV" >> "$OUT"
echo "\`;" >> "$OUT"
echo "// End of CSV data" >> "$OUT"
echo "</script>" >> "$OUT"

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ó–∞–ø–∏—Å–≤–∞–º–µ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ <table> —Å –æ—Ü–≤–µ—Ç—è–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º—É–º–∞ –∏ –∫–ª–∏–∫–∞–µ–º–∏ <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # –ø—Ä–∞–≤–∏–º –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å–æ—Ä—Ç–∏—Ä–∞—â –±—É—Ç–æ–Ω
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –º–∞—Ä–∫–∏—Ä–∞–º–µ class="max" —Å–∞–º–æ –Ω–∞ maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
cat >>"$OUT" <<'EOF'
<script>
// –ñ–∏–≤–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø—Ä–∏ –∫–ª–∏–∫ –Ω–∞ –∑–∞–≥–ª–∞–≤–∏–µ:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –ø–æ—Å–æ–∫–∞ (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // –†–µ–±–∏–ª–¥ –Ω–∞ tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // –ó–∞–ø–æ–º–Ω—è–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    .dataTables_wrapper .dataTables_scroll { overflow-x: auto; }
    th { background: #f0f0f0; white-space: nowrap; }
    td { white-space: nowrap; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x:auto;">
      <table id="data-table" class="table table-striped table-bordered" style="width:100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# –í–∫–∞—Ä–≤–∞–º–µ CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th>${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    scrollX: true,
    paging: false,
    ordering: false,
    info: false
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX:true, paging:false, ordering:false, info:false, buttons:['colvis'] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    paging: false,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, paging: false, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    .dataTables_wrapper .dataTables_scroll { overflow: auto; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div class="table-responsive">
      <table id="data-table" class="table table-striped table-bordered w-100">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: false,
    paging: false,
    scrollX: true,
    order: [],
    columnDefs: [{ targets:[0], orderable:false }]
  });

  table.columns().every(function(){
    const col = this;
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ 
        dom:'Bfrtip', 
        buttons:['colvis'], 
        responsive:false, 
        paging:false, 
        scrollX:true, 
        order:[] 
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# Escape backticks in CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Start HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# CSV content
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# JavaScript end
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  // Header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Body
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    paging: false,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  // –§–∏–ª—Ç—Ä–∏
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // –î–∞—Ç–∞ —Ñ–∏–ª—Ç—ä—Ä
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        paging: false,
        order: []
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."




CSV_ESCAPED=$(sed \
  -e 's/\\/\\\\/g' \
  -e 's/"/\\"/g' \
  -e 's/`/\\`/g' \
  -e 's/<\/script>/<\/scr"+"ipt>/g' \
  "$CSV")



#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# Escape —Å–∞–º–æ backticks –æ—Ç CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# –ù–∞—á–∞–ª–æ –Ω–∞ HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    th button { float:right; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# –ò–Ω–∂–µ–∫—Ç–∏—Ä–∞–π CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# –§–∏–Ω–∞–ª–Ω–∞ HTML —á–∞—Å—Ç —Å JS –ª–æ–≥–∏–∫–∞
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      const time = row[4+2*j+1];
      let [h,m,s] = time.split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    paging: false
  });

  table.columns().every(function(){
    const col = this, idx = col.index();
    const inp = $('<input>').attr('placeholder','filter')
      .addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    const btn = $('<button class="btn btn-sm btn-outline-secondary ml-1">Hide</button>');
    btn.on('click',()=>{
      const visible = table.column(idx).visible();
      table.column(idx).visible(!visible);
      btn.text(visible ? 'Show' : 'Hide');
    });
    $(col.header()).empty().append(inp).append(btn);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);

    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    const sel = dates.map((d,i)=>({date: d, index: i}))
                     .filter(d=>!min||d.date>=min)
                     .filter(d=>!max||d.date<=max);
    $('#table-header th:last-child:contains("Difference")').remove();
    $('#table-body tr').each((_,tr)=>$(tr).find('td:last').remove());

    if(sel.length === 2){
      let i1 = sel[0].index, i2 = sel[1].index;
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2];
        let delta = d2 - d1;
        let sign = delta < 0 ? '-' : '';
        let abs = Math.abs(delta);
        let hh = Math.floor(abs/3600), mm = Math.floor((abs%3600)/60), ss = abs%60;
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        order: [],
        paging: false
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

# 1) –ü—Ä–æ–≤–µ—Ä–∫–∞
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äò$CSV_INPUT‚Äô –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# 2) –ü—Ä–æ—á–∏—Ç–∞–º–µ header –∏ data
IFS= read -r header_line < "$CSV_INPUT"
IFS=',' read -r -a header_arr <<< "$header_line"
mapfile -t data_lines < <(tail -n +2 "$CSV_INPUT")

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω–∞—Ç–∞ —á–∞—Å—Ç (HEAD) ‚Äì single-quoted so nothing expands
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // –í–≥—Ä–∞–¥–µ–Ω CSV ‚Üí JS –º–∞—Å–∏–≤–∏
HTML_HEAD

# 4) –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ header[] –º–∞—Å–∏–≤–∞
echo "    const header = [" >>"$OUT_HTML"
for i in "${!header_arr[@]}"; do
  # escape –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏ –≤ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞
  col=${header_arr[i]//\"/\\\"}
  if (( i < ${#header_arr[@]}-1 )); then
    printf '      "%s",\n' "$col" >>"$OUT_HTML"
  else
    printf '      "%s"\n' "$col" >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 5) –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ data[] –º–∞—Å–∏–≤–∞
echo "    const data = [" >>"$OUT_HTML"
for idx in "${!data_lines[@]}"; do
  line=${data_lines[idx]}
  # split by comma
  IFS=',' read -r -a cells <<< "$line"
  printf '      [' >>"$OUT_HTML"
  for j in "${!cells[@]}"; do
    cell=${cells[j]//\"/\\\"}
    if (( j < ${#cells[@]}-1 )); then
      printf "\"%s\"," "$cell" >>"$OUT_HTML"
    else
      printf "\"%s\"" "$cell" >>"$OUT_HTML"
    fi
  done
  if (( idx < ${#data_lines[@]}-1 )); then
    printf '],\n' >>"$OUT_HTML"
  else
    printf ']\n' >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 6) –ü–∏—Å–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω–∞—Ç–∞ —á–∞—Å—Ç (TAIL) ‚Äì —Å—ä—â–æ single-quoted
cat >>"$OUT_HTML" <<'HTML_TAIL'
    // Document ready ‚Üí render —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
    $(document).ready(function(){
      const N = (header.length - 4) / 2; // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + –∫–æ–ª–æ–Ω–∞ Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–µ—Ä –Ω–∞ body –∏ highlight max
      data.forEach(row => {
        // –ø–∞—Ä—Å–∏–º–µ elapsed –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ –º–µ—Ä–∏–º max
        const secs = [], tr = $('<tr>');
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = (j === maxIdx ? 'max' : '');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = –ø–æ—Å–ª–µ–¥–Ω–æ ‚àí –ø—ä—Ä–≤–æ
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? '-' : '';
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX:  true,       // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching:true,       // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],  // –±—É—Ç–æ–Ω hide/show
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –ü—Ä–æ—á–∏—Ç–∞–º–µ header (–ø—ä—Ä–≤–∏ —Ä–µ–¥)
IFS= read -r header_line < "$CSV"
IFS=',' read -r -a header_arr <<< "$header_line"

# –ü—Ä–æ—á–∏—Ç–∞–º–µ data (–≤—Å–∏—á–∫–æ —Å–ª–µ–¥ –ø—ä—Ä–≤–∏—è —Ä–µ–¥)
data_lines=()
while IFS= read -r line; do
  data_lines+=("$line")
done < <(tail -n +2 "$CSV")

# –§—É–Ω–∫—Ü–∏—è –∑–∞ –ø—Ä–µ–≤—Ä—ä—â–∞–Ω–µ –Ω–∞ CSV-—Ä–µ–¥ –≤ JS-—Å—Ç—Ä–∏–Ω–≥-–∞—Ä–µ–π
to_js_array(){
  local line="$1"
  IFS=',' read -r -a cells <<< "$line"
  printf '['
  local first=1
  for cell in "${cells[@]}"; do
    # –µ—Å–∫–µ–π–ø–≤–∞–º–µ –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–∏ –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏ –≤ cell
    esc=${cell//\"/\\\"}
    if (( first )); then
      printf "\"%s\"" "$esc"
      first=0
    else
      printf ",\"%s\"" "$esc"
    fi
  done
  printf ']'
}

# –ì–ï–ù–ï–†–ò–†–ê–ú–ï HTML
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Header –∏ data –≤–≥—Ä–∞–¥–µ–Ω–∏ –∫–∞—Ç–æ JS –º–∞—Å–∏–≤–∏
    const header = [
EOF

# –í–º—ä–∫–≤–∞–º–µ header
first=1
for col in "${header_arr[@]}"; do
  esc=${col//\"/\\\"}
  if (( first )); then
    printf '      "%s"\n' "$esc" >>"$OUT"
    first=0
  else
    printf '     ,"%s"\n' "$esc" >>"$OUT"
  fi
done

cat >>"$OUT" <<EOF
    ];

    const data = [
EOF

# –í–º—ä–∫–≤–∞–º–µ data —Ä–µ–¥ –ø–æ —Ä–µ–¥
for i in "${!data_lines[@]}"; do
  line=${data_lines[i]}
  jsarr=$(to_js_array "$line")
  if (( i < ${#data_lines[@]} - 1 )); then
    printf '      %s,\n' "$jsarr" >>"$OUT"
  else
    printf '      %s\n' "$jsarr" >>"$OUT"
  fi
done

cat >>"$OUT" <<'EOF'
    ];

    $(document).ready(function(){
      const N = (header.length - 4)/2; // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–∏—Å—É–≤–∞–º–µ header + –¥–æ–±–∞–≤—è–º–µ Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–∏—Å—É–≤–∞–º–µ body + highlight max
      data.forEach(row => {
        // –ø–∞—Ä—Å–∏–º–µ Elapsed –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ —Ç—ä—Ä—Å–∏–º max
        const secs = [], tr = $('<tr>'), LENGTH=N;
        let maxSec=-1, maxIdx=0;
        for(let j=0;j<LENGTH;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j; }
        }
        // STATUS..JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for(let j=0;j<LENGTH;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls=(j===maxIdx?'max':'');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0],
              sign = diff<0?'-':'',
              sabs = Math.abs(diff),
              h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60,
              dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);
        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,   // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX:  true,    // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching:true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT (–æ—Ç $CSV)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# 1) –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ CSV-—Ç–æ
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤: $(pwd)" >&2
  exit 1
fi

# 2) –ï–∫—Å–ø–µ–π–ø–≤–∞–º–µ —Å–∞–º–æ backticks (–∞–∫–æ –≥–∏ –∏–º–∞)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML-–∞
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS Libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const rawCSV = `
HTML_START

# 4) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 5) –ü–∏—Å–∞–Ω–µ –Ω–∞ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // –∫–æ–ª–∫–æ date/elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–µ—Ä: —Ö–µ–¥—ä—Ä + —Ä–∞–∑–ª–∏–∫–∞
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–µ—Ä: body + highlight max
      data.forEach(row => {
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX: true,      // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching: true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],// –±—É—Ç–æ–Ω hide/show –∫–æ–ª–æ–Ω–∏
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT)"





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤: $(pwd)" >&2
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks, –æ—Å—Ç–∞–Ω–∞–ª–æ—Ç–æ –æ—Å—Ç–∞–≤—è–º–µ –Ω–µ–ø—Ä–æ–º–µ–Ω–µ–Ω–æ
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) –ü–∏—Å–∞–Ω–µ –Ω–∞ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML-–∞ (single-quoted here-doc –∑–∞ –¥–∞ –Ω–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞ $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const rawCSV = `
HTML_START

# 2) –î–æ–±–∞–≤—è–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–∏—Ä–∞–Ω–µ –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + —Ä–∞–∑–ª–∏–∫–∞
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–∏—Ä–∞–Ω–µ –Ω–∞ body + highlight max
      data.forEach(row => {
        // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–º–∏—Ä–∞–º–µ –º–∞–∫—Å–∏–º—É–º–∞
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }

        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX: true,      // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching: true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],// –±—É—Ç–æ–Ω hide/show –∫–æ–ª–æ–Ω–∏
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."








#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤:" >&2
  echo "   $(pwd)" >&2
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks (–∞–∫–æ –≥–∏ –∏–º–∞ –≤ CSV-—Ç–æ)
ESCAPED_CSV=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) –ü–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–∞—Ç–∞ (—Å—Ç–∞—Ç–∏—á–Ω–∞) —á–∞—Å—Ç –æ—Ç HTML-–∞
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css">
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // –í–ì–†–ê–î–ï–ù–û CSV
    const rawCSV = `
HTML_HEAD

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$ESCAPED_CSV" >> "$OUT_HTML"

# 3) –ü–µ—á–∞—Ç–∞–º–µ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ (—Å—Ç–∞—Ç–∏—á–Ω–∞) —á–∞—Å—Ç –æ—Ç HTML + JS
cat >>"$OUT_HTML" <<'HTML_TAIL'
`;
    function parseCSV(txt) {
      return txt.trim().split("\n").map(r=>r.split(","));
    }
    $(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4)/2;  // –∫–æ–ª–∫–æ date/elapsed –¥–≤–æ–π–∫–∏

      // header + Difference
      header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // body
      data.forEach(row=>{
        // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–π-–≥–æ–ª—è–º–æ Elapsed
        let secs = [], maxSec=-1, maxIdx=0;
        for(let j=0;j<N;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(":").map(Number);
          const s = hh*3600+mm*60+ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j }
        }
        const tr = $("<tr>");
        // –ø—ä—Ä–≤–∏ 4 –∫–æ–ª–æ–Ω–∏
        row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
        // date/elapsed –¥–≤–æ–π–∫–∏
        for(let j=0;j<N;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = j===maxIdx?"max":"";
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff<0?"-":"";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable –±–µ–∑ paging + –±—É—Ç–æ–Ω –∑–∞ hide/show
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging: false,
        searching: true,
        buttons: ['colvis'],
        responsive: true,
        order: []
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML (–æ—Ç $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ –ø–æ–¥–∞–¥–µ—à –ø—ä—Ç –∫—ä–º CSV, –≥–æ –ø–æ–ª–∑–≤–∞–º–µ, –∏–Ω–∞—á–µ ‚Äì report.csv –¥–æ —Å–∫—Ä–∏–ø—Ç–∞
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CSV_INPUT="${1:-report.csv}"
# –ê–∫–æ –ø—ä—Ç—ä—Ç –∫—ä–º CSV –Ω–µ –µ –∞–±—Å–æ–ª—é—Ç–µ–Ω, –≥–æ –¥–æ–ø—ä–ª–≤–∞–º–µ —Å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞
if [[ "$CSV_INPUT" != /* ]]; then
  CSV_PATH="$SCRIPT_DIR/$CSV_INPUT"
else
  CSV_PATH="$CSV_INPUT"
fi

# –ò–∑—Ö–æ–¥–Ω–∏—è—Ç HTML
OUT_HTML="${2:-interactive_report.html}"

# –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –∏–º–∞ –ª–∏ CSV
if [[ ! -f "$CSV_PATH" ]]; then
  echo "‚ùå –ù–µ –º–æ–≥–∞ –¥–∞ –æ—Ç–∫—Ä–∏—è CSV —Ñ–∞–π–ª–∞:" >&2
  echo "   –ò–∑–≥–ª–µ–∂–¥–∞, —á–µ —Ç—ä—Ä—Å—è —Ç—É–∫: $CSV_PATH" >&2
  echo "   –¢–µ–∫—É—â–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: $(pwd)"   >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $SCRIPT_DIR:"   >&2
  ls -1 "$SCRIPT_DIR" >&2 || true
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks (–æ—Å—Ç–∞–Ω–∞–ª–∏—è—Ç JS/HTML –∫–æ–¥ –Ω–µ —Å–µ –ø–∏–ø–∞)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_PATH")

# 1) –ü—ä—Ä–≤–∞ —á–∞—Å—Ç –Ω–∞ HTML (single-quoted –∑–∞ –¥–∞ –Ω–µ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞—Ç $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = `
HTML_START

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ report.csv
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML+JS
cat >>"$OUT_HTML" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

  // header + Difference
  header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // body
  data.forEach(row=>{
    let secsRow=[], maxSec=-1, maxIdx=0;
    for(let j=0;j<N;j++){
      let [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0;j<N;j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = j===maxIdx?'max':'';
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let diff = secsRow[secsRow.length-1] - secsRow[0],
        sign = diff<0?'-':'',
        s    = Math.abs(diff),
        h2   = Math.floor(s/3600), m2=Math.floor((s%3600)/60), s2=s%60,
        str  = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
    tr.append(`<td>${str}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // DataTable –±–µ–∑ paging
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –£—Å–ø–µ—à–Ω–æ: –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML (—á–µ—Ç–µ $CSV_PATH)"





#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT="\${2:-interactive_report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö \$CSV" >&2
  exit 1
fi

# –ï–∫—Å–ø–µ–π–ø–≤–∞–º–µ —Å–∞–º–æ backticks
CSV_ESCAPED=\$(sed 's/`/\\\\`/g' "\$CSV")

# 1) HTML —Å—Ç–∞—Ä—Ç (–Ω–∏—â–æ –Ω–µ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞ —Ç—É–∫, –∑–∞—Ä–∞–¥–∏ single-quoted here-doc)
cat >"\$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <!-- Bootstrap -->
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV –∫–∞—Ç–æ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–µ–Ω string ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = \`
HTML_START

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å–∞–º–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ CSV
printf '%s\n' "\$CSV_ESCAPED" >> "\$OUT"

# 3) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML+JS (–ø–∞–∫ –±–µ–∑ —Ä–∞–∑—à–∏—Ä—è–≤–∞–Ω–∏—è)
cat >>"\$OUT" <<'HTML_END'
\`;
function parseCSV(text){
  return text.trim().split("\\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏
  const N      = (header.length - 4) / 2;

  // --- –†–∏—Å—É–≤–∞–º–µ header + –¥–æ–±–∞–≤—è–º–µ Difference ---
  header.forEach(h => {
    $('#table-header').append(`<th>\${h}</th>`);
  });
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // --- –ü–æ–ø—ä–ª–≤–∞–º–µ body + highlight –º–∞–∫—Å–∏–º—É–º–∞ ---
  data.forEach(row => {
    // –ü–∞—Ä—Å–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ —Ç—ä—Ä—Å–∏–º max
    let secsRow = [], maxSec=-1, maxIdx=0;
    for(let j=0; j<N; j++){
      let [hh,mm,ss] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec=sec; maxIdx=j; }
    }

    // –°—ä–∑–¥–∞–≤–∞–º–µ —Ä–µ–¥
    const tr = $('<tr>');
    // STATUS, STAGE, BATCH, JOB.NAME
    row.slice(0,4).forEach(cell => tr.append(`<td>\${cell}</td>`));
    // Date/Elapsed –¥–≤–æ–π–∫–∏
    for(let j=0; j<N; j++){
      tr.append(`<td>\${row[4 + 2*j]}</td>`);
      let cls = (j===maxIdx ? 'max' : '');
      tr.append(`<td class="\${cls}">\${row[4 + 2*j + 1]}</td>`);
    }
    // –†–∞–∑–ª–∏–∫–∞ = last - first
    let diffSec = secsRow[secsRow.length-1] - secsRow[0],
        sign    = diffSec<0 ? '-' : '',
        s       = Math.abs(diffSec),
        hh2     = Math.floor(s/3600),
        mm2     = Math.floor((s%3600)/60),
        ss2     = s%60,
        diffStr = `${sign}${String(hh2).padStart(2,'0')}:${String(mm2).padStart(2,'0')}:${String(ss2).padStart(2,'0')}`;
    tr.append(`<td>\${diffStr}</td>`);

    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∏ —Å –±—É—Ç–æ–Ω –∑–∞ hide/show ---
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '\$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# 1) –ü—Ä–æ—á–∏—Ç–∞–º–µ CSV –∏ escape-–∞–º–µ —Å–∞–º–æ backticks
#    (–æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ $ –Ω—è–º–∞—Ç –∑–Ω–∞—á–µ–Ω–∏–µ, –∑–∞—â–æ—Ç–æ —Ç—É–∫ —Å–∞–º–æ
#     —â–µ –≥–æ inser—Ç–∏–º)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) –ü—ä—Ä–≤–∞ —á–∞—Å—Ç –æ—Ç HTML (–±–µ–∑ –¥–∞ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞—Ç –Ω–∏–∫–∞–∫–≤–∏ $)
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = `
HTML_START

# 3) –ò–Ω–∂–µ–∫—Ç–∏—Ä–∞–º–µ —Å–∞–º–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ report.csv
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# 4) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2; // –¥–≤–æ–π–∫–∏—Ç–µ Date/Elapsed

  // Render header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Render body + highlight max
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    // STATUS,STAGE,BATCH,JOB.NAME
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    // Date/Elapsed pairs
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    // Average
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // Init DataTables
  const table = $('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });
  // Column filters
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Date-range filter + Difference
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ dom:'Bfrtip',buttons:['colvis'],responsive:true,order:[] });
    }
  }
  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

# 1) –ü—Ä–æ—á–∏—Ç–∞–º–µ CSV –∏ –≥–æ –µ–∫—Ä–∞–Ω–∏—Ä–∞–º–µ –∑–∞ backticks
if [ ! -f "$CSV" ]; then
  echo "–ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi
# Slurp whole file, –∏–∑–±—è–≥–≤–∞–º–µ backtick ‚Äû`‚Äú
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML-–∞
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
    th { cursor: pointer; background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = \`
${CSV_ESCAPED}
\`;
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

\$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2; // –±—Ä–æ—è—Ç –¥–≤–æ–π–∫–∏ Date/Elapsed

  // –†–∏—Å—É–≤–∞–º–µ header
  header.forEach((h,i)=>{
    \$('#table-header').append(
      `<th data-col="\${i}">\${h}</th>`
    );
  });

  const secsData = [];

  // –ü–æ–ø—ä–ª–≤–∞–º–µ body
  data.forEach((row,ridx)=>{
    const tr = \$('<tr>');
    const secsRow = [];
    let maxSec = -1, maxIdx = -1;

    // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–º–∏—Ä–∞–º–µ max
    for(let j=0;j<N;j++){
      const val = row[4+2*j+1];
      const [h,m,s] = val.split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }

    // STATUS..JOB.NAME
    for(let c=0;c<4;c++){
      tr.append(`<td>\${row[c]}</td>`);
    }
    // Date/Elapsed
    for(let j=0;j<N;j++){
      tr.append(`<td>\${row[4+2*j]}</td>`);
      const cls = j===maxIdx ? 'max' : '';
      tr.append(`<td class="\${cls}">\${row[4+2*j+1]}</td>`);
    }
    // AVERAGE
    const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
    const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

    secsData.push(secsRow);
    \$('#table-body').append(tr);
  });

  // Init DataTable
  const table = \$('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });

  // Column filters
  table.columns().every(function(){
    const col=this;
    const idx=col.index();
    const inp=\$('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    \$(col.header()).empty().append(inp);
  });

  // Date-range filter
  function applyDateFilter(){
    const min=\$('#min-date').val();
    const max=\$('#max-date').val();
    const dates=header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      const show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    // –∞–∫–æ —Ç–æ—á–Ω–æ 2 –¥–∞—Ç–∏ ‚Äì Difference
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !table.column(':contains("Difference")').nodes().length){
      const i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      table.column.adjust().draw(false);
      \$('#table-header').append('<th>Difference</th>');
      \$('#table-body tr').each((ri,tr)=>{
        const d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        const s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        const sign=delta<0?'-':'';
        \$(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  \$('#clear-dates').on('click',()=>{
    \$('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ: $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä ‚Äî –≤–µ—á–µ —Ä–∞–±–æ—Ç–∏ –±–µ–∑ fetch!"







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />

  <!-- DataTables + Buttons + Responsive -->
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />

  <!-- Flatpickr –∑–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä -->
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />

  <style>
    /* –ñ—ä–ª—Ç–æ highlight –∑–∞ max */
    td.max { background-color: #ffeb3b !important; }
    /* –ú–∞–ª–∫–æ padding –Ω–∞ date-range –ø–æ–ª–µ—Ç–æ */
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <!-- Date range pickers -->
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <!-- Table -->
    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
  // 1) –ó–∞—Ä–µ–∂–¥–∞–º–µ CSV
  async function loadCSV(path) {
    const resp = await fetch(path);
    const text = await resp.text();
    return text.trim().split('\n').map(r => r.split(','));
  }

  $(document).ready(async function(){
    const data = await loadCSV('${CSV}');
    const header = data.shift();
    const N = (header.length - 5) / 2; // –±—Ä–æ—è—Ç –¥–≤–æ–π–∫–∏ Date/Elapsed (–ø–æ—Å–ª–µ –∏–º–∞ AVERAGE)

    // –†–∏—Å—É–≤–∞–º–µ header
    header.forEach((h,i) => {
      $('#table-header').append(
        `<th data-col="\${i}" class="text-nowrap">${h}</th>`
      );
    });

    // –ü–æ–ø—ä–ª–≤–∞–º–µ body –∏ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ secsData
    const secsData = [];
    data.forEach((row, ridx) => {
      const tr = $('<tr>');
      const secsRow = [];

      // –∏–∑–æ–ª–∏—Ä–∞–º–µ Elapsed –∫–æ–ª–æ–Ω–∏ (index: 5,7,9,...)
      let maxSec = -1, maxIdx = -1;
      for(let j=0; j<N; j++){
        const val = row[4 + 2*j + 1];
        const [h,m,s] = val.split(':').map(Number);
        const sec = h*3600 + m*60 + s;
        secsRow.push(sec);
        if(sec > maxSec){ maxSec=sec; maxIdx=j; }
      }

      // STATUS, STAGE, BATCH, JOB.NAME (0..3)
      for(let c=0; c<4; c++){
        tr.append(`<td>\${row[c]}</td>`);
      }
      // Date/Elapsed –¥–≤–æ–π–∫–∏
      for(let j=0; j<N; j++){
        tr.append(`<td>\${row[4 + 2*j]}</td>`);
        const cls = (j===maxIdx ? 'max' : '');
        tr.append(`<td class="\${cls}">\${row[4 + 2*j +1]}</td>`);
      }
      // AVERAGE
      const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
      const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
      tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

      secsData.push(secsRow);
      $('#table-body').append(tr);
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable
    const table = $('#data-table').DataTable({
      dom: 'Bfrtip',
      buttons: [ 'colvis' ],
      responsive: true,
      order: [],
      columnDefs: [{ targets: [0], orderable: false }]
    });

    // –ö–æ–ª–æ–Ω–Ω–∏ —Ñ–∏–ª—Ç—Ä–∏
    table.columns().every(function(){
      const col = this;
      const idx = col.index();
      const inp = $('<input>')
        .attr('placeholder','filter')
        .addClass('form-control form-control-sm')
        .on('keyup change clear', ()=>col.search(inp.val()).draw());
      $(col.header()).empty().append(inp);
    });

    // Date range —Ñ–∏–ª—Ç—ä—Ä
    function applyDateFilter() {
      const min = $('#min-date').val();
      const max = $('#max-date').val();
      const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
      dates.forEach((d,i)=>{
        const show = (!min||d>=min) && (!max||d<=max);
        table.column(4+2*i).visible(show);
        table.column(4+2*i+1).visible(show);
      });

      // —Ç–æ—á–Ω–æ –¥–≤–µ –¥–∞—Ç–∏ => —Ä–∞–∑–ª–∏–∫–∞
      const selected = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
      if(selected.length===2 && !table.column(':contains("Difference")').nodes().length) {
        const i1 = dates.indexOf(selected[0]);
        const i2 = dates.indexOf(selected[1]);
        // –¥–æ–±–∞–≤—è–º–µ –∫–æ–ª–æ–Ω–∞ Difference
        table.column.adjust().draw(false);
        $('#table-header').append('<th>Difference</th>');
        $('#table-body tr').each((ri,tr)=>{
          const sec1 = secsData[ri][i1], sec2 = secsData[ri][i2];
          const dsec = sec2 - sec1, s = Math.abs(dsec);
          const hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60), ss = s%60;
          const sign = dsec<0?'-':'';
          $(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
        });
      }
    }

    // flatpickr –∑–∞ date inputs
    flatpickr(".flatpickr", { dateFormat: "Y-m-d", onChange: applyDateFilter });
    $('#clear-dates').on('click', ()=>{
      $('#min-date,#max-date').val('');
      applyDateFilter();
    });
  });
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ: $OUT (—á–µ—Ç–µ $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ó–∞–ø–∏—Å–≤–∞–º–µ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ <table> —Å –æ—Ü–≤–µ—Ç—è–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º—É–º–∞ –∏ –∫–ª–∏–∫–∞–µ–º–∏ <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # –ø—Ä–∞–≤–∏–º –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å–æ—Ä—Ç–∏—Ä–∞—â –±—É—Ç–æ–Ω
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –º–∞—Ä–∫–∏—Ä–∞–º–µ class="max" —Å–∞–º–æ –Ω–∞ maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
cat >>"$OUT" <<'EOF'
<script>
// –ñ–∏–≤–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø—Ä–∏ –∫–ª–∏–∫ –Ω–∞ –∑–∞–≥–ª–∞–≤–∏–µ:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –ø–æ—Å–æ–∫–∞ (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // –†–µ–±–∏–ª–¥ –Ω–∞ tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // –ó–∞–ø–æ–º–Ω—è–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ü–∏—à–µ–º –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏ –≤ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ —Å–∞–º–∞—Ç–∞ <table> –æ—Ç CSV, –∫–∞—Ç–æ –æ—Ü–≤–µ—Ç—è–≤–∞–º–µ max Elapsed –Ω–∞ —Ä–µ–¥
awk -F, '
BEGIN {
  OFS="";
  print "<table>";
}
NR==1 {
  # header
  print "<tr>";
  for(i=1;i<=NF;i++){
    header[i]=$i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    print "<th>"$i"</th>";
  }
  print "</tr>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600+T[2]*60+T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –∫–∞—Ç–æ —Å–∞–º–æ –ø—Ä–∏ maxcol –¥–æ–±–∞–≤—è–º–µ class="max"
  print "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    print "<td" cls ">" , $i , "</td>";
  }
  print "</tr>";
}
END {
  print "</table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ –∂–∏–≤–æ—Ç–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø—Ä–∏ –ø–∏—Å–∞–Ω–µ –≤ –ø–æ–ª–µ—Ç–æ #search
cat >>"$OUT" <<'EOF'
<script>
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("table tr").forEach(function(row, i) {
    if(i === 0) return; // skip header
    var text = row.textContent.toLowerCase();
    row.style.display = text.includes(filter) ? "" : "none";
  });
});
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä, –∑–∞ –¥–∞ –≤–∏–¥–∏—à —Ç—ä—Ä—Å–∞—á–∫–∞—Ç–∞ –∏ –æ—Ü–≤–µ—Ç–µ–Ω–∏—è –º–∞–∫—Å–∏–º—É–º."




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

awk -F, '
BEGIN {
  OFS=""
  # –ù–∞—á–∞–ª–æ –Ω–∞ HTML-–∞ –∏ —Å—Ç–∏–ª–∏—Å—Ç–∏–∫–∞
  print "<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><style>"
  print "table, th, td { border: 1px solid #ccc; border-collapse: collapse; }"
  print "th, td { padding: 4px 8px; }"
  print ".max { background-color: #ffeb3b; }"
  print "</style></head><body><table>"
}
NR==1 {
  # –•–µ–¥—ä—Ä-—Ä–µ–¥: –Ω–∞–º–∏—Ä–∞–º–µ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  printf "<tr>"
  for(i=1;i<=NF;i++){
    header[i]=$i
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    printf "<th>%s</th>", $i
  }
  print "</tr>"
  next
}
{
  # –ó–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥ –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ—è –æ—Ç Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ –µ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞
  maxsec = -1; maxcol = 0
  for(j=1;j<=ecount;j++){
    idx = elapsed_idx[j]
    split($idx, T, ":")
    sec = T[1]*3600 + T[2]*60 + T[3]
    if(sec > maxsec){
      maxsec = sec
      maxcol = idx
    }
  }
  # –û—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –∫–∞—Ç–æ cell i=maxcol –ø–æ–ª—É—á–∞–≤–∞ –∫–ª–∞—Å="max"
  printf "<tr>"
  for(i=1;i<=NF;i++){
    if(i==maxcol)
      printf "<td class=\"max\">%s</td>", $i
    else
      printf "<td>%s</td>", $i
  }
  print "</tr>"
}
END {
  print "</table></body></html>"
}' "$CSV" > "$OUT"

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ $OUT –≤ –±—Ä–∞—É–∑—ä—Ä, –∑–∞ –¥–∞ –≤–∏–¥–∏—à –æ—Ü–≤–µ—Ç–µ–Ω–∏—Ç–µ –º–∞–∫—Å–∏–º—É–º–∏."






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º—è–Ω–∞ –Ω–∞ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# --- –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –¥–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files     = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# --- –ü–∞—Ä—Å–≤–∞–º–µ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª –∏ –ø—ä–ª–Ω–∏–º data[key][idx] ---
data  = {}                           # data[(stage,batch,job)] = { idx0: {...}, idx1: {...}, ... }
dates = [None]*len(files)            # dates[i] = –¥–∞—Ç–∞ –æ—Ç —Ñ–∞–π–ª i

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date              = parts[3]
            elapsed           = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # –ó–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª
    if dates[idx] is None:
        dates[idx] = date

# --- –ü–∏—Å–∞–Ω–µ –Ω–∞ CSV –Ω–∞ stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
header.append("AVERAGE")
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á –≥–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –ø–æ –µ–¥–∏–Ω —Ä–µ–¥
for key in sorted(data.keys()):
    rec = []
    d   = data[key]
    # STATUS: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–æ (idx=0) –∏ –ø–æ—Å–ª–µ–¥–Ω–æ (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "‚Üë"
    elif sN < s1: status = "‚Üì"
    else:          status = "="

    # –ü—ä—Ä–≤–∏—Ç–µ 4 –ø–æ–ª–µ—Ç–∞
    rec = [status, *key]

    # –°–ø–∏—Å—ä–∫ –∑–∞ –≤—Å–∏—á–∫–∏ secs, –∑–∞ —Å–º—è—Ç–∞–Ω–µ –Ω–∞ —Å—Ä–µ–¥–Ω–æ
    secs_list = []

    # –ü–æ –¥–≤–æ–π–∫–∏ Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", ""]

    # –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh  = avg // 3600
        mm  = (avg % 3600) // 60
        ss  = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out.writerow(rec)






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
# –ê–∫–æ –∏–º–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏, –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –ø—ä—Ä–≤–∏—è—Ç –µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º–µ–Ω—è–º–µ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# --- –°—ä–±–∏—Ä–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# --- –ü–∞—Ä—Å–∏–º–µ –≤—Å–µ–∫–∏ —Ä–µ–¥ –∏ –≥—Ä–∞–¥–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ data[key][idx] ---
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date    = parts[3]
            elapsed = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # –ó–∞–ø–∞–∑–≤–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –Ω–∞ idx-—Ç–∏—è —Ñ–∞–π–ª
    if dates[idx] is None:
        dates[idx] = date

# --- –ü–∏—à–µ–º CSV –Ω–∞ stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")
# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ job (—Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ STAGE,BATCH,JOB)
for key in sorted(data.keys()):
    rec = []
    d = data[key]
    # STATUS = ‚Üë –∞–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç e –ø–æ-–±–∞–≤–µ–Ω, ‚Üì –∞–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç e –µ –ø–æ-–±—ä—Ä–∑, = –∞–∫–æ –µ–¥–Ω–∞–∫–≤–∏
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "‚Üë"
    elif sN < s1: status = "‚Üì"
    else:          status = "="

    rec = [status, *key]
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec += [info["date"], info["elapsed"]]
        else:
            rec += ["", ""]
    out.writerow(rec)





#!/usr/bin/env bash
set -euo pipefail

# –ë—Ä–æ–π —Ñ–∞–π–ª–∞ –Ω–∞–∑–∞–¥ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 31)
N=${1:-31}

# –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ (–ø–æ modification time)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")
if [ "${#files[@]}" -lt 1 ]; then
  echo "–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ JT* —Ñ–∞–π–ª–æ–≤–µ."
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS=","
    # –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    printf "STATUS,STAGE,BATCH,JOB.NAME"
    for(i=1;i<=N;i++){
      printf ",Date%d,Elapsed%d", i, i
    }
    print ""
    idx=0
  }
  # –ó–∞ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª —É–≤–µ–ª–∏—á–∞–≤–∞–º–µ idx
  FNR==1 { idx++ }
  {
    # –∫–ª—é—á –∑–∞ JOB
    key = $1 SUBSEP $2 SUBSEP $3
    if (!(key in seen)) {
      seen[key]=1
      keys[++K]=key
    }
    # –∑–∞–ø–æ–º–Ω—è–º–µ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª (–µ–¥–Ω–∞ –∏ —Å—ä—â–∞ per —Ñ–∞–π–ª)
    if (!(idx in dates)) {
      dates[idx] = $4
    }
    # Elapsed –∏ –≤ —Å–µ–∫—É–Ω–¥–∏
    elapsed[key,idx] = $8
    split($8, T, ":")
    secs[key,idx]    = T[1]*3600 + T[2]*60 + T[3]
  }
  END {
    # –∑–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á
    for(j=1;j<=K;j++){
      key = keys[j]
      # —Å—Ç–∞—Ç—É—Å: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–∏ vs –ø–æ—Å–ª–µ–¥–µ–Ω –¥–µ–Ω
      s1 = (key,1 in secs ? secs[key,1] : 0)
      sN = (key,N in secs ? secs[key,N] : 0)
      status = (sN > s1 ? "‚Üë" : (sN < s1 ? "‚Üì" : "="))
      # —Ä–∞–∑–±–∏–≤–∞–º–µ –∫–ª—é—á–∞ –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ STAGE,BATCH,JOB.NAME
      split(key, F, SUBSEP)
      printf "%s,%s,%s,%s", status, F[1], F[2], F[3]
      # –∏ –∑–∞ –≤—Å–µ–∫–∏ –¥–µ–Ω Datei, Elapsedi
      for(i=1;i<=N;i++){
        d = (i in dates ? dates[i] : "")
        e = ((key,i) in elapsed ? elapsed[key,i] : "")
        printf ",%s,%s", d, e
      }
      print ""
    }
  }
' "${files[@]}"







#!/usr/bin/env bash
set -euo pipefail

# –ë—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 31; –º–æ–∂–µ—à –¥–∞ –ø–æ–¥–∞–¥–µ—à –¥—Ä—É–≥–æ —á–∏—Å–ª–æ –∫–∞—Ç–æ –ø—ä—Ä–≤–∏ –∞—Ä–≥—É–º–µ–Ω—Ç)
N=${1:-31}

# –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ –ø–æ modification time
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -eq 0 ]; then
  echo "–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT*"
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS = ",";
    idx = 0;
  }
  # –í—Å–µ–∫–∏ –ø—ä—Ç, –∫–æ–≥–∞—Ç–æ –∑–∞–ø–æ—á–≤–∞ –Ω–æ–≤ —Ñ–∞–π–ª, –≤–¥–∏–≥–∞–º–µ –±—Ä–æ—è—á–∞
  FNR==1 { idx++; }
  {
    # –°—Ç—Ä–æ–∏–º –∫–ª—é—á–∞ –æ—Ç BATCH.STAGE,BATCH,JOB.NAME
    key = $1 FS $2 FS $3;
    # –ü–∞–∑–∏ —Å–ø–∏—Å—ä–∫ —Å —É–Ω–∏–∫–∞–ª–Ω–∏ –∫–ª—é—á–æ–≤–µ –∑–∞ –∫—Ä–∞–π–Ω–æ—Ç–æ –æ–±—Ö–æ–∂–¥–∞–Ω–µ
    if (!(key in seen)) {
      seen[key]=1;
      keys[++K]=key;
    }
    # –ó–∞–ø–∏—à–∏ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª (—Ñ–∞–π–ª—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ —Å—ä—â–∞—Ç–∞ –¥–∞—Ç–∞ –Ω–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥)
    if (!(idx in dates)) {
      dates[idx] = $4;
    }
    # –ó–∞–ø–∞–∑–∏ elapsed –∏ —Å–µ–∫—É–Ω–¥–∏
    elapsed[key","idx] = $8;
    split($8, T, ":");
    secs[key","idx] = T[1]*3600 + T[2]*60 + T[3];
  }
  END {
    # 1) –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    printf "BATCH.STAGE,BATCH,JOB.NAME";
    for (i=1; i<=N; i++) {
      printf ",Date%d,Elapsed%d", i, i;
    }
    print "";

    # 2) –ó–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á ‚Äì –∏–∑–ø–∏—Å–≤–∞–º–µ —Ä–µ–¥
    for (r=1; r<=K; r++) {
      key = keys[r];
      split(key, F, FS);
      # –ø—ä—Ä–≤–∏—Ç–µ —Ç—Ä–∏ –ø–æ–ª–µ—Ç–∞
      printf "%s,%s,%s", F[1], F[2], F[3];
      # —Å–ª–µ–¥ —Ç–æ–≤–∞ –∑–∞ –≤—Å–µ–∫–∏ –æ—Ç N-—Ç–µ –¥–Ω–∏
      for (i=1; i<=N; i++) {
        d = dates[i];
        e = elapsed[key","i] ? elapsed[key","i] : "";
        arrow = "";
        if (i>1 && e!="") {
          prev = secs[key","i-1];
          curr = secs[key","i];
          if (curr > prev)   arrow = "‚Üë";  # –∑–∞–±–∞–≤—è–Ω–µ
          else if (curr < prev) arrow = "‚Üì";  # —É—Å–∫–æ—è–≤–∞–Ω–µ
        }
        printf ",%s,%s%s", d, arrow, e;
      }
      print "";
    }
  }
' "${files[@]}"






#!/usr/bin/env bash
set -euo pipefail

# –∞–∫–æ –ø–æ–¥–∞–¥–µ—à –µ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç, —Ç–æ–≤–∞ –µ –±—Ä–æ—è—Ç –¥–Ω–∏ –Ω–∞–∑–∞–¥; –∏–Ω–∞—á–µ ‚Äì 31
N=${1:-31}

# 1) —Å—ä–±–∏—Ä–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ –ø–æ modification time (ls -1tr —Å—Ç–∞—Ä—Ç–∏—Ä–∞ —Å—Ç–∞—Ä–æ->–Ω–æ–≤–æ)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -lt 2 ]; then
  echo "–ù—è–º–∞ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ —Ñ–∞–π–ª–æ–≤–µ –≤ JT* (—Ç—Ä—è–±–≤–∞—Ç –ø–æ–Ω–µ 2 –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ $N)."
  exit 1
fi

# –ü–µ—á–∞—Ç–∞–º–µ header —Å–∞–º–æ –≤–µ–¥–Ω—ä–∂
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# 2) –∑–∞ –≤—Å–µ–∫–∏ –¥–≤–∞ –ø–æ—Ä–µ–¥–Ω–∏ —Ñ–∞–π–ª–∞ ‚Äì —Å—Ç–∞—Ä–∏—è—Ç –∏ —Å–ª–µ–¥–≤–∞—â–∏—è
for ((i=1; i<${#files[@]}; i++)); do
  f1=${files[i-1]}
  f2=${files[i]}

  # —Å—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ awk –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ
  awk -F, -v OFS=, '
    FNR==NR {
      # —á–µ—Ç–µ–º file1
      key            = $1 FS $2 FS $3
      date1[key]     = $4
      elapsed1[key]  = $8
      split($8, t1, ":")
      secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
      next
    }
    {
      # —á–µ—Ç–µ–º file2
      key            = $1 FS $2 FS $3
      d2             = $4
      e2             = $8
      split(e2, t2, ":")
      secs2          = t2[1]*3600 + t2[2]*60 + t2[3]

      # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
      delta          = (key in secs1 ? secs1[key] : 0) - secs2

      # –ø–µ—á–∞—Ç–∞–º–µ —Å–∞–º–æ –∞–∫–æ secs1 > secs2 (—Ç.–µ. date1 –µ –ø–æ-–±–∞–≤–Ω–æ)
      if (secs1[key] > secs2) {
        # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ Diff –∫–∞—Ç–æ HH:MM:SS (–ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–æ —á–∏—Å–ª–æ)
        hh   = int(delta/3600)
        mm   = int((delta%3600)/60)
        ss   = delta % 60
        diff = sprintf("%02d:%02d:%02d", hh, mm, ss)

        # —Å—Ç—Ä–µ–ª–∫–∞—Ç–∞ –≤–∏–Ω–∞–≥–∏ ‚Üë (date1 –µ –ø–æ-–±–∞–≤–Ω–æ)
        arrow = "‚Üë"

        # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ:
        #   arrow+stage, batch, job.name,
        #   date1, elapsed1,
        #   date2, elapsed2,
        #   diff
        print arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
      }
    }
  ' "${f1}" "${f2}"
done




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- –≤—Ç–æ—Ä–∏ —Ñ–∞–π–ª (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ‚Üë –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2), –∏–Ω–∞—á–µ ‚Üì
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "‚Üë" : "‚Üì")

    # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-







#!/usr/bin/env bash
set -euo pipefail

if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –Ω–∞–º–µ—Ä–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ JT*<–¥–∞—Ç–∞>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# –ø–µ—á–∞—Ç–∞–º–µ header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# –ø—Ä–∞–≤–∏–º awk –∏ –≤–µ–¥–Ω–∞–≥–∞ pipe –∫—ä–º sort –∏ cut
awk -F, -v OFS=, '
  # –ü—ä—Ä–≤–æ: –∑–∞—Ä–µ–∂–¥–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç file1 (date1)
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t1, ":")
    secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # –°–ª–µ–¥ —Ç–æ–≤–∞ file2 (date2)
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta          = secs1[key] - secs2
    # —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2)
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ Diff –∫–∞—Ç–æ HH:MM:SS (–±–µ–∑ –∑–Ω–∞–∫, –≤–∏–Ω–∞–≥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–æ)
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta % 60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ –≤–∏–Ω–∞–≥–∏ ‚Üë (date1 –ø–æ-–±–∞–≤–Ω–æ)
      arrow = "‚Üë"
      # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) –ø—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) —Å–µ–≥–∞ file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = secs1[key] - secs2
    # —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ (—â–µ –µ –≤–∏–Ω–∞–≥–∏ ‚Üë —Ç—É–∫)
      arrow = "‚Üë"
      # –ø–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –∫–æ–ª–æ–Ω–∏—Ç–µ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # —Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ delta (–Ω–∞–π-–≥–æ–ª—è–º first)
| cut -d, -f2-          # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) –ø—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) —Å–µ–≥–∞ file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = secs1[key] - secs2
    # —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ (—â–µ –µ –≤–∏–Ω–∞–≥–∏ ‚Üë —Ç—É–∫)
      arrow = "‚Üë"
      # –ø–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –∫–æ–ª–æ–Ω–∏—Ç–µ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # —Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ delta (–Ω–∞–π-–≥–æ–ª—è–º first)
| cut -d, -f2-          # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- –≤—Ç–æ—Ä–∏ —Ñ–∞–π–ª (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ‚Üë –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2), –∏–Ω–∞—á–µ ‚Üì
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "‚Üë" : "‚Üì")

    # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK + SORT + CUT –Ω–∞ –µ–¥–∏–Ω —Ä–µ–¥
awk -F, -v OFS=, '
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    arrow          = (secs1[key] > secs2 ? "‚Üë" : "‚Üì")

    # –ü—ä—Ä–≤–∞ –∫–æ–ª–æ–Ω–∞ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
    print delta, arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta, add arrow, sort and drop the temp column
awk -F, -v OFS=, '
  # 1) –ü—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1 –∏ –∑–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ:
  #      key = BATCH.STAGE FS BATCH FS JOB.NAME
  #      date1[key]    = $4
  #      elapsed1[key] = $8  (–∏ –≤ —Å–µ–∫—É–Ω–¥–∏ secs1[key])
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  # 2) –ü–æ—Å–ª–µ –º–∏–Ω–∞–≤–∞–º–µ file2 –∏ –∑–∞ –≤—Å–µ–∫–∏ —Å—ä—â–∏—è key:
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ diff –≤ ¬±HH:MM:SS
    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2) ‚Äì —Å—Ç—Ä–µ–ª–∫–∞ ‚Üë, –∏–Ω–∞—á–µ ‚Üì
    arrow          = (secs1[key] > secs2 ? "‚Üë" : "‚Üì")

    # –ü—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ —Å—Ç—Ä–µ–ª–∫–∞—Ç–∞+stage –∏ –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \     # —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø–æ delta –Ω–∏–∑—Ö–æ–¥—è—â–æ
| cut -d, -f2-            # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# awk + sort + cut
awk -F, -v OFS=, '
  # –ß–µ—Ç–µ–º –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª: –∑–∞–ø–∞–∑–≤–∞–º–µ –ø–æ –∫–ª—é—á (1,2,3) –¥–∞—Ç–∞—Ç–∞ –∏ elapsed, –∏ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ secs1
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  # –í—Ç–æ—Ä–∏ —Ñ–∞–π–ª: —Å–º—è—Ç–∞–º–µ secs2 –∏ delta
  {
    key    = $1 FS $2 FS $3
    d2     = $4
    e2     = $8
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    # –§–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ diff –∫–∞—Ç–æ ¬±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü—ä—Ä–≤–æ –∫–æ–ª–æ–Ω–∞ —Å delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
    print delta, \
          $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \
| cut -d, -f2-



#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –ù–∞–º–µ—Ä–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞ JT*<–¥–∞—Ç–∞>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

awk -F, -v OFS=, '
  # –ü—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ –ø—ä—Ä–≤–∏—è —Ñ–∞–π–ª –∏ –∑–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ –∑–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á (1,2,3):
  #   - –Ω–µ–≥–æ–≤–∞—Ç–∞ –¥–∞—Ç–∞ (–ø–æ–ª–µ 4)
  #   - elapsed time (–ø–æ–ª–µ 8) –∫–∞–∫—Ç–æ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª, —Ç–∞–∫–∞ –∏ –≤ —Å–µ–∫—É–Ω–¥–∏
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, tt, ":")
    secs1[key]    = tt[1]*3600 + tt[2]*60 + tt[3]
    next
  }

  # –°–µ–≥–∞ –≤—ä–≤ –≤—Ç–æ—Ä–∏—è —Ñ–∞–π–ª –∑–∞ –≤—Å–µ–∫–∏ —Å—ä—â–∏—è –∫–ª—é—á:
  {
    key      = $1 FS $2 FS $3
    d2       = $4
    e2       = $8
    split(e2, tt2, ":")
    secs2    = tt2[1]*3600 + tt2[2]*60 + tt2[3]
    s1       = (key in secs1 ? secs1[key] : 0)
    delta    = secs2 - s1

    # –§–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –≤ ¬±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ –∂–µ–ª–∞–Ω–∏—è —Ä–µ–¥
    print \
      $1,    $2,    $3,          \
      date1[key], elapsed1[key], \
      d2,          e2,            \
      diff
  }
' "$file1" "$file2"




#!/usr/bin/env bash

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –¥–≤–µ –¥–∞—Ç–∏
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –û—Ç–∫—Ä–∏–≤–∞–º–µ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞ JT*<–¥–∞—Ç–∞>*
files1=(JT*${d1}*)
files2=(JT*${d2}*)
if [ ! -f "${files1[0]}" ] || [ ! -f "${files2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
f1=${files1[0]}
f2=${files2[0]}

awk -F, -v OFS=, '
  #
  # –ü—ä—Ä–≤–æ —á–µ—Ç–µ–º —Ñ–∞–π–ª1 (–∑–∞ date1):
  #   key = –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –æ—Ç –ø–æ–ª–µ—Ç–∞ 1..4 (JOB fields)
  #   –∑–∞–ø–∏—Å–≤–∞–º–µ date1, start, stop –∏ elapsed –∏ –ø—Ä–µ—Å–º—è—Ç–∞–º–µ —Å–µ–∫—É–Ω–¥–∏
  #
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4
    date1[key]    = $5        # –ø–æ–ªe 5 –µ –¥–∞—Ç–∞—Ç–∞ –≤—ä–≤ –≤—Ö–æ–¥–Ω–∏—è —Ä–µ–¥
    start1[key]   = $7        # –ø–æ–ª–µ 7 = —Å—Ç–∞—Ä—Ç –≤—Ä–µ–º–µ
    stop1[key]    = $8        # –ø–æ–ª–µ 8 = —Å—Ç–æ–ø –≤—Ä–µ–º–µ
    elapsed1[key] = $9        # –ø–æ–ª–µ 9 = elapsed
    split($9, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  #
  # –°–µ–≥–∞ —á–µ—Ç–µ–º —Ñ–∞–π–ª2 (–∑–∞ date2) –∏ –∑–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á
  # ‚óè –≤–∑–∏–º–∞–º–µ –ø–æ–ª–µ—Ç–∞ 1..4
  # ‚óè –≤–∑–∏–º–∞–º–µ date2, start2, stop2, elapsed2
  # ‚óè —Å–º—è—Ç–∞–º–µ diff = elapsed2 - elapsed1
  #
  {
    key    = $1 FS $2 FS $3 FS $4
    d2     = $5
    s2     = $7
    e2     = $9
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    sign   = ""
    if (delta<0) { sign="-"; delta = -delta }
    hh     = int(delta/3600)
    mm     = int((delta%3600)/60)
    ss     = delta%60
    diff   = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ:
    #  $1,$2,$3,$4 ‚Äî –ø–æ–ª–µ—Ç–∞ –¥–æ JOB.NAME
    #  date1, start1, stop1, elapsed1
    #  date2, start2, stop2, elapsed2
    #  diff
    print \
      $1, $2, $3, $4, \
      date1[key], start1[key], stop1[key], elapsed1[key], \
      d2,       s2,         $8,        e2,        \
      diff
  }
' "$f1" "$f2"




#!/usr/bin/env bash

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

date1=$1
date2=$2

# –ù–∞–º–∏—Ä–∞–º–µ –∏–º–µ–Ω–∞—Ç–∞ –Ω–∞ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞
file1=(JT*${date1}*)
file2=(JT*${date2}*)

if [ ! -f "${file1[0]}" ] || [ ! -f "${file2[0]}" ]; then
  echo "–ù–µ –º–æ–∂–∞—Ö–∞ –¥–∞ —Å–µ –Ω–∞–º–µ—Ä—è—Ç —Ñ–∞–π–ª–æ–≤–µ JT*${date1}* –∏–ª–∏ JT*${date2}*"
  exit 1
fi

file1=${file1[0]}
file2=${file2[0]}

awk -F, -v OFS=, '
  # –ü—Ä–æ—á–∏—Ç–∞–º–µ –ø—ä—Ä–≤–∏—è —Ñ–∞–π–ª, –∑–∞–ø–∞–∑–≤–∞–º–µ Elapsed Time (–ø–æ–ª–µ 8) –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –Ω–∏–∑
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t = $8
    split(t, a, ":")
    secs = a[1]*3600 + a[2]*60 + a[3]
    t1_secs[key] = secs
    t1_str[key]  = t
    next
  }
  # –°–µ–≥–∞ –≤—Ç–æ—Ä–∏—è —Ñ–∞–π–ª: –ø–∞–∫ –ø—Ä–∞–≤–∏–º –∫–ª—é—á–∞ –∏ –≤–∑–∏–º–∞–º–µ –≤—Ä–µ–º–µ t2
  {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t2 = $8
    split(t2, b, ":")
    secs2 = b[1]*3600 + b[2]*60 + b[3]
    secs1 = (key in t1_secs ? t1_secs[key] : 0)
    delta = secs2 - secs1

    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–º–µ delta –≤ HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ –ø–æ–ª–µ—Ç–∞ 1,2,3,4,6,7, original t1, t2 –∏ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞
    print $1, $2, $3, $4, $6, $7, t1_str[key], t2, diff
  }
' "$file1" "$file2"




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Usage: $0 <DATE1> <DATE2>"
  exit 1
fi

DATE1="$1"
DATE2="$2"

FILE1=$(ls JT*"$DATE1"*.CSV 2>/dev/null | head -n 1)
FILE2=$(ls JT*"$DATE2"*.CSV 2>/dev/null | head -n 1)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Missing input files for given dates."
  exit 1
fi

echo "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ $FILE1 —Å $FILE2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,Start1,Stop1,Elapsed1,Start2,Stop2,Elapsed2,–†–∞–∑–ª–∏–∫–∞"

awk -F',' '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
{
  key = $1","$2","$3","$4;
  data[key] = $6","$7","$8;
  elapsed[key] = hms_to_minutes($8);
}
' "$FILE2" > /tmp/jt2.map

awk -F',' -v f2="/tmp/jt2.map" '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
function minutes_to_hhmm(mm,   h, m) {
  sign = (mm < 0) ? "-" : "";
  mm = (mm < 0) ? -mm : mm;
  h = int(mm);
  m = int((mm - h) * 60 + 0.5);
  return sign sprintf("%d:%02d", h, m);
}
BEGIN {
  while ((getline < f2) > 0) {
    split($0, parts, " ");
    split(parts[1], k, "=");
    split(k[2], d, ",");
    key = d[1]","d[2]","d[3]","d[4];
    info[key] = d[5]","d[6]","d[7];
    e2[key] = hms_to_minutes(d[7]);
  }
}
{
  key = $1","$2","$3","$4;
  if (key in info) {
    e1 = hms_to_minutes($8);
    diff = e1 - e2[key];
    printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", $1,$2,$3,$4,$6,$7,$8,info[key],minutes_to_hhmm(diff);
  }
}
' "$FILE1" | sort -t',' -k11,11





#!/bin/bash

d1="$1"
d2="$2"

f1=$(ls JT*${d1}*.CSV 2>/dev/null)
f2=$(ls JT*${d2}*.CSV 2>/dev/null)

if [[ -z "$f1" || -z "$f2" ]]; then
  echo "–§–∞–π–ª(–æ–≤–µ) –Ω–µ —Å–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏."
  exit 1
fi

echo "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ $f1 —Å $f2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,–ü–æ–ª–µ6,–ü–æ–ª–µ7,–î–∞—Ç–∞1 Elapsed,–î–∞—Ç–∞2 Start,–î–∞—Ç–∞2 Stop,–î–∞—Ç–∞2 Elapsed,–†–∞–∑–ª–∏–∫–∞"

join -t, -1 1 -2 1 <(cut -d',' -f1-8 "$f1" | sort) <(cut -d',' -f1-8 "$f2" | sort) | awk -F',' '
function to_seconds(t,  a) {
  split(t, a, ":"); return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs) {
  sign = (secs < 0) ? "-" : "";
  secs = (secs < 0) ? -secs : secs;
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return sign h ":" (m < 10 ? "0" m : m);
}
{
  print $0 > "/tmp/jt_temp.csv"  # –∞–∫–æ –∏—Å–∫–∞—à –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏—à
  e1 = $8; e2 = $16;
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
    $1, $2, $3, $4, $6, $7, e1, $14, $15, e2, to_hhmm(diff)
}
' | sort -t',' -k11 -r




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "–ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ: $0 <DATE1: YYYYMMDD> <DATE2: YYYYMMDD>"
  exit 1
fi

DATE1=$1
DATE2=$2

FILE1=$(ls JT*${DATE1}*.CSV 2>/dev/null)
FILE2=$(ls JT*${DATE2}*.CSV 2>/dev/null)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "–ù—è–∫–æ–π –æ—Ç —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ª–∏–ø—Å–≤–∞:"
  echo "  $FILE1"
  echo "  $FILE2"
  exit 2
fi

echo "–°—Ä–∞–≤–Ω—è–≤–∞–Ω–µ –Ω–∞ $FILE1 —Å $FILE2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "------------------------------------------------------------------"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,–ü–æ–ª–µ6,–ü–æ–ª–µ7,Elapsed1,Elapsed2,–†–∞–∑–ª–∏–∫–∞"

paste -d'\n' "$FILE1" "$FILE2" | paste - - | awk -F'\t' '
function to_seconds(t,  a) {
  split(t, a, ":");
  return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs, h, m) {
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return h ":" (m < 10 ? "0" m : m);
}
{
  split($1, f1, ",");
  split($2, f2, ",");

  e1 = f1[8]; e2 = f2[8];
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s\n", f1[1], f1[2], f1[3], f1[4], f1[6], f1[7], e1, e2, to_hhmm(diff)
}' | sort -t',' -k9 -r



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ —Ö–µ–¥—ä—Ä–∏—Ç–µ
  const total = rows.length;
  const rawValue = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = rawValue + 1;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const total = rows.length;
  const requested = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = Math.min(requested, total); // –ù–µ –ø–æ–∑–≤–æ–ª—è–≤–∞–π –¥–∞ –∏—Å–∫–∞–º–µ –ø–æ–≤–µ—á–µ, –æ—Ç–∫–æ–ª–∫–æ—Ç–æ –∏–º–∞–º–µ

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // —Å–∞–º–æ –¥–∞–Ω–Ω–∏
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows(days) {
  const allRows = Array.from(document.getElementById('eomTable').getElementsByTagName('tr'));
  const dataRows = allRows.slice(2); // –ü—Ä–µ—Å–∫–∞—á–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ –¥–≤–∞ —Ä–µ–¥–∞
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –≤–∏–Ω–∞–≥–∏ –ø–æ–∫–∞–∑–≤–∞–π –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
    } else {
      tr.hidden = (i - 2) < start ? false : true;
    }
  });
}




const visibleRows = Math.min(maxRows, rows.length);
rows.forEach((tr, i) => {
  tr.hidden = i < rows.length - visibleRows;
});






#!/bin/bash

main_log="main_log.txt"
rrex_log="rrex_data.txt"
output_log="merged_log.txt"

> "$output_log"

while IFS= read -r line; do
    # –ò–∑–≤–ª–∏—á–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç —Ñ–æ—Ä–º–∞—Ç–∞ JT.20240520
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # –¢—ä—Ä—Å–∏–º —Å—ä–≤–ø–∞–¥–∞—â —Ä–µ–¥ –≤ RREX —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –ø–æ –ø—ä—Ä–≤–æ—Ç–æ –ø–æ–ª–µ (–¥–∞—Ç–∞—Ç–∞)
        match=$(awk -F'|' -v d="$date" '$1 == d {print $0}' "$rrex_log")

        if [[ -n "$match" ]]; then
            # –í–∑–µ–º–∞–º–µ —Å–∞–º–æ –≤—Ä–µ–º–µ–Ω–∞—Ç–∞
            rrex_start=$(echo "$match" | awk -F'|' '{print $2}' | cut -d' ' -f2)
            rrex_end=$(echo "$match" | awk -F'|' '{print $3}' | cut -d' ' -f2)
            rrex_duration=$(echo "$match" | awk -F'|' '{print $4}')

            echo "$line | RREX_START: $rrex_start | RREX_END: $rrex_end | RREX_DURATION: $rrex_duration" >> "$output_log"
        else
            echo "$line | RREX: N/A" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

main_log="main_log.txt"        # –ª–æ–≥ —Å JT.20240520
rrex_log="rrex_log.txt"        # –ª–æ–≥ —Å—ä—Å Start/End/Duration –∑–∞ –≤—Å—è–∫–∞ –¥–∞—Ç–∞
output_log="enhanced_log.txt"

> "$output_log"

while IFS= read -r line; do
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # –¢—ä—Ä—Å–∏ —Ä–µ–¥ –≤ rrex_log, –∑–∞–ø–æ—á–≤–∞—â —Å –¥–∞—Ç–∞—Ç–∞
        rrex_info=$(awk -F'|' -v d="$date" '$1 == d { print $2, $3, $4 }' "$rrex_log")

        if [[ -n "$rrex_info" ]]; then
            echo "$line | $rrex_info" >> "$output_log"
        else
            echo "$line | [No RREX data]" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

input_log="main_log.txt"
output_log="enhanced_log.txt"
log_dir="./logs"  # –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –¥–∞—Ç–∏

> "$output_log"  # –ø—Ä–∞–∑–Ω–æ –∏–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª

while IFS= read -r line; do
    # –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞—Ç–∞—Ç–∞ —Å–ª–µ–¥ JT.
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]+')

    if [[ -n "$date" ]]; then
        file="$log_dir/$date.log"

        if [[ -f "$file" ]]; then
            # –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ —Ä–µ–¥–∞ —Å—ä—Å Stop, Start, Elapsed (–ø—Ä–∏–º–µ—Ä–Ω–∞ –ª–æ–≥–∏–∫–∞)
            match=$(grep -i 'Stop.*Start.*Elapsed' "$file" | head -n 1)

            # –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ –≤ –∫—Ä–∞—è –Ω–∞ —Ä–µ–¥–∞
            echo "$line $match" >> "$output_log"
        else
            echo "$line [No file for $date]" >> "$output_log"
        fi
    else
        echo "$line [No JT date found]" >> "$output_log"
    fi
done < "$input_log"




def run_advanced_shell_script():
    script_path = os.path.join(BASE_DIR, "scripts", "advanced_log.sh")
    try:
        output = subprocess.check_output(["bash", script_path], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("Shell —Å–∫—Ä–∏–ø—Ç—ä—Ç –∑–∞ advanced –ª–æ–≥ –∞–Ω–∞–ª–∏–∑ –µ –∏–∑–ø—ä–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ.")
        # –ê–∫–æ –∏—Å–∫–∞—à –¥–∞ –≥–æ –∑–∞–ø–∏—à–µ—à:
        result_file = os.path.join(RESULT_DIR, "advanced_combined.log")
        os.makedirs(RESULT_DIR, exist_ok=True)
        with open(result_file, "w") as f:
            f.write(output)
    except subprocess.CalledProcessError as e:
        logging.error(f"Shell —Å–∫—Ä–∏–ø—Ç –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ shell —Å–∫—Ä–∏–ø—Ç–∞: {str(e)}")




import tempfile

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # –°—ä–∑–¥–∞–≤–∞–º–µ –≤—Ä–µ–º–µ–Ω–µ–Ω shell —Å–∫—Ä–∏–ø—Ç —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞—Ç–∞ –ª–æ–≥–∏–∫–∞
    script_content = f"""#!/bin/bash
LIMIT_DATE="{limit_date}"
CHAR_LIMIT={char_limit}
LOG_DIR="{log_dir}"
for f in $LOG_DIR/{log_files}; do
    awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
        /\\[ERROR\\]/ && length($0) >= {char_limit} {{
            log_date = substr($0, 2, 10)
            if (log_date >= limit) {{
                if ($0 ~ /{match_keywords}/) {{
                    match($0, /\\] .*? /, arr)
                    if (arr[1] != "" && arr[1] != "\\\\") {{
                        key = arr[1]
                        print key "|" "[" host "] [" file "] " $0
                    }}
                }}
            }}
        }}
    ' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
"""

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sh", mode="w") as tmpfile:
            tmpfile.write(script_content)
            tmpfile_path = tmpfile.name

        remote_path = f"/tmp/monitor_adv_{host}.sh"

        # –ö–∞—á–≤–∞–º–µ —Å–∫—Ä–∏–ø—Ç–∞ –Ω–∞ –æ—Ç–¥–∞–ª–µ—á–µ–Ω–∞—Ç–∞ –º–∞—à–∏–Ω–∞
        subprocess.run(["scp", tmpfile_path, f"{user}@{host}:{remote_path}"], check=True)

        # –î–∞–≤–∞–º–µ –ø—Ä–∞–≤–∞ –∏ –≥–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞–º–µ –ø—Ä–µ–∑ ssh
        ssh_cmd = f"chmod +x {remote_path} && bash {remote_path} && rm {remote_path}"
        output = subprocess.check_output(["ssh", f"{user}@{host}", ssh_cmd], stderr=subprocess.STDOUT, timeout=60, universal_newlines=True)

        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH/Script –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ advanced_log_filter: {str(e)}")
    finally:
        if os.path.exists(tmpfile_path):
            os.unlink(tmpfile_path)






def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Shell —Å–∫—Ä–∏–ø—Ç, –≤–≥—Ä–∞–¥–µ–Ω –≤ Python (—Ç–æ—á–Ω–æ –∫–∞—Ç–æ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞)
    remote_script = f'''
        LIMIT_DATE="{limit_date}"
        CHAR_LIMIT={char_limit}
        for f in {log_dir}/{{{log_files}}}; do
            awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
                /\\[ERROR\\]/ && length($0) >= {char_limit} {{
                    log_date = substr($0, 2, 10)
                    if (log_date >= limit) {{
                        if ($0 ~ /{match_keywords}/) {{
                            match($0, /\\] .*? /, arr)
                            if (arr[1] != "" && arr[1] != "\\\\") {{
                                key = arr[1]
                                print key "|" "[" host "] [" file "] " $0
                            }}
                        }}
                    }}
                }}
            ' "$f"
        done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
    '''

    ssh_cmd = ["ssh", f"{user}@{host}", remote_script]

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=40, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")







def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dirs = conf.get('log_dirs', 'paths').split(',')

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å—ä–∫ –æ—Ç –ª–æ–≥ —Ñ–∞–π–ª–æ–≤–µ –≤—ä–≤ –≤—Å–∏—á–∫–∏ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    log_patterns = []
    for log_dir in log_dirs:
        log_dir = log_dir.rstrip('/')
        for f in log_files:
            log_patterns.append(f"{log_dir}/{f}")
    log_patterns_str = ' '.join(log_patterns)

    # awk —Å–∫—Ä–∏–ø—Ç (–±–µ–∑ –≤—ä–Ω—à–µ–Ω shell parsing)
    awk_script = (
        f"""/\\[ERROR\\]/ && length($0) > {char_limit} {{
            log_date = substr($0, 2, 19);
            if (log_date >= "{limit_date}") {{
                if ($0 ~ /{match_keywords}/)
                    print host "|" file "|" $0;
            }}
        }}"""
    )

    remote_cmd = f"for file in {log_patterns_str}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"
    ssh_cmd = ["ssh", f"{user}@{host}", remote_cmd]

    logging.debug(f"[{host}] SSH –∫–æ–º–∞–Ω–¥–∞: {' '.join(ssh_cmd)}")

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=30, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")






#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print host \"|\" file \"|\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=20, universal_newlines=True
        )
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan –Ω–µ—É—Å–ø–µ—à–µ–Ω: {str(e)}")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()




[advanced_log_filter]
log_files = mdb.log,runtime.log*,database.log*,ejb.log*
char_limit = 1000
match_keywords = DATABASE|RUNTIME|EJB|MDB



#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] –ó–∞–ø–æ—á–≤–∞ —Å–∫–∞–Ω–∏—Ä–∞–Ω–µ...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
            logging.warning(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {str(e)}")
            logging.error(f"[{host}] SSH –≤—Ä—ä–∑–∫–∞ –Ω–µ—É—Å–ø–µ—à–Ω–∞: {str(e)}")
            break

    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] –ù—è–º–∞ –æ—Ç–∫—Ä–∏—Ç–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏–ª–∏ –Ω—è–º–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.")

    logging.info(f"[{host}] –°–∫–∞–Ω–∏—Ä–∞–Ω–µ –∑–∞–≤—ä—Ä—à–∏.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print \"[advanced] |\" host \"|\" file \":\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=15, universal_newlines=True
        )
        if output:
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced log scan –∑–∞–ø–∏—Å–∞–Ω.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan –Ω–µ—É—Å–ø–µ—à–µ–Ω: {str(e)}")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        scan_host(host, user, log_dirs, keywords)
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()





# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –ª–æ–≥–æ–≤–µ
[log_dirs]
paths = /var/log,/opt/bank/logs

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (–ª–æ–∫–∞–ª–Ω–∏ –∑–∞ –±–µ–∫–µ–Ω–¥–∞)
[file_monitor]
dirs = /var/bank/inbox,/tmp/transactions

# –ö–ª—é—á–æ–≤–∏ –¥—É–º–∏ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ
[keywords]
errors = ERROR,FATAL,EXCEPTION
warnings = WARN,DEPRECATED

# –ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
[users]
admin = root,monitoring_user
readonly = viewer


# Monitoring Framework for Banking VMs

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞
- `config/`: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (.conf –∏ .properties)
- `hosts/`: –°–ø–∏—Å—ä–∫ —Å —Ö–æ—Å—Ç–æ–≤–µ
- `logs/`: –õ–æ–≥–æ–≤–µ –æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∫—Ä–∏–ø—Ç–∞
- `scripts/`: Python —Å–∫—Ä–∏–ø—Ç–æ–≤–µ

## –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
- `common.conf`: —Å—ä–¥—ä—Ä–∂–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –∫–ª—é—á–æ–≤–∏ –¥—É–º–∏ –∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
- `settings.properties`: –ª–æ–≥ –Ω–∏–≤–æ, ssh –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –∏–Ω—Ç–µ—Ä–≤–∞–ª–∏
- `host_list.txt`: –µ–¥–∏–Ω —Ä–µ–¥ = –µ–¥–∏–Ω hostname

## –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ
```bash
cd scripts
python3 monitor.py


# –õ–æ–≥–≤–∞–Ω–µ
log.level=INFO
log.rotation=daily
log.retention_days=7

# SSH –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
backend.host=this-backend-host
remote.user=monitoring_user
connection.timeout=10

# –°–∫–∞–Ω–∏—Ä–∞–Ω–µ
scan.interval=300        # —Å–µ–∫—É–Ω–¥–∏ –º–µ–∂–¥—É –ø—Ä–æ–≤–µ—Ä–∫–∏
scan.parallelism=4       # –ø–∞—Ä–∞–ª–µ–ª–Ω–∏ ssh –∑–∞–¥–∞—á–∏


#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

# –ê—Ä—Ö–∏–≤–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–∞ –ª–æ–∫–∞–ª–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ —Ñ–∞–π–ª–æ–≤–µ
def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

# SSH –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –ª–æ–≥–æ–≤–µ
def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] –ó–∞–ø–æ—á–≤–∞ —Å–∫–∞–Ω–∏—Ä–∞–Ω–µ...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
            logging.warning(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {str(e)}")
            logging.error(f"[{host}] SSH –≤—Ä—ä–∑–∫–∞ –Ω–µ—É—Å–ø–µ—à–Ω–∞: {str(e)}")
            break  # –ø—Ä–µ–∫—ä—Å–≤–∞–º–µ –∞–∫–æ –Ω—è–º–∞ SSH –¥–æ—Å—Ç—ä–ø

    # –ó–∞–ø–∏—Å –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–µ–Ω —Ñ–∞–π–ª
    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] –ù—è–º–∞ –æ—Ç–∫—Ä–∏—Ç–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏–ª–∏ –Ω—è–º–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.")

    logging.info(f"[{host}] –°–∫–∞–Ω–∏—Ä–∞–Ω–µ –∑–∞–≤—ä—Ä—à–∏.")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')

    # Remote log scan
    for host in hosts:
        scan_host(host, user, log_dirs, keywords)

    # Local file check
    monitor_files(conf)

    # Archive results
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()






function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const x = cobMeta.data[i].x;
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const barVal = data.datasets[0].data[i];
              if (barVal > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(barVal);
                ctx.fillText(formatHHMM(barVal), x, y + 12);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





plugins: {
  tooltip: {
    callbacks: {
      label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
    }
  },
  title: {
    display: true,
    text: "EOM COB Elapsed Times",
    font: {
      size: 13,
      weight: "bold"
    },
    color: getTextColor()
  },
  legend: {
    labels: {
      font: { size: 13 },
      color: getTextColor()
    }
  },
  labelsInside: labelsInsidePlugin // —Ç–æ–≤–∞ –µ –∫–ª—é—á–æ–≤–æ
}







const labelsInsidePlugin = {
  id: "labelsInside",
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const meta = chart.getDatasetMeta(0);
    const yScale = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const value = data.datasets[0].data[i];
      if (value > 0) {
        const x = meta.data[i].x;
        const y = yScale.getPixelForValue(value) + 14;
        ctx.fillText(formatHHMM(value), x, y);
      }
    });

    ctx.restore();
  }
};




<div class="chart-container" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime > 0) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const value = data.datasets[0].data[i];
              if (value > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(value) + 12;
                ctx.fillText(formatHHMM(value), x, y);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}
</script>





<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>






function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}







function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}








<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHMM(v),
            maxTicksLimit: 8
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>





function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 13,
              color: "#333"
            }
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v),
            font: {
              size: 13,
              color: "#333"
            }
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      }
    },
    plugins: [{
      id: 'labelsInside',
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const meta = chart.getDatasetMeta(0);
        const yScale = scales.y;

        ctx.save();
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const bar = meta.data[i];
          const value = data.datasets[0].data[i];
          const y = yScale.getPixelForValue(value);
          const x = bar.x;
          if (value > 0) {
            ctx.fillText(formatHMM(value), x, y + 12);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





<table class="rounded" id="eomChartTable">
  <tr>
    <th colspan="6">EOM COB & RR Elapsed Time</th>
  </tr>
  <tr>
    <td colspan="6">
      <div class="chart-container" id="eomChartWrapper">
        <canvas id="eomChart"></canvas>
      </div>
    </td>
  </tr>
</table>



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 },
            color: getTextColor()
          }
        }
      }
    },
    plugins: [
      {
        id: "labelsInside",
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const cobMeta = chart.getDatasetMeta(0);
          const rrMeta = chart.getDatasetMeta(1);
          const yScale = scales.y;

          ctx.save();
          ctx.font = "bold 11px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob = data.datasets[0].data[i] || 0;
            const rr = data.datasets[1].data[i] || 0;
            const total = cob + rr;
            const x = cobMeta.data[i].x;

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }

            if (rr > 0) {
              const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
              ctx.fillText(formatHHMM(rr), x, yRR);
            }

            if (total > 0) {
              const yTotal = yScale.getPixelForValue(total) - 6;
              ctx.fillText(formatHHMM(total), x, yTotal);
            }
          });

          ctx.restore();
        }
      }
    ]
  });

  updateChartsTheme();
}






options: {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    x: {
      stacked: true,
      ticks: {
        maxRotation: 45,
        minRotation: 45
      }
    },
    y: {
      beginAtZero: true,
      ticks: {
        callback: v => formatHHMM(v)
      }
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
      }
    },
    title: {
      display: true,
      text: "EOM COB & RR Elapsed Times",
      font: {
        size: 13,
        weight: "bold"
      },
      color: getTextColor()
    },
    legend: {
      labels: {
        font: { size: 13 }
      }
    }
  }
},
plugins: [
  {
    id: "labelsInside",
    afterDatasetsDraw(chart) {
      const { ctx, data, scales } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);
      const yScale = scales.y;

      ctx.save();
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i] || 0;
        const rr = data.datasets[1].data[i] || 0;
        const total = cob + rr;
        const x = cobMeta.data[i].x;

        if (cob > 0) {
          const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        if (rr > 0) {
          const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        if (total > 0) {
          const yTotal = yScale.getPixelForValue(total) - 6;
          ctx.fillText(formatHHMM(total), x, yTotal);
        }
      });

      ctx.restore();
    }
  }
]




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = cobElapsed[i] || 0;
              const rr = rrElapsed[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}







function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => {
              const raw = ctx.raw || 0;
              return `${ctx.dataset.label}: ${formatHHMM(raw)}`;
            }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCobMid = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCobMid);
              }

              if (rr > 0) {
                const yRRMid = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRRMid);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales: { y } } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i];
              const rr = data.datasets[1].data[i];
              const total = cob + rr;

              const cobTop = y.getPixelForValue(cob);
              const rrTop = y.getPixelForValue(rr);
              const totalTop = y.getPixelForValue(total);
              const cobBottom = y.getPixelForValue(0);
              const rrBottom = y.getPixelForValue(cob);
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (cobTop + cobBottom) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (rrTop + rrBottom) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                ctx.fillText(formatHHMM(total), x, totalTop - 6);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




plugins: [
  {
    id: 'labelsInside',
    afterDatasetsDraw(chart) {
      const { ctx, data, scales: { y } } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);

      ctx.save();
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(rr);
        const totalTop = y.getPixelForValue(total);
        const cobBottom = y.getPixelForValue(0);
        const rrBottom = y.getPixelForValue(cob);

        const x = cobMeta.data[i].x;

        // COB inside
        if (cob > 0) {
          const yCob = (cobTop + cobBottom) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        // RR inside
        if (rr > 0) {
          const yRR = (rrTop + rrBottom) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        // Total on top
        if (total > 0) {
          ctx.fillText(formatHHMM(total), x, totalTop - 6);
        }
      });

      ctx.restore();
    }
  }
]




function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 9) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();
    const rrVal = cells[6].innerText.trim();

    if (date && cobVal && rrVal) {
      dates.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
      rrElapsed.push(parseElapsedToHours(rrVal));
    }
  }

  dates.reverse();
  cobElapsed.reverse();
  rrElapsed.reverse();

  return { dates, cobElapsed, rrElapsed };
}

let eomChartInstance;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) eomChartInstance.destroy();

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
          order: 2
        },
        {
          label: "Duration Limit (2:30)",
          data: Array(dates.length).fill(2.5),
          type: "line",
          borderColor: "red",
          borderDash: [6, 4],
          pointRadius: 0,
          borderWidth: 2,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          max: 7,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: [] // –ü—Ä–∞–∑–Ω–æ, –±–µ–∑ EOM –º–∞—Ä–∫–µ—Ä–∏
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times vs Duration Limit",
          color: getTextColor(),
          font: {
            size: 13,
            weight: "bold"
          }
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [{
      id: "labelsInside",
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const cobMeta = chart.getDatasetMeta(0);
        const yScale = scales.y;
        ctx.save();
        ctx.font = "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const cob = data.datasets[0].data[i];
          const rr = data.datasets[1].data[i];
          const total = cob + rr;
          const x = cobMeta.data[i].x;

          if (cob > 0) {
            const yCob = yScale.getPixelForValue(cob);
            ctx.fillText(formatHHMM(cob), x, yCob);
          }

          if (rr > 0) {
            const yTop = yScale.getPixelForValue(cob + rr);
            const yBottom = yScale.getPixelForValue(cob);
            const yRR = (yTop + yBottom) / 2;
            ctx.fillText(formatHHMM(rr), x, yRR);
          }

          if (total > 0) {
            const yTotal = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, yTotal);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(54, 162, 235, 0.6)",
          borderColor: "rgba(54, 162, 235, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(128, 128, 128, 0.6)",
          borderColor: "rgba(128, 128, 128, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 13 },
            color: "#333"
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: formatHHMM,
            font: { size: 13 },
            color: "#333"
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 13 }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: "#222"
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        datalabels: {
          display: true,
          color: () => document.body.classList.contains("dark-mode") ? "white" : "black",
          font: {
            weight: 'bold',
            size: 11,
            family: 'sans-serif'
          },
          formatter: value => formatHHMM(value)
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [ChartDataLabels]
  });

  updateChartsTheme();
}




function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ header

  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    const date = cells[0].innerText.trim();
    const cob = parseElapsedToHours(cells[3].innerText);
    const rr = parseElapsedToHours(cells[7].innerText);

    dates.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    dates: dates.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}





document.addEventListener("DOMContentLoaded", () => {
  const eomSlider = document.getElementById("eomRange");
  const eomInput = document.getElementById("eomValue");

  function syncEomFromSlider() {
    eomInput.value = eomSlider.value;
    updateEomTableRows();
    renderEOMChart();
  }

  function syncEomFromInput() {
    let value = parseInt(eomInput.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 12) value = 12;
    eomInput.value = value;
    eomSlider.value = value;
    syncEomFromSlider();
  }

  eomSlider.addEventListener("input", syncEomFromSlider);
  eomInput.addEventListener("input", syncEomFromInput);

  syncEomFromSlider(); // Initial load
});





<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


const eomChartWrapper = document.getElementById("eomChartWrapper");

toggleEomBtn.addEventListener("click", () => {
  eomVisible = !eomVisible;
  eomTable.classList.toggle("hidden", !eomVisible);
  eomSliderWrapper.classList.toggle("hidden", !eomVisible);
  eomChartWrapper.classList.toggle("hidden", !eomVisible);

  if (eomVisible) {
    updateEomTableRows();
    renderEOMChart();
  }
});



function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseTimeToMinutes(cells[3].innerText.trim());
    const rrTime = parseTimeToMinutes(cells[6].innerText.trim());

    if (cobTime && rrTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
      rrElapsed.push(rrTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: getEOMAnnotations(labels, cobElapsed)
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      }
    }
  });

  updateChartsTheme();
}






let eomChartInstance = null;

function parseElapsedToHours(str) {
    if (!str || str.length < 8) return 0;
    const parts = str.split(':').map(Number);
    const hours = parts[0];
    const minutes = parts[1];
    const seconds = parts[2];
    return hours + (minutes / 60) + (seconds / 3600);
}

function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 12;

    const dates = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cobTime = parseElapsedToHours(cells[3].innerText.trim());
        const rrTime = parseElapsedToHours(cells[6].innerText.trim());

        if (cobTime && rrTime) {
            dates.push(date);
            cobElapsed.push(cobTime);
            rrElapsed.push(rrTime);
        }
    }

    return {
        labels: dates.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (eomChartInstance) {
        eomChartInstance.destroy();
    }

    eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1"
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1"
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 20,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        font: {
                            size: 13,
                            weight: "bold"
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });

    updateChartsTheme();
}







<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


let eomChartInstance = null;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) {
    eomChartInstance.destroy();
  }

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: {
            stepSize: 1
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: "EOM COB + RR Elapsed Time (stacked)",
          font: {
            size: 13,
            weight: 'bold'
          },
          color: "#222"
        },
        legend: {
          display: true,
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeOutBounce'
      }
    }
  });
}


function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: 






function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
    const labels = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cob = parseTimeToMinutes(cells[3].innerText.trim());
        const rr = parseTimeToMinutes(cells[6].innerText.trim());

        if (cob > 0 || rr > 0) {
            labels.push(date);
            cobElapsed.push(cob);
            rrElapsed.push(rr);
        }
    }

    return {
        labels: labels.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (window.eomChartInstance) {
        window.eomChartInstance.destroy();
    }

    window.eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 10,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        maxTicksLimit: 8,
                        callback: v => formatHHMM(v)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });

    updateChartsTheme();
}



<script>
document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    eomTable.classList.toggle("show", eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });

  function updateEomTableRows() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // Skip headers
    const maxRows = parseInt(eomRange.value, 10);

    rows.forEach((tr, i, arr) => {
      tr.hidden = i < arr.length - maxRows;
    });
  }
});
</script>





#eomTable {
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

#eomTable.show {
  opacity: 1;
  transform: scaleY(1);
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomTable = document.getElementById("eomTable");

let isEomVisible = false;

toggleEomBtn.addEventListener("click", () => {
  isEomVisible = !isEomVisible;
  if (isEomVisible) {
    eomTable.classList.add("show");
  } else {
    eomTable.classList.remove("show");
  }
});





<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <div class="daysValue" id="eomValue">10</div>
    </div>
  </div>
</div>






<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span>
      <span>&nbsp;days</span>
    </div>
  </div>
</div>




document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




<div class="tool-button" id="eomControlWrapper">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <label for="eomRange" id="eomLabel">EOM Days:</label>
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span><span>&nbsp;days</span>
    </div>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);
    
    if (eomVisible) {
      updateEomTableRows(); // –ü—Ä–µ—Å–º—è—Ç–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ, –∫–æ–≥–∞—Ç–æ —Å–µ –ø–æ–∫–∞–∑–≤–∞
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}





<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
</div>
<div id="eomSliderWrapper" class="daysSliderWrapper hidden">
  <label for="eomRange" id="eomLabel">EOM Days:</label>
  <div class="daysInputWrapper">
    <input type="range" id="eomRange" min="3" max="12" value="10" />
    <span id="eomValue">10</span><span>&nbsp;days</span>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
      updateEomTableRows(); // –æ–±–Ω–æ–≤–∏ –ø—Ä–∏ –ø–æ–∫–∞–∑–≤–∞–Ω–µ
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows();
  });
});





function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3
  const totalRows = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < totalRows - maxRows; // —Å–∫—Ä–∏–≤–∞–º–µ –≥–æ—Ä–Ω–∏—Ç–µ
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞—à –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}

if (eomVisible) {
  eomTable.classList.remove("hidden");
  eomSliderWrapper.classList.remove("hidden");
  updateEomTableRows(); // <-- –¢—É–∫ —Å–µ –≤–∏–∫–∞
}



document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows();
});






document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("mousedown", (e) => {
    if (e.target.tagName === 'INPUT') return; // –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è–≤–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –æ—Ç range

    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows(e.target.value); // —Å–∞–º–æ –∞–∫–æ –∏–º–∞—à —Ñ—É–Ω–∫—Ü–∏—è
  });
});




<script>
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });
</script>





toggleEomBtn.addEventListener("click", (event) => {
  // –ò–≥–Ω–æ—Ä–∏—Ä–∞–π –∫–ª–∏–∫–æ–≤–µ –ø–æ –≤–ª–æ–∂–µ–Ω–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤—ä—Ç—Ä–µ –≤ –±—É—Ç–æ–Ω–∞
  if (event.target !== toggleEomBtn && !toggleEomBtn.contains(event.target)) return;

  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});



<div class="tool-button" id="toggleEomBtn">
  <span>Show EOM COBs</span>
  <div id="eomSliderWrapper" class="hidden eom-slider">
    <label for="eomRange" id="eomLabel">EOM COB Days:</label>
    <div id="eomInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10">
      <span id="eomValue">10</span>
      <span>days</span>
    </div>
  </div>
</div>


.eom-slider {
  margin-top: 8px;
  font-size: 13px;
  text-align: center;
}

#eomInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 5px;
}

#eomInputWrapper input[type="range"] {
  width: 85px;
  accent-color: #3b8de3;
}

#eomLabel {
  color: #111;
  font-weight: bold;
}

body.dark-mode #eomLabel {
  color: #eee;
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomSliderWrapper = document.getElementById("eomSliderWrapper");
const eomTable = document.getElementById("eomTable");

toggleEomBtn.addEventListener("click", () => {
  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});

document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows(e.target.value); // –∞–∫–æ –∏–º–∞—à —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ
});







<div class="eom-controls">
  <button id="toggleEomTable" class="tool-button">Show EOM COBs</button>

  <div id="eomSliderWrapper" class="tool-button hidden">
    <label for="eomRange">EOM COB Days:</label>
    <span id="eomValue">10</span>
    <input type="range" id="eomRange" min="3" max="12" value="10" />
  </div>
</div>


.eom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

#eomSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  color: #333;
  margin-right: 5px;
}

#eomSliderWrapper input[type="range"] {
  width: 85px;
  accent-color: #b3e0ff;
}

#eomValue {
  font-size: 13px;
  font-weight: bold;
  color: #111;
  margin: 0 5px;
}

body.dark-mode #eomSliderWrapper label {
  color: #eee;
}
body.dark-mode #eomValue {
  color: #eee;
}


document.getElementById("toggleEomTable").addEventListener("click", () => {
  const table = document.getElementById("eomTable");
  const slider = document.getElementById("eomSliderWrapper");
  table.classList.toggle("hidden");
  slider.classList.toggle("hidden");
});


<button id="toggleEomBtn" class="tool-button">üìÖ Show EOM COBs</button>

<div id="eomDaysSliderWrapper" class="tool-button hidden">
  <label for="eomDaysRange">EOM COB Days:</label>
  <span id="eomDaysValue">10</span>
  <input type="range" min="3" max="12" value="10" id="eomDaysRange" />
</div>

document.addEventListener('DOMContentLoaded', () => {
  const eomBtn = document.getElementById('toggleEomBtn');
  const eomTable = document.getElementById('eomTable');
  const eomSlider = document.getElementById('eomDaysRange');
  const eomValue = document.getElementById('eomDaysValue');
  const eomSliderWrapper = document.getElementById('eomDaysSliderWrapper');

  eomBtn.addEventListener('click', () => {
    const isHidden = eomTable.classList.contains('hidden');
    eomTable.classList.toggle('hidden', !isHidden);
    eomSliderWrapper.classList.toggle('hidden', !isHidden);
  });

  eomSlider.addEventListener('input', () => {
    eomValue.textContent = eomSlider.value;
    updateEomTableRows(); // —Ç—Ä—è–±–≤–∞ –¥–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞, —â–µ –¥–æ–±–∞–≤–∏–º –ª–æ–≥–∏–∫–∞—Ç–∞ –ø–æ—Å–ª–µ
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = parseInt(document.getElementById('eomDaysRange').value, 10);

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}




<button id="toggleEomBtn" class="tool-button">üìÖ Show EOM COBs</button>

<div id="eomSliderWrapper" class="tool-bottom hidden">
  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

#eomSliderWrapper {
  margin-top: 10px;
  font-size: 14px;
}


const toggleEomBtn = document.getElementById('toggleEomBtn');
const eomSliderWrapper = document.getElementById('eomSliderWrapper');
const eomTable = document.getElementById('eomTable'); // –£–≤–µ—Ä–∏ —Å–µ, —á–µ –∏–º–∞ —Ç–∞–∫–∞–≤–∞ —Ç–∞–±–ª–∏—Ü–∞

toggleEomBtn.addEventListener('click', () => {
  eomTable?.classList.toggle('hidden');
  eomSliderWrapper.classList.toggle('hidden');
});

function syncEOMSliderAndInput(value) {
  const v = Math.max(1, Math.min(12, parseInt(value) || 5));
  document.getElementById('eomDaysRange').value = v;
  document.getElementById('eomDaysInput').value = v;
  updateEOMTableRows(v); // –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π —Ç–∞–∑–∏ —Ñ—É–Ω–∫—Ü–∏—è, –∞–∫–æ –æ—â–µ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
}

document.getElementById('eomDaysRange').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));
document.getElementById('eomDaysInput').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));





<div id="cobToolsMenu" class="tools-menu">
  <!-- Existing tools -->
  
  <button onclick="toggleEOMTable()">Show EOM COBs</button>

  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

<table id="eomTable" style="display: none;">
  <!-- Your EOM table rows -->
</table>

<script>
  function toggleEOMTable() {
    const table = document.getElementById('eomTable');
    table.style.display = table.style.display === 'none' ? 'table' : 'none';
  }

  function syncEOMSliderAndInput(value) {
    const v = Math.max(1, Math.min(12, parseInt(value) || 5));
    document.getElementById('eomDaysRange').value = v;
    document.getElementById('eomDaysInput').value = v;
    updateEOMTableRows(v); // –¢—Ä—è–±–≤–∞ –¥–∞ –∏–º–∞—à –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∞ —Ç–∞–∑–∏ —Ñ—É–Ω–∫—Ü–∏—è
  }

  document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('eomDaysRange');
    const input = document.getElementById('eomDaysInput');
    slider.addEventListener('input', () => syncEOMSliderAndInput(slider.value));
    input.addEventListener('input', () => syncEOMSliderAndInput(input.value));
    syncEOMSliderAndInput(5);
  });
</script>




<footer>
  <p style="margin-top: 30px;">
    –ó–∞ –∏–¥–µ–∏/–±—ä–≥–æ–≤–µ, –º–æ–ª—è –ø–∏—à–µ—Ç–µ –≤ –æ—Ñ–∏—Ü–∏–∞–ª–Ω–∞—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–∞ <strong>COB Analyser</strong>.<br>
    <a href="https://your-confluence-link-here" style="color: #66c1ff; text-decoration: none;" target="_blank">
      –û—Ç–≤–æ—Ä–∏ COB Analyser –≤ Confluence
    </a>
  </p>
  <br>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>
  –î–∏–ª—è–Ω
</footer>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7f9;
      color: #333;
      padding: 30px;
      line-height: 1.6;
    }
    .container {
      background-color: #fff;
      border: 1px solid #ddd;
      border-left: 5px solid #007ACC;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }
    h1 {
      font-size: 1.5em;
      color: #007ACC;
    }
    .section {
      margin-top: 20px;
    }
    .highlight {
      background-color: #eef;
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      display: inline-block;
    }
    footer {
      margin-top: 30px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</h1>

    <div class="section">
      –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser –≤ SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <span class="highlight">today_cob_date</span> –µ –ø—Ä–∏–∫—Ä–µ–ø–µ–Ω.
    </div>

    <div class="section">
      <strong>LOG —Ñ–∞–π–ª—ä—Ç</strong>, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:
      <div class="highlight">/opt/t24/support_scripts/cob_analyser/log/</div>
    </div>

    <footer>
      –ü–æ–∑–¥—Ä–∞–≤–∏,<br>
      –î–∏—è–Ω
    </footer>
  </div>
</body>
</html>





<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* –û–±—â —Å—Ç–∏–ª –∑–∞ –∏–º–µ–π–ª–∞ */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }

    /* –¶–µ–Ω—Ç—Ä–∏—Ä–∞—â–∞ —Ç–∞–±–ª–∏—Ü–∞ */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* –•–µ–¥—ä—Ä */
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* –¢—è–ª–æ */
    .email-body {
      padding: 30px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ —Ç–µ–∫—Å—Ç–∞ */
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ –∏ –∫–æ–¥–∞ */
    }

    /* –§—É—Ç—ä—Ä */
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ –ø–æ–¥–ø–∏—Å–∞ */
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</p>
              <p>üìÇ –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser</strong> –≤ <strong>SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <em>today_cob_date</em> –µ –ø—Ä–∏–∫–∞—á–µ–Ω.</p>
              <p>üìÇ LOG —Ñ–∞–π–ª—ä—Ç, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:</p>
              <p><code>/opt/t24/support_scripts/cob_analyser/log</code></p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>–î–∏–ª—è–Ω</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>






<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* –û–±—â —Å—Ç–∏–ª –∑–∞ –∏–º–µ–π–ª–∞ */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }
    /* –¶–µ–Ω—Ç—Ä–∏—Ä–∞—â–∞ —Ç–∞–±–ª–∏—Ü–∞ */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }
    .email-body {
      padding: 30px;
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
    }
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</p>
              <p>üìÇ –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser</strong> –≤ <strong>SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <em>today_cob_date</em> –µ –ø—Ä–∏–∫–∞—á–µ–Ω.</p>
              <p>üìÇ LOG —Ñ–∞–π–ª—ä—Ç, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:<br>
                 <code>/opt/t24/support_scripts/cob_analyser/log</code>
              </p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>–î–∏–ª—è–Ω</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>



for i in {0..11}; do
  last_day=$(date -d "$current_date -$i month -1 day" +%Y%m%d)
  echo "$last_day"

  jtfind="$jt_path/JT_$last_day.csv"

  if [[ -s "$jtfind" ]]; then
    echo "COB $last_day $jtfind"
    echo "-----Started-----"
    cat "$jtfind" | grep A000 | cut -d ',' -f6 | head -1
    echo "-----Stopped-----"
    cat "$jtfind" | grep R999 | cut -d ',' -f7 | head -1
  else
    echo "File not found or empty: $jtfind, skipping..."
  fi
done





function getEOMAnnotations(labels, yData) {
  const annotations = {};
  const topY = Math.max(...yData);  // –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Å–∏–≤–∞ –æ—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç–∏

  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}



function getEOMAnnotations(labels, chart) {
  const annotations = {};
  const topY = Math.max(...chart.data.datasets[0].data);  // –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ Y
  
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,  // –ª–µ–∫–æ –Ω–∞–¥ –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}




function getEOMAnnotations(labels, heights) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      const height = heights?.[i] || 1; // –∞–∫–æ –Ω—è–º–∞ –º–∞—Å–∏–≤, –ø–∞–¥–∞–º–µ –Ω–∞ 1
      const adjustedY = height + 50; // –∏–∑–¥–∏–≥–∞–º–µ —Ç–µ–∫—Å—Ç–∞ —Å 50 –Ω–∞–¥ —Å—Ç—ä–ª–±–∞

      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: adjustedY,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -10,
        rotation: 0
      };
    }
  }

  return annotations;
}





// make sure you‚Äôve imported & registered both Chart.js and chartjs-plugin-annotation before this runs
// e.g.:
//   import { Chart, BarController, BarElement, CategoryScale, LinearScale, Title } from 'chart.js';
//   import annotationPlugin from 'chartjs-plugin-annotation';
//   Chart.register(BarController, BarElement, CategoryScale, LinearScale, Title, annotationPlugin);

let recordsChartInstance;

function renderRecordsChart() {
  // 1) pull your data
  const { labels, recordsPerMinute } = getRecordsData();  // your existing extractor

  // 2) destroy previous chart
  if (recordsChartInstance) recordsChartInstance.destroy();

  // 3) create new one
  const ctx = document.getElementById('recordsChart').getContext('2d');
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: 'rgba(54,162,235,0.6)',
        borderColor:   'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
          stacked: true,
          ticks: { font: { size: 13 }, color: '#333' }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { font: { size: 13 }, color: '#333' }
        }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 14, weight: 'bold' },
          color: '#222'
        },
        annotation: {
          // ask our helper to build a map of annotations:
          annotations: buildEOMAnnotations(recordsChartInstance)
        }
      }
    }
  });
}

/**
 * Walks the chart‚Äôs labels and data, finds month-breaks
 * and returns a map of annotation configs for line + label.
 */
function buildEOMAnnotations(chart) {
  const ann = {};
  const labels = chart.data.labels;
  const data   = chart.data.datasets[0].data;
  const yScale = chart.scales.y;

  labels.forEach((lbl, i) => {
    const next = labels[i + 1];
    // compare YYYYMM prefix of this vs next
    if (next && lbl.slice(0,6) !== next.slice(0,6)) {
      // vertical dashed line
      ann[`eomLine${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: lbl,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6,4],
        borderDashOffset: 2
      };
      // label at the top
      ann[`eomLabel${i}`] = {
        type: 'label',
        xScaleID: 'x',
        xValue: lbl,
        yScaleID: 'y',
        yValue: yScale.max,     // attach to top of the scale
        content: ['EOM'],
        font: { size: 12, weight: 'bold' },
        color: 'orange',
        textAlign: 'center',
        backgroundColor: 'transparent',
        yAdjust: -8             // shift up 8px from top
      };
    }
  });

  return ann;
}

// call on load / whenever you update your table
renderRecordsChart();




function getEOMAnnotationsWithHeights(records, labels) {
    const annotations = {};
    for (let i = 0; i < labels.length - 1; i++) {
        const current = labels[i];
        const next = labels[i + 1];

        if (current.substring(0, 6) !== next.substring(0, 6)) {
            const yVal = records[i] || 0;
            annotations[`line-eom-${i}`] = {
                type: 'line',
                scaleID: 'x',
                value: current,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [6, 4]
            };

            annotations[`text-eom-${i}`] = {
                type: 'label',
                xValue: current,
                yValue: yVal,
                backgroundColor: 'transparent',
                content: ['EOM'],
                font: {
                    size: 12,
                    weight: 'bold'
                },
                color: 'orange',
                textAlign: 'center',
                position: 'start',
                xAdjust: 0,
                yAdjust: -Math.max(20, Math.min(yVal * 0.05, 40)), // –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–Ω–µ
                rotation: 0
            };
        }
    }
    return annotations;
}





function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Records Per Minute',
                    data: recordsPerMinute,
                    backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                    borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                    borderRadius: 15,
                    hoverBorderWidth: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                annotation: {
                    annotations: getEOMAnnotationsWithHeights(recordsPerMinute, labels)
                },
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });

    updateChartsTheme();
}




function getEOMAnnotationsWithHeights(chart) {
  const annotations = [];
  const labels = chart.data.labels;
  const datasets = chart.data.datasets;

  // –ù–∞–º–µ—Ä–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ –¥–Ω–∏ –æ—Ç –º–µ—Å–µ—Ü–∞
  const lastDays = [];
  for (let i = 0; i < labels.length; i++) {
    const current = labels[i].substring(0, 6);
    const next = labels[i + 1]?.substring(0, 6);
    if (current !== next) {
      lastDays.push({ index: i, date: labels[i] });
    }
  }

  // –ó–∞ –≤—Å—è–∫–∞ –¥–∞—Ç–∞ –Ω–∞–º–µ—Ä–∏ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ Y
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(ds => {
      const val = ds.data[index];
      if (typeof val === 'number' && val > maxY) {
        maxY = val;
      }
    });

    annotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [4, 4],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: {
          x: 'end',
          y: 'start'
        },
        yAdjust: -10,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          size: 11,
          weight: 'bold'
        }
      }
    });
  });

  return annotations;
}


const annotations = getEOMAnnotationsWithHeights(chart);

options: {
  // ...
  plugins: {
    annotation: {
      annotations: annotations
    }
  }
}





function getEOMAnnotationsWithHeights(chart, labels, datasets) {
  const eomAnnotations = [];
  const lastDays = [];

  // –ù–∞–º–∏—Ä–∞–º–µ –≤—Å–∏—á–∫–∏ –ø–æ—Å–ª–µ–¥–Ω–∏ –¥–∞—Ç–∏ –∑–∞ –≤—Å–µ–∫–∏ –º–µ—Å–µ—Ü
  for (let i = 0; i < labels.length; i++) {
    const currentDate = labels[i];
    const currentMonth = currentDate.substring(0, 6);
    const nextDate = labels[i + 1];
    const nextMonth = nextDate ? nextDate.substring(0, 6) : null;

    if (currentMonth !== nextMonth) {
      lastDays.push({ index: i, date: currentDate });
    }
  }

  // –ó–∞ –≤—Å—è–∫–∞ —Ç–∞–∫–∞–≤–∞ –¥–∞—Ç–∞ –Ω–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –æ—Ç –≤—Å–∏—á–∫–∏ datasets
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(dataset => {
      const value = dataset.data[index];
      if (typeof value === 'number' && value > maxY) {
        maxY = value;
      }
    });

    eomAnnotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [6, 3],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: 'end',
        yAdjust: -8,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          weight: 'bold'
        }
      },
      yMax: maxY
    });
  });

  return eomAnnotations;
}





function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };
      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: 1, // –ù—è–º–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, —â–µ –≥–æ –∫–æ—Ä–∏–≥–∏—Ä–∞–º–µ —Å—ä—Å yAdjust
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -30, // —Ç–æ–≤–∞ –º–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞–¥ –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
        rotation: 0
      };
    }
  }
  return annotations;
}







function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          xAdjust: 30,
          yAdjust: -5,
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}





<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // –ò–∑–≤–ª–∏—á–∞–º–µ –º–µ—Å–µ—Ü –∏ –≥–æ–¥–∏–Ω–∞ –æ—Ç –¥–∞—Ç–∞—Ç–∞ (—Ñ–æ—Ä–º–∞—Ç YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (‚ÄúClose-Of-Business‚Äù or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	‚Ä¢	Start & Stop Times for each day‚Äôs batch run
	‚Ä¢	Elapsed Duration (how long the entire COB took)
	‚Ä¢	Throughput (records or transactions processed per minute)
	‚Ä¢	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	‚Ä¢	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	‚Ä¢	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	‚Ä¢	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	‚Ä¢	Bar charts for throughput (records per minute) and COB durations
	‚Ä¢	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	‚Ä¢	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	‚Ä¢	Automatic warnings for missing batches, slow batches, and restarts during COB
	‚Ä¢	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues‚Äîwithout manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # –æ–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ø–∏—Å—ä–∫ –æ—Ç —Ñ–∞–π–ª–æ–≤–µ
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # –æ–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ø–∏—Å—ä–∫ –æ—Ç –æ—Ç–¥–∞–ª–µ—á–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh ‚Äî Secure Upload/Download/Cleanup wrapper with ‚Äìall & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we‚Äôre in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} ‚Äî Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * –ü—Ä–æ–º–µ–Ω—è —à–∏—Ä–∏–Ω–∞—Ç–∞ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ
 * —Å–ø—Ä—è–º–æ –±—Ä–æ—è –¥–Ω–∏:
 *   3‚Äì10  –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-0-10
 *  11‚Äì20  –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-11-20
 *  21‚Äì31+ –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // –º–∞—Ö–∞–º–µ –≤—Å–∏—á–∫–∏ –ø—Ä–µ–¥–∏—à–Ω–∏
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // —Å–ª–∞–≥–∞–º–µ –Ω–æ–≤–∏—è
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // –æ–≥—Ä–∞–Ω–∏—á–∞–≤–∞–º–µ 3‚Äì31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) —Å–∫—Ä–∏–≤–∞–º–µ/–ø–æ–∫–∞–∑–≤–∞–º–µ —Ä–µ–¥–æ–≤–µ
    updateTableRows(v);
    // 2) –ø—Ä–µ–∏–∑—á–µ—Ä—Ç–∞–≤–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) –Ω–∞—Å—Ç—Ä–æ–π–≤–∞–º–µ —à–∏—Ä–∏–Ω–∞—Ç–∞
    updateContainerWidth(v);
  }

  // —Å–ª—É—à–∞–º–µ –ø—Ä–æ–º–µ–Ω–∏ –∏ –æ—Ç –¥–≤–∞—Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∞
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ ‚Äì 10 –¥–Ω–∏
  syncSliderAndInput(10);
});




// 1) –í–∑–∏–º–∞–º–µ —Å–∞–º–æ –≤–∏–¥–∏–º–∏—Ç–µ (–Ω–µ—Å–∫—Ä–∏—Ç–∏) –¥–∞–Ω–Ω–∏ –æ—Ç —Ç–∞–±–ª—Ü–∞—Ç–∞
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 header-—Ä–µ–¥–∞ –∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ —Å–∞–º–æ –Ω–µ—Å–∫—Ä–∏—Ç–∏—Ç–µ
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ (–∏–ª–∏ –ø—Ä–µ-—Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ) COB-–≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // –∞–∫–æ –≤–µ—á–µ –∏–º–∞–º–µ Chart, –ø—ä—Ä–≤–æ –≥–æ —É–Ω–∏—â–æ–∂–∞–≤–∞–º–µ
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // —Å–∞–º–æ –≤–∏–¥–∏–º–∏—Ç–µ —Ä–µ–¥–æ–≤–µ

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ –∑–∞–≥–ª–∞–≤–∫–∞—Ç–∞
    const visibleRows = rows.filter(row => !row.hidden); // –í–ó–ò–ú–ê–® –°–ê–ú–û –í–ò–î–ò–ú–ò–¢–ï —Ä–µ–¥–æ–≤–µ

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // –∫–∞–∫—Ç–æ –≥–æ—Ä–µ
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // –∫–∞–∫—Ç–æ –≥–æ—Ä–µ
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏–µ—Ç–æ
    const selectedRows = dataRows.slice(-maxDays); // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ä–µ–¥–∞

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // –ü–æ—Å–ª–µ–¥–Ω–∏—Ç–µ "days" —Ä–µ–¥–∞
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // –î–∞—Ç–∞
            values.push(parseElapsedTime(cells[1].innerText.trim())); // –í—Ä–µ–º–µ –≤ —Å–µ–∫—É–Ω–¥–∏
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // –í–∑–∏–º–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
    const trend = calculateTrendline(values);         // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ —Ç—Ä–µ–Ω–¥ –ª–∏–Ω–∏—è—Ç–∞
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // —É–Ω–∏—â–æ–∂–∞–≤–∞–º–µ —Å—Ç–∞—Ä–∞—Ç–∞ –≥—Ä–∞—Ñ–∏–∫–∞ –∞–∫–æ –∏–º–∞
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ä–µ–¥–∞

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // –ü—Ä–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // –ü—Ä–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // –°—Ç–∞—Ä—Ç–æ–≤–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ - 10 –¥–Ω–∏
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // –ü—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // –ü—Ä–∏ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –∏–Ω–ø—É—Ç
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper –∑–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞ —Å default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- –∑–∞ Records per Minute –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip –∑–∞–≥–ª–∞–≤–∏—è
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –µ–ª–µ–º–µ–Ω—Ç–∞
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —Ç–≤–æ–π –≤–∫—É—Å */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- –∑–∞ COB elapsed –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// –ø—Ä–∏ –≤—Å—è–∫–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ –∏ –¥—Ä—É–≥–∏—Ç–µ –≥—Ä–∞—Ñ–∏–∫–∏
});

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-–∏, –∞–∫–æ –≤–µ—á–µ –Ω—è–º–∞—à —Ç–∞–∫–∏–≤–∞:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 (header-–∏)
    return getAllRows().slice(2);
  }

  // –¢–æ—á–Ω–æ —Ç–≤–æ–µ—Ç–æ –ø–æ—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // –±—Ä–æ–π, –∫–æ–π—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –ø–æ–∫–∞–∑–≤–∞–º–µ
    const count = Math.max(minRows, Math.min(days, total));
    // –∏–Ω–¥–µ–∫—Å –≤ dataRows, –æ—Ç –∫–æ–π—Ç–æ –∑–∞–ø–æ—á–≤–∞–º–µ –¥–∞ –ø–æ–∫–∞–∑–≤–∞–º–µ
    const firstToShow = total - count;

    // –≤–∏–Ω–∞–≥–∏ –ø–æ–∫–∞–∑–≤–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ 2 —Ä–µ–¥–∞
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è slider ‚Üî input –∏ initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 10 –¥–Ω–∏
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // –∫–æ–≥–∞—Ç–æ –º—ä—Ä–¥–∞–º–µ —Å–ª–∞–π–¥–µ—Ä–∞
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // –∞–∫–æ –∏—Å–∫–∞—à –¥–∞ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞—à –∏ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ:
      renderIDsChart();
      renderCOBChart();
    });

    // –∫–æ–≥–∞—Ç–æ –ø—Ä–æ–º–µ–Ω–∏–º —Ä—ä—á–Ω–æ –≤ –ø–æ–ª–µ—Ç–æ
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // –°–ª–∞–≥–∞–º–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // –í—Ä—ä–∑–∫–∞ –º–µ–∂–¥—É —Å–ª–∞–π–¥–µ—Ä–∞ –∏ –∏–Ω–ø—É—Ç–∞
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // –§—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ –≤—Å–∏—á–∫–∏ <tr>
    const dataRows = getDataRows(); // –§—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ —Å–∞–º–æ –≤–∞–ª–∏–¥–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ (–±–µ–∑ —Ö–µ–¥—ä—Ä–∞)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // –ü–æ–∫–∞–∑–≤–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // –ù–ï –ø–æ–≤–µ—á–µ –æ—Ç —Ä–µ–¥–æ–≤–µ—Ç–µ
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø–æ–∫–∞–∑–≤–∞–º–µ 10 –¥–Ω–∏
  updateTableRows(10);

  // –ó–∞–∫–∞—á–∞–º–µ —Å–ª—É—à–∞—Ç–µ–ª–∏ –∑–∞ –ø—Ä–æ–º—è–Ω–∞
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 –¥–µ–Ω–∞
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// –ü—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ header-–∏—Ç–µ
  const visibleCount = Math.max(days, 3); // –º–∏–Ω–∏–º—É–º 3 –¥–µ–Ω–∞ –≤–∏–¥–∏–º–∏
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper –∑–∞ –¥–∞ –≤–∑–µ–º–µ–º —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Å–ª–∞–π–¥–µ—Ä–∞ (–∏ –¥–∞ –∏–º–∞–º–µ –≤–∏–Ω–∞–≥–∏ –ø–æ–Ω–µ 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) –∞–¥–∞–ø—Ç–∏—Ä–∞–Ω–∞ getRecordsData(), –≤—Ä—ä—â–∞ —Å–∞–º–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ –¥–≤–∞ <tr> (header-–∏—Ç–µ)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // –≤–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ maxDays —Ä–µ–¥–∞ (–æ–±—Ä–∞—Ç–µ–Ω —Ä–µ–¥ –∑–∞ —É–¥–æ–±–Ω–æ –ø–æ–ø—ä–ª–≤–∞–Ω–µ)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) –∞–¥–∞–ø—Ç–∏—Ä–∞–Ω–∞ getCOBDataFromTable(), –≤—Ä—ä—â–∞ —Å–∞–º–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ —Å–∞–º–æ –∑–∞–≥–ª–∞–≤–Ω–∏—è <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // –≤–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ maxDays —Ä–µ–¥–∞
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() ‚Äì –≤–µ—á–µ –ø–æ–ª–∑–≤–∞ dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* ‚Ä¶ */],
        borderColor:     ['rgba(255,99,132,1)',   /* ‚Ä¶ */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() ‚Äì –≤–µ—á–µ –ø–æ–ª–∑–≤–∞ dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) –±–∏–Ω–¥–∏—Ä–∞–º–µ –∫—ä–º slider-–∞ –¥–∞ —Ä–µ-—Ä–∏—Å—É–≤–∞ –∏ –¥–≤–µ—Ç–µ
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// –≥–æ—Ç–æ–≤–æ ‚Äî —Å–∞–º–æ —Ç–µ–∑–∏ 5 –±–ª–æ–∫–∞ –¥–æ–±–∞–≤—è—à/–∑–∞–º–µ—Å—Ç–≤–∞—à, –æ—Å—Ç–∞–Ω–∞–ª–æ—Ç–æ –Ω–µ —Å–µ –ø—Ä–æ–º–µ–Ω—è. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// –û–±–Ω–æ–≤—è–≤–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ —Å –Ω–æ–≤–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ header —Ä–µ–¥–æ–≤–µ—Ç–µ
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ —Å–ª–∞–π–¥–µ—Ä–∞ -> input –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ input -> —Å–ª–∞–π–¥–µ—Ä–∞ –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –ó–∞–∫–∞—á–∞–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// –û–±–Ω–æ–≤—è–≤–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ —Å –Ω–æ–≤–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ header —Ä–µ–¥–æ–≤–µ—Ç–µ
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ —Å–ª–∞–π–¥–µ—Ä–∞ -> input –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ input -> —Å–ª–∞–π–¥–µ—Ä–∞ –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –ó–∞–∫–∞—á–∞–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// –í–∑–∏–º–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ä–µ–¥–æ–≤–µ –æ—Ç —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// –û–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –≤–∏–¥–∏–º–∏—Ç–µ —Ä–µ–¥–æ–≤–µ —Å–ø–æ—Ä–µ–¥ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏ –∑–∞ COB –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏ –∑–∞ ID –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// –ü–æ–º–æ—â–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –ø–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ –≤—Ä–µ–º–µ
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–æ–≤–∞—Ç–∞ COB –≥—Ä–∞—Ñ–∏–∫–∞
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–æ–≤–∞—Ç–∞ ID –≥—Ä–∞—Ñ–∏–∫–∞
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–µ–∫—É–Ω–¥–∏ –∫—ä–º HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–ª–∞–π–¥–µ—Ä–∞
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // –Ω–æ–≤–æ!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // –Ω–æ–≤–æ!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // –ü—Ä–µ—Å–∫–∞—á–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : '‚òÄÔ∏è';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // –î–æ–±–∞–≤—è–º–µ –∏–º–µ –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // –ü—Ä–∞–∑–µ–Ω —Ä–µ–¥ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∏—Ç–µ
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">‚úÖ Export Selected</button>
  <button id="exportAllBtn" class="small-button">‚¨áÔ∏è Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">‚ùå Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // –ø—Ä–∞–∑–µ–Ω —Ä–µ–¥ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∏—Ç–µ
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">üìÑ Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">‚úÖ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">‚ùå Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* –ø–æ–¥ "Export CSV" –±—É—Ç–æ–Ω–∞ */
  left: 180px; /* –∏–∑–Ω–∞—Å—è —Å–µ –≤–¥—è—Å–Ω–æ */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">üìÑ Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- –ê–∫–æ –∏—Å–∫–∞—à –º–æ–∂–µ –¥–∞ –¥–æ–±–∞–≤–∏—à –æ—â–µ —á–µ–∫–±–æ–∫—Å–æ–≤–µ -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">‚úÖ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">‚ùå Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- –ê–∫–æ –∏–º–∞—à –æ—â–µ —Ç–∞–±–ª–∏—Ü–∏ –¥–æ–±–∞–≤—è—à —Ç—É–∫ -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ —á–µ–∫–±–æ–∫—Å –ø—Ä–æ–∑–æ—Ä–µ—Ü
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –≤—Å–∏—á–∫–∏ —Å–∞ –º–∞—Ä–∫–∏—Ä–∞–Ω–∏

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // –ó–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –º–æ–¥–∞–ª –ø—Ä–æ–∑–æ—Ä–µ—Ü–∞
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : 'üåû';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* –ó–∞ —Å–≤–µ—Ç—ä–ª —Ñ–æ–Ω */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* –ó–∞ —Ç—ä–º–µ–Ω —Ñ–æ–Ω */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* –°–ª–∞–π–¥—ä—Ä —Ü–≤–µ—Ç—ä—Ç */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // —Ç—É–∫ –∏–∑–≤–∏–∫–≤–∞—à –∫–∞–∫–≤–æ—Ç–æ –æ—â–µ –∏—Å–∫–∞—à –∫–∞—Ç–æ update –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–∏, —Ç–∞–±–ª–∏—Ü–∏ –∏ —Ç.–Ω.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // –∑–∞ –¥–∞ —Å–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞ –ø—Ä–∞–≤–∏–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : 'üåû';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* –ü—Ä–µ–º–µ—Å—Ç–≤–∞–Ω–µ –∑–∞–µ–¥–Ω–æ —Å —Ç–µ–∫—Å—Ç–∞ */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = 'üåô';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = 'üåû';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">üåû</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">‚òÄÔ∏è</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? 'üåô' : '‚òÄÔ∏è';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">‚òÄÔ∏è</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? 'üåô' : '‚òÄÔ∏è';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // –≤—Å–∏—á–∫–∏ <tr>
  const dataRows = getDataRows();  // —Å–∞–º–æ <tr> –∑–∞ –¥–∞–Ω–Ω–∏
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –ø–æ–∫–∞–∑–≤–∞–º–µ –≤–∏–Ω–∞–≥–∏ header-–∏—Ç–µ
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // –≤—Å–∏—á–∫–∏ tr (–≤–∫–ª. th + tr)
  const dataRows = getDataRows(); // —Å–∞–º–æ –¥–∞–Ω–Ω–∏—Ç–µ
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –ø—ä—Ä–≤–∏—Ç–µ –¥–≤–∞ (header) –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 —Ä–µ–¥–∞ —Å <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º–∞–ª–Ω–æ 3 –¥–Ω–∏
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // –ó–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ 2 –∑–∞–≥–ª–∞–≤–Ω–∏ —Ä–µ–¥–∞
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º–∞–ª–Ω–æ 3 –¥–Ω–∏
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // –ó–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ 2 –∑–∞–≥–ª–∞–≤–Ω–∏ —Ä–µ–¥–∞

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // –º–∏–Ω–∏–º—É–º 3 –¥–Ω–∏, –Ω–µ 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // –ú–∏–Ω–∏–º—É–º 3 –¥–Ω–∏
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // –∞–∫–æ –∏—Å–∫–∞—à –∏ CPU –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ –¥–∞ —Å–µ –∞–¥–∞–ø—Ç–∏—Ä–∞!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // –ó–∞ –¥–∞ —Å–µ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞—Ç –ø—Ä–∞–≤–∏–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 –¥–Ω–∏
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 —Ä–µ–¥–∞
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø–æ–∫–∞–∑–≤–∞–º–µ –∏–∑–±—Ä–∞–Ω–∏—è –±—Ä–æ–π –¥–Ω–∏
    daysValue.textContent = `${daysRange.value} days`;

    // –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ –æ—â–µ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    renderIDsChart();
    renderTimingChart();

    // –°–ª—É—à–∞–º–µ –∑–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –ø–ª—ä–∑–≥–∞—á–∞
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // –ò–∑—Ç—Ä–∏–≤–∞–º–µ —Å—Ç–∞—Ä–∏—Ç–µ –≥—Ä–∞—Ñ–∏–∫–∏ –ø—Ä–µ–¥–∏ –¥–∞ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –Ω–æ–≤–∏
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ –æ—Ç–Ω–æ–≤–æ —Å–ø–æ—Ä–µ–¥ –Ω–æ–≤–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

