<script>
  // --- Запазваме инстанции, за да можем да ги destroy-нем при рефреш ---
  let recordsChartInstance;
  let timingChartInstance;

  /**
   * Връща labels + recordsPerMinute само за последните N дни,
   * където N е зададено в <input id="daysRange">.
   */
  function getRecordsData() {
    const table = document.getElementById("recordsTable");
    // всички редове без header-а
    const rows = Array.from(table.getElementsByTagName("tr")).slice(1);
    // само валидните редове с 10 клетки
    const valid = rows.filter(r => r.getElementsByTagName("td").length === 10);
    // колко дни искаме
    const days = parseInt(document.getElementById("daysRange").value, 10);
    // стойности от последните days
    const slice = valid.slice(-days);

    const labels = [];
    const recordsPerMinute = [];
    slice.forEach(row => {
      const cells = row.getElementsByTagName("td");
      const date = cells[0].innerText.trim();
      // helper: parseTimeToMinutes вече е дефиниран в твоя код
      const elapsed = parseTimeToMinutes(cells[4].innerText.trim());
      const txCount = parseInt(cells[5].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(txCount / elapsed);
      }
    });
    return { labels, recordsPerMinute };
  }

  /**
   * Рисува или рефрешва recordsChart-а спрямо последните N дни.
   */
  function renderRecordsChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById("recordsChart").getContext("2d");

    if (recordsChartInstance) {
      recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Records Per Minute',
          data: recordsPerMinute,
          backgroundColor: [
            'rgba(255, 99, 132, 0.6)',
            'rgba(54, 162, 235, 0.6)',
            'rgba(75, 192, 192, 0.6)'
          ],
          borderColor: [
            'rgba(255, 99, 132, 1)',
            'rgba(54, 162, 235, 1)',
            'rgba(75, 192, 192, 1)'
          ],
          borderWidth: 2,
          borderRadius: 15,
          hoverBorderWidth: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            stacked: true,
            ticks: {
              font: { size: 13 },
              color: "#333"
            }
          },
          y: {
            stacked: true,
            beginAtZero: true,
            ticks: {
              font: { size: 13 },
              color: "#333"
            }
          }
        },
        plugins: {
          legend: {
            display: false
          },
          title: {
            display: true,
            text: "Records Processed per minute",
            font: { size: 13, weight: 'bold' },
            color: "#222"
          },
          tooltip: {
            callbacks: {
              label(ctx) {
                return ctx.dataset.label + ": " + ctx.formattedValue;
              }
            }
          }
        },
        animation: {
          duration: 1500,
          easing: 'easeOutBounce'
        }
      }
    });
  }

  /**
   * Връща всички time-series масиви само за последните N дни.
   */
  function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(1)
      .filter(r => r.getElementsByTagName("td").length === 10);
    const days = parseInt(document.getElementById("daysRange").value, 10);
    const slice = rows.slice(-days);

    const dates = [];
    const ilc03time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a77time = [];
    const baseMinutes = parseTimeToMinutes("12:00:00");

    slice.forEach(row => {
      const cells = row.getElementsByTagName("td");
      const date = cells[0].innerText.trim();
      function adjust(tStr) {
        const m = parseTimeToMinutes(tStr.trim());
        return m < baseMinutes ? m + 1440 : m;
      }

      dates.push(date);
      ilc03time.push(adjust(cells[1].innerText));
      cobStart.push(adjust(cells[2].innerText));
      cobStop.push(adjust(cells[3].innerText));
      rrStart.push(adjust(cells[6].innerText));
      rrStop.push(adjust(cells[7].innerText));
      a77time.push(adjust(cells[9].innerText));
    });

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time };
  }

  /**
   * Рисува или рефрешва timingChart-а спрямо последните N дни.
   */
  function renderTimingChart() {
    const {
      dates, ilc03time, cobStart, cobStop,
      rrStart, rrStop, a77time
    } = getTimingChartData();
    const ctx = document.getElementById("timingChart").getContext("2d");

    if (timingChartInstance) {
      timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: dates,
        datasets: [
          {
            label: 'ILC03 Time',
            data: ilc03time,
            borderColor: 'rgba(155,99,132,1)',
            tension: 0.3
          },
          {
            label: 'COB Start Time',
            data: cobStart,
            borderColor: 'rgba(255,99,132,1)',
            tension: 0.3
          },
          {
            label: 'COB End Time',
            data: cobStop,
            borderColor: 'rgba(54,162,235,1)',
            tension: 0.3
          },
          {
            label: 'RR Start Time',
            data: rrStart,
            borderColor: 'rgba(75,192,192,1)',
            tension: 0.3
          },
          {
            label: 'RR Stop Time',
            data: rrStop,
            borderColor: 'rgba(175,92,192,1)',
            tension: 0.3
          },
          {
            label: 'A770 Time',
            data: a77time,
            borderColor: 'rgba(54,113,35,1)',
            tension: 0.3
          },
          {
            label: 'ILC03 Cutoff (22:30)',
            data: Array(dates.length).fill(1350),
            borderColor: getCutoffColor(),
            borderDash: [10,5],
            pointRadius: 0,
            borderWidth: 2
          },
          {
            label: 'RR Cutoff (01:30)',
            data: Array(dates.length).fill(1530),
            borderColor: 'orange',
            borderDash: [10,5],
            pointRadius: 0,
            borderWidth: 2
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            min: 1200, max: 1680,
            ticks: {
              callback(value) {
                const h = Math.floor(value / 60) % 24;
                const m = Math.floor(value % 60);
                return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
              },
              font: { size: 13 },
              color: "#333"
            }
          }
        },
        plugins: {
          legend: {
            display: false,
            labels: {
              font: { size: 13, weight: 'bold' },
              color: "#444"
            }
          },
          title: {
            display: true,
            text: 'COB & RR Times vs Cutoff Threshold',
            font: { size: 13, weight: 'bold' },
            color: getCutoffColor()
          }
        },
        animation: {
          duration: 1500,
          easing: 'easeOutBounce'
        }
      }
    });
  }

  // === Hook към слайдъра ===
  document.getElementById('daysRange').addEventListener('input', () => {
    // label вече се ъпдейта в твоя код
    renderRecordsChart();
    renderTimingChart();
  });

  // първоначално зареждане
  renderRecordsChart();
  renderTimingChart();
</script>



/**
 * Скрива всички table-rows извън последните N, където
 * N = max(days, 3)
 */
function updateTableRows(days) {
  const rows = Array.from(
    document.getElementById('recordsTable')
            .getElementsByTagName('tr')
  ).slice(1);  // пропускаме header-а
  const n = rows.length;

  // Колко да покажем (най-малко 3)
  const visibleCount = Math.max(days, 3);
  // Индексът, от който започваме да показваме
  const start = Math.max(0, n - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start;
  });
}

plugins: [{
  id: 'labelsInside',
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const cobMeta = chart.getDatasetMeta(0);
    // RR колоните са върху COB, но взимаме техния мета вече за изчисления
    const yScale  = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const cob   = data.datasets[0].data[i];
      const rr    = data.datasets[1].data[i];
      const total = cob + rr;
      const x     = cobMeta.data[i].x;

      // COB етикет вътре в синята част
      if (cob > 0) {
        const cobTop    = yScale.getPixelForValue(cob);
        const cobBottom = yScale.getPixelForValue(0);
        const yCob      = (cobTop + cobBottom) / 2;
        ctx.fillText(formatHHMM(cob), x, yCob);
      }

      // RR етикет вътре в сивата част
      if (rr > 0) {
        const rrTop     = yScale.getPixelForValue(total);
        const rrBottom  = yScale.getPixelForValue(cob);
        const yRr       = (rrTop + rrBottom) / 2;
        ctx.fillText(formatHHMM(rr), x, yRr);
      }

      // Total над колоната
      if (total > 0) {
        const yTotal = yScale.getPixelForValue(total) - 6;
        ctx.fillText(formatHHMM(total), x, yTotal);
      }
    });

    ctx.restore();
  }
}]





/**
 * Скрива table-rows извън текущия range:
 * - при days ≤ 10: остава видим само последните 10
 * - при days > 10: остава видим само последните days
 */
function updateTableRows(days) {
  const rows = Array.from(
    document.getElementById('recordsTable')
            .getElementsByTagName('tr')
  ).slice(1);  // пропускаме header-а
  const n = rows.length;

  // Ако нямаме поне 1 ред, нищо не правим
  if (n === 0) return;

  // Започваме от този индекс
  const start = days <= 10
    ? Math.max(0, n - 10)    // винаги последните 10, ако могат
    : Math.max(0, n - days); // или последните days

  rows.forEach((tr, i) => {
    tr.hidden = i < start;
  });
}



/**
 * Скрива (hidden) всички table-rows извън текущия range,
 * но само когато days > 10. Последните 10 винаги остават видими.
 */
function updateTableRows(days) {
  // всички редове, без header-а
  const rows = Array.from(
    document.getElementById('recordsTable')
            .getElementsByTagName('tr')
  ).slice(1);
  const n = rows.length;

  if (days > 10) {
    // index от k до n-1 ще са видими, където k = n - days
    const k = n - days;
    rows.forEach((tr, i) => {
      // ако i < k – скрий, иначе – покажи
      tr.hidden = i < k;
    });
  } else {
    // days ≤ 10: не пипаме таблицата – махаме hidden на всички
    rows.forEach(tr => tr.hidden = false);
  }
}


function onDaysChange() {
  const days = parseInt(slider.value, 10);
  label.textContent = days;

  updateContainerWidth(days);
  updateTableRows(days);    // <— добавяш го тук
  renderElapsedChart();     // вече той рисува графиката
}
