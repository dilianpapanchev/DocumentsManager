use std::env;
use std::fs::{self, DirEntry, Metadata};
use std::io;
use std::path::{Path, PathBuf};
use std::time::Instant;

fn get_size(path: &Path) -> u64 {
    match fs::metadata(path) {
        Ok(metadata) => {
            if metadata.is_file() {
                metadata.len()
            } else if metadata.is_dir() {
                let mut size = 0;
                if let Ok(entries) = fs::read_dir(path) {
                    for entry in entries.filter_map(Result::ok) {
                        let entry_path = entry.path();
                        size += get_size(&entry_path);
                    }
                }
                size
            } else {
                0
            }
        }
        Err(_) => 0,
    }
}

fn collect_entries(path: &Path, results: &mut Vec<(PathBuf, u64)>) {
    if let Ok(entries) = fs::read_dir(path) {
        for entry in entries.filter_map(Result::ok) {
            let entry_path = entry.path();
            let size = get_size(&entry_path);
            results.push((entry_path.clone(), size));
            if entry_path.is_dir() {
                collect_entries(&entry_path, results);
            }
        }
    }
}

fn main() -> io::Result<()> {
    let start = Instant::now();

    let args: Vec<String> = env::args().collect();
    let root_path = if args.len() > 1 {
        PathBuf::from(&args[1])
    } else {
        env::current_dir()?
    };

    println!("Analyzing: {}", root_path.display());

    let mut results = Vec::new();
    collect_entries(&root_path, &mut results);

    results.sort_by(|a, b| b.1.cmp(&a.1)); // сортиране по големина (намаляващо)

    println!("\nTop 20 biggest files/directories:");
    for (path, size) in results.iter().take(20) {
        println!("{:<10} {}", format_size(*size), path.display());
    }

    println!("\nDone in {:.2?}", start.elapsed());
    Ok(())
}

fn format_size(size: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if size >= GB {
        format!("{:.2} GB", size as f64 / GB as f64)
    } else if size >= MB {
        format!("{:.2} MB", size as f64 / MB as f64)
    } else if size >= KB {
        format!("{:.2} KB", size as f64 / KB as f64)
    } else {
        format!("{} B", size)
    }
}








#!/usr/bin/env python3
"""
disk_analyser.py

Recursively walks through a directory tree on a Linux system,
calculates total sizes for each directory (including its children),
and prints the top-N largest directories/files in human-readable form.

Usage:
    python3 disk_analyser.py /path/to/scan --top 10

If --top is omitted, it defaults to 10. If no path is given, it uses the current directory.
"""

import os
import argparse
import sys
from collections import defaultdict

def parse_args():
    parser = argparse.ArgumentParser(
        description="Scan a directory recursively and report the largest directories or files."
    )
    parser.add_argument(
        "root_path",
        nargs="?",
        default=".",
        help="Path to the directory you want to analyze (default: current directory)."
    )
    parser.add_argument(
        "--top",
        "-t",
        type=int,
        default=10,
        help="Number of top entries to display (default: 10)."
    )
    parser.add_argument(
        "--dirs-only",
        action="store_true",
        help="Show only directories (skip individual files)."
    )
    parser.add_argument(
        "--files-only",
        action="store_true",
        help="Show only files (skip aggregating directory totals)."
    )
    return parser.parse_args()

def sizeof_fmt(num_bytes, suffix="B"):
    """
    Convert a size in bytes to a human-readable string.
    e.g. 1024 -> "1.0KB", 1048576 -> "1.0MB"
    """
    for unit in ["", "K", "M", "G", "T", "P", "E"]:
        if abs(num_bytes) < 1024.0:
            return f"{num_bytes:.1f}{unit}{suffix}"
        num_bytes /= 1024.0
    return f"{num_bytes:.1f}Z{suffix}"

def accumulate_sizes(root):
    """
    Walk through the directory tree starting at `root`.
    Returns two mappings:
      1) dir_size_map: maps each directory path to the total size (in bytes) of all files under it.
      2) file_size_map: maps each file path to its size in bytes.
    """
    dir_size_map = defaultdict(int)
    file_size_map = {}

    # os.walk yields (dirpath, dirnames, filenames)
    for dirpath, dirnames, filenames in os.walk(root, onerror=_walk_error, followlinks=False):
        total_size_in_dir = 0
        for fname in filenames:
            fpath = os.path.join(dirpath, fname)
            try:
                stat = os.stat(fpath, follow_symlinks=False)
                size = stat.st_size
            except (OSError, PermissionError):
                # Skip files we can't access
                continue

            file_size_map[fpath] = size
            total_size_in_dir += size

        # Add this directory's own files to its entry
        dir_size_map[dirpath] += total_size_in_dir

        # Propagate size upward: every parent directory gets this total
        parent = dirpath
        while True:
            parent = os.path.dirname(parent.rstrip(os.sep))
            if not parent or parent == dirpath:
                break
            dir_size_map[parent] += total_size_in_dir
            dirpath = parent

    return dir_size_map, file_size_map

def _walk_error(err):
    """
    Handler for os.walk errors (e.g., permission issues).
    Just print a warning to stderr and continue.
    """
    sys.stderr.write(f"Warning: cannot access {err.filename}: {err.strerror}\n")

def main():
    args = parse_args()
    root = os.path.abspath(args.root_path)

    if not os.path.exists(root):
        print(f"Error: The path '{root}' does not exist.")
        sys.exit(1)

    # Build maps of sizes
    dir_size_map, file_size_map = accumulate_sizes(root)

    items = []
    if not args.files_only:
        # Include directories (with aggregated sizes)
        for dpath, total in dir_size_map.items():
            items.append((total, dpath, "dir"))
    if not args.dirs_only:
        # Include individual files
        for fpath, size in file_size_map.items():
            items.append((size, fpath, "file"))

    # Sort by size descending
    items.sort(key=lambda x: x[0], reverse=True)

    # Print header
    print(f"\nTop {args.top} largest {'directories and files' if not (args.files_only or args.dirs_only) else ('directories' if args.dirs_only else 'files')} under '{root}':\n")
    print(f"{'Type':<6}  {'Size':>10}  Path")
    print(f"{'-'*6}  {'-'*10}  {'-'*60}")

    count = 0
    for total, path, kind in items:
        human = sizeof_fmt(total)
        label = "DIR" if kind == "dir" else "FILE"
        print(f"{label:<6}  {human:>10}  {path}")
        count += 1
        if count >= args.top:
            break

    print()

if __name__ == "__main__":
    main()






// disk_usage_html.cpp
// ==============
// Compile with:
//   g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html
// If you see “undefined reference to `std::filesystem::…’” errors, add “-lstdc++fs” at the end:
//   g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html -lstdc++fs

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <string>

namespace fs = std::filesystem;

struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte count into a human-readable string (e.g. "1.23 MB")
static std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024.0 && unitIndex < 4) {
        readableSize /= 1024.0;
        ++unitIndex;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// URL‐encode a few characters so <a href="file://…"> works
static std::string urlEncode(const std::string& path) {
    std::ostringstream oss;
    for (char c : path) {
        switch (c) {
            case ' ' : oss << "%20"; break;
            case '"' : oss << "%22"; break;
            case '#' : oss << "%23"; break;
            case '%' : oss << "%25"; break;
            case '&' : oss << "%26"; break;
            case '\'' : oss << "%27"; break;
            case '+' : oss << "%2B"; break;
            case ',' : oss << "%2C"; break;
            case '/' : oss << "/";   break; // leave slash as-is
            case ':' : oss << "%3A"; break;
            case ';' : oss << "%3B"; break;
            case '<' : oss << "%3C"; break;
            case '=' : oss << "%3D"; break;
            case '>' : oss << "%3E"; break;
            case '?' : oss << "%3F"; break;
            case '[' : oss << "%5B"; break;
            case '\\': oss << "%5C"; break;
            case ']' : oss << "%5D"; break;
            case '^' : oss << "%5E"; break;
            case '`' : oss << "%60"; break;
            case '{' : oss << "%7B"; break;
            case '|' : oss << "%7C"; break;
            case '}' : oss << "%7D"; break;
            case '~' : oss << "%7E"; break;
            default:
                if (static_cast<unsigned char>(c) >= 0x20 && static_cast<unsigned char>(c) <= 0x7E) {
                    oss << c;
                } else {
                    oss << "%"
                        << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                        << (static_cast<int>(static_cast<unsigned char>(c)))
                        << std::dec << std::nouppercase;
                }
        }
    }
    return oss.str();
}

// Collect files in dirPath up to two levels deep
static void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath
static void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Write out a complete HTML report called “disk_usage.html”
static void generateHtmlReport(const std::vector<FileEntry>& files, uintmax_t totalSize) {
    std::ofstream html("disk_usage.html");
    if (!html.is_open()) {
        std::cerr << "Error: could not open disk_usage.html for writing.\n";
        return;
    }

    // Use a raw‐string literal with custom delimiter R"HTML(... )HTML"
    html << R"HTML(<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disk Usage Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 8px 12px; border: 1px solid #ccc; }
    th { background-color: #f2f2f2; cursor: pointer; }
    tr:nth-child(even) { background-color: #fafafa; }
    tr:hover { background-color: #f1f1f1; }
    caption { font-size: 1.2em; margin-bottom: 10px; font-weight: bold; }
    .total-row { font-weight: bold; background-color: #e8e8e8; }
  </style>
</head>
<body>

<h2>Disk Usage Report</h2>
<p>Generated by <code>disk_usage_html</code>. Click on a column header to sort. Click a file path to open (in your file‐manager or default handler).</p>

<table id="usageTable">
  <caption>Files and Sizes</caption>
  <thead>
    <tr>
      <th onclick="sortTable(0)">Size</th>
      <th onclick="sortTable(1)">Path</th>
    </tr>
  </thead>
  <tbody>
)HTML";

    // One HTML row per file entry
    for (auto const& fe : files) {
        std::string hrSize = humanReadableSize(fe.size);
        std::string filePath = fe.path.string();
        std::string url = std::string("file://") + urlEncode(filePath);

        html << "    <tr>\n";
        html << "      <td>" << hrSize << "</td>\n";
        html << "      <td><a href=\"" << url << "\">" << filePath << "</a></td>\n";
        html << "    </tr>\n";
    }

    // Close out the table and insert a “Total” footer row
    html << R"HTML(  </tbody>
  <tfoot>
    <tr class="total-row">
      <td colspan="2">Total disk usage: )HTML"
         << humanReadableSize(totalSize)
         << R"HTML(</td>
    </tr>
  </tfoot>
</table>

<script>
// Simple table‐sorting script (sort strings or human‐readable sizes).
function sortTable(colIndex) {
  var table = document.getElementById("usageTable");
  var tbody = table.tBodies[0];
  var rows = Array.from(tbody.querySelectorAll("tr"));

  // If we clicked the same column twice, reverse
  if (tbody.getAttribute("data-sort-col") == colIndex) {
    rows.reverse();
    tbody.setAttribute("data-sort-col", -1);
  } else {
    rows.sort(function(a, b) {
      var aText = a.cells[colIndex].innerText.trim();
      var bText = b.cells[colIndex].innerText.trim();

      if (colIndex === 0) {
        // Column 0 is “Size” (like “1.23 MB”). Convert to bytes:
        function parseHR(s) {
          var parts = s.split(" ");
          var num = parseFloat(parts[0]);
          var unit = parts[1];
          var factor = 1;
          switch (unit) {
            case "TB": factor = 1024 * 1024 * 1024 * 1024; break;
            case "GB": factor = 1024 * 1024 * 1024; break;
            case "MB": factor = 1024 * 1024; break;
            case "KB": factor = 1024; break;
            default:   factor = 1; break;
          }
          return num * factor;
        }
        return parseHR(aText) - parseHR(bText);
      } else {
        // Column 1 is “Path,” do a string compare
        return aText.localeCompare(bText);
      }
    });
    tbody.setAttribute("data-sort-col", colIndex);
  }

  // Re-attach sorted rows
  rows.forEach(function(r) {
    tbody.appendChild(r);
  });
}
</script>

</body>
</html>
)HTML";

    html.close();
    std::cout << "HTML report written to disk_usage.html\n"
              << "Open it in your web browser to view.\n";
}

// Scans directory (two levels or recursive) and builds the HTML report
static void analyzeAndGenerate(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << "\n";
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        } else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort descending by size
        std::sort(files.begin(), files.end(),
            [](auto const& a, auto const& b) {
                return a.size > b.size;
            });

        // Sum up total sizes
        for (auto const& fe : files) {
            totalSize += fe.size;
        }

        // Finally, write the HTML
        generateHtmlReport(files, totalSize);
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << "\n";
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "\n=== Disk Usage (HTML report) ===\n\n";
    std::cout << "Enter directory path: ";
    std::getline(std::cin, pathInput);
    if (pathInput.empty()) {
        std::cerr << "No path entered. Exiting.\n";
        return 1;
    }

    std::cout << "Recursive scan? (y/n): ";
    std::cin >> recursiveChoice;
    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');

    analyzeAndGenerate(pathInput, recursive);
    return 0;
}








// disk_usage_html.cpp
// Compile with: g++ -std=c++17 disk_usage_html.cpp -o disk_usage_html
// (If you get undefined-reference errors on std::filesystem, add -lstdc++fs at the end.)

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <string>

namespace fs = std::filesystem;

// Simple struct to hold (path, size).
struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte count into a human-readable string (e.g. "1.23 MB").
static std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024.0 && unitIndex < 4) {
        readableSize /= 1024.0;
        ++unitIndex;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// URL-encode spaces and a few other characters so that <a href="file://..."> links work in the browser.
static std::string urlEncode(const std::string& path) {
    std::ostringstream oss;
    for (char c : path) {
        switch (c) {
            case ' ' : oss << "%20"; break;
            case '"' : oss << "%22"; break;
            case '#' : oss << "%23"; break;
            case '%' : oss << "%25"; break;
            case '&' : oss << "%26"; break;
            case '\'' : oss << "%27"; break;
            case '+' : oss << "%2B"; break;
            case ',' : oss << "%2C"; break;
            case '/' : oss << "/";   break; // keep forward slash as is
            case ':' : oss << "%3A"; break;
            case ';' : oss << "%3B"; break;
            case '<' : oss << "%3C"; break;
            case '=' : oss << "%3D"; break;
            case '>' : oss << "%3E"; break;
            case '?' : oss << "%3F"; break;
            case '[' : oss << "%5B"; break;
            case '\\': oss << "%5C"; break;
            case ']' : oss << "%5D"; break;
            case '^' : oss << "%5E"; break;
            case '`' : oss << "%60"; break;
            case '{' : oss << "%7B"; break;
            case '|' : oss << "%7C"; break;
            case '}' : oss << "%7D"; break;
            case '~' : oss << "%7E"; break;
            default:
                // For any character in the ASCII printable range, leave as-is.
                if (static_cast<unsigned char>(c) >= 0x20 && static_cast<unsigned char>(c) <= 0x7E) {
                    oss << c;
                } else {
                    // Percent-encode anything outside that range:
                    oss << "%" << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                        << (static_cast<int>(static_cast<unsigned char>(c))) 
                        << std::dec << std::nouppercase;
                }
                break;
        }
    }
    return oss.str();
}

// Collect files in dirPath up to two levels deep (no recursion beyond grandchildren).
static void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            // One level deeper
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath.
static void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Generate a simple HTML report named "disk_usage.html" in the current directory.
static void generateHtmlReport(const std::vector<FileEntry>& files, uintmax_t totalSize) {
    std::ofstream html("disk_usage.html");
    if (!html.is_open()) {
        std::cerr << "Error: could not open disk_usage.html for writing.\n";
        return;
    }

    // Basic HTML + inline CSS for a clean table.
    html << R"(<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disk Usage Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 8px 12px; border: 1px solid #ccc; }
    th { background-color: #f2f2f2; cursor: pointer; }
    tr:nth-child(even) { background-color: #fafafa; }
    tr:hover { background-color: #f1f1f1; }
    caption { font-size: 1.2em; margin-bottom: 10px; font-weight: bold; }
    .total-row { font-weight: bold; background-color: #e8e8e8; }
  </style>
</head>
<body>

<h2>Disk Usage Report</h2>
<p>Generated by <code>disk_usage_html</code>. Click on a column header to sort. Click a file path to open (in your file-manager or default handler).</p>

<table id="usageTable">
  <caption>Files and Sizes</caption>
  <thead>
    <tr>
      <th onclick="sortTable(0)">Size</th>
      <th onclick="sortTable(1)">Path</th>
    </tr>
  </thead>
  <tbody>
)";

    // Write one row per file
    for (auto const& fe : files) {
        std::string hrSize = humanReadableSize(fe.size);
        std::string filePath = fe.path.string();
        // Make a file:// URL. On Linux, "file:///home/..." is typical.
        // We'll percent-encode the path so spaces/characters work.
        std::string url = std::string("file://") + urlEncode(filePath);

        html << "    <tr>\n";
        html << "      <td>" << hrSize << "</td>\n";
        html << "      <td><a href=\"" << url << "\">" << filePath << "</a></td>\n";
        html << "    </tr>\n";
    }

    // Final “Total” row (spanning both columns)
    html << R"(  </tbody>
  <tfoot>
    <tr class="total-row">
      <td colspan="2">Total disk usage: )"
         << humanReadableSize(totalSize) 
         << R"(</td>
    </tr>
  </tfoot>
</table>

<script>
// Simple table-sorting script (sorts strings or human-readable sizes).
function sortTable(colIndex) {
  var table = document.getElementById("usageTable");
  var tbody = table.tBodies[0];
  var rows = Array.from(tbody.querySelectorAll("tr"));

  // If we clicked the same column twice, reverse order.
  if (tbody.getAttribute("data-sort-col") == colIndex) {
    rows.reverse();
    tbody.setAttribute("data-sort-col", -1);
  } else {
    // Sort ascending by default
    rows.sort(function(a, b) {
      var aText = a.cells[colIndex].innerText.trim();
      var bText = b.cells[colIndex].innerText.trim();

      if (colIndex === 0) {
        // Column 0 is "Size" which is in “1.23 MB” human-readable. Convert to bytes:
        function parseHR(s) {
          var parts = s.split(" ");
          var num = parseFloat(parts[0]);
          var unit = parts[1];
          var factor = 1;
          switch (unit) {
            case "TB": factor = 1024 * 1024 * 1024 * 1024; break;
            case "GB": factor = 1024 * 1024 * 1024; break;
            case "MB": factor = 1024 * 1024; break;
            case "KB": factor = 1024; break;
            default:   factor = 1; break;
          }
          return num * factor;
        }
        return parseHR(aText) - parseHR(bText);
      } else {
        // Column 1 is “Path,” so string compare
        return aText.localeCompare(bText);
      }
    });
    tbody.setAttribute("data-sort-col", colIndex);
  }

  // Re-attach rows in new order
  rows.forEach(function(r) {
    tbody.appendChild(r);
  });
}
</script>

</body>
</html>)";

    html.close();
    std::cout << "HTML report written to disk_usage.html\n"
              << "Open it in your web browser to view.\n";
}

// Scan directory (two levels) or recursively based on 'recursive', then produce HTML table.
static void analyzeAndGenerate(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << "\n";
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        } else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort descending by size so largest files appear first
        std::sort(files.begin(), files.end(),
            [](auto const& a, auto const& b) {
                return a.size > b.size;
            });

        // Compute total size
        for (auto const& fe : files) {
            totalSize += fe.size;
        }

        // Generate HTML
        generateHtmlReport(files, totalSize);
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << "\n";
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "\n=== Disk Usage (HTML report) ===\n\n";
    std::cout << "Enter directory path: ";
    std::getline(std::cin, pathInput);
    if (pathInput.empty()) {
        std::cerr << "No path entered. Exiting.\n";
        return 1;
    }

    std::cout << "Recursive scan? (y/n): ";
    std::cin >> recursiveChoice;
    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');

    analyzeAndGenerate(pathInput, recursive);
    return 0;
}





// disk_usage.cpp
// Compile with: g++ -std=c++17 disk_usage.cpp -o disk_usage [-lstdc++fs]

#include <iostream>
#include <filesystem>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>

namespace fs = std::filesystem;

struct FileEntry {
    fs::path path;
    uintmax_t size;
};

// Convert a raw byte‐count into a human‐readable string (e.g. "1.23 MB")
std::string humanReadableSize(uintmax_t size) {
    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    int unitIndex = 0;
    double readableSize = static_cast<double>(size);

    while (readableSize >= 1024 && unitIndex < 4) {
        readableSize /= 1024;
        ++unitIndex;
    }

    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readableSize << " " << units[unitIndex];
    return out.str();
}

// Collect files in dirPath up to two levels deep (no recursion beyond grandchildren)
void collectFilesTwoLevels(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
        else if (fs::is_directory(entry.path())) {
            // Now iterate one level deeper
            for (auto const& subEntry : fs::directory_iterator(entry.path())) {
                if (fs::is_regular_file(subEntry.path())) {
                    files.push_back({ subEntry.path(), fs::file_size(subEntry.path()) });
                }
            }
        }
    }
}

// Recursively collect every file under dirPath
void collectFilesRecursive(const fs::path& dirPath, std::vector<FileEntry>& files) {
    for (auto const& entry : fs::recursive_directory_iterator(dirPath)) {
        if (fs::is_regular_file(entry.path())) {
            files.push_back({ entry.path(), fs::file_size(entry.path()) });
        }
    }
}

// Analyze disk usage, either two‐levels deep or fully recursive based on 'recursive'
void analyzeDiskUsage(const fs::path& dirPath, bool recursive) {
    std::vector<FileEntry> files;
    uintmax_t totalSize = 0;

    try {
        if (!fs::exists(dirPath) || !fs::is_directory(dirPath)) {
            std::cerr << "Invalid directory: " << dirPath << std::endl;
            return;
        }

        if (recursive) {
            collectFilesRecursive(dirPath, files);
        }
        else {
            collectFilesTwoLevels(dirPath, files);
        }

        // Sort files descending by size
        std::sort(files.begin(), files.end(),
                  [](const FileEntry& a, const FileEntry& b) {
                      return a.size > b.size; 
                  });

        // Print each file's size and path
        for (auto const& file : files) {
            totalSize += file.size;
            std::cout 
                << std::setw(10) << humanReadableSize(file.size) 
                << "\t" 
                << file.path 
                << std::endl;
        }

        std::cout << "\nTotal disk usage: " << humanReadableSize(totalSize) << std::endl;
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Filesystem error: " << e.what() << std::endl;
    }
}

int main() {
    std::string pathInput;
    char recursiveChoice;

    std::cout << "Enter directory path: ";
    std::cin  >> pathInput;

    std::cout << "Recursive scan? (y/n): ";
    std::cin  >> recursiveChoice;

    bool recursive = (recursiveChoice == 'y' || recursiveChoice == 'Y');
    analyzeDiskUsage(pathInput, recursive);

    return 0;
}





#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    if (depth > max_depth) return 0;
    std::uintmax_t size = 0;
    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir, int max_depth, std::uintmax_t min_size_bytes) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    try {
        for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
            if (fs::is_directory(entry)) {
                std::uintmax_t total = get_size(entry.path(), 1, max_depth);
                if (total >= min_size_bytes)
                    raw_data.emplace_back(entry.path().string(), total);
            }
        }
    } catch (...) {
        return {};
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::string current_path = fs::current_path().string();

    while (true) {
        std::vector<std::string> entries;
        entries.push_back(".. (Back)");

        try {
            for (const auto& entry : fs::directory_iterator(current_path, fs::directory_options::skip_permission_denied)) {
                if (fs::is_directory(entry))
                    entries.push_back(entry.path().string());
            }
        } catch (...) {
            entries.clear();
        }

        if (entries.size() <= 1) {
            clear();
            mvprintw(0, 0, "No accessible subdirectories. Press any key to go back.");
            getch();
            current_path = fs::path(current_path).parent_path().string();
            continue;
        }

        std::sort(entries.begin() + 1, entries.end());
        int highlight = 0, start = 0;

        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter = open, q = quit)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);
                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";
                mvprintw(i + 1, 0, "%s", display.c_str());
                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {
                if (highlight == 0) {
                    current_path = fs::path(current_path).parent_path().string();
                    break;
                } else if (highlight > 0 && highlight < (int)entries.size()) {
                    current_path = entries[highlight];
                    break;
                }
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }

        clear();
        mvprintw(0, 0, "Use this directory? %s [y/n]", current_path.c_str());
        int ch = getch();
        if (ch == 'y' || ch == 'Y')
            return current_path;
    }
}

int choose_depth() {
    int depth = 2;
    while (true) {
        clear();
        mvprintw(0, 0, "Select analysis depth (1–5): Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current depth: %d", depth);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') depth = std::min(depth + 1, 5);
        else if (ch == '-') depth = std::max(depth - 1, 1);
    }
    return depth;
}

int choose_min_size() {
    int size_mb = 0;
    while (true) {
        clear();
        mvprintw(0, 0, "Filter out directories smaller than X MB. Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current minimum size: %d MB", size_mb);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') size_mb = std::min(size_mb + 10, 10000);
        else if (ch == '-') size_mb = std::max(size_mb - 10, 0);
    }
    return size_mb;
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Results (press q to quit)");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;
            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        int depth = choose_depth();
        int min_mb = choose_min_size();
        auto data = analyze_dir(selected, depth, static_cast<std::uintmax_t>(min_mb) * 1024 * 1024);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No directories matched the criteria. Press any key to exit.");
            getch();
        }
    }

    endwin();
    return 0;
}








g++ -std=c++17 -o disk_usage_ui_enhanced disk_usage_ui_enhanced.cpp -lncurses -lstdc++fs





#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    if (depth > max_depth) return 0;
    std::uintmax_t size = 0;
    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir, int max_depth, std::uintmax_t min_size_bytes) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, max_depth);
            if (total >= min_size_bytes)
                raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::string current_path = fs::current_path().string();

    while (true) {
        std::vector<std::string> entries;
        entries.push_back(".. (Back)");
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin() + 1, entries.end());

        int highlight = 0, start = 0;
        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter = open)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);
                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";
                mvprintw(i + 1, 0, "%s", display.c_str());
                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {
                if (highlight == 0) {
                    current_path = fs::path(current_path).parent_path().string();
                    break;
                } else {
                    current_path = entries[highlight];
                    break;
                }
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }

        // Confirm selection
        clear();
        mvprintw(0, 0, "Use this directory? %s [y/n]", current_path.c_str());
        int ch = getch();
        if (ch == 'y' || ch == 'Y')
            return current_path;
    }
}

int choose_depth() {
    int depth = 2;
    while (true) {
        clear();
        mvprintw(0, 0, "Select analysis depth (1–5): Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current depth: %d", depth);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') depth = std::min(depth + 1, 5);
        else if (ch == '-') depth = std::max(depth - 1, 1);
    }
    return depth;
}

int choose_min_size() {
    int size_mb = 0;
    while (true) {
        clear();
        mvprintw(0, 0, "Filter directories smaller than X MB. Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current minimum size: %d MB", size_mb);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') size_mb = std::min(size_mb + 10, 10000);
        else if (ch == '-') size_mb = std::max(size_mb - 10, 0);
    }
    return size_mb;
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Results (press q to quit)");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;
            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        int depth = choose_depth();
        int min_mb = choose_min_size();
        auto data = analyze_dir(selected, depth, static_cast<std::uintmax_t>(min_mb) * 1024 * 1024);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No directories matched the criteria.");
            getch();
        }
    }

    endwin();
    return 0;
}







#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    std::uintmax_t size = 0;
    if (depth > max_depth) return 0;

    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, 2);
            raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::vector<std::string> entries;
    std::string current_path = ".";

    while (true) {
        entries.clear();
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin(), entries.end());
        int highlight = 0, start = 0;

        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter to select, q to quit)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);

                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";

                mvprintw(i + 1, 0, "%s", display.c_str());

                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {  // Enter
                current_path = entries[highlight];
                return current_path;
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }
    }
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Linux Disk Usage - q to quit");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        auto data = analyze_dir(selected);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No subdirectories found.");
            getch();
        }
    }

    endwin();
    return 0;
}





g++ -std=c++17 -o disk_usage file.cpp -lncurses -lstdc++fs






#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = { "B", "KB", "MB", "GB", "TB" };
    double readable_size = static_cast<double>(size);
    int i = 0;

    while (readable_size >= 1024 && i < 4) {
        readable_size /= 1024;
        ++i;
    }

    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable_size << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_directory_size(const fs::path& dir_path) {
    std::uintmax_t size = 0;

    for (const auto& entry : fs::recursive_directory_iterator(dir_path, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_regular_file(entry.status()))
                size += fs::file_size(entry.path());
        } catch (...) {}
    }

    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_usage(const fs::path& root) {
    std::vector<std::pair<std::string, std::uintmax_t>> dir_sizes;

    for (const auto& entry : fs::directory_iterator(root, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            auto size = get_directory_size(entry.path());
            dir_sizes.emplace_back(entry.path().string(), size);
        }
    }

    std::sort(dir_sizes.begin(), dir_sizes.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : dir_sizes)
        result.emplace_back(path, human_readable(size));

    return result;
}

void draw_ui(const std::vector<std::pair<std::string, std::string>>& data) {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    int height, width;
    getmaxyx(stdscr, height, width);

    int start = 0;
    int highlight = 0;

    while (true) {
        clear();
        mvprintw(0, 0, "Linux Disk Usage Analyzer - Press 'q' to Quit");
        mvhline(1, 0, '-', width);

        int visible_lines = height - 3;
        for (int i = 0; i < visible_lines && (start + i) < (int)data.size(); ++i) {
            if (highlight == (start + i)) {
                attron(A_REVERSE);
            }

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > width - 15)
                name = name.substr(0, width - 18) + "...";

            mvprintw(i + 2, 0, "%-*s %12s", width - 15, name.c_str(), size.c_str());

            if (highlight == (start + i)) {
                attroff(A_REVERSE);
            }
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + visible_lines) start = highlight - visible_lines + 1;
    }

    endwin();
}

int main(int argc, char* argv[]) {
    fs::path target_dir = ".";

    if (argc > 1)
        target_dir = argv[1];

    if (!fs::exists(target_dir) || !fs::is_directory(target_dir)) {
        std::cerr << "Invalid directory: " << target_dir << "\n";
        return 1;
    }

    auto data = analyze_usage(target_dir);
    draw_ui(data);
    return 0;
}






body {
    font-family: 'Segoe UI', sans-serif;
    margin: 0;
    padding: 20px;
    background: #f4f469;
    color: #333;
    transition: background 0.3s ease;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    font-size: 2.2em;
    text-shadow: 1px 1px 2px #ccc;
}

.toolbar {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}

.toolbar input[type="text"],
.toolbar input[type="date"] {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    width: 200px;
    background: #fff;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    transition: all 0.2s ease-in-out;
}

.toolbar input[type="text"]:focus,
.toolbar input[type="date"]:focus {
    outline: none;
    border-color: #b3e0ff;
    box-shadow: 0 0 5px #b3e0ff;
}

.toolbar label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
}

.toolbar input[type="checkbox"] {
    transform: scale(1.2);
    transition: transform 0.2s ease-in-out;
}

table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    border: 1px solid #b3e0ff;
    overflow: hidden;
    transition: box-shadow 0.3s ease;
}

th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #b3e0ff;
    border-right: 1px solid #b3e0ff;
}

th {
    background-color: #b3e0ff;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: background 0.2s ease;
    white-space: nowrap;
}

th:hover {
    background-color: #e9f0f9;
}

th.sorted-asc::after,
th.sorted-desc::after {
    content: ' ▼';
    font-weight: bold;
    font-size: 12px;
    margin-left: 4px;
    vertical-align: middle;
    line-height: 1;
}

th.sorted-desc::after {
    content: ' ▲';
}

td.diff-positive {
    background-color: #daedda;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.diff-negative {
    background-color: #e8d7da;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.max-elapsed {
    background-color: #fff3cd;
    font-weight: bold;
}

.page-title {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
}

.page-title .title-icon {
    width: 30px;
    height: 30px;
    position: absolute;
    left: 20px;
    top: 10px;
}

.page-title h1 {
    margin: 0;
    font-size: 28px;
}

/* Responsive */
@media (max-width: 769px) {
    .toolbar {
        flex-direction: column;
        align-items: center;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
    }
}





#!/usr/bin/env bash
set -euo pipefail

HTML_FILE="${1:-interactive_report.html}"

if [[ ! -f "$HTML_FILE" ]]; then
  echo "❌ HTML файлът не съществува: $HTML_FILE" >&2
  exit 1
fi

# Извличане на CSV данните от HTML-а
csv=$(awk '/^const rawCSV = `$/,/^`;$/' "$HTML_FILE" | sed '1d;$d')

# Проверка дали има съдържание
if [[ -z "$csv" ]]; then
  echo "❌ Не открих CSV данни във файла." >&2
  exit 1
fi

# Преобразуване в масив
IFS=$'\n' read -rd '' -a lines <<< "$csv"

# Заглавия
IFS=',' read -r -a headers <<< "${lines[0]}"
N_HEADERS=${#headers[@]}
N_JOBS=$(( ${#lines[@]} - 1 ))
N_DATES=$(( (N_HEADERS - 4) / 2 ))

echo "📊 Summary за: $HTML_FILE"
echo "——————————————"
echo "Общо jobs:         $N_JOBS"
echo "Брой дати:         $N_DATES"
echo "Колони (общо):     $N_HEADERS"
echo

# Сумарни времена по DateX
for ((d=0; d<N_DATES; d++)); do
  elapsed_idx=$((4 + 2*d + 1))
  total_sec=0
  count=0

  for ((i=1; i<=N_JOBS; i++)); do
    line="${lines[i]}"
    IFS=',' read -r -a fields <<< "$line"
    time="${fields[elapsed_idx]}"
    if [[ "$time" =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
      IFS=: read -r h m s <<< "$time"
      total_sec=$(( total_sec + h*3600 + m*60 + s ))
      ((count++))
    fi
  done

  if (( count > 0 )); then
    avg_sec=$(( total_sec / count ))
    hh=$(( avg_sec / 3600 ))
    mm=$(( (avg_sec % 3600) / 60 ))
    ss=$(( avg_sec % 60 ))
    printf "Date %d average:   %02d:%02d:%02d\n" "$((d+1))" "$hh" "$mm" "$ss"
  fi
done





#!/bin/bash

CONFIG_FILE="./config/hosts.list"
LOG_DIR="./logs/$(date +%F)"
USER="your_ssh_user"  # Замени с реален потребител за SSH

mkdir -p "$LOG_DIR"

if [ ! -f "$CONFIG_FILE" ]; then
  echo "⛔ Не е намерен файл: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  # Пропуска празни редове и коментари
  [[ -z "$HOST" || "$HOST" =~ ^# ]] && continue

  echo "👉 Свързване с $HOST..."
  OUTPUT=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "Успешно Влизане"' 2>&1)

  if [[ $? -eq 0 ]]; then
    echo "$HOST: ✅ $OUTPUT"
    echo "$OUTPUT" > "$LOG_DIR/$HOST.log"
  else
    echo "$HOST: ❌ Неуспешно свързване"
    echo "Грешка при свързване: $OUTPUT" > "$LOG_DIR/$HOST.log"
  fi

done < "$CONFIG_FILE"






#!/bin/bash

CONFIG_FILE="./config/hosts.list"
USER="your_ssh_user"  # Смени това с валидно SSH потребителско име

if [ ! -f "$CONFIG_FILE" ]; then
  echo "⛔ Не е намерен файл: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  if [ -z "$HOST" ]; then continue; fi
  echo "👉 Свързване с $HOST..."

  ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "Успешно Влизане"' 2>/dev/null

  if [ $? -ne 0 ]; then
    echo "❌ Грешка при свързване с $HOST"
  fi

done < "$CONFIG_FILE"





# Създай главната директория
mkdir -p monitoring/{config,logs,tmp,scripts,results}

# Създай примерна поддиректория с текущата дата (за логове и резултати)
TODAY=$(date +%F)
mkdir -p monitoring/logs/$TODAY
mkdir -p monitoring/results/$TODAY

# Създай примерни файлове в директорията config
touch monitoring/config/{main.conf,hosts.list,keywords.conf,env.properties}

# Създай основните скриптови файлове
touch monitoring/scripts/{monitor_main.sh,ssh_runner.sh,check_disk.sh,check_memory.sh,check_services.sh,report_generator.sh}

# Създай README файл
touch monitoring/README.md

# Добави права за изпълнение на скриптовете
chmod +x monitoring/scripts/*.sh

# Потвърждение
echo "✅ Структурата на monitoring е създадена успешно."





const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

let fromx = null;
let tox = null;

for (let j = 1; j <= 35; j++) {
    const idx = headers.indexOf(`DateS${j}`);
    if (idx === -1) continue;

    if (fromx === null && row[idx] && parseInt(row[idx]) === fromval) fromx = j;
    if (tox === null && row[idx] && parseInt(row[idx]) === toval) tox = j;
    if (fromx !== null && tox !== null) break;
}

if (fromx !== null && tox !== null) {
    visibleCols.push(
        `DateS${fromx}`, `StartS${fromx}`, `StopS${fromx}`, `ElapsedS${fromx}`,
        `DateS${tox}`, `StartS${tox}`, `StopS${tox}`, `ElapsedS${tox}`
    );
    insertDiffAfter = headers.indexOf(`ElapsedS${tox}`);
}






function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromRaw = datefrom.value;
    const toRaw = dateto.value;
    const compare = compareCheckbox.checked;

    let filtered = csvData.filter(row =>
        row.join(" ").toLowerCase().includes(keyword)
    );

    const baseCols = headers.slice(0, 5);
    let visibleCols = [...baseCols];
    let insertDiffAfter = null;

    if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        let fromIdx = -1;
        let toIdx = -1;

        for (let i = 0; i < 35; i++) {
            const idx = headers.indexOf(`DateS${i}`);
            if (idx === -1) continue;

            if (fromIdx === -1 && filtered.some(row => parseInt(row[idx]) === fromval)) fromIdx = i;
            if (toIdx === -1 && filtered.some(row => parseInt(row[idx]) === toval)) toIdx = i;
            if (fromIdx !== -1 && toIdx !== -1) break;
        }

        if (fromIdx !== -1 && toIdx !== -1) {
            visibleCols.push(
                `DateS${fromIdx}`, `StartS${fromIdx}`, `StopS${fromIdx}`, `ElapsedS${fromIdx}`,
                `DateS${toIdx}`, `StartS${toIdx}`, `StopS${toIdx}`, `ElapsedS${toIdx}`
            );
            insertDiffAfter = headers.indexOf(`ElapsedS${toIdx}`);
        }
    } else if (fromRaw || toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10) || null;
        const toval = parseInt(toRaw.replaceAll("-", ""), 10) || null;

        for (let i = 0; i < 35; i++) {
            const dateKey = `DateS${i}`;
            const idx = headers.indexOf(dateKey);
            if (idx === -1) continue;

            const col = dateKey;
            const rowVal = row => parseInt(row[idx]);

            let hasMatch = false;

            if (fromval && toval) {
                hasMatch = row => {
                    const val = rowVal(row);
                    return val >= fromval && val <= toval;
                };
            } else if (fromval) {
                hasMatch = row => rowVal(row) === fromval;
            } else if (toval) {
                hasMatch = row => rowVal(row) === toval;
            }

            if (hasMatch && filtered.some(hasMatch)) {
                visibleCols.push(`DateS${i}`, `StartS${i}`, `StopS${i}`, `ElapsedS${i}`);
            }
        }
    } else {
        visibleCols = headers;
    }

    if (currentSort.index >= 0) {
        filtered.sort((a, b) => {
            const valA = a[currentSort.index] || "";
            const valB = b[currentSort.index] || "";
            return currentSort.direction === 1
                ? valA.localeCompare(valB)
                : valB.localeCompare(valA);
        });
    } else if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        const idx = headers.indexOf("DateS3");
        if (idx === -1) return;

        for (let i = 0; i < 35; i++) {
            const testIdx = headers.indexOf(`DateS${i}`);
            if (testIdx === -1) continue;

            filtered = filtered.map(row => {
                const fromIdx = headers.indexOf(`ElapsedS${from}`);
                const toIdx = headers.indexOf(`ElapsedS${to}`);
                const fromElapsed = row[fromIdx] || null;
                const toElapsed = row[toIdx] || null;

                let diff = null;
                if (fromElapsed && toElapsed) {
                    diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                }

                return {
                    row,
                    diff
                };
            });

            filtered.sort((a, b) =>
                currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff
            );

            filtered = filtered.map(obj => obj.row);
        }
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}






const valFrom = parseInt(datefrom.value.replaceAll("-", ""), 10);
const valTo = parseInt(dateto.value.replaceAll("-", ""), 10);

// Оригинални стойности
let fromval = valFrom;
let toval = valTo;

// За да работи range правилно
const from = Math.min(valFrom, valTo);
const to = Math.max(valFrom, valTo);





let fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
let toval = parseInt(dateto.value.replaceAll("-", ""), 10);

if (fromval > toval) {
    [fromval, toval] = [toval, fromval];
}







<script>



const csvData = 'UI_DATA';

let data = [];
let headers = [];
let currentSort = {
    index: -1,
    direction: 1
};

const textFilter = document.getElementById("textFilter");
const datefrom = document.getElementById("datefrom");
const dateto = document.getElementById("dateto");
const compareCheckbox = document.getElementById("compareCheckbox");
const dataTable = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function msToSeconds(ms) {
    const [h, m, s] = ms.split(':').map(Number);
    return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
    const negative = sec < 0;
    sec = Math.abs(sec);
    const h = String(Math.floor(sec / 3600)).padStart(2, '0');
    const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
    const s = String(sec % 60).padStart(2, '0');
    return (negative ? '-' : '') + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
    const fromval = datefrom.value;
    const toval = dateto.value;
    const enabled = !!(fromval && toval);
    compareCheckbox.disabled = !enabled;

    if (!enabled) {
        compareCheckbox.checked = false;
        currentSort.index = -1;
        direction = 1;
    }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
    dataTable.innerHTML = "";
    headerRow.innerHTML = "";

    const visibleIndexes = visibleCols.map(col => headers.indexOf(col));

    visibleCols.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;
        const idx = headers.indexOf(col);
        th.classList.add("sortable");
        if (idx === currentSort.index) {
            th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        }
        th.onclick = () => {
            if (idx === currentSort.index) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = idx;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(th);
    });

    if (compareCheckbox.checked && currentSort.index === -1) {
        const thDiff = document.createElement("th");
        thDiff.textContent = "Difference";
        thDiff.classList.add("sortable");
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        thDiff.onclick = () => {
            if (currentSort.index === -1) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = -1;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(thDiff);
    }

    rows.forEach(row => {
        const tr = document.createElement("tr");

        let maxElapsed = 0;
        let maxIndexes = [];

        headers.forEach((head, i) => {
            if (/Elapsed\d+/.test(head) && row[i]) {
                const sec = msToSeconds(row[i]);
                if (sec > maxElapsed) {
                    maxElapsed = sec;
                    maxIndexes = [i];
                } else if (sec === maxElapsed) {
                    maxIndexes.push(i);
                }
            }
        });

        visibleIndexes.forEach(i => {
            const td = document.createElement("td");
            td.textContent = row[i];
            if (maxIndexes.includes(i)) {
                td.classList.add("max-elapsed");
            }
            tr.appendChild(td);
        });

        if (compareCheckbox.checked && diffAfterIndex) {
            const idx = headers.indexOf("DateS(3)");
            if (idx === -1) return;

            const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
            const toval = parseInt(dateto.value.replaceAll("-", ""), 10);
            const dateval = parseInt(row[idx].replaceAll("-", ""), 10);
            if (isNaN(dateval) || dateval < fromval || dateval > toval) return;

            const fromIdx = headers.indexOf(`Elapsed${fromval}`);
            const toIdx = headers.indexOf(`Elapsed${toval}`);
            const fromElapsed = fromIdx >= 0 ? row[fromIdx] : null;
            const toElapsed = toIdx >= 0 ? row[toIdx] : null;

            const tdDiff = document.createElement("td");
            if (fromElapsed && toElapsed) {
                const diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                tdDiff.textContent = secondsToHMS(diff);
                tdDiff.classList.add(diff < 0 ? "diff-negative" : "diff-positive");
            }
            tr.appendChild(tdDiff);
        }

        dataTable.appendChild(tr);
    });
}

function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
    const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

    let from = Math.min(fromval, toval);
    let to = Math.max(fromval, toval);

    let visibleCols = headers.slice(0, 5); // първите 5 (DateS, Start, Stop, Elapsed)

    const dateIndexes = [];
    for (let i = 0; i < 35; i++) {
        const colDate = new Date();
        colDate.setDate(colDate.getDate() - i);
        const dateStr = colDate.toISOString().slice(0, 10).replaceAll("-", "");
        dateIndexes.push(dateStr);
    }

    if (compareCheckbox.checked && from && to) {
        const filteredDates = dateIndexes.filter(date => {
            const val = parseInt(date);
            return val >= from && val <= to;
        });

        visibleCols = [];

        filteredDates.forEach(d => {
            visibleCols.push(`DateS(${d})`, `StartS(${d})`, `StopS(${d})`, `ElapsedS(${d})`);
        });
    } else {
        visibleCols = headers;
    }

    const filtered = data.filter(row => {
        const rowStr = row.join(" ").toLowerCase();
        return rowStr.includes(keyword);
    });

    const insertDiffAfter = headers.indexOf(`ElapsedS(${toval})`);

    if (compareCheckbox.checked && from && to) {
        filtered.sort((a, b) => {
            const fromIdx = headers.indexOf(`Elapsed${from}`);
            const toIdx = headers.indexOf(`Elapsed${to}`);
            const aDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(a[toIdx]) - msToSeconds(a[fromIdx]) : 0;
            const bDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(b[toIdx]) - msToSeconds(b[fromIdx]) : 0;
            return (currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff);
        });
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}

function parseCSV(csv) {
    const lines = csv.trim().split('\n');
    headers = lines[0].split(',');
    data = lines.slice(1).map(line => line.split(','));
}

textFilter.addEventListener("input", filterData);
datefrom.addEventListener("input", filterData);
dateto.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
    if (compareCheckbox.checked && currentSort.index === -1) {
        currentSort.direction = 1;
    }
    filterData();
});

// Инициализация
parseCSV(csvData);
filterData();
</script>





const row = data[0]; // only the first row
const val = row[dateIndex];
let hasMatch = false;

if (val && /^\d{8}$/.test(val)) {
  const valInt = parseInt(val);
  if (fromInt && toInt) {
    hasMatch = valInt >= fromInt && valInt <= toInt;
  } else if (fromInt) {
    hasMatch = valInt === fromInt;
  } else if (toInt) {
    hasMatch = valInt === toInt;
  }
}





const hasMatch = data.some(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  return (
    (fromInt && !toInt && valInt === fromInt) ||
    (!fromInt && toInt && valInt === toInt) ||
    (fromInt && toInt && valInt >= fromInt && valInt <= toInt)
  );
});




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " 🡻"; }
    th.sorted-desc::after { content: " 🡹"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2
Running,Load,202405,JobA,20250429,10:00,10:30,00:30:00,20250430,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20250429,11:00,11:30,00:30:00,20250430,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20250429,12:00,12:20,00:20:00,20250430,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function buildTable(rows, visibleCols, diffColIndex = null, diffs = []) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const index = headers.indexOf(col);
    if (index === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === index) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (diffColIndex !== null && index === diffColIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");
    visibleCols.forEach((col, colIdx) => {
      const i = headers.indexOf(col);
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      tr.appendChild(td);

      if (diffColIndex !== null && i === diffColIndex) {
        const tdDiff = document.createElement("td");
        const diffVal = diffs[idx];
        if (diffVal !== null) {
          tdDiff.textContent = secondsToHMS(diffVal);
          tdDiff.className = diffVal < 0 ? "diff-negative" : "diff-positive";
        }
        tr.appendChild(tdDiff);
      }
    });
    table.appendChild(tr);
  });
}

function filterData() {
  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;
  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let diffIndex = null;
  let diffs = [];

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const fromDate = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
  const toDate = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

  if (compare && fromDate && toDate) {
    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
    }
    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      diffIndex = headers.indexOf(`Elapsed${toX}`);
      diffs = filtered.map(row => {
        const from = row[headers.indexOf(`Elapsed${fromX}`)];
        const to = row[headers.indexOf(`Elapsed${toX}`)];
        return (from && to) ? hmsToSeconds(to) - hmsToSeconds(from) : null;
      });
    }
  } else if (fromDate || toDate) {
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      const valid = data.every(row => {
        const val = row[idx];
        if (!val) return false;
        const valInt = parseInt(val);
        if (fromDate && !toDate) return valInt === fromDate;
        if (!fromDate && toDate) return valInt === toDate;
        return valInt >= fromDate && valInt <= toDate;
      });
      if (valid) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.index >= 0 && currentSort.direction > 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2 && currentSort.direction > 0) {
    filtered = filtered
      .map((row, i) => ({ row, diff: diffs[i] || 0 }))
      .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
      .map(obj => obj.row);
  }

  buildTable(filtered, visibleCols, diffIndex, diffs);
}

parseCSV(csvData);
textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

filterData();
</script>

</body>
</html>






const valid = data.every(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  if (fromInt && !toInt) return valInt === fromInt;
  if (!fromInt && toInt) return valInt === toInt;
  return valInt >= fromInt && valInt <= toInt;
});






#!/usr/bin/env python3

import glob, sys, os, csv

def parse_time(t):
    """Превръща 'HH:MM:SS' в секунди."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- Настройка на директория и брой дни назад ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# Смяна на работната директория
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"Не мога да вляза в директория '{files_dir}': {e}")

# Взимаме последните N файла JT* по дата на промяна
all_files = [f for f in glob.glob("JT*.csv") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]

if not files:
    sys.exit("Няма намерени файлове JT* в текущата папка.")

# Парсваме всички файлове и пълним data[key][idx]
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue

            stage, batch, job = parts[0], parts[1], parts[2]
            date   = parts[3]
            start  = parts[4]
            stop   = parts[5]
            elapsed = parts[6]

            try:
                secs = parse_time(elapsed)
            except:
                continue

            key = (stage, batch, job)
            d = data.setdefault(key, {})
            d.setdefault(idx, {})["date"] = date
            d[idx]["start"] = start
            d[idx]["stop"] = stop
            d[idx]["elapsed"] = elapsed
            d[idx]["secs"] = secs

            if dates[idx] is None:
                dates[idx] = date

# Пишем на CSV на stdout —
out = csv.writer(sys.stdout, lineterminator="\n")

# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME", "AVERAGE"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Start{i}", f"Stop{i}", f"Elapsed{i}"]
out.writerow(header)

# За всеки JOB ключ генерираме по един ред
for key in sorted(data.keys()):
    rec = ["" for _ in range(5)]  # STATUS, STAGE, BATCH, JOB.NAME, AVERAGE
    rec[1:4] = list(key)

    d = data[key]

    # Статус: сравняваме първо (idx=0) и последно (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)

    if s1 and sN:
        if sN > s1:
            status = "↑"
        elif sN < s1:
            status = "↓"
        else:
            status = "="
    else:
        status = "-"
    rec[0] = status

    # Списък за всички secs, за смятане на средно
    secs_list = []

    # По двойки Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["start"])
            rec.append(info["stop"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", "", "", ""]

    # Изчисляване на AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh = avg // 3600
        mm = (avg % 3600) // 60
        ss = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""

    rec[4] = avg_str  # Вмъкваме след "JOB.NAME"

    out.writerow(rec)






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Viewer</title>
  <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/.2877641!320h320!0853_kbc!openduw_pmF" />
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f4f4f4;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    .table-wrapper {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      border: 1px solid #dee2ff;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border: 1px solid #dee2ff;
    }

    th {
      background-color: #b0c8ff;
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    th.sorted.asc::after,
    th.sorted.desc::after {
      content: "";
      display: inline-block;
      width: 0;
      height: 0;
      margin-left: 10px;
      vertical-align: middle;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
    }

    th.sorted.asc::after {
      border-bottom: 5px solid black;
    }

    th.sorted.desc::after {
      border-top: 5px solid black;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d6f0da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f7d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff6cd;
      font-weight: bold;
      border-radius: 4px;
    }

    /* Sticky column styles */
    th.sticky-col, td.sticky-col {
      position: sticky;
      background: white;
      z-index: 2;
    }

    th.sticky-0, td.sticky-0 { left: 0; }
    th.sticky-1, td.sticky-1 { left: 120px; }
    th.sticky-2, td.sticky-2 { left: 240px; }
    th.sticky-3, td.sticky-3 { left: 360px; }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <h1>JST Advanced Viewer</h1>

  <div class="toolbar">
    <label>
      <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job..." />
    </label>
    <label>
      <input type="date" id="dateFrom" />
    </label>
    <label>
      <input type="checkbox" id="compareCheckbox" /> Compare
    </label>
  </div>

  <div class="table-wrapper">
    <table id="dataTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const csvData = `Status,Stage,Batch,Job.name,Date1,Start1,Stop1,Elapsed1
OK,Stage1,BatchA,JobX,2025-05-20,10:00,10:05,00:05
FAIL,Stage2,BatchB,JobY,2025-05-20,09:00,09:30,00:30
OK,Stage1,BatchA,JobX,2025-05-21,10:00,10:07,00:07
FAIL,Stage2,BatchB,JobY,2025-05-21,09:00,09:20,00:20`;

    let data = [];
    let currentSort = { index: null, direction: 1 };

    const textFilter = document.getElementById("textFilter");
    const dateFrom = document.getElementById("dateFrom");
    const compareCheckbox = document.getElementById("compareCheckbox");
    const table = document.getElementById("dataTable");
    const headerRow = document.getElementById("headerRow");
    const tbody = table.querySelector("tbody");

    function msToSeconds(ms) {
      const [m, s] = ms.split(":").map(Number);
      return m * 60 + s;
    }

    function secondsToHMS(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2, "0")}`;
    }

    function buildTable(headers, visibleRows, diffAfter) {
      headerRow.innerHTML = "";
      tbody.innerHTML = "";

      headers.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;

        if (["Status", "Stage", "Batch", "Job.name"].includes(col)) {
          th.classList.add("sticky-col", `sticky-${i}`);
        }

        if (currentSort.index === i) {
          th.classList.add("sorted", currentSort.direction === 1 ? "asc" : "desc");
        }

        th.onclick = () => {
          if (currentSort.index === i) {
            currentSort.direction *= -1;
          } else {
            currentSort.index = i;
            currentSort.direction = 1;
          }
          filterData();
        };

        headerRow.appendChild(th);
      });

      visibleRows.forEach((row, rIndex) => {
        const tr = document.createElement("tr");

        row.forEach((cell, i) => {
          const td = document.createElement("td");
          td.textContent = cell;

          if (["Status", "Stage", "Batch", "Job.name"].includes(headers[i])) {
            td.classList.add("sticky-col", `sticky-${i}`);
          }

          if (i === diffAfter?.index && diffAfter[rIndex]?.diff != null) {
            td.classList.add(diffAfter[rIndex].diff > 0 ? "diff-positive" : "diff-negative");
          }

          if (diffAfter?.max === msToSeconds(cell)) {
            td.classList.add("max-elapsed");
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });
    }

    function filterData() {
      const keyword = textFilter.value.toLowerCase();
      const from = dateFrom.value;
      const compare = compareCheckbox.checked;

      let filtered = data.filter(row => row.join(",").toLowerCase().includes(keyword));
      if (from) {
        filtered = filtered.filter(row => row[4] >= from);
      }

      let diffAfter = null;
      if (compare) {
        diffAfter = [];
        const grouped = {};
        filtered.forEach(r => {
          const key = `${r[0]}-${r[1]}-${r[2]}-${r[3]}`;
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(r);
        });

        filtered = [];
        for (const key in grouped) {
          const group = grouped[key];
          if (group.length >= 2) {
            const g = group.slice(-2);
            const v1 = msToSeconds(g[0][7]);
            const v2 = msToSeconds(g[1][7]);
            const diff = v2 - v1;

            diffAfter.push({ index: 7, diff, max: Math.max(v1, v2) });
            filtered.push(...g);
          }
        }
      }

      if (currentSort.index !== null) {
        filtered.sort((a, b) => {
          const valA = a[currentSort.index];
          const valB = b[currentSort.index];
          return currentSort.direction * valA.localeCompare(valB);
        });
      }

      buildTable(data[0], filtered, diffAfter);
    }

    function parseCSV(csv) {
      return csv.split("\n").map(row => row.split(","));
    }

    data = parseCSV(csvData);
    buildTable(data[0], data.slice(1));
    
    textFilter.addEventListener("input", filterData);
    dateFrom.addEventListener("input", filterData);
    compareCheckbox.addEventListener("change", filterData);
  </script>
</body>
</html>






csv_file = 'your_file.csv'
html_file = 'your_file.html'
output_file = 'output.html'

# Read the CSV content
with open(csv_file, 'r', encoding='utf-8') as f:
    csv_content = f.read()

# Escape for JavaScript
escaped_csv = csv_content.replace('\\', '\\\\') \
                         .replace('\n', '\\n') \
                         .replace('"', '\\"')

# Read the HTML file
with open(html_file, 'r', encoding='utf-8') as f:
    html_content = f.read()

# Replace fancy quotes with standard and inject CSV
html_content = html_content.replace("‘", "'").replace("’", "'")
updated_html = html_content.replace("'JT_DATA'", f'"{escaped_csv}"')

# Save to output
with open(output_file, 'w', encoding='utf-8') as f:
    f.write(updated_html)

print(f"Injected CSV data into '{output_file}' successfully.")





#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# Parse arguments
if len(sys.argv) < 4:
    print("Usage: python3 monitor.py <jt_dir> <days> <html_template_file>")
    sys.exit(1)

files_dir = sys.argv[1]
try:
    n = int(sys.argv[2])
except ValueError:
    n = 31
template_path = sys.argv[3]

# Collect .jt files
files = []
if os.path.isdir(files_dir):
    files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
    files = sorted(files, key=os.path.getmtime)[-n:]
    if not files:
        sys.exit("No JT files found.")
else:
    sys.exit("Invalid directory.")

# Extract and collect data
data = {}
dates = [None] * len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            key = (parts[0], parts[1], parts[2])
            date = parts[3]
            start, stop, elapsed = parts[5], parts[6], parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            data.setdefault(key, {})[idx] = {
                "date": date, "start": start, "stop": stop,
                "elapsed": elapsed, "secs": secs
            }
            if dates[idx] is None:
                dates[idx] = date

# Create output lines
out_lines = []

header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

for key in sorted(data.keys()):
    status = "-"
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0: status = "NEW"
    elif s > 0 and e == 0: status = "LOST"
    elif s > 0 and e > s: status = "SLOW"
    elif s == e and s > 0: status = "STABLE"

    rec = [status, *key]
    secs_list = []

    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""),
                    info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    if secs_list:
        total = sum(secs_list)
        avg = total // len(secs_list)
        avg_str = f"{avg//3600:02d}:{(avg%3600)//60:02d}:{avg%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)
    out_lines.append(','.join(str(x) for x in rec))

# Escape lines and join with JS newline
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

# Replace in HTML template
with open(template_path, 'r', encoding='utf-8') as f:
    html_content = f.read()

new_content = html_content.replace(
    "const csvData = '';",
    f"const csvData = '{csv_string}';"
)

with open(template_path, 'w', encoding='utf-8') as f:
    f.write(new_content)

print(f"Injected data into: {template_path}")







#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    """Преобраз 'HH:MM:SS' в секунди."""
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# --- Настройка на директория и брой дни назад ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

files_dir = arg1
try:
    n = int(arg2) if arg2 else 31
except ValueError:
    n = 31

# Събиране на файловете
files = []
if os.path.isdir(files_dir):
    try:
        files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
        files = sorted(files, key=os.path.getmtime)[-n:]
        if not files:
            sys.exit("Няма намерени файлове .JT в текущата папка.")
    except Exception as e:
        sys.exit(f"Не мога да вляза в директория {files_dir}: {e}")
else:
    sys.exit("Невалидна директория.")

# Данни
data = {}
dates = [None] * len(files)

# Парсване на всеки файл
for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage_batch_job = (parts[0], parts[1], parts[2])
            date     = parts[3]
            start    = parts[5]
            stop     = parts[6]
            elapsed  = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            key = stage_batch_job
            data.setdefault(key, {})[idx] = {
                "start": start,
                "stop": stop,
                "elapsed": elapsed,
                "secs": secs,
                "date": date
            }

            if dates[idx] is None:
                dates[idx] = date

# --- Генериране на CSV редове ---
out_lines = []

# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

# По ключ
for key in sorted(data.keys()):
    status = ""
    secs_list = []

    # Изчисляване на STATUS
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0:
        status = "NEW"
    elif s > 0 and e == 0:
        status = "LOST"
    elif s > 0 and e > s:
        status = "SLOW"
    elif s == e and s > 0:
        status = "STABLE"
    else:
        status = "-"

    rec = [status, *key]

    # Събиране на редовете
    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""), info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    # Изчисляване на AVERAGE
    if secs_list:
        s = sum(secs_list)
        m = s // len(secs_list)
        avg_str = f"{m//3600:02d}:{(m%3600)//60:02d}:{m%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out_lines.append(','.join(str(x) for x in rec))

# --- Запис като JS променлива ---
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

with open("csv_output.js", 'w', encoding='utf-8') as f:
    f.write(f"const csvData = '{csv_string}';\n")

print("Генериран файл: csv_output.js")





import os
import csv
import sys
import html

def find_all_files(root_dir):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    try:
        with open(file_path, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile)
            for i, row in enumerate(reader, start=1):
                if i in rows_to_print:
                    line = ','.join(row)
                    output_lines.append(line)
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python csv_to_js_var.py <root_directory> <output_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    output_file = sys.argv[2]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_all_files(root_directory)

    if not files:
        print("No files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"Output written to {output_file}")






import os
import csv
import sys
import html

def find_files_by_date(root_dir, date_mask):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if date_mask in filename:
                matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    with open(file_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        for i, row in enumerate(reader, start=1):
            if i in rows_to_print:
                line = ','.join(row)
                output_lines.append(line)
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python csv_to_js_var.py <root_directory> <date_mask> <output_html_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    date_mask = sys.argv[2]
    output_html_file = sys.argv[3]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_files_by_date(root_directory, date_mask)

    if not files:
        print("No matching files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_html_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"JavaScript CSV data written to {output_html_file}")




.page-title {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 20px;
}

.page-title .title-icon {
  width: 36px;
  height: 36px;
}

.page-title h1 {
  margin: 0;
  font-size: 28px;
  color: #0059b3;
}




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " 🡻"; }
    th.sorted-desc::after { content: " 🡹"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach((col) => {
    const th = document.createElement("th");
    const colIndex = headers.indexOf(col);
    th.textContent = col;
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach(row => {
    const tr = document.createElement("tr");

    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          tdDiff.setAttribute("data-diff", diff);
        }
        tr.appendChild(tdDiff);
      }
    });

    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromVal = parseInt(fromRaw.replaceAll("-", ""));
    const toVal = parseInt(toRaw.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromVal)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toVal)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      const rowsWithDiff = filtered.map(row => {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;
        let diff = 0;
        if (fromElapsed && toElapsed) {
          diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
        }
        return { row, diff };
      });

      filtered = rowsWithDiff
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(obj => obj.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>








} else if (currentSort.index === -2) {
  const diffs = [];
  filtered.forEach(row => {
    const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
    const toDate = parseInt(dateTo.value.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let j = 1; j <= 31; j++) {
      const idx = headers.indexOf(`Date${j}`);
      if (idx === -1) continue;
      if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
      if (toX === null && parseInt(row[idx]) === toDate) toX = j;
    }

    const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
    const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

    let diff = 0;
    if (fromElapsed && toElapsed) {
      diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
    }

    diffs.push({ row, diff });
  });

  filtered = diffs
    .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
    .map(item => item.row);
}






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " 🡻"; }
    th.sorted-desc::after { content: " 🡹"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;
  currentDiffs = [];

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const colIndex = headers.indexOf(col);
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, rowIndex) => {
    const tr = document.createElement("tr");
    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
        const toDate = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;

        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
          if (toX === null && parseInt(row[idx]) === toDate) toX = j;
        }

        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          diffValue = diff;
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[rowIndex] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];
  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromDate = parseInt(fromRaw.replaceAll("-", ""));
    const toDate = parseInt(toRaw.replaceAll("-", ""));

    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      filtered = filtered
        .map((row, i) => ({ row, diff: currentDiffs[i] || 0 }))
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(item => item.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>





const fromDate = parseInt(fromRaw.replaceAll("-", ""));
const toDate = parseInt(toRaw.replaceAll("-", ""));

let fromX = null, toX = null;

for (let i = 1; i <= 31; i++) {
  const idx = headers.indexOf(`Date${i}`);
  if (idx === -1) continue;

  if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) {
    fromX = i;
  }

  if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) {
    toX = i;
  }

  if (fromX !== null && toX !== null) break;
}

if (fromX !== null && toX !== null) {
  visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
  visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
  insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #f4f6f9;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 200px;
      background: #fff;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    th {
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
    }

    th.sorted-asc::after {
      content: " 🡻";
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-desc::after {
      content: " 🡹";
      font-weight: bold;
      font-size: 12px;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d4edda;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f8d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff3cd;
      font-weight: bold;
    }
    
    th {
        white-space: nowrap;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
        display: inline-block;
        margin-left: 4px;
        vertical-align: middle;
        line-height: 1;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2,Date3,Start3,Stop3,Elapsed3,Date4,Start4,Stop4,Elapsed4,Date5,Start5,Stop5,Elapsed5,Date6,Start6,Stop6,Elapsed6,Date7,Start7,Stop7,Elapsed7,Date8,Start8,Stop8,Elapsed8,Date9,Start9,Stop9,Elapsed9,Date10,Start10,Stop10,Elapsed10,Date11,Start11,Stop11,Elapsed11,Date12,Start12,Stop12,Elapsed12,Date13,Start13,Stop13,Elapsed13,Date14,Start14,Stop14,Elapsed14,Date15,Start15,Stop15,Elapsed15,Date16,Start16,Stop16,Elapsed16,Date17,Start17,Stop17,Elapsed17,Date18,Start18,Stop18,Elapsed18,Date19,Start19,Stop19,Elapsed19,Date20,Start20,Stop20,Elapsed20,Date21,Start21,Stop21,Elapsed21,Date22,Start22,Stop22,Elapsed22,Date23,Start23,Stop23,Elapsed23,Date24,Start24,Stop24,Elapsed24,Date25,Start25,Stop25,Elapsed25,Date26,Start26,Stop26,Elapsed26,Date27,Start27,Stop27,Elapsed27,Date28,Start28,Stop28,Elapsed28,Date29,Start29,Stop29,Elapsed29,Date30,Start30,Stop30,Elapsed30,Date31,Start31,Stop31,Elapsed31,AVERAGE
OK,C,BATCH716,Job_1,20240501,00:00:00,00:01:06,00:01:06,20250502,00:00:00,00:02:18,00:02:18,20250503,00:00:00,00:01:33,00:01:33,20250504,00:00:00,00:01:12,00:01:12,20250505,00:00:00,00:02:05,00:02:05,20250506,00:00:00,00:05:18,00:05:18,20250507,00:00:00,00:01:56,00:01:56,20250508,00:00:00,00:00:38,00:00:38,20250509,00:00:00,00:03:34,00:03:34,20250510,00:00:00,00:02:25,00:02:25,20250511,00:00:00,00:04:14,00:04:14,20250512,00:00:00,00:01:47,00:01:47,20250513,00:00:00,00:00:34,00:00:34,20250514,00:00:00,00:03:33,00:03:33,20250515,00:00:00,00:02:31,00:02:31,20250516,00:00:00,00:02:17,00:02:17,20250517,00:00:00,00:04:46,00:04:46,20250518,00:00:00,00:01:16,00:01:16,20250519,00:00:00,00:00:29,00:00:29,20250520,00:00:00,00:03:53,00:03:53,20250521,00:00:00,00:01:29,00:01:29,20250522,00:00:00,00:03:54,00:03:54,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:03:33,00:03:33,20250525,00:00:00,00:05:42,00:05:42,20250526,00:00:00,00:03:27,00:03:27,20250527,00:00:00,00:05:20,00:05:20,20250528,00:00:00,00:05:14,00:05:14,20250529,00:00:00,00:04:29,00:04:29,20250530,00:00:00,00:02:53,00:02:53,20250531,00:00:00,00:04:30,00:04:30,00:03:00
OK,A,BATCH716,Job_2,20240501,00:00:00,00:01:39,00:01:39,20250502,00:00:00,00:00:55,00:00:55,20250503,00:00:00,00:04:43,00:04:43,20250504,00:00:00,00:01:27,00:01:27,20250505,00:00:00,00:03:26,00:03:26,20250506,00:00:00,00:01:49,00:01:49,20250507,00:00:00,00:05:23,00:05:23,20250508,00:00:00,00:01:54,00:01:54,20250509,00:00:00,00:04:54,00:04:54,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:00:38,00:00:38,20250512,00:00:00,00:02:26,00:02:26,20250513,00:00:00,00:03:01,00:03:01,20250514,00:00:00,00:03:14,00:03:14,20250515,00:00:00,00:02:16,00:02:16,20250516,00:00:00,00:04:06,00:04:06,20250517,00:00:00,00:03:43,00:03:43,20250518,00:00:00,00:01:28,00:01:28,20250519,00:00:00,00:05:20,00:05:20,20250520,00:00:00,00:03:25,00:03:25,20250521,00:00:00,00:05:06,00:05:06,20250522,00:00:00,00:00:08,00:00:08,20250523,00:00:00,00:00:46,00:00:46,20250524,00:00:00,00:05:45,00:05:45,20250525,00:00:00,00:03:55,00:03:55,20250526,00:00:00,00:03:06,00:03:06,20250527,00:00:00,00:03:13,00:03:13,20250528,00:00:00,00:04:13,00:04:13,20250529,00:00:00,00:04:01,00:04:01,20250530,00:00:00,00:00:03,00:00:03,20250531,00:00:00,00:03:44,00:03:44,00:02:58
OK,C,BATCH440,Job_3,20240501,00:00:00,00:02:56,00:02:56,20250502,00:00:00,00:01:19,00:01:19,20250503,00:00:00,00:01:13,00:01:13,20250504,00:00:00,00:05:52,00:05:52,20250505,00:00:00,00:04:46,00:04:46,20250506,00:00:00,00:02:19,00:02:19,20250507,00:00:00,00:02:53,00:02:53,20250508,00:00:00,00:01:43,00:01:43,20250509,00:00:00,00:01:29,00:01:29,20250510,00:00:00,00:01:05,00:01:05,20250511,00:00:00,00:00:56,00:00:56,20250512,00:00:00,00:02:57,00:02:57,20250513,00:00:00,00:04:51,00:04:51,20250514,00:00:00,00:03:42,00:03:42,20250515,00:00:00,00:01:31,00:01:31,20250516,00:00:00,00:01:17,00:01:17,20250517,00:00:00,00:02:17,00:02:17,20250518,00:00:00,00:00:17,00:00:17,20250519,00:00:00,00:00:24,00:00:24,20250520,00:00:00,00:00:31,00:00:31,20250521,00:00:00,00:04:11,00:04:11,20250522,00:00:00,00:04:24,00:04:24,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:04:03,00:04:03,20250525,00:00:00,00:01:59,00:01:59,20250526,00:00:00,00:01:39,00:01:39,20250527,00:00:00,00:00:32,00:00:32,20250528,00:00:00,00:00:32,00:00:32,20250529,00:00:00,00:03:47,00:03:47,20250530,00:00:00,00:03:57,00:03:57,20250531,00:00:00,00:01:43,00:01:43,00:02:28
ERROR,C,BATCH740,Job_4,20240501,00:00:00,00:04:31,00:04:31,20250502,00:00:00,00:00:22,00:00:22,20250503,00:00:00,00:00:33,00:00:33,20250504,00:00:00,00:02:23,00:02:23,20250505,00:00:00,00:02:47,00:02:47,20250506,00:00:00,00:04:11,00:04:11,20250507,00:00:00,00:01:10,00:01:10,20250508,00:00:00,00:03:24,00:03:24,20250509,00:00:00,00:05:35,00:05:35,20250510,00:00:00,00:02:15,00:02:15,20250511,00:00:00,00:03:34,00:03:34,20250512,00:00:00,00:04:42,00:04:42,20250513,00:00:00,00:05:18,00:05:18,20250514,00:00:00,00:05:00,00:05:00,20250515,00:00:00,00:04:12,00:04:12,20250516,00:00:00,00:05:13,00:05:13,20250517,00:00:00,00:01:14,00:01:14,20250518,00:00:00,00:05:05,00:05:05,20250519,00:00:00,00:02:03,00:02:03,20250520,00:00:00,00:05:13,00:05:13,20250521,00:00:00,00:05:00,00:05:00,20250522,00:00:00,00:01:01,00:01:01,20250523,00:00:00,00:01:15,00:01:15,20250524,00:00:00,00:05:27,00:05:27,20250525,00:00:00,00:00:53,00:00:53,20250526,00:00:00,00:03:59,00:03:59,20250527,00:00:00,00:05:55,00:05:55,20250528,00:00:00,00:02:13,00:02:13,20250529,00:00:00,00:00:18,00:00:18,20250530,00:00:00,00:00:12,00:00:12,20250531,00:00:00,00:02:55,00:02:55,00:03:09
OK,C,BATCH966,Job_5,20240501,00:00:00,00:05:44,00:05:44,20250502,00:00:00,00:00:58,00:00:58,20250503,00:00:00,00:03:09,00:03:09,20250504,00:00:00,00:03:53,00:03:53,20250505,00:00:00,00:03:33,00:03:33,20250506,00:00:00,00:02:08,00:02:08,20250507,00:00:00,00:04:22,00:04:22,20250508,00:00:00,00:02:51,00:02:51,20250509,00:00:00,00:04:24,00:04:24,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:03:54,00:03:54,20250512,00:00:00,00:00:46,00:00:46,20250513,00:00:00,00:01:45,00:01:45,20250514,00:00:00,00:00:11,00:00:11,20250515,00:00:00,00:04:58,00:04:58,20250516,00:00:00,00:03:42,00:03:42,20250517,00:00:00,00:03:13,00:03:13,20250518,00:00:00,00:02:05,00:02:05,20250519,00:00:00,00:02:33,00:02:33,20250520,00:00:00,00:00:46,00:00:46,20250521,00:00:00,00:04:58,00:04:58,20250522,00:00:00,00:05:06,00:05:06,20250523,00:00:00,00:02:17,00:02:17,20250524,00:00:00,00:02:47,00:02:47,20250525,00:00:00,00:01:37,00:01:37,20250526,00:00:00,00:04:03,00:04:03,20250527,00:00:00,00:03:57,00:03:57,20250528,00:00:00,00:04:24,00:04:24,20250529,00:00:00,00:05:07,00:05:07,20250530,00:00:00,00:05:52,00:05:52,20250531,00:00:00,00:01:23,00:01:23,00:03:11`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");

const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols = headers, diffAfterIndex = null) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach(col => {
    const th = document.createElement("th");
    th.textContent = col;
    const originalIndex = headers.indexOf(col);
    if (originalIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === originalIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: originalIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && originalIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  const elapsedIndexes = headers
    .map((h, i) => ({ h, i }))
    .filter(obj => /^Elapsed\d+$/.test(obj.h))
    .map(obj => obj.i);

  currentDiffs = [];

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");

    let maxElapsedSec = -1;
    let maxElapsedIndexes = [];

    elapsedIndexes.forEach(i => {
      const val = row[i];
      if (val && /^\d{2}:\d{2}:\d{2}$/.test(val)) {
        const sec = hmsToSeconds(val);
        if (sec > maxElapsedSec) {
          maxElapsedSec = sec;
          maxElapsedIndexes = [i];
        } else if (sec === maxElapsedSec) {
          maxElapsedIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] !== undefined ? row[i] : "";
      if (maxElapsedIndexes.includes(i)) {
        td.style.backgroundColor = "yellow";
        td.style.fontWeight = "bold";
      }
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
        const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
        const fromElapsed = row[headers.indexOf(`Elapsed${fromDay}`)];
        const toElapsed = row[headers.indexOf(`Elapsed${toDay}`)];
        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diffSec = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          diffValue = diffSec;
          tdDiff.textContent = secondsToHMS(diffSec);
          tdDiff.style.backgroundColor = diffSec < 0 ? "#f88" : "#8f8";
          tdDiff.style.fontWeight = "bold";
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[idx] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];

  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromParsed = fromRaw.replaceAll("-", "");
    const toParsed = toRaw.replaceAll("-", "");
    const fromDay = parseInt(fromParsed.slice(-2));
    const toDay = parseInt(toParsed.slice(-2));
    visibleCols.push(...[`Date${fromDay}`, `Start${fromDay}`, `Stop${fromDay}`, `Elapsed${fromDay}`]);
    visibleCols.push(...[`Date${toDay}`, `Start${toDay}`, `Stop${toDay}`, `Elapsed${toDay}`]);
    insertDiffAfter = headers.indexOf(`Elapsed${toDay}`);
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction === 0) {
    filtered = [...filtered];
  } else if (currentSort.index >= 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2) {
    const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
    const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
    const fromIdx = headers.indexOf(`Elapsed${fromDay}`);
    const toIdx = headers.indexOf(`Elapsed${toDay}`);
    filtered.sort((a, b) => {
      const aFrom = a[fromIdx], aTo = a[toIdx];
      const bFrom = b[fromIdx], bTo = b[toIdx];
      const aDiff = (aTo && aFrom) ? hmsToSeconds(aTo) - hmsToSeconds(aFrom) : 0;
      const bDiff = (bTo && bFrom) ? hmsToSeconds(bTo) - hmsToSeconds(bFrom) : 0;
      return currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff;
    });
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>
</body>
</html>








#!/usr/bin/env bash
set -euo pipefail

# Ако скриптът е в различна папка, автоматично отиваме там
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих '$CSV' в $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# Escape-ваме само backticks, за да ги вградим безопасно в JS template
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .toggles { margin-bottom:10px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

  <div class="controls">
    <input id="search"    placeholder="Global search…"/>
    <input id="start" type="date"/>
    <input id="end"   type="date"/>
    <button id="apply" >Apply Date Filter</button>
    <button id="all"   >All Dates</button>
    <button id="cmp"   >Compare Dates</button>
    <button id="reset" >Reset All</button>
  </div>

  <div class="toggles" id="toggles"></div>

  <table id="report">
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>

  <script>
  // ── Вградeно CSV ───────────────────────────────────────────
  const rawCSV = \`
$CSV_ESCAPED
\`.trim();
  // ──────────────────────────────────────────────────────────

  function parseCSV(txt) {
    return txt.split('\\n').map(r => r.split(','));
  }
  function toSec(s) {
    const [h,m,x] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + x;
  }
  function fmt(n){ return (n>=0?'+':'')+n; }

  let header = [],       // финалният header
      cols   = [],       // {name,hidden}
      rows   = [],       // {vals,hidden,maxIdx,diff}
      sortState={col:null,dir:'asc'},
      cmpDates=[null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    init();
    renderToggles();
    renderTable();

    document.getElementById('search' ).addEventListener('input', filterTable);
    document.getElementById('apply'  ).addEventListener('click', filterTable);
    document.getElementById('all'    ).addEventListener('click', allDates);
    document.getElementById('cmp'    ).addEventListener('click', compareDates);
    document.getElementById('reset'  ).addEventListener('click', resetAll);
    document.getElementById('start'  ).addEventListener('change', ()=>cmpDates[0]=document.getElementById('start').value.replace(/-/g,''));
    document.getElementById('end'    ).addEventListener('change', ()=>cmpDates[1]=document.getElementById('end').value.replace(/-/g,''));
  });

  function init(){
    const arr = parseCSV(rawCSV);
    const origH = arr.shift();   // оригинален header: [STATUS,STAGE,BATCH,JOB.NAME,Date1,Elapsed1,...,AVERAGE]
    const dataArr = arr;         // всички data редове
    const staticCnt = 4;
    const summaryCnt = 1;        // само AVERAGE
    const pairCnt = (origH.length - staticCnt - summaryCnt) / 2;

    // Построяваме финален header:
    header = [
      ...origH.slice(0,staticCnt),
      // за всяка двойка DateX,ElapsedX – взимаме датата от първия data-ред
      ...Array.from({length:pairCnt}, (_,i)=> dataArr[0][ staticCnt + 2*i ]),
      origH[ staticCnt + 2*pairCnt ], // AVERAGE
      'Difference'
    ];

    // Инициализираме cols
    cols = header.map(h=>({name:h, hidden:false}));

    // Подготвяме rows
    rows = dataArr.map(r=>{
      const vals = [];
      // 4 статични
      for(let i=0;i<staticCnt;i++) vals.push(r[i]);
      // N elapsed-ове
      for(let i=0;i<pairCnt;i++){
        vals.push(r[ staticCnt+2*i+1 ]||'');
      }
      // AVERAGE
      vals.push(r[ staticCnt+2*pairCnt ]||'');
      // Ще добавим Difference при рендер
      return { vals, hidden:false, maxIdx:staticCnt, diff:0 };
    });

    // Изчисляваме maxIdx и първоначално diff за всеки row
    rows.forEach(row=>{
      let maxSec=-1, mi=staticCnt;
      for(let i=0;i<pairCnt;i++){
        const sec = toSec(row.vals[staticCnt+i]);
        if(sec>maxSec){ maxSec=sec; mi=staticCnt+i; }
      }
      row.maxIdx = mi;
      const first = toSec(row.vals[staticCnt+0]);
      const last  = toSec(row.vals[staticCnt+pairCnt-1]);
      row.diff = last-first;
    });
  }

  function renderToggles(){
    const c = document.getElementById('toggles');
    c.innerHTML='';
    cols.forEach((col,i)=>{
      const lbl=document.createElement('label');
      const cb =document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
      lbl.append(cb,' ',col.name);
      c.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML='';
    tbody.innerHTML='';

    // HEADER
    const hr=document.createElement('tr');
    cols.forEach((col,i)=>{
      if(col.hidden) return;
      const th=document.createElement('th');
      th.textContent=col.name;
      th.onclick=()=>sortBy(i);
      if(sortState.col===i)
        th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    thead.append(hr);

    // BODY
    rows.forEach(r=>{
      if(r.hidden) return;
      const tr=document.createElement('tr');
      cols.forEach((col,i)=>{
        if(col.hidden) return;
        const td=document.createElement('td');
        td.textContent = r.vals[i]||'';
        if(i===r.maxIdx) td.classList.add('max');
        if(i===cols.length-1){
          // Difference колона
          td.textContent = fmt(r.diff);
          td.classList.add(r.diff>=0?'diff-pos':'diff-neg');
        }
        tr.append(td);
      });
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
    else sortState.dir='asc';
    sortState.col=ci;
    const th=document.querySelectorAll('th')[ci];
    th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    rows.sort((a,b)=>{
      const A=a.vals[ci]||'', B=b.vals[ci]||'';
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return sortState.dir==='asc'? cmp : -cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term=document.getElementById('search').value.toLowerCase();
    const sd=document.getElementById('start').value.replace(/-/g,''), 
          ed=document.getElementById('end').value.replace(/-/g,'');
    rows.forEach(r=>{
      let ok=true;
      if(term) ok = r.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        const d = r.vals[4]; // датата е на позиция 4
        ok = (!sd||d>=sd) && (!ed||d<=ed);
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function allDates(){
    // взимаме всички дати от колона 4
    const ds = rows.map(r=>r.vals[4]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end').value   = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeDate(idx){
    // на промяна на start/end запомняме YYYYMMDD
    cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
  }

  function compareDates(){
    const [d1,d2] = cmpDates;
    if(!d1||!d2) return alert('Изберете две дати.');
    const i1 = rows.findIndex(r=>r.vals[4]===d1);
    const i2 = rows.findIndex(r=>r.vals[4]===d2);
    if(i1<0||i2<0) return alert('Няма такъв ред.');
    rows.forEach(r=>{
      const f = toSec(r.vals[4]),
            l = toSec(r.vals[4 + parseInt((header.length-5)/2)]); // последният elapsed
      r.diff = l - f;
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    cols.forEach(c=>c.hidden=false);
    rows.forEach(r=>{ r.hidden=false; });
    sortState={col:null,dir:'asc'};
    renderToggles();
    renderTable();
  }
  </script>

</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – отвори го в браузър!"







#!/usr/bin/env bash
set -euo pipefail

# Ако скриптът е в друга папка, се местим там
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих '$CSV' в $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# Четем целия CSV в масив от редове
mapfile -t lines < "$CSV"
# Първият ред е header
IFS=',' read -r -a hdr <<< "${lines[0]}"
# Изчисляваме N = брой date/elapsed двойки
len=${#hdr[@]}
N=$(( (len - 4 - 2) / 2 ))
# Вземаме истинските дати от първия data-ред
IFS=',' read -r -a firstRow <<< "${lines[1]}"
dateLabels=()
for i in $(seq 0 $((N-1))); do
  idx=$((4 + 2*i))
  dateLabels+=("${firstRow[idx]}")
done
# Средният и разликата са след тях
avgLabel="${hdr[4 + 2*N]}"
diffLabel="${hdr[5 + 2*N]}"
# Първите 4 колони
staticLabels=( "${hdr[0]}" "${hdr[1]}" "${hdr[2]}" "${hdr[3]}" )
# Финален header
finalHeader=( "${staticLabels[@]}" "${dateLabels[@]}" "$avgLabel" "$diffLabel" )

# Сглобяваме data масив: за всеки ред – 4 статични, N elapsed, AVG, DIFF
dataRows=()
for ((r=1; r<${#lines[@]}; r++)); do
  IFS=',' read -r -a row <<< "${lines[r]}"
  # статични
  out=( "${row[0]}" "${row[1]}" "${row[2]}" "${row[3]}" )
  # elapsed
  for i in $(seq 0 $((N-1))); do
    out+=( "${row[4 + 2*i + 1]}" )
  done
  # average & difference
  out+=( "${row[4 + 2*N]}" "${row[5 + 2*N]}" )
  # join със ‘|’ (ще split-нем в JS)
  dataRows+=( "$(IFS='|'; echo "${out[*]}")" )
done

# Генерираме HTML
cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Report</title>
<style>
  body{margin:0;padding:20px;font-family:sans-serif;overflow-x:auto;}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:15px}
  .controls input,.controls button{padding:6px 10px;}
  .toggles{margin-bottom:15px}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ccc;padding:8px;white-space:nowrap}
  th{background:#f0f0f0;cursor:pointer;position:relative}
  th.sort-asc::after{content:" ↑"} th.sort-desc::after{content:" ↓"}
  td.max{background:#fff9c4} td.diff-pos{background:#e6f4ea}
  td.diff-neg{background:#fce8e6}
</style>
</head>
<body>

<div class="controls">
  <input id="search"    placeholder="Global search…"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply" >Apply Date Filter</button>
  <button id="all"   >All Dates</button>
  <button id="cmp"   >Compare Dates</button>
  <button id="reset" >Reset All</button>
</div>

<div class="toggles" id="toggles"></div>
<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// header и data ги вграждаме директно от bash-а
const header = [$(printf '"%s",' "${finalHeader[@]}" )].map(h=>h.replace(/",$/,''));
const rawData = [
$(printf "  '%s',\n" "${dataRows[@]}")
].map(r=>r.split('|'));

let cols = header.map((name,i)=>({name,idx:i,hidden:false}));
let rows = rawData.map(r=>({vals:r,hidden:false}));
let sortState={col:null,dir:'asc'};
let cmpDates=[null,null];

// init
document.addEventListener('DOMContentLoaded',()=>{
  renderToggles();
  renderTable();
  document.getElementById('search').addEventListener('input',filter);
  document.getElementById('apply').addEventListener('click',filter);
  document.getElementById('all').addEventListener('click',allDates);
  document.getElementById('cmp').addEventListener('click',compare);
  document.getElementById('reset').addEventListener('click',resetAll);
  document.getElementById('start').addEventListener('change',()=>cmpDates[0]=this.value.replace(/-/g,''));
  document.getElementById('end').addEventListener('change',()=>cmpDates[1]=this.value.replace(/-/g,''));
});

// рендер чекбоксове
function renderToggles(){
  const c=document.getElementById('toggles'); c.innerHTML='';
  cols.forEach((cdef,i)=>{
    const lbl=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.checked=!cdef.hidden;
    cb.onchange=()=>{ cdef.hidden=!cb.checked; renderTable(); };
    lbl.append(cb,' ',cdef.name);
    c.append(lbl);
  });
}

// рендер на таблица
function renderTable(){
  const thead=document.getElementById('thead'),
        tbody=document.getElementById('tbody');
  thead.innerHTML=''; tbody.innerHTML='';

  // заглавен ред
  const trh=document.createElement('tr');
  cols.forEach((cdef,i)=>{
    if(cdef.hidden) return;
    const th=document.createElement('th');
    th.textContent=cdef.name;
    th.onclick=()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    trh.append(th);
  });
  thead.append(trh);

  // данни
  rows.forEach(rdef=>{
    if(rdef.hidden) return;
    const tr=document.createElement('tr');
    cols.forEach((cdef,i)=>{
      if(cdef.hidden) return;
      const td=document.createElement('td');
      td.textContent = rdef.vals[i]||'';
      // mark max (първи динамичен >4)
      if(i>=4 && i<4+dateLabels.length && +parseSec(rdef.vals[i])===Math.max(...dateLabels.map((_,j)=>parseSec(rdef.vals[4+j]))))
        td.classList.add('max');
      tr.append(td);
    });
    tbody.append(tr);
  });
}

// сортиране toggle asc/desc
function sortBy(ci){
  document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc'; sortState.col=ci;
  const ths=document.querySelectorAll('th')[ci];
  ths.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
  rows.sort((a,b)=>{
    const A=a.vals[ci], B=b.vals[ci];
    const nA=parseFloat(A), nB=parseFloat(B);
    let cmp=!isNaN(nA)&&!isNaN(nB)? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'?cmp:-cmp;
  });
  renderTable();
}

// филтър
function filter(){
  const term=document.getElementById('search').value.toLowerCase();
  const sd=document.getElementById('start').value.replace(/-/g,''),
        ed=document.getElementById('end'  ).value.replace(/-/g,'');
  rows.forEach(rdef=>{
    let ok=true;
    if(term) ok = rdef.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      const v=rdef.vals[4];
      ok = (!sd||v>=sd) && (!ed||v<=ed);
    }
    rdef.hidden=!ok;
  });
  renderTable();
}

// All Dates
function allDates(){
  const dates = rows.map(r=>r.vals[4]).sort();
  const s=dates[0], e=dates.at(-1);
  document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end')  .value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filter();
}

// Compare Dates
function compare(){
  if(!cmpDates[0]||!cmpDates[1]) return alert('Изберете две дати');
  const idx1=rows.findIndex(r=>r.vals[4]===cmpDates[0]),
        idx2=rows.findIndex(r=>r.vals[4]===cmpDates[1]);
  if(idx1<0||idx2<0) return alert('Няма намерен ред');
  rows.forEach((r,i)=>{
    const v1=parseSec(rows[idx1].vals[5]),
          v2=parseSec(rows[idx2].vals[5]);
    r.diffAll=v2-v1;
    const tdDiff=document.querySelectorAll('tbody tr')[i]
             .appendChild(document.createElement('td'));
    tdDiff.textContent = fmtDiff(r.diffAll);
    tdDiff.classList.add(r.diffAll>=0?'diff-pos':'diff-neg');
  });
}

// reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  cols.forEach(c=>c.hidden=false);
  rows.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  renderToggles();
  renderTable();
}

// parse HH:MM:SS
function parseSec(s){ const [h,m,x]=(s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
function fmtDiff(n){ return (n>=0?'+':'')+n; }

</script>
</body>
</html>
EOF

echo "✅ Генериран $OUT – отвори в браузър!"







#!/usr/bin/env bash
set -euo pipefail

# Отиваме в папката на скрипта
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих '$CSV' в $(pwd)" >&2
  echo "   Съдържание на $(pwd):" >&2
  ls -1
  exit 1
fi

# Ескейп на backticks, за да вградим CSV-то в JS
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search…"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply">Apply Date Filter</button>
  <button id="all"  >All Dates</button>
  <button id="cmp"  >Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// ─── ВГРАДЕНО CSV ────────────────────────────────────
const rawCSV = `
$CSV_ESCAPED
`.trim();
// ────────────────────────────────────────────────────

function parseCSV(txt){
  return txt.split('\n').map(r=>r.split(','));
}
function parseSec(s){
  const [h,m,x] = (s||'00:00:00').split(':').map(Number);
  return h*3600 + m*60 + x;
}
function fmtDiff(n){ return (n>=0?'+':'') + n; }

let header, rows, N;
let columns   = [];    // {name, idx, hidden}
let data      = [];    // {vals, hidden, maxIdx, diffVal}
let sortState = {col:null,dir:'asc'};
let cmpDates  = [null,null];

document.addEventListener('DOMContentLoaded',()=>{
  // Flatpickr заместваме input[type=date] ако е нужно, иначе native.
  initData();
  buildToggles();
  renderTable();

  // Слушатели
  document.getElementById('search').addEventListener('input', filterTable);
  document.getElementById('apply' ).addEventListener('click', filterTable);
  document.getElementById('all'   ).addEventListener('click', setAllDates);
  document.getElementById('cmp'   ).addEventListener('click', compareDates);
  document.getElementById('reset' ).addEventListener('click', resetAll);
  document.getElementById('start' ).addEventListener('change', ()=>storeDate(0));
  document.getElementById('end'   ).addEventListener('change', ()=>storeDate(1));
});

function initData(){
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;

  // Определяме N = брой двойки Date/Elapsed
  // Чакаме последната колона да е "AVERAGE" или няма – игнорираме я
  const totalCols = header.length;
  const hasAvg = header[totalCols-1]==='AVERAGE';
  N = (totalCols - 4 - (hasAvg?1:0)) / 2;

  // Първите 4 статични
  columns = [];
  for(let i=0;i<4;i++){
    columns.push({name: header[i], idx:i, hidden:false});
  }
  // След това вземаме само Elapsed колони, но именуваме по реалните дати
  for(let j=0;j<N;j++){
    const dateIdx    = 4 + 2*j;
    const elapsedIdx = dateIdx + 1;
    const dateLabel  = rows[0][dateIdx];  // взимаме датата от първия ред
    columns.push({name: dateLabel, idx: elapsedIdx, hidden:false});
  }
  // И накрая Difference
  columns.push({name:'Difference', idx:null, hidden:false});

  // Подготвяме data[]
  data = rows.map(r=>{
    const vals = [];
    // статични
    for(let i=0;i<4;i++) vals.push(r[i]);
    // Elapsed стойности
    for(let j=0;j<N;j++){
      vals.push(r[4 + 2*j + 1] || '');
    }
    // изчисляваме maxIdx сред новите колони (0..3 + j)
    let maxIdx = 4, maxSec=-1;
    for(let k=0;k<N;k++){
      const s = parseSec(vals[4+k]);
      if(s>maxSec){ maxSec=s; maxIdx=4+k; }
    }
    return {vals, hidden:false, maxIdx, diffVal:0};
  });
}

function buildToggles(){
  const c = document.getElementById('toggles');
  c.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
    lbl.append(cb,' ',col.name);
    c.append(lbl);
  });
}

function renderTable(){
  const thead = document.getElementById('thead'),
        tbody = document.getElementById('tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // HEADER
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    hr.append(th);
  });
  thead.append(hr);

  // BODY
  data.forEach(row=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,i)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      // Стойност: ако idx=null (Difference), ще добавим по-долу
      if(col.idx!==null) td.textContent = row.vals[col.idx] || '';
      if(col.idx!==null && col.idx >= 4 && col.idx < 4+N) {
        // highlight max
        if(i===row.maxIdx) td.classList.add('max');
      }
      tr.append(td);
    });
    // Difference = lastElap - firstElap
    const firstSec = parseSec(row.vals[4]);
    const lastSec  = parseSec(row.vals[4+N-1]);
    const d        = lastSec - firstSec;
    const td2      = document.createElement('td');
    td2.textContent = fmtDiff(d);
    td2.classList.add(d>=0?'diff-pos':'diff-neg');
    tr.append(td2);

    tbody.append(tr);
  });
}

function sortBy(ci){
  document.querySelectorAll('#thead th')
    .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc';
  sortState.col=ci;
  const th = document.querySelectorAll('#thead th')[ci];
  th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');

  data.sort((a,b)=>{
    const A = a.vals[ columns[ci].idx ] || '',
          B = b.vals[ columns[ci].idx ] || '';
    const nA = parseFloat(A), nB = parseFloat(B);
    let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'? cmp : -cmp;
  });
  renderTable();
}

function filterTable(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value.replace(/-/g,'');
  const ed   = document.getElementById('end').value.replace(/-/g,'');

  data.forEach(r=>{
    let ok = true;
    if(term) ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      ok = r.vals[4] && (!sd||r.vals[4]>=sd) && (!ed||r.vals[4]<=ed);
    }
    r.hidden = !ok;
  });
  renderTable();
}

// Задава "All Dates" във формата YYYY-MM-DD
function setAllDates(){
  if(N<1) return;
  const dates = rows.map(r=>r[4]).sort(); // колоната с дати
  const s = dates[0], e = dates.at(-1);
  document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filterTable();
}

// Запазва избраната дата (YYYY-MM-DD → YYYYMMDD)
function storeDate(i){
  const v = document.getElementById(i? 'end':'start').value.replace(/-/g,'');
  cmpDates[i] = v || null;
}

function compareDates(){
  const [d1,d2] = cmpDates;
  if(!d1||!d2) return alert('Изберете и двете дати.');
  // намираме ред, чийто дата= d1/d2
  const idx1 = rows.findIndex(r=>r[4]===d1);
  const idx2 = rows.findIndex(r=>r[4]===d2);
  if(idx1<0||idx2<0) return alert('Не намерих ред за избраните дати.');
  data.forEach((r,i)=>{
    const s1 = parseSec(rows[idx1][5]),  // Elapsed е в колона 5 (4+1)
          s2 = parseSec(rows[idx2][5]);
    r.diffAll = s2 - s1;
  });
  renderTable();
}

function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start' ).value='';
  document.getElementById('end'   ).value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  buildToggles();
  renderTable();
}
</script>

</body>
</html>
EOF

echo "✅ Генериран $OUT – отвори в браузър!"






#!/usr/bin/env bash
set -euo pipefail

# Първо: местим се в директорията на самия скрипт
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Параметри (по подразбиране report.csv -> report.html)
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-report.html}"

# Проверка за CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ Не открих CSV файла '$CSV_INPUT' в папката $SCRIPT_DIR" >&2
  echo "   (Текуща папка: $(pwd))" >&2
  echo "   Съдържание на $(pwd):" >&2
  ls -1
  exit 1
fi

# Прочитаме цялото CSV и ескейпваме backticks
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# Генерираме HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // Вградeно CSV
    const rawCSV = \`
$CSV_CONTENT
\`;

    // Парсване
    function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
    function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
    function fmtDiff(n){ return (n>=0?'+':'') + n; }

    let header=[], rows=[], N;
    let columns=[], dateCols=[], elapsedCols=[];
    let data=[], currentSort={col:null,dir:'asc'};
    let cmpDates=[null,null];

    document.addEventListener('DOMContentLoaded',()=>{
      flatpickr('#start',{dateFormat:'Y-m-d'});
      flatpickr('#end',  {dateFormat:'Y-m-d'});

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search').addEventListener('input',renderFilter);
      document.getElementById('applyDates').addEventListener('click',renderFilter);
      document.getElementById('allDates').addEventListener('click',setAllDates);
      document.getElementById('compare').addEventListener('click',compareDates);
      document.getElementById('reset').addEventListener('click',resetAll);
      document.getElementById('start').addEventListener('change', ()=>storeCompare(0));
      document.getElementById('end').addEventListener('change',   ()=>storeCompare(1));
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/^[0-9]{8}$/.test(h)) dateCols.push(i);
        if(/^Elapsed/i.test(h))   elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          const s=parseSec(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const c=document.getElementById('toggles'); c.innerHTML='';
      columns.forEach((col,i)=>{
        const lbl=document.createElement('label');
        const cb=document.createElement('input');
        cb.type='checkbox'; cb.checked=!col.hidden;
        cb.onchange=()=>{ col.hidden=!cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        c.append(lbl);
      });
    }

    function renderTable(){
      const thead=document.getElementById('thead'),
            tbody=document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // Header
      const hr=document.createElement('tr');
      columns.forEach((col,i)=>{
        if(col.hidden) return;
        const th=document.createElement('th');
        th.textContent=col.name;
        th.onclick=()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // Body
      data.forEach(d=>{
        if(d.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((col,i)=>{
          if(col.hidden) return;
          const td=document.createElement('td');
          td.textContent=d.vals[i]||'';
          if(i===d.maxIdx) td.classList.add('max');
          tr.append(td);
        });
        const val = parseSec(d.vals[elapsedCols.at(-1)]) - parseSec(d.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=fmtDiff(val);
        td2.classList.add(val>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function renderFilter(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd=document.getElementById('start').value.replace(/-/g,''), 
            ed=document.getElementById('end').value.replace(/-/g,'');
      data.forEach(d=>{
        let ok=true;
        if(term)
          ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const v=d.vals[ci]||'';
            return (!sd||v>=sd) && (!ed||v<=ed);
          });
        }
        d.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds=dateCols.map(ci=>header[ci]).sort();
      const s=ds[0], e=ds.at(-1);
      document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
      document.getElementById('end'  ).value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
      renderFilter();
    }

    function storeCompare(idx){
      cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
    }

    function compareDates(){
      const [c1,c2] = cmpDates;
      if(!c1||!c2) return alert('Изберете две дати');
      const ci1 = header.indexOf(c1), ci2 = header.indexOf(c2);
      if(ci1<0||ci2<0) return alert('Дата не намерена в header');
      const ei1=ci1+1, ei2=ci2+1;
      data.forEach(d=>{
        d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(d=>{d.hidden=false; d.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран \${OUT_HTML} – отвори го в браузър!"






#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT_HTML="\${2:-report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "❌ Не открих CSV файла '\$CSV' в \$PWD" >&2
  exit 1
fi

# Escape на backticks за JS-template
CSV_CONTENT=\$(sed 's/`/\\\\`/g' "\$CSV")

cat >"\$OUT_HTML" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:10px; }
    .columns-toggle label { margin-right:10px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="apply">Apply Date Filter</button>
      <button id="all">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ─── Вградeно CSV ───────────────────────────────────────
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ────────────────────────────────────────────────────────

  function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
  function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
  function fmtDiff(n){ return (n>=0?'+':'') + n; }

  let header = [], rows = [], N;
  let columns = [], dateCols = [], elapsedCols = [], data = [];
  let currentSort = {col:null, dir:'asc'};
  let cmpDates = [null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    flatpickr('#start', {dateFormat:'Y-m-d'});
    flatpickr('#end',   {dateFormat:'Y-m-d'});

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('apply' ).addEventListener('click', filterTable);
    document.getElementById('all'   ).addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset' ).addEventListener('click', resetAll);
    document.getElementById('start' ).addEventListener('change', ()=>storeCompare(0));
    document.getElementById('end'   ).addEventListener('change', ()=>storeCompare(1));
  });

  function initData(){
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4)/2;

    // Определяме индекси
    dateCols    = header.map((h,i)=>/^[0-9]{8}\$/.test(h)?i:-1).filter(i=>i>=0);
    elapsedCols = header.map((h,i)=>/^Elapsed/i.test(h)?i:-1).filter(i=>i>=0);
    columns     = header.map(h=>({name:h,hidden:false}));

    // Подготвяме data
    data = rows.map(r=>{
      let maxIdx = elapsedCols[0], maxSec=-1;
      elapsedCols.forEach(ci=>{
        let s = parseSec(r[ci]);
        if(s>maxSec){ maxSec=s; maxIdx=ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles(){
    const ctr=document.getElementById('toggles');
    ctr.innerHTML='';
    columns.forEach((c,i)=>{
      const lbl=document.createElement('label');
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=!c.hidden;
      cb.onchange=()=>{ c.hidden=!cb.checked; renderTable(); };
      lbl.append(cb,' ',c.name);
      ctr.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML=''; tbody.innerHTML='';

    // Header + Difference
    const hr=document.createElement('tr');
    columns.forEach((c,i)=>{
      if(c.hidden) return;
      const th=document.createElement('th');
      th.textContent=c.name;
      th.onclick=()=>sortBy(i);
      if(currentSort.col===i) th.classList.add(
        currentSort.dir==='asc'?'sort-asc':'sort-desc'
      );
      hr.append(th);
    });
    const thD=document.createElement('th');
    thD.textContent='Difference';
    hr.append(thD);
    thead.append(hr);

    // Body
    data.forEach((d,ri)=>{
      if(d.hidden) return;
      const tr=document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const td=document.createElement('td');
        td.textContent = d.vals[i]||'';
        if(i===d.maxIdx) td.classList.add('max');
        tr.append(td);
      });
      const diffVal = d.diffAll;
      const td2=document.createElement('td');
      td2.textContent = fmtDiff(diffVal);
      td2.classList.add(diffVal>=0?'diff-pos':'diff-neg');
      tr.append(td2);
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col=ci;
    const th=document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci];
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp =(!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term = document.getElementById('search').value.toLowerCase();
    const sd = document.getElementById('start').value.replace(/-/g,''), 
          ed = document.getElementById('end'  ).value.replace(/-/g,'');
    data.forEach(d=>{
      let ok=true;
      if(term) ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        ok = dateCols.some(ci=>{
          const hv = d.vals[ci];
          return (!sd||hv>=sd) && (!ed||hv<=ed);
        });
      }
      d.hidden=!ok;
    });
    renderTable();
  }

  function setAllDates(){
    if(!dateCols.length) return;
    const ds = dateCols.map(ci=>header[ci]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeCompare(idx){
    const val = (idx===0?document.getElementById('start'):document.getElementById('end')).value.replace(/-/g,'');
    cmpDates[idx]=val;
  }

  function compareDates(){
    if(!cmpDates[0]||!cmpDates[1]) return alert('Изберете две дати');
    const ci1 = header.indexOf(cmpDates[0]);
    const ci2 = header.indexOf(cmpDates[1]);
    if(ci1<0||ci2<0) return alert('Не намерих колоната за избраната дата');
    const ei1 = ci1+1, ei2 = ci2+1;
    data.forEach(d=>{
      d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(d=>{d.hidden=false; d.diffAll=0;});
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>
</body>
</html>
EOF

echo "✅ Generated \$OUT_HTML – open it in your browser!"






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Вграждаме CSV-то в JS template literal (escape на backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { background:#fff; padding:20px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // ─── Вградeно CSV ──────────────────────────────────────────────────────────
    const rawCSV = \`
$CSV_CONTENT
\`;
    // ────────────────────────────────────────────────────────────────────────────

    // CSV → матрица
    function parseCSV(txt) {
      return txt.trim().split('\\n').map(r=>r.split(','));
    }
    // HH:MM:SS → секунди
    function parseElapsed(s) {
      const [h,m,x] = (s||'00:00:00').split(':').map(Number);
      return h*3600 + m*60 + x;
    }
    function formatDiff(n){ return (n>=0?'+':'') + n; }

    let header, rows, N;
    let columns = [], dateCols = [], elapsedCols = [];
    let data = [], currentSort = {col:null,dir:'asc'};

    document.addEventListener('DOMContentLoaded', () => {
      // Поправена инициализация на flatpickr:
      flatpickr('#start', { dateFormat: "Y-m-d" });
      flatpickr('#end',   { dateFormat: "Y-m-d" });

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search'     ).addEventListener('input', filterTable);
      document.getElementById('applyDates').addEventListener('click', filterTable);
      document.getElementById('allDates'   ).addEventListener('click', setAllDates);
      document.getElementById('compare'    ).addEventListener('click', compareDates);
      document.getElementById('reset'      ).addEventListener('click', resetAll);
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/date/i.test(h))    dateCols.push(i);
        if(/elapsed/i.test(h)) elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          let s=parseElapsed(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const ct = document.getElementById('toggles');
      ct.innerHTML = '';
      columns.forEach((col,i)=>{
        const lbl = document.createElement('label');
        const cb  = document.createElement('input');
        cb.type='checkbox'; cb.checked = !col.hidden;
        cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        ct.append(lbl);
      });
    }

    function renderTable(){
      const thead = document.getElementById('thead');
      const tbody = document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // HEADER
      const hr = document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const th=document.createElement('th');
        th.textContent=c.name;
        th.onclick = ()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // BODY
      data.forEach((row,ri)=>{
        if(row.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((c,i)=>{
          if(c.hidden) return;
          const td=document.createElement('td');
          td.textContent = row.vals[i]||'';
          if(elapsedCols.includes(i)&&row.maxIdx===i) td.classList.add('max');
          tr.append(td);
        });
        const d = parseElapsed(row.vals[elapsedCols.at(-1)]) - parseElapsed(row.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=formatDiff(d);
        td2.classList.add(d>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function filterTable(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd  =document.getElementById('start').value;
      const ed  =document.getElementById('end').value;
      data.forEach(r=>{
        let ok=true;
        if(term) ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const d=(r.vals[ci]||'').split('T')[0];
            return (!sd||d>=sd) && (!ed||d<=ed);
          });
        }
        r.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds = dateCols.map(ci=>header[ci]).sort();
      document.getElementById('start').value=ds[0];
      document.getElementById('end'  ).value=ds.at(-1);
      filterTable();
    }

    function compareDates(){
      const sd=document.getElementById('start').value;
      const ed=document.getElementById('end').value;
      if(!sd||!ed) return alert('Изберете две дати');
      const ci1 = header.indexOf(sd);
      const ci2 = header.indexOf(ed);
      if(ci1<0||ci2<0) return alert('Няма колона с такава дата');
      const ei1 = ci1+1, ei2 = ci2+1; 
      data.forEach(r=>{
        const v1=parseElapsed(r.vals[ei1]);
        const v2=parseElapsed(r.vals[ei2]);
        r.diffAll = v2 - v1;
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(r=>{r.hidden=false; r.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – двойно клик в браузър!"




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ CSV файлът '$CSV' не е намерен в $(pwd)" >&2
  exit 1
fi

# Ескейпваме backticks, за да вградим CSV-то в JS-template
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; background:#fff; padding:20px; border-radius:6px;
                 box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    .table-wrap { background:#fff; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search…" />
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <div class="table-wrap">
      <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ─── Вградeно CSV ──────────────────────────────────────────────────────────
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ────────────────────────────────────────────────────────────────────────────

  // Парсване на CSV
  function parseCSV(txt) {
    return txt.trim().split('\\n').map(r => r.split(','));
  }
  function parseElapsed(s) {
    const [h,m,sec] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + sec;
  }
  function formatDiff(n) { return (n>=0?'+':'') + n; }

  // Глобално състояние
  let header, rows, N;
  let columns = [], dateCols = [], elapsedCols = [];
  let data = [], currentSort = { col:null, dir:'asc' };

  // Инициализация
  document.addEventListener('DOMContentLoaded', () => {
    flatpickr('#start,{ dateFormat:"Y-m-d" }');
    flatpickr('#end',  { dateFormat:"Y-m-d" });

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('applyDates').addEventListener('click', filterTable);
    document.getElementById('allDates').addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset').addEventListener('click', resetAll);
  });

  function initData() {
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4) / 2;

    // Дефинираме колони
    header.forEach((h,i) => {
      columns.push({ name:h, hidden:false });
      if (/date/i.test(h))    dateCols.push(i);
      if (/elapsed/i.test(h)) elapsedCols.push(i);
    });

    // Подготвяме data[] обекти
    data = rows.map(r => {
      let maxIdx = elapsedCols[0], maxSec = -1;
      elapsedCols.forEach(ci => {
        const s = parseElapsed(r[ci]);
        if (s>maxSec) { maxSec = s; maxIdx = ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles() {
    const ctr = document.getElementById('toggles');
    ctr.innerHTML = '';
    columns.forEach((col,i) => {
      const lbl = document.createElement('label');
      const cb  = document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{
        col.hidden = !cb.checked;
        renderTable();
      };
      lbl.append(cb,' ',col.name);
      ctr.append(lbl);
    });
  }

  function renderTable() {
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    thead.innerHTML = ''; tbody.innerHTML = '';

    // HEADER
    const hr = document.createElement('tr');
    columns.forEach((col,i) => {
      if (col.hidden) return;
      const th = document.createElement('th');
      th.textContent = col.name;
      th.onclick = ()=>sortBy(i);
      if (currentSort.col===i)
        th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    const thD = document.createElement('th');
    thD.textContent = 'Difference';
    hr.append(thD);
    thead.append(hr);

    // BODY
    data.forEach(row=>{
      if (row.hidden) return;
      const tr = document.createElement('tr');
      columns.forEach((col,i)=>{
        if (col.hidden) return;
        const td = document.createElement('td');
        td.textContent = row.vals[i]||'';
        if (elapsedCols.includes(i) && row.maxIdx===i)
          td.classList.add('max');
        tr.append(td);
      });
      // Difference = lastElapsed - firstElapsed
      const d = parseElapsed(row.vals[ elapsedCols[elapsedCols.length-1] ]) -
                parseElapsed(row.vals[ elapsedCols[0] ]);
      const td2 = document.createElement('td');
      td2.textContent = formatDiff(d);
      if (d>0) td2.classList.add('diff-pos');
      if (d<0) td2.classList.add('diff-neg');
      tr.append(td2);

      tbody.append(tr);
    });
  }

  function sortBy(ci) {
    // clear classes
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    // toggle dir
    if (currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col = ci;
    // mark header
    const th = document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    // sort data
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci], cmp;
      const nA=parseFloat(A), nB=parseFloat(B);
      if (!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
      else cmp=A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable() {
    const term = document.getElementById('search').value.toLowerCase();
    const sd   = document.getElementById('start').value;
    const ed   = document.getElementById('end').value;
    data.forEach(r=>{
      let ok = true;
      if (term) {
        ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      }
      if (ok && (sd||ed)) {
        ok = dateCols.some(ci=>{
          const d = (r.vals[ci]||'').split('T')[0];
          return (!sd||d>=sd) && (!ed||d<=ed);
        });
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function setAllDates() {
    if (!dateCols.length) return;
    // Извличаме header датите
    const dates = dateCols.map(ci=>header[ci]).sort();
    document.getElementById('start').value = dates[0];
    document.getElementById('end').value   = dates[dates.length-1];
    filterTable();
  }

  function compareDates() {
    const sd = document.getElementById('start').value;
    const ed = document.getElementById('end').value;
    if (!sd||!ed) return alert('Изберете две дати');
    // намираме колоните по header
    const ci1 = header.findIndex(h=>h===sd);
    const ci2 = header.findIndex(h=>h===ed);
    if (ci1<0||ci2<0) return alert('Дата не намерена в колони');
    // сравняваме Elapsed стълбовете (след всяка date колона)
    const ei1 = dateCols.indexOf(ci1)>=0 ? dateCols.indexOf(ci1)+1 : ci1+1;
    const ei2 = dateCols.indexOf(ci2)>=0 ? dateCols.indexOf(ci2)+1 : ci2+1;
    data.forEach(r=>{
      const v1=parseElapsed(r.vals[ei1]);
      const v2=parseElapsed(r.vals[ei2]);
      r.diffAll = v2 - v1;
    });
    renderTable();
  }

  function resetAll() {
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>

</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ CSV файлът '$CSV' не е намерен в $(pwd)" >&2
  exit 1
fi

# Escape двойни кавички, за да вградим CSV-то в JS
CSV_ESCAPED=$(sed 's/"/\\"/g' "$CSV")

cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Advanced Report</title>
<style>
  body { font-family:sans-serif; padding:20px; background:#f4f4f4; }
  .controls { margin-bottom:15px; display:flex; flex-wrap:wrap; gap:10px; }
  .controls input, .controls button { padding:6px 10px; }
  .columns-toggle { margin-bottom:15px; }
  .columns-toggle label { margin-right:8px; }
  .table-wrap { overflow-x:auto; background:#fff; padding:10px; border:1px solid #ccc; }
  table { border-collapse:collapse; width:100%; }
  th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
  th { background:#eee; cursor:pointer; position:relative; user-select:none; }
  th.sort-asc::after  { content:" ↑"; }
  th.sort-desc::after { content:" ↓"; }
  td.max { background:#fff9c4; }
  .hidden { display:none; }
  .diff-pos { background:#e6f4ea; }
  .diff-neg { background:#fce8e6; }
</style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search…" />
  <input id="start" type="date" />
  <input id="end"   type="date" />
  <button id="applyDates">Apply Date Filter</button>
  <button id="compare">Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<div class="table-wrap">
  <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
</div>

<script>
// Вградено CSV
const rawCSV = \`
$CSV_ESCAPED
\`.trim();

// Парсване на CSV в масив от масиви
function parseCSV(txt) {
  return txt.split('\\n').map(r => r.split(','));
}

let header, rows, N;
let columns;    // {name,hidden}[]
let dateCols;   // индексите на date колони
let elapsedCols;// индексите на elapsed колони
let data;       // {vals,hidden,maxIdx,diff:{}}[]

const thead = document.getElementById('thead');
const tbody = document.getElementById('tbody');
const toggles= document.getElementById('toggles');

function init() {
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;
  N = (header.length - 4)/2;

  // Колони
  columns = header.map((h,i) => ({
    name: h, hidden: false
  }));
  dateCols    = header.map((h,i)=>/date/i.test(h)?i:-1).filter(i=>i>=0);
  elapsedCols = header.map((h,i)=>/elapsed/i.test(h)?i:-1).filter(i=>i>=0);

  // Данни
  data = rows.map(r => {
    let maxIdx=elapsedCols[0], maxSec=-1;
    elapsedCols.forEach(ci=>{
      const [h,m,s] = (r[ci]||'00:00:00').split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      if(sec>maxSec){ maxSec=sec; maxIdx=ci; }
    });
    return { vals:r.slice(), hidden:false, maxIdx, diff:{} };
  });

  buildToggles();
  render();
}

// Създава чекбоксове за скриване/показване на колони
function buildToggles(){
  toggles.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{
      col.hidden = !cb.checked;
      render();
    };
    lbl.append(cb, ' ', col.name);
    toggles.append(lbl);
  });
}

// Рендер на таблицата
function render(){
  // Header
  thead.innerHTML = '';
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    hr.append(th);
  });
  const tdiff = document.createElement('th');
  tdiff.textContent = 'Difference';
  hr.append(tdiff);
  thead.append(hr);

  // Body
  tbody.innerHTML = '';
  data.forEach((row,ri)=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,ci)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      td.textContent = row.vals[ci]||'';
      if(elapsedCols.includes(ci) && row.maxIdx===ci) td.classList.add('max');
      // сравнение
      if(row.diff[ci]!=null){
        td.classList.add(row.diff[ci]>=0? 'diff-pos':'diff-neg');
        td.textContent += ' '+row.diff[ci];
      }
      tr.append(td);
    });
    // difference col = lastElapsed-firstElapsed
    const diffAll = elapsedCols.reduce((acc,ci)=>acc + (row.diff[ci]||0), 0);
    const td2 = document.createElement('td');
    td2.textContent = formatDiff(diffAll);
    tr.append(td2);

    tbody.append(tr);
  });
}

// Форматира разлика секунди -> +X
function formatDiff(d){ return (d>=0?'+':'')+d; }

// Сортиране
function sortBy(ci){
  const dir = thead.querySelectorAll('th')[ci].classList.toggle('sort-asc')
             ? 'asc':'desc';
  thead.querySelectorAll('th').forEach((th,i)=>i!==ci && th.classList.remove('sort-asc','sort-desc'));
  if(dir==='desc') thead.querySelectorAll('th')[ci].classList.add('sort-desc');
  data.sort((a,b)=>{
    let A=a.vals[ci], B=b.vals[ci], res=0;
    const nA=parseFloat(A), nB=parseFloat(B);
    if(!isNaN(nA) && !isNaN(nB)) res=nA-nB;
    else res= A.localeCompare(B);
    return dir==='asc'? res : -res;
  });
  render();
}

// Филтриране
function filter(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value;
  const ed   = document.getElementById('end').value;
  data.forEach(r=>{
    let ok=true;
    if(term){
      ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    }
    if(ok && (sd||ed)){
      ok = dateCols.some(ci=>{
        const d = (r.vals[ci]||'').split('T')[0];
        return (!sd||d>=sd) && (!ed||d<=ed);
      });
    }
    r.hidden = !ok;
  });
  render();
}

// Запаметява индексите на редовете за сравнение
let cmpIdx = [];
function pickCompare(){
  const sd = document.getElementById('start').value;
  const ed = document.getElementById('end').value;
  if(sd){
    cmpIdx[0] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(sd));
  }
  if(ed){
    cmpIdx[1] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(ed));
  }
}

// Сравнение
function compare(){
  if(cmpIdx.length<2) return alert('Изберете две дати');
  data.forEach(r=>{
    elapsedCols.forEach(ci=>{
      const v1=parseElapsed(data[cmpIdx[0]].vals[ci]);
      const v2=parseElapsed(data[cmpIdx[1]].vals[ci]);
      r.diff[ci] = v2 - v1;
    });
  });
  render();
}

// Парсване HH:MM:SS -> секунди
function parseElapsed(s){
  const [h,m,x]= (s||'00:00:00').split(':').map(Number);
  return h*3600+m*60+x;
}

// Reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diff={}; });
  cmpIdx=[];
  init();
}

document.getElementById('search').addEventListener('input',filter);
document.getElementById('applyDates').addEventListener('click',filter);
document.getElementById('compare').addEventListener('click',compare);
document.getElementById('reset').addEventListener('click',resetAll);
document.getElementById('start').addEventListener('change',pickCompare);
document.getElementById('end'  ).addEventListener('change',pickCompare);

init();
</script>

</body>
</html>
EOF

echo "✅ Генериран: $OUT"






#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

# Проверка за наличен CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът '$CSV_INPUT' не е намерен в $(pwd)" >&2
  exit 1
fi

# Вграждане на CSV съдържанието (escape на backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# Генерираме HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    :root {
      --primary-color: #4285f4;
      --secondary-color: #f1f3f4;
      --hover-color: #e8f0fe;
      --border-color: #dadce0;
      --text-color: #202124;
      --light-text: #5f6368;
      --max-highlight: #fff9c4;
      --diff-positive: #e6f4ea;
      --diff-negative: #fce8e6;
    }
    body {
      font-family: 'Roboto',sans-serif; margin:0; padding:20px; background:#f8f9fa; color:var(--text-color);
    }
    .container {
      background:#fff; border-radius:8px; box-shadow:0 1px 2px rgba(0,0,0,0.1); padding:20px;
    }
    h1 { color:var(--primary-color); font-weight:500; margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:20px; align-items:center }
    .controls input, .controls button { padding:8px 12px; border:1px solid var(--border-color); border-radius:4px; font-family:inherit }
    .controls button { background:var(--primary-color); color:#fff; cursor:pointer; }
    .controls button:hover { background:#3367d6; }
    .table-container { overflow-x:auto; border:1px solid var(--border-color); border-radius:4px }
    table { width:100%; border-collapse:collapse; }
    th,td { padding:12px 15px; text-align:left; border-bottom:1px solid var(--border-color) }
    th { background:var(--secondary-color); color:var(--light-text); position:relative; cursor:pointer }
    tr:hover { background:var(--hover-color) }
    th.sort-asc::after { content:" ↑"; color:var(--primary-color) }
    th.sort-desc::after { content:" ↓"; color:var(--primary-color) }
    td.max { background:var(--max-highlight); font-weight:500 }
    .column-toggle { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:15px }
    .column-toggle label { display:flex; align-items:center; gap:5px; cursor:pointer; font-size:13px; background:var(--secondary-color); padding:5px 8px; border-radius:4px }
    .hidden { display:none!important }
    .diff-positive { background:var(--diff-positive) }
    .diff-negative { background:var(--diff-negative) }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Report</h1>
    <div class="controls">
      <input type="text" id="search" placeholder="Search across all columns..."/>
      <input type="text" id="start-date" class="date-picker" placeholder="From date"/>
      <input type="text" id="end-date" class="date-picker" placeholder="To date"/>
      <button id="apply-dates">Apply</button>
      <button id="compare-dates">Compare Dates</button>
      <button id="reset-all">Reset All</button>
    </div>
    <div class="column-toggle" id="column-toggle-container"></div>
    <div class="table-container">
      <table id="data-table"><thead></thead><tbody></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

  <script>
    // Вградено CSV
    const csvData = \`
$CSV_CONTENT
\`;

    // Помощни функции
    function parseCSV(text) {
      return text.trim().split('\n').map(r=>r.split(','));
    }
    function parseElapsed(s) {
      const [h,m,sec]=s.split(':').map(Number);
      return h*3600+m*60+sec;
    }
    function formatElapsed(sec) {
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return \`\${String(h).padStart(2,'0')}:\${String(m).padStart(2,'0')}:\${String(s).padStart(2,'0')}\`;
    }

    // Глобално състояние
    let columns = [], dateCols = [], elapsedCols = [];
    let allData = [], isComparing=false, compareIdx=[];

    // Зареждане и инициализация
    \$(document).ready(function(){
      flatpickr('.date-picker',{dateFormat:'Y-m-d',allowInput:true});
      const rows = parseCSV(csvData);
      const header = rows.shift();
      const N = (header.length-4)/2;
      // Колони
      header.forEach((h,i)=>{
        const isDate = /date/i.test(h);
        const isElapsed = /elapsed/i.test(h);
        columns.push({name:h,hidden:false});
        if(isDate) dateCols.push(i);
        if(isElapsed) elapsedCols.push(i);
      });
      // Данни
      rows.forEach(r=>{
        let maxIdx=elapsedCols[0], maxVal=-1;
        r.forEach((v,i)=> {
          if(elapsedCols.includes(i) && v){
            const secs=parseElapsed(v);
            if(secs>maxVal){ maxVal=secs; maxIdx=i; }
          }
        });
        allData.push({values:r,hidden:false,maxIdx,diff:{}}); 
      });
      initToggles();
      renderTable();
      // Events
      \$('#search').on('input',filterData);
      \$('#apply-dates').click(filterData);
      \$('#compare-dates').click(doCompare);
      \$('#reset-all').click(resetAll);
      \$('#start-date, #end-date').change(storeCompareIdx);
    });

    function initToggles(){
      const ct=\$('#column-toggle-container').empty();
      columns.forEach((col,i)=>{
        const chk=\$('<input type="checkbox">').prop('checked',!col.hidden)
          .change(_=>{col.hidden=!chk.prop('checked');renderTable();});
        ct.append(\$('<label>').append(chk,document.createTextNode(col.name)));
      });
    }

    function renderTable(){
      const tbl=\$('#data-table');
      const thead=tbl.find('thead').empty().append('<tr>');
      const tbody=tbl.find('tbody').empty();
      // Header + Difference
      columns.forEach((c,i)=>!c.hidden&& thead.append(\`<th data-col="\${i}">\${c.name}</th>\`));
      thead.append('<th>Difference</th>');
      thead.find('th').click(function(){
        sortBy(+this.dataset.col);
      });
      // Body
      allData.forEach(r=>{
        if(r.hidden) return;
        const tr=\$('<tr>');
        columns.forEach((c,i)=> {
          if(c.hidden) return;
          const v=r.values[i];
          const td=\$('<td>').text(v);
          if(elapsedCols.includes(i)&&i===r.maxIdx) td.addClass('max');
          if(isComparing && r.diff[i]!=null){
            td.addClass(r.diff[i]>=0?'diff-positive':'diff-negative')
              .append(' '+(r.diff[i]>=0?'+':'')+r.diff[i]);
          }
          tr.append(td);
        });
        // difference col
        const dsum = elapsedCols.reduce((acc,i)=>acc+(r.diff[i]||0),0);
        tr.append(\`<td>\${formatElapsed(dsum)}</td>\`);
        tbody.append(tr);
      });
      // DataTable
      tbl.DataTable({destroy:true,paging:false,scrollX:true,searching:true,dom:'Bfrtip',buttons:['colvis'],order:[]});
    }

    function sortBy(col){
      allData.sort((a,b)=>{
        const A=a.values[col], B=b.values[col];
        const nA=parseFloat(A),nB=parseFloat(B);
        let cmp=0;
        if(!isNaN(nA)&&!isNaN(nB)){ cmp=nA-nB; }
        else { cmp=A.localeCompare(B); }
        return cmp;
      });
      renderTable();
    }

    function filterData(){
      const term=\$('#search').val().toLowerCase();
      const sD=\$('#start-date').val(), eD=\$('#end-date').val();
      allData.forEach(r=>{
        const bySearch=term? r.values.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term)) : true;
        const byDate=(sD||eD)? dateCols.some(i=>{
          const d=r.values[i]; if(!d) return false;
          const dd=d.split('T')[0];
          return (!sD||dd>=sD)&&(!eD||dd<=eD);
        }):true;
        r.hidden=!(bySearch&&byDate);
      });
      renderTable();
    }

    function storeCompareIdx(){
      const dval=this.value;
      if(!dval) return;
      const col=dateCols[0];
      const idx=allData.findIndex(r=>r.values[col].startsWith(dval));
      if(this.id==='start-date') compareIdx[0]=idx;
      else compareIdx[1]=idx;
    }

    function doCompare(){
      if(compareIdx.length<2||compareIdx[0]==null||compareIdx[1]==null){
        alert('Изберете две дати!');
        return;
      }
      allData.forEach(r=>{
        r.diff={};
        elapsedCols.forEach(i=>{
          const v1=parseElapsed(allData[compareIdx[0]].values[i]);
          const v2=parseElapsed(allData[compareIdx[1]].values[i]);
          r.diff[i]=v2-v1;
        });
      });
      isComparing=true;
      renderTable();
    }

    function resetAll(){
      \$('#search,#start-date,#end-date').val('');
      columns.forEach(c=>c.hidden=false);
      allData.forEach(r=>{r.hidden=false; r.diff={}}); 
      isComparing=false; compareIdx=[];
      initToggles();
      renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Четем цялото CSV в една променлива (escape на backticks само)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    /* ...твоя CSS от примера... */
    .dataTables_scrollBody { overflow-x:auto!important; }
    td.max { background: var(--max-highlight) !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  <!-- ... твоя HTML за controls, toggles и т.н. ... -->
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ─── ВГРАДЕНО CSV ───────────────────────────────────────────────────────────
const csvData = \`
$CSV_CONTENT
\`;
// ──────────────────────────────────────────────────────────────────────────────

function parseCSV(text){
  return text.trim().split('\\n').map(r => r.split(','));
}

$(function(){
  const header = parseCSV(csvData).shift();
  const data   = parseCSV(csvData).slice(1);
  const N      = (header.length - 4) / 2;

  // … тук пълниш columns[], dateColumns[], elapsedColumns[] както преди …

  // Рендер на хедъра + Difference
  const thead = $('#data-table thead tr');
  header.forEach(h => thead.append('<th>' + h + '</th>'));
  thead.append('<th>Difference</th>');

  // Рендер на body
  data.forEach(row => {
    // … същата логика за изчисляване на maxIdx и diffStr …
    const tr = $('<tr>');
    // първите 4 поли
    row.slice(0,4).forEach(v => tr.append('<td>'+v+'</td>'));
    // date/elapsed двойки + highlight
    for(let j=0;j<N;j++){
      tr.append('<td>'+row[4+2*j]+'</td>');
      const cls = (j===maxIdx?'max':'');
      tr.append('<td class="'+cls+'">'+row[4+2*j+1]+'</td>');
    }
    tr.append('<td>'+diffStr+'</td>');
    $('#data-table tbody').append(tr);
  });

  // Инициализиране на DataTable
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging:   false,
    scrollX:  true,
    searching:true,
    buttons: ['colvis'],
    order:   [],
    columnDefs:[{ targets:[0], orderable:false }]
  });
});
</script>

</body>
</html>
EOF

echo "✅ Генериран $OUT – отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# Генерираме HTML с модерен дизайн и всички функционалности
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Report</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --primary-color: #4285f4;
    --secondary-color: #f1f3f4;
    --hover-color: #e8f0fe;
    --border-color: #dadce0;
    --text-color: #202124;
    --light-text: #5f6368;
    --max-highlight: #fff9c4;
    --diff-positive: #e6f4ea;
    --diff-negative: #fce8e6;
  }
  
  body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 20px;
    color: var(--text-color);
    background-color: #f8f9fa;
  }
  
  .container {
    max-width: 100%;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    padding: 20px;
  }
  
  h1 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 500;
  }
  
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    align-items: center;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--secondary-color);
    padding: 8px 12px;
    border-radius: 4px;
  }
  
  label {
    font-size: 14px;
    color: var(--light-text);
  }
  
  input, button, select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: inherit;
  }
  
  button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background-color: #3367d6;
  }
  
  #search {
    flex-grow: 1;
    min-width: 200px;
  }
  
  .table-container {
    overflow-x: auto;
    margin-top: 20px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }
  
  th {
    background-color: var(--secondary-color);
    color: var(--light-text);
    font-weight: 500;
    position: relative;
    cursor: pointer;
    user-select: none;
  }
  
  th:hover {
    background-color: var(--hover-color);
  }
  
  th.sort-asc::after {
    content: " ↑";
    color: var(--primary-color);
  }
  
  th.sort-desc::after {
    content: " ↓";
    color: var(--primary-color);
  }
  
  tr:hover {
    background-color: var(--hover-color);
  }
  
  .max {
    background-color: var(--max-highlight);
    font-weight: 500;
  }
  
  .column-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 15px;
  }
  
  .column-toggle label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    padding: 5px 8px;
    background: var(--secondary-color);
    border-radius: 4px;
  }
  
  .hidden {
    display: none !important;
  }
  
  .date-range {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .date-range input {
    width: 150px;
  }
  
  .diff-positive {
    background-color: var(--diff-positive);
  }
  
  .diff-negative {
    background-color: var(--diff-negative);
  }
  
  @media (max-width: 768px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
    
    #search {
      width: 100%;
    }
  }
</style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  
  <div class="controls">
    <input type="text" id="search" placeholder="Search across all columns...">
    
    <div class="control-group date-range">
      <label for="start-date">From:</label>
      <input type="text" id="start-date" class="date-picker" placeholder="Start date">
      <label for="end-date">To:</label>
      <input type="text" id="end-date" class="date-picker" placeholder="End date">
      <button id="apply-dates">Apply</button>
    </div>
    
    <button id="compare-dates">Compare Dates</button>
    <button id="reset-all">Reset All</button>
  </div>
  
  <div class="column-toggle" id="column-toggle-container">
    <!-- Column toggles will be inserted here by JavaScript -->
  </div>
  
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
// Глобални променливи за състоянието
let allData = [];
let columns = [];
let dateColumns = [];
let elapsedColumns = [];
let currentSort = { column: null, direction: 'asc' };
let isComparing = false;
let comparedDateIndices = [];

// Инициализация на календарите
flatpickr(".date-picker", {
  dateFormat: "Y-m-d",
  allowInput: true
});

// Зареждане на данните от CSV таблицата в HTML
function loadData() {
  const table = document.getElementById('data-table');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  // Изчистване на текущите данни
  thead.innerHTML = '';
  tbody.innerHTML = '';
  
  // Създаване на заглавния ред
  const headerRow = document.createElement('tr');
  columns.forEach((col, index) => {
    if (col.hidden) return;
    
    const th = document.createElement('th');
    th.textContent = col.name;
    th.dataset.columnIndex = index;
    th.addEventListener('click', () => sortData(index));
    
    if (currentSort.column === index) {
      th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  
  // Попълване на данните
  allData.forEach(row => {
    if (row.hidden) return;
    
    const tr = document.createElement('tr');
    columns.forEach((col, colIndex) => {
      if (col.hidden) return;
      
      const td = document.createElement('td');
      td.textContent = row.values[colIndex];
      
      // Маркиране на максималните стойности в Elapsed колоните
      if (elapsedColumns.includes(colIndex) && row.maxElapsedIndex === colIndex) {
        td.classList.add('max');
      }
      
      // Маркиране на разликите при сравнение на дати
      if (isComparing && row.diffValues && row.diffValues[colIndex] !== undefined) {
        const diff = row.diffValues[colIndex];
        if (diff > 0) {
          td.classList.add('diff-positive');
          td.textContent += ` (+${diff})`;
        } else if (diff < 0) {
          td.classList.add('diff-negative');
          td.textContent += ` (${diff})`;
        }
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// Функция за сортиране
function sortData(columnIndex) {
  if (currentSort.column === columnIndex) {
    // Промяна на посоката, ако вече сме сортирали по тази колона
    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
  } else {
    // Сортиране по нова колона във възходящ ред
    currentSort.column = columnIndex;
    currentSort.direction = 'asc';
  }
  
  allData.sort((a, b) => {
    const valA = a.values[columnIndex];
    const valB = b.values[columnIndex];
    
    // Опит за разпознаване на числа и дати
    const numA = parseFloat(valA);
    const numB = parseFloat(valB);
    const dateA = new Date(valA);
    const dateB = new Date(valB);
    
    let comparison = 0;
    
    if (!isNaN(numA) {
      // Числено сравнение
      comparison = numA - numB;
    } else if (dateA instanceof Date && !isNaN(dateA) {
      // Сравнение на дати
      comparison = dateA - dateB;
    } else {
      // Текстово сравнение
      comparison = valA.localeCompare(valB);
    }
    
    return currentSort.direction === 'asc' ? comparison : -comparison;
  });
  
  loadData();
}

// Филтриране на данните
function filterData() {
  const searchTerm = document.getElementById('search').value.toLowerCase();
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  
  allData.forEach(row => {
    let matchesSearch = true;
    let matchesDate = true;
    
    // Филтриране по търсене
    if (searchTerm) {
      matchesSearch = columns.some((col, index) => {
        if (col.hidden) return false;
        return row.values[index].toLowerCase().includes(searchTerm);
      });
    }
    
    // Филтриране по дати
    if (startDate || endDate) {
      matchesDate = dateColumns.some(dateCol => {
        const dateStr = row.values[dateCol];
        if (!dateStr) return false;
        
        const rowDate = new Date(dateStr);
        if (isNaN(rowDate)) return false;
        
        const compareDate = rowDate.toISOString().split('T')[0];
        
        if (startDate && endDate) {
          return compareDate >= startDate && compareDate <= endDate;
        } else if (startDate) {
          return compareDate >= startDate;
        } else if (endDate) {
          return compareDate <= endDate;
        }
        return true;
      });
    }
    
    row.hidden = !(matchesSearch && matchesDate);
  });
  
  loadData();
}

// Сравнение на дати
function compareDates() {
  if (comparedDateIndices.length < 2) {
    alert('Please select two different dates first by using the date filters.');
    return;
  }
  
  const [firstIndex, secondIndex] = comparedDateIndices;
  const firstRow = allData[firstIndex];
  const secondRow = allData[secondIndex];
  
  allData.forEach(row => {
    row.diffValues = [];
    
    columns.forEach((col, colIndex) => {
      if (elapsedColumns.includes(colIndex)) {
        // Изчисляване на разликата за Elapsed времето
        const time1 = parseElapsedTime(firstRow.values[colIndex]);
        const time2 = parseElapsedTime(secondRow.values[colIndex]);
        row.diffValues[colIndex] = time2 - time1;
      } else if (!isNaN(parseFloat(row.values[colIndex]))) {
        // Изчисляване на разликата за числови стойности
        const num1 = parseFloat(firstRow.values[colIndex]);
        const num2 = parseFloat(secondRow.values[colIndex]);
        row.diffValues[colIndex] = num2 - num1;
      }
    });
  });
  
  isComparing = true;
  loadData();
}

// Парсване на Elapsed време във секунди
function parseElapsedTime(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
  }
  return 0;
}

// Форматиране на секунди обратно във формат HH:MM:SS
function formatElapsedTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// Инициализация на колоните за скриване/показване
function initColumnToggles() {
  const container = document.getElementById('column-toggle-container');
  container.innerHTML = '';
  
  columns.forEach((col, index) => {
    const checkboxId = `col-toggle-${index}`;
    const label = document.createElement('label');
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.checked = !col.hidden;
    checkbox.addEventListener('change', () => {
      col.hidden = !checkbox.checked;
      loadData();
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(col.name));
    container.appendChild(label);
  });
}

// Зареждане на CSV данните
function parseCSV(csv) {
  const lines = csv.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  // Инициализиране на колоните
  columns = headers.map((header, index) => {
    const isDate = header.toLowerCase().includes('date');
    const isElapsed = header.toLowerCase().includes('elapsed');
    
    if (isDate) dateColumns.push(index);
    if (isElapsed) elapsedColumns.push(index);
    
    return {
      name: header,
      hidden: false,
      isDate,
      isElapsed
    };
  });
  
  // Парсване на редовете
  allData = lines.slice(1).map(line => {
    const values = line.split(',');
    let maxElapsedIndex = -1;
    let maxElapsed = -1;
    
    // Намиране на максималното Elapsed време
    elapsedColumns.forEach(colIndex => {
      if (values[colIndex]) {
        const seconds = parseElapsedTime(values[colIndex]);
        if (seconds > maxElapsed) {
          maxElapsed = seconds;
          maxElapsedIndex = colIndex;
        }
      }
    });
    
    return {
      values,
      hidden: false,
      maxElapsedIndex,
      diffValues: null
    };
  });
  
  // Инициализиране на UI елементите
  initColumnToggles();
  loadData();
}

// Зареждане на CSV файла
function loadCSV() {
  return fetch(window.location.href)
    .then(response => response.text())
    .then(csv => {
      // Премахване на BOM символа, ако има такъв
      if (csv.charCodeAt(0) === 0xFEFF) {
        csv = csv.substring(1);
      }
      parseCSV(csv);
    })
    .catch(error => {
      console.error('Error loading CSV:', error);
      alert('Error loading CSV data. Please check console for details.');
    });
}

// Инициализация на event listeners
function initEventListeners() {
  document.getElementById('search').addEventListener('input', filterData);
  document.getElementById('apply-dates').addEventListener('click', filterData);
  document.getElementById('compare-dates').addEventListener('click', compareDates);
  
  document.getElementById('reset-all').addEventListener('click', () => {
    // Нулиране на всички филтри
    document.getElementById('search').value = '';
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    
    // Нулиране на скритите колони
    columns.forEach(col => col.hidden = false);
    
    // Нулиране на сравнението
    isComparing = false;
    comparedDateIndices = [];
    
    // Нулиране на сортирането
    currentSort = { column: null, direction: 'asc' };
    
    // Нулиране на скриването на редове
    allData.forEach(row => row.hidden = false);
    
    // Презареждане на UI
    initColumnToggles();
    filterData();
  });
  
  // Запазване на индексите на избраните дати
  document.getElementById('start-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // Намиране на първия ред, който съвпада с избраната дата
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[0] = index;
    }
  });
  
  document.getElementById('end-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // Намиране на първия ред, който съвпада с избраната дата
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[1] = index;
    }
  });
}

// Стартиране на приложението при зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  initEventListeners();
  loadCSV();
});
</script>
</body>
</html>
EOF

# Вмъкване на CSV данните директно в HTML като JavaScript променлива
echo "<script>" >> "$OUT"
echo "// CSV data" >> "$OUT"
echo "const csvData = \`" >> "$OUT"
cat "$CSV" >> "$OUT"
echo "\`;" >> "$OUT"
echo "// End of CSV data" >> "$OUT"
echo "</script>" >> "$OUT"

echo "✅ Готово! Отвори '$OUT' в браузър."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Записваме началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси…">
EOF

# 2) Генерираме <table> с оцветяване на максимума и кликаеми <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # правим колоната сортиращ бутон
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, маркираме class="max" само на maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за търсене и сортиране
cat >>"$OUT" <<'EOF'
<script>
// Живо филтриране:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// Сортиране при клик на заглавие:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // Определяме посока (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // Сортиране
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // Ребилд на tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // Запомняме състоянието
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    .dataTables_wrapper .dataTables_scroll { overflow-x: auto; }
    th { background: #f0f0f0; white-space: nowrap; }
    td { white-space: nowrap; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x:auto;">
      <table id="data-table" class="table table-striped table-bordered" style="width:100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# Вкарваме CSV съдържанието
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th>${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    scrollX: true,
    paging: false,
    ordering: false,
    info: false
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX:true, paging:false, ordering:false, info:false, buttons:['colvis'] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    paging: false,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, paging: false, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    .dataTables_wrapper .dataTables_scroll { overflow: auto; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div class="table-responsive">
      <table id="data-table" class="table table-striped table-bordered w-100">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: false,
    paging: false,
    scrollX: true,
    order: [],
    columnDefs: [{ targets:[0], orderable:false }]
  });

  table.columns().every(function(){
    const col = this;
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ 
        dom:'Bfrtip', 
        buttons:['colvis'], 
        responsive:false, 
        paging:false, 
        scrollX:true, 
        order:[] 
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# Escape backticks in CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Start HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# CSV content
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# JavaScript end
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  // Header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Body
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    paging: false,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  // Филтри
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Дата филтър
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        paging: false,
        order: []
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."




CSV_ESCAPED=$(sed \
  -e 's/\\/\\\\/g' \
  -e 's/"/\\"/g' \
  -e 's/`/\\`/g' \
  -e 's/<\/script>/<\/scr"+"ipt>/g' \
  "$CSV")



#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# Escape само backticks от CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Начало на HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    th button { float:right; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# Инжектирай CSV съдържание
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# Финална HTML част с JS логика
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      const time = row[4+2*j+1];
      let [h,m,s] = time.split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    paging: false
  });

  table.columns().every(function(){
    const col = this, idx = col.index();
    const inp = $('<input>').attr('placeholder','filter')
      .addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    const btn = $('<button class="btn btn-sm btn-outline-secondary ml-1">Hide</button>');
    btn.on('click',()=>{
      const visible = table.column(idx).visible();
      table.column(idx).visible(!visible);
      btn.text(visible ? 'Show' : 'Hide');
    });
    $(col.header()).empty().append(inp).append(btn);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);

    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    const sel = dates.map((d,i)=>({date: d, index: i}))
                     .filter(d=>!min||d.date>=min)
                     .filter(d=>!max||d.date<=max);
    $('#table-header th:last-child:contains("Difference")').remove();
    $('#table-body tr').each((_,tr)=>$(tr).find('td:last').remove());

    if(sel.length === 2){
      let i1 = sel[0].index, i2 = sel[1].index;
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2];
        let delta = d2 - d1;
        let sign = delta < 0 ? '-' : '';
        let abs = Math.abs(delta);
        let hh = Math.floor(abs/3600), mm = Math.floor((abs%3600)/60), ss = abs%60;
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        order: [],
        paging: false
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

# 1) Проверка
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът ‘$CSV_INPUT’ не е намерен в $(pwd)" >&2
  exit 1
fi

# 2) Прочитаме header и data
IFS= read -r header_line < "$CSV_INPUT"
IFS=',' read -r -a header_arr <<< "$header_line"
mapfile -t data_lines < <(tail -n +2 "$CSV_INPUT")

# 3) Писане на статичната част (HEAD) – single-quoted so nothing expands
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Вграден CSV → JS масиви
HTML_HEAD

# 4) Вмъкване на header[] масива
echo "    const header = [" >>"$OUT_HTML"
for i in "${!header_arr[@]}"; do
  # escape двойни кавички в стойността
  col=${header_arr[i]//\"/\\\"}
  if (( i < ${#header_arr[@]}-1 )); then
    printf '      "%s",\n' "$col" >>"$OUT_HTML"
  else
    printf '      "%s"\n' "$col" >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 5) Вмъкване на data[] масива
echo "    const data = [" >>"$OUT_HTML"
for idx in "${!data_lines[@]}"; do
  line=${data_lines[idx]}
  # split by comma
  IFS=',' read -r -a cells <<< "$line"
  printf '      [' >>"$OUT_HTML"
  for j in "${!cells[@]}"; do
    cell=${cells[j]//\"/\\\"}
    if (( j < ${#cells[@]}-1 )); then
      printf "\"%s\"," "$cell" >>"$OUT_HTML"
    else
      printf "\"%s\"" "$cell" >>"$OUT_HTML"
    fi
  done
  if (( idx < ${#data_lines[@]}-1 )); then
    printf '],\n' >>"$OUT_HTML"
  else
    printf ']\n' >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 6) Писане на статичната част (TAIL) – също single-quoted
cat >>"$OUT_HTML" <<'HTML_TAIL'
    // Document ready → render таблицата
    $(document).ready(function(){
      const N = (header.length - 4) / 2; // брой Date/Elapsed двойки

      // Рендер на хедъра + колона Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендер на body и highlight max
      data.forEach(row => {
        // парсиме elapsed в секунди и мерим max
        const secs = [], tr = $('<tr>');
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = (j === maxIdx ? 'max' : '');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = последно − първо
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? '-' : '';
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // Инициализация на DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,      // без страници
        scrollX:  true,       // хоризонтално скролване
        searching:true,       // глобална търсачка
        buttons: ['colvis'],  // бутон hide/show
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Прочитаме header (първи ред)
IFS= read -r header_line < "$CSV"
IFS=',' read -r -a header_arr <<< "$header_line"

# Прочитаме data (всичко след първия ред)
data_lines=()
while IFS= read -r line; do
  data_lines+=("$line")
done < <(tail -n +2 "$CSV")

# Функция за превръщане на CSV-ред в JS-стринг-арей
to_js_array(){
  local line="$1"
  IFS=',' read -r -a cells <<< "$line"
  printf '['
  local first=1
  for cell in "${cells[@]}"; do
    # ескейпваме евентуални двойни кавички в cell
    esc=${cell//\"/\\\"}
    if (( first )); then
      printf "\"%s\"" "$esc"
      first=0
    else
      printf ",\"%s\"" "$esc"
    fi
  done
  printf ']'
}

# ГЕНЕРИРАМЕ HTML
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Header и data вградени като JS масиви
    const header = [
EOF

# Вмъкваме header
first=1
for col in "${header_arr[@]}"; do
  esc=${col//\"/\\\"}
  if (( first )); then
    printf '      "%s"\n' "$esc" >>"$OUT"
    first=0
  else
    printf '     ,"%s"\n' "$esc" >>"$OUT"
  fi
done

cat >>"$OUT" <<EOF
    ];

    const data = [
EOF

# Вмъкваме data ред по ред
for i in "${!data_lines[@]}"; do
  line=${data_lines[i]}
  jsarr=$(to_js_array "$line")
  if (( i < ${#data_lines[@]} - 1 )); then
    printf '      %s,\n' "$jsarr" >>"$OUT"
  else
    printf '      %s\n' "$jsarr" >>"$OUT"
  fi
done

cat >>"$OUT" <<'EOF'
    ];

    $(document).ready(function(){
      const N = (header.length - 4)/2; // брой Date/Elapsed двойки

      // Рисуваме header + добавяме Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рисуваме body + highlight max
      data.forEach(row => {
        // парсиме Elapsed в секунди и търсим max
        const secs = [], tr = $('<tr>'), LENGTH=N;
        let maxSec=-1, maxIdx=0;
        for(let j=0;j<LENGTH;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j; }
        }
        // STATUS..JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for(let j=0;j<LENGTH;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls=(j===maxIdx?'max':'');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0],
              sign = diff<0?'-':'',
              sabs = Math.abs(diff),
              h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60,
              dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);
        $('#table-body').append(tr);
      });

      // Инициализираме DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,   // без страници
        scrollX:  true,    // хоризонтално скролване
        searching:true,    // глобална търсачка
        buttons: ['colvis'],
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
EOF

echo "✅ Генериран: $OUT (от $CSV)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# 1) Проверка за CSV-то
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в: $(pwd)" >&2
  exit 1
fi

# 2) Експейпваме само backticks (ако ги има)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 3) Писане на началото на HTML-а
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* хоризонтално скролване */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS Libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ——— ВГРАДЕНО CSV —————————————————————————————
    const rawCSV = `
HTML_START

# 4) Вкарваме съдържанието на CSV-то
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 5) Писане на останалата част от HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // колко date/elapsed двойки

      // Рендер: хедър + разлика
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендер: body + highlight max
      data.forEach(row => {
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // Инициализация на DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // без страници
        scrollX: true,      // хоризонтално скролване
        searching: true,    // глобална търсачка
        buttons: ['colvis'],// бутон hide/show колони
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT)"





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в: $(pwd)" >&2
  exit 1
fi

# Екранираме само backticks, останалото оставяме непроменено
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) Писане на началото на HTML-а (single-quoted here-doc за да не разширява $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* хоризонтално скролване на таблицата */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ——— ВГРАДЕНО CSV —————————————————————————————
    const rawCSV = `
HTML_START

# 2) Добавяме съдържанието на CSV-то
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) Писане на останалата част от HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // брой Date/Elapsed двойки

      // Рендиране на хедъра + разлика
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендиране на body + highlight max
      data.forEach(row => {
        // изчисляваме секунди и намираме максимума
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }

        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // Инициализация на DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // без страници
        scrollX: true,      // хоризонтално скролване
        searching: true,    // глобална търсачка
        buttons: ['colvis'],// бутон hide/show колони
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT). Отвори го директно в браузър."








#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# Диагностика
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в:" >&2
  echo "   $(pwd)" >&2
  exit 1
fi

# Екранираме само backticks (ако ги има в CSV-то)
ESCAPED_CSV=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) Печатаме първата (статична) част от HTML-а
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css">
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ВГРАДЕНО CSV
    const rawCSV = `
HTML_HEAD

# 2) Вкарваме съдържанието на CSV-то
printf '%s\n' "$ESCAPED_CSV" >> "$OUT_HTML"

# 3) Печатаме останалата (статична) част от HTML + JS
cat >>"$OUT_HTML" <<'HTML_TAIL'
`;
    function parseCSV(txt) {
      return txt.trim().split("\n").map(r=>r.split(","));
    }
    $(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4)/2;  // колко date/elapsed двойки

      // header + Difference
      header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // body
      data.forEach(row=>{
        // изчисляваме секунди и най-голямо Elapsed
        let secs = [], maxSec=-1, maxIdx=0;
        for(let j=0;j<N;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(":").map(Number);
          const s = hh*3600+mm*60+ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j }
        }
        const tr = $("<tr>");
        // първи 4 колони
        row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
        // date/elapsed двойки
        for(let j=0;j<N;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = j===maxIdx?"max":"";
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff<0?"-":"";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // Инициализираме DataTable без paging + бутон за hide/show
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging: false,
        searching: true,
        buttons: ['colvis'],
        responsive: true,
        order: []
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "✅ Готово – генериран $OUT_HTML (от $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Ако подадеш път към CSV, го ползваме, иначе – report.csv до скрипта
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CSV_INPUT="${1:-report.csv}"
# Ако пътът към CSV не е абсолютен, го допълваме с директорията на скрипта
if [[ "$CSV_INPUT" != /* ]]; then
  CSV_PATH="$SCRIPT_DIR/$CSV_INPUT"
else
  CSV_PATH="$CSV_INPUT"
fi

# Изходният HTML
OUT_HTML="${2:-interactive_report.html}"

# Диагностика: има ли CSV
if [[ ! -f "$CSV_PATH" ]]; then
  echo "❌ Не мога да открия CSV файла:" >&2
  echo "   Изглежда, че търся тук: $CSV_PATH" >&2
  echo "   Текуща директория: $(pwd)"   >&2
  echo "   Съдържание на $SCRIPT_DIR:"   >&2
  ls -1 "$SCRIPT_DIR" >&2 || true
  exit 1
fi

# Екранираме само backticks (останалият JS/HTML код не се пипа)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_PATH")

# 1) Първа част на HTML (single-quoted за да не се разширяват $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ——— ВГРАДЕНО CSV —————————————————————————————
const rawCSV = `
HTML_START

# 2) Вкарваме съдържанието на report.csv
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) Останалата част от HTML+JS
cat >>"$OUT_HTML" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;  // брой Date/Elapsed двойки

  // header + Difference
  header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // body
  data.forEach(row=>{
    let secsRow=[], maxSec=-1, maxIdx=0;
    for(let j=0;j<N;j++){
      let [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0;j<N;j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = j===maxIdx?'max':'';
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let diff = secsRow[secsRow.length-1] - secsRow[0],
        sign = diff<0?'-':'',
        s    = Math.abs(diff),
        h2   = Math.floor(s/3600), m2=Math.floor((s%3600)/60), s2=s%60,
        str  = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
    tr.append(`<td>${str}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // DataTable без paging
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Успешно: генериран $OUT_HTML (чете $CSV_PATH)"





#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT="\${2:-interactive_report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "❌ Не открих \$CSV" >&2
  exit 1
fi

# Експейпваме само backticks
CSV_ESCAPED=\$(sed 's/`/\\\\`/g' "\$CSV")

# 1) HTML старт (нищо не се разширява тук, заради single-quoted here-doc)
cat >"\$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <!-- Bootstrap -->
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

<script>
// ——— ВГРАДЕНО CSV като многострочен string —————————————————
const rawCSV = \`
HTML_START

# 2) Вкарваме самото съдържание на CSV
printf '%s\n' "\$CSV_ESCAPED" >> "\$OUT"

# 3) Останалата част от HTML+JS (пак без разширявания)
cat >>"\$OUT" <<'HTML_END'
\`;
function parseCSV(text){
  return text.trim().split("\\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  // брой Date/Elapsed двойки
  const N      = (header.length - 4) / 2;

  // --- Рисуваме header + добавяме Difference ---
  header.forEach(h => {
    $('#table-header').append(`<th>\${h}</th>`);
  });
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // --- Попълваме body + highlight максимума ---
  data.forEach(row => {
    // Парсваме секунди и търсим max
    let secsRow = [], maxSec=-1, maxIdx=0;
    for(let j=0; j<N; j++){
      let [hh,mm,ss] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec=sec; maxIdx=j; }
    }

    // Създаваме ред
    const tr = $('<tr>');
    // STATUS, STAGE, BATCH, JOB.NAME
    row.slice(0,4).forEach(cell => tr.append(`<td>\${cell}</td>`));
    // Date/Elapsed двойки
    for(let j=0; j<N; j++){
      tr.append(`<td>\${row[4 + 2*j]}</td>`);
      let cls = (j===maxIdx ? 'max' : '');
      tr.append(`<td class="\${cls}">\${row[4 + 2*j + 1]}</td>`);
    }
    // Разлика = last - first
    let diffSec = secsRow[secsRow.length-1] - secsRow[0],
        sign    = diffSec<0 ? '-' : '',
        s       = Math.abs(diffSec),
        hh2     = Math.floor(s/3600),
        mm2     = Math.floor((s%3600)/60),
        ss2     = s%60,
        diffStr = `${sign}${String(hh2).padStart(2,'0')}:${String(mm2).padStart(2,'0')}:${String(ss2).padStart(2,'0')}`;
    tr.append(`<td>\${diffStr}</td>`);

    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // --- Инициализираме DataTable без страници и с бутон за hide/show ---
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово! Отвори '\$OUT' в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# 1) Прочитаме CSV и escape-аме само backticks
#    (останалите $ нямат значение, защото тук само
#     ще го inserтим)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) Първа част от HTML (без да се разширяват никакви $)
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
// ——— ВГРАДЕНО CSV ————————————————————————————————
const rawCSV = `
HTML_START

# 3) Инжектираме самото съдържание на report.csv
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# 4) Останалата част от HTML + JS logic
cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2; // двойките Date/Elapsed

  // Render header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Render body + highlight max
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    // STATUS,STAGE,BATCH,JOB.NAME
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    // Date/Elapsed pairs
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    // Average
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // Init DataTables
  const table = $('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });
  // Column filters
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Date-range filter + Difference
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ dom:'Bfrtip',buttons:['colvis'],responsive:true,order:[] });
    }
  }
  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

# 1) Прочитаме CSV и го екранираме за backticks
if [ ! -f "$CSV" ]; then
  echo "Не открих $CSV" >&2
  exit 1
fi
# Slurp whole file, избягваме backtick „`“
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) Генерираме HTML-а
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
    th { cursor: pointer; background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
// ——— ВГРАДЕНО CSV —————————————————————————————————————————
const rawCSV = \`
${CSV_ESCAPED}
\`;
// ————————————————————————————————————————————————————————

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

\$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2; // броят двойки Date/Elapsed

  // Рисуваме header
  header.forEach((h,i)=>{
    \$('#table-header').append(
      `<th data-col="\${i}">\${h}</th>`
    );
  });

  const secsData = [];

  // Попълваме body
  data.forEach((row,ridx)=>{
    const tr = \$('<tr>');
    const secsRow = [];
    let maxSec = -1, maxIdx = -1;

    // изчисляваме секунди и намираме max
    for(let j=0;j<N;j++){
      const val = row[4+2*j+1];
      const [h,m,s] = val.split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }

    // STATUS..JOB.NAME
    for(let c=0;c<4;c++){
      tr.append(`<td>\${row[c]}</td>`);
    }
    // Date/Elapsed
    for(let j=0;j<N;j++){
      tr.append(`<td>\${row[4+2*j]}</td>`);
      const cls = j===maxIdx ? 'max' : '';
      tr.append(`<td class="\${cls}">\${row[4+2*j+1]}</td>`);
    }
    // AVERAGE
    const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
    const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

    secsData.push(secsRow);
    \$('#table-body').append(tr);
  });

  // Init DataTable
  const table = \$('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });

  // Column filters
  table.columns().every(function(){
    const col=this;
    const idx=col.index();
    const inp=\$('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    \$(col.header()).empty().append(inp);
  });

  // Date-range filter
  function applyDateFilter(){
    const min=\$('#min-date').val();
    const max=\$('#max-date').val();
    const dates=header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      const show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    // ако точно 2 дати – Difference
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !table.column(':contains("Difference")').nodes().length){
      const i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      table.column.adjust().draw(false);
      \$('#table-header').append('<th>Difference</th>');
      \$('#table-body tr').each((ri,tr)=>{
        const d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        const s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        const sign=delta<0?'-':'';
        \$(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  \$('#clear-dates').on('click',()=>{
    \$('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
  </script>
</body>
</html>
EOF

echo "✅ Генерирано: $OUT (от $CSV). Отвори в браузър — вече работи без fetch!"







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />

  <!-- DataTables + Buttons + Responsive -->
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />

  <!-- Flatpickr за календар -->
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />

  <style>
    /* Жълто highlight за max */
    td.max { background-color: #ffeb3b !important; }
    /* Малко padding на date-range полето */
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <!-- Date range pickers -->
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <!-- Table -->
    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
  // 1) Зареждаме CSV
  async function loadCSV(path) {
    const resp = await fetch(path);
    const text = await resp.text();
    return text.trim().split('\n').map(r => r.split(','));
  }

  $(document).ready(async function(){
    const data = await loadCSV('${CSV}');
    const header = data.shift();
    const N = (header.length - 5) / 2; // броят двойки Date/Elapsed (после има AVERAGE)

    // Рисуваме header
    header.forEach((h,i) => {
      $('#table-header').append(
        `<th data-col="\${i}" class="text-nowrap">${h}</th>`
      );
    });

    // Попълваме body и изчисляваме secsData
    const secsData = [];
    data.forEach((row, ridx) => {
      const tr = $('<tr>');
      const secsRow = [];

      // изолираме Elapsed колони (index: 5,7,9,...)
      let maxSec = -1, maxIdx = -1;
      for(let j=0; j<N; j++){
        const val = row[4 + 2*j + 1];
        const [h,m,s] = val.split(':').map(Number);
        const sec = h*3600 + m*60 + s;
        secsRow.push(sec);
        if(sec > maxSec){ maxSec=sec; maxIdx=j; }
      }

      // STATUS, STAGE, BATCH, JOB.NAME (0..3)
      for(let c=0; c<4; c++){
        tr.append(`<td>\${row[c]}</td>`);
      }
      // Date/Elapsed двойки
      for(let j=0; j<N; j++){
        tr.append(`<td>\${row[4 + 2*j]}</td>`);
        const cls = (j===maxIdx ? 'max' : '');
        tr.append(`<td class="\${cls}">\${row[4 + 2*j +1]}</td>`);
      }
      // AVERAGE
      const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
      const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
      tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

      secsData.push(secsRow);
      $('#table-body').append(tr);
    });

    // Инициализираме DataTable
    const table = $('#data-table').DataTable({
      dom: 'Bfrtip',
      buttons: [ 'colvis' ],
      responsive: true,
      order: [],
      columnDefs: [{ targets: [0], orderable: false }]
    });

    // Колонни филтри
    table.columns().every(function(){
      const col = this;
      const idx = col.index();
      const inp = $('<input>')
        .attr('placeholder','filter')
        .addClass('form-control form-control-sm')
        .on('keyup change clear', ()=>col.search(inp.val()).draw());
      $(col.header()).empty().append(inp);
    });

    // Date range филтър
    function applyDateFilter() {
      const min = $('#min-date').val();
      const max = $('#max-date').val();
      const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
      dates.forEach((d,i)=>{
        const show = (!min||d>=min) && (!max||d<=max);
        table.column(4+2*i).visible(show);
        table.column(4+2*i+1).visible(show);
      });

      // точно две дати => разлика
      const selected = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
      if(selected.length===2 && !table.column(':contains("Difference")').nodes().length) {
        const i1 = dates.indexOf(selected[0]);
        const i2 = dates.indexOf(selected[1]);
        // добавяме колона Difference
        table.column.adjust().draw(false);
        $('#table-header').append('<th>Difference</th>');
        $('#table-body tr').each((ri,tr)=>{
          const sec1 = secsData[ri][i1], sec2 = secsData[ri][i2];
          const dsec = sec2 - sec1, s = Math.abs(dsec);
          const hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60), ss = s%60;
          const sign = dsec<0?'-':'';
          $(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
        });
      }
    }

    // flatpickr за date inputs
    flatpickr(".flatpickr", { dateFormat: "Y-m-d", onChange: applyDateFilter });
    $('#clear-dates').on('click', ()=>{
      $('#min-date,#max-date').val('');
      applyDateFilter();
    });
  });
  </script>
</body>
</html>
EOF

echo "✅ Генерирано: $OUT (чете $CSV). Отвори го в браузър."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Записваме началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси…">
EOF

# 2) Генерираме <table> с оцветяване на максимума и кликаеми <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # правим колоната сортиращ бутон
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, маркираме class="max" само на maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за търсене и сортиране
cat >>"$OUT" <<'EOF'
<script>
// Живо филтриране:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// Сортиране при клик на заглавие:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // Определяме посока (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // Сортиране
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // Ребилд на tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // Запомняме състоянието
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Пишем началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси в таблицата…">
EOF

# 2) Генерираме самата <table> от CSV, като оцветяваме max Elapsed на ред
awk -F, '
BEGIN {
  OFS="";
  print "<table>";
}
NR==1 {
  # header
  print "<tr>";
  for(i=1;i<=NF;i++){
    header[i]=$i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    print "<th>"$i"</th>";
  }
  print "</tr>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600+T[2]*60+T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, като само при maxcol добавяме class="max"
  print "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    print "<td" cls ">" , $i , "</td>";
  }
  print "</tr>";
}
END {
  print "</table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за живото филтриране при писане в полето #search
cat >>"$OUT" <<'EOF'
<script>
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("table tr").forEach(function(row, i) {
    if(i === 0) return; // skip header
    var text = row.textContent.toLowerCase();
    row.style.display = text.includes(filter) ? "" : "none";
  });
});
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър, за да видиш търсачката и оцветения максимум."




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

awk -F, '
BEGIN {
  OFS=""
  # Начало на HTML-а и стилистика
  print "<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><style>"
  print "table, th, td { border: 1px solid #ccc; border-collapse: collapse; }"
  print "th, td { padding: 4px 8px; }"
  print ".max { background-color: #ffeb3b; }"
  print "</style></head><body><table>"
}
NR==1 {
  # Хедър-ред: намираме индексите на Elapsed колоните
  printf "<tr>"
  for(i=1;i<=NF;i++){
    header[i]=$i
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    printf "<th>%s</th>", $i
  }
  print "</tr>"
  next
}
{
  # За всеки ред намираме коя от Elapsed колоните е максимална
  maxsec = -1; maxcol = 0
  for(j=1;j<=ecount;j++){
    idx = elapsed_idx[j]
    split($idx, T, ":")
    sec = T[1]*3600 + T[2]*60 + T[3]
    if(sec > maxsec){
      maxsec = sec
      maxcol = idx
    }
  }
  # Отпечатваме реда, като cell i=maxcol получава клас="max"
  printf "<tr>"
  for(i=1;i<=NF;i++){
    if(i==maxcol)
      printf "<td class=\"max\">%s</td>", $i
    else
      printf "<td>%s</td>", $i
  }
  print "</tr>"
}
END {
  print "</table></body></html>"
}' "$CSV" > "$OUT"

echo "✅ Готово! Отвори $OUT в браузър, за да видиш оцветените максимуми."






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """Превръща 'HH:MM:SS' в секунди."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- Настройка на директория и брой дни назад ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# Смяна на работната директория
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"Не мога да вляза в директория '{files_dir}': {e}")

# --- Вземаме последните N файла JT* по дата на промяна ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files     = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("Няма намерени файлове JT* в текущата папка.")

# --- Парсваме всеки файл и пълним data[key][idx] ---
data  = {}                           # data[(stage,batch,job)] = { idx0: {...}, idx1: {...}, ... }
dates = [None]*len(files)            # dates[i] = дата от файл i

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date              = parts[3]
            elapsed           = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # Запаметяваме датата за този файл
    if dates[idx] is None:
        dates[idx] = date

# --- Писане на CSV на stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")

# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
header.append("AVERAGE")
out.writerow(header)

# За всеки JOB ключ генерираме по един ред
for key in sorted(data.keys()):
    rec = []
    d   = data[key]
    # STATUS: сравняваме първо (idx=0) и последно (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "↑"
    elif sN < s1: status = "↓"
    else:          status = "="

    # Първите 4 полета
    rec = [status, *key]

    # Списък за всички secs, за смятане на средно
    secs_list = []

    # По двойки Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", ""]

    # Изчисляваме AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh  = avg // 3600
        mm  = (avg % 3600) // 60
        ss  = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out.writerow(rec)






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """Превръща 'HH:MM:SS' в секунди."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- Настройка на директория и брой дни назад ---
# Ако има аргументи, проверяваме дали първият е директория:
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# Сменяме работната директория
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"Не мога да вляза в директория '{files_dir}': {e}")

# --- Събираме последните N файла JT* по време на промяна ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("Няма намерени файлове JT* в текущата папка.")

# --- Парсиме всеки ред и градим структурата data[key][idx] ---
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date    = parts[3]
            elapsed = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # Запазваме датата на idx-тия файл
    if dates[idx] is None:
        dates[idx] = date

# --- Пишем CSV на stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")
# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
out.writerow(header)

# За всеки job (сортираме по STAGE,BATCH,JOB)
for key in sorted(data.keys()):
    rec = []
    d = data[key]
    # STATUS = ↑ ако последният e по-бавен, ↓ ако последният e е по-бърз, = ако еднакви
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "↑"
    elif sN < s1: status = "↓"
    else:          status = "="

    rec = [status, *key]
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec += [info["date"], info["elapsed"]]
        else:
            rec += ["", ""]
    out.writerow(rec)





#!/usr/bin/env bash
set -euo pipefail

# Брой файла назад (по подразбиране 31)
N=${1:-31}

# Вземаме последните N файла (по modification time)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")
if [ "${#files[@]}" -lt 1 ]; then
  echo "Няма намерени JT* файлове."
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS=","
    # Заглавен ред
    printf "STATUS,STAGE,BATCH,JOB.NAME"
    for(i=1;i<=N;i++){
      printf ",Date%d,Elapsed%d", i, i
    }
    print ""
    idx=0
  }
  # За всеки файл увеличаваме idx
  FNR==1 { idx++ }
  {
    # ключ за JOB
    key = $1 SUBSEP $2 SUBSEP $3
    if (!(key in seen)) {
      seen[key]=1
      keys[++K]=key
    }
    # запомняме датата за този файл (една и съща per файл)
    if (!(idx in dates)) {
      dates[idx] = $4
    }
    # Elapsed и в секунди
    elapsed[key,idx] = $8
    split($8, T, ":")
    secs[key,idx]    = T[1]*3600 + T[2]*60 + T[3]
  }
  END {
    # за всеки JOB ключ
    for(j=1;j<=K;j++){
      key = keys[j]
      # статус: сравняваме първи vs последен ден
      s1 = (key,1 in secs ? secs[key,1] : 0)
      sN = (key,N in secs ? secs[key,N] : 0)
      status = (sN > s1 ? "↑" : (sN < s1 ? "↓" : "="))
      # разбиваме ключа обратно на STAGE,BATCH,JOB.NAME
      split(key, F, SUBSEP)
      printf "%s,%s,%s,%s", status, F[1], F[2], F[3]
      # и за всеки ден Datei, Elapsedi
      for(i=1;i<=N;i++){
        d = (i in dates ? dates[i] : "")
        e = ((key,i) in elapsed ? elapsed[key,i] : "")
        printf ",%s,%s", d, e
      }
      print ""
    }
  }
' "${files[@]}"







#!/usr/bin/env bash
set -euo pipefail

# Брой дни назад (по подразбиране 31; можеш да подадеш друго число като първи аргумент)
N=${1:-31}

# Вземаме последните N файла по modification time
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -eq 0 ]; then
  echo "Няма намерени файлове JT*"
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS = ",";
    idx = 0;
  }
  # Всеки път, когато започва нов файл, вдигаме брояча
  FNR==1 { idx++; }
  {
    # Строим ключа от BATCH.STAGE,BATCH,JOB.NAME
    key = $1 FS $2 FS $3;
    # Пази списък с уникални ключове за крайното обхождане
    if (!(key in seen)) {
      seen[key]=1;
      keys[++K]=key;
    }
    # Запиши датата за този файл (файлът съдържа същата дата на всеки ред)
    if (!(idx in dates)) {
      dates[idx] = $4;
    }
    # Запази elapsed и секунди
    elapsed[key","idx] = $8;
    split($8, T, ":");
    secs[key","idx] = T[1]*3600 + T[2]*60 + T[3];
  }
  END {
    # 1) Заглавен ред
    printf "BATCH.STAGE,BATCH,JOB.NAME";
    for (i=1; i<=N; i++) {
      printf ",Date%d,Elapsed%d", i, i;
    }
    print "";

    # 2) За всеки ключ – изписваме ред
    for (r=1; r<=K; r++) {
      key = keys[r];
      split(key, F, FS);
      # първите три полета
      printf "%s,%s,%s", F[1], F[2], F[3];
      # след това за всеки от N-те дни
      for (i=1; i<=N; i++) {
        d = dates[i];
        e = elapsed[key","i] ? elapsed[key","i] : "";
        arrow = "";
        if (i>1 && e!="") {
          prev = secs[key","i-1];
          curr = secs[key","i];
          if (curr > prev)   arrow = "↑";  # забавяне
          else if (curr < prev) arrow = "↓";  # ускояване
        }
        printf ",%s,%s%s", d, arrow, e;
      }
      print "";
    }
  }
' "${files[@]}"






#!/usr/bin/env bash
set -euo pipefail

# ако подадеш един аргумент, това е броят дни назад; иначе – 31
N=${1:-31}

# 1) събираме последните N файла по modification time (ls -1tr стартира старо->ново)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -lt 2 ]; then
  echo "Няма достатъчно файлове в JT* (трябват поне 2 от последните $N)."
  exit 1
fi

# Печатаме header само веднъж
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# 2) за всеки два поредни файла – старият и следващия
for ((i=1; i<${#files[@]}; i++)); do
  f1=${files[i-1]}
  f2=${files[i]}

  # стартираме awk за сравнение и филтриране
  awk -F, -v OFS=, '
    FNR==NR {
      # четем file1
      key            = $1 FS $2 FS $3
      date1[key]     = $4
      elapsed1[key]  = $8
      split($8, t1, ":")
      secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
      next
    }
    {
      # четем file2
      key            = $1 FS $2 FS $3
      d2             = $4
      e2             = $8
      split(e2, t2, ":")
      secs2          = t2[1]*3600 + t2[2]*60 + t2[3]

      # delta = secs1 - secs2 (в полза на date1)
      delta          = (key in secs1 ? secs1[key] : 0) - secs2

      # печатаме само ако secs1 > secs2 (т.е. date1 е по-бавно)
      if (secs1[key] > secs2) {
        # форматираме Diff като HH:MM:SS (положително число)
        hh   = int(delta/3600)
        mm   = int((delta%3600)/60)
        ss   = delta % 60
        diff = sprintf("%02d:%02d:%02d", hh, mm, ss)

        # стрелката винаги ↑ (date1 е по-бавно)
        arrow = "↑"

        # отпечатваме:
        #   arrow+stage, batch, job.name,
        #   date1, elapsed1,
        #   date2, elapsed2,
        #   diff
        print arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
      }
    }
  ' "${f1}" "${f2}"
done




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- първи файл (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- втори файл (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # форматираме ±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ↑ ако date1 е по-бавно (secs1 > secs2), иначе ↓
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "↑" : "↓")

    # първо delta (за сортиране), после всички полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-







#!/usr/bin/env bash
set -euo pipefail

if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# намери файловете JT*<дата>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# печатаме header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# правим awk и веднага pipe към sort и cut
awk -F, -v OFS=, '
  # Първо: зареждаме данните от file1 (date1)
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t1, ":")
    secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # След това file2 (date2)
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    # delta = secs1 - secs2 (в полза на date1)
    delta          = secs1[key] - secs2
    # филтрираме само ако date1 е по-бавно (secs1 > secs2)
    if (secs1[key] > secs2) {
      # форматираме Diff като HH:MM:SS (без знак, винаги положително)
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta % 60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка винаги ↑ (date1 по-бавно)
      arrow = "↑"
      # първо delta (за сортиране), после всичко останало
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) първо минаваме през file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) сега file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = secs1[key] - secs2
    # само ако date1 е по-бавно
    if (secs1[key] > secs2) {
      # форматираме ±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка (ще е винаги ↑ тук)
      arrow = "↑"
      # печатаме първо delta (за сортиране), после колоните
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # сортираме по delta (най-голям first)
| cut -d, -f2-          # махаме временната numeric delta-колона




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) първо минаваме през file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) сега file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = secs1[key] - secs2
    # само ако date1 е по-бавно
    if (secs1[key] > secs2) {
      # форматираме ±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка (ще е винаги ↑ тук)
      arrow = "↑"
      # печатаме първо delta (за сортиране), после колоните
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # сортираме по delta (най-голям first)
| cut -d, -f2-          # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- първи файл (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- втори файл (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # форматираме ±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ↑ ако date1 е по-бавно (secs1 > secs2), иначе ↓
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "↑" : "↓")

    # първо delta (за сортиране), после всички полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK + SORT + CUT на един ред
awk -F, -v OFS=, '
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първа колона delta (за сортиране), после всичко останало
    print delta, arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta, add arrow, sort and drop the temp column
awk -F, -v OFS=, '
  # 1) Първо минаваме през file1 и запаметяваме:
  #      key = BATCH.STAGE FS BATCH FS JOB.NAME
  #      date1[key]    = $4
  #      elapsed1[key] = $8  (и в секунди secs1[key])
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  # 2) После минаваме file2 и за всеки същия key:
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    # форматираме diff в ±HH:MM:SS
    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # ако date1 е по-бавно (secs1 > secs2) – стрелка ↑, иначе ↓
    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първо delta (за сортиране), после стрелката+stage и останалите полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \     # сортиране по delta низходящо
| cut -d, -f2-            # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# awk + sort + cut
awk -F, -v OFS=, '
  # Четем първи файл: запазваме по ключ (1,2,3) датата и elapsed, и изчисляваме secs1
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  # Втори файл: смятаме secs2 и delta
  {
    key    = $1 FS $2 FS $3
    d2     = $4
    e2     = $8
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    # Форматираме diff като ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Първо колона с delta (за сортиране), после всичко останало
    print delta, \
          $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \
| cut -d, -f2-



#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Намери файловете по маска JT*<дата>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Заглавен ред
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

awk -F, -v OFS=, '
  # Първо минаваме през първия файл и запаметяваме за всеки ключ (1,2,3):
  #   - неговата дата (поле 4)
  #   - elapsed time (поле 8) както в оригинал, така и в секунди
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, tt, ":")
    secs1[key]    = tt[1]*3600 + tt[2]*60 + tt[3]
    next
  }

  # Сега във втория файл за всеки същия ключ:
  {
    key      = $1 FS $2 FS $3
    d2       = $4
    e2       = $8
    split(e2, tt2, ":")
    secs2    = tt2[1]*3600 + tt2[2]*60 + tt2[3]
    s1       = (key in secs1 ? secs1[key] : 0)
    delta    = secs2 - s1

    # Форматираме разликата в ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме желания ред
    print \
      $1,    $2,    $3,          \
      date1[key], elapsed1[key], \
      d2,          e2,            \
      diff
  }
' "$file1" "$file2"




#!/usr/bin/env bash

# Проверка за две дати
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Откриваме файловете по маска JT*<дата>*
files1=(JT*${d1}*)
files2=(JT*${d2}*)
if [ ! -f "${files1[0]}" ] || [ ! -f "${files2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
f1=${files1[0]}
f2=${files2[0]}

awk -F, -v OFS=, '
  #
  # Първо четем файл1 (за date1):
  #   key = комбинация от полета 1..4 (JOB fields)
  #   записваме date1, start, stop и elapsed и пресмятаме секунди
  #
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4
    date1[key]    = $5        # полe 5 е датата във входния ред
    start1[key]   = $7        # поле 7 = старт време
    stop1[key]    = $8        # поле 8 = стоп време
    elapsed1[key] = $9        # поле 9 = elapsed
    split($9, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  #
  # Сега четем файл2 (за date2) и за всеки ключ
  # ● взимаме полета 1..4
  # ● взимаме date2, start2, stop2, elapsed2
  # ● смятаме diff = elapsed2 - elapsed1
  #
  {
    key    = $1 FS $2 FS $3 FS $4
    d2     = $5
    s2     = $7
    e2     = $9
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    sign   = ""
    if (delta<0) { sign="-"; delta = -delta }
    hh     = int(delta/3600)
    mm     = int((delta%3600)/60)
    ss     = delta%60
    diff   = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме:
    #  $1,$2,$3,$4 — полета до JOB.NAME
    #  date1, start1, stop1, elapsed1
    #  date2, start2, stop2, elapsed2
    #  diff
    print \
      $1, $2, $3, $4, \
      date1[key], start1[key], stop1[key], elapsed1[key], \
      d2,       s2,         $8,        e2,        \
      diff
  }
' "$f1" "$f2"




#!/usr/bin/env bash

# Проверка на параметри
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

date1=$1
date2=$2

# Намираме имената на файловете по маска
file1=(JT*${date1}*)
file2=(JT*${date2}*)

if [ ! -f "${file1[0]}" ] || [ ! -f "${file2[0]}" ]; then
  echo "Не можаха да се намерят файлове JT*${date1}* или JT*${date2}*"
  exit 1
fi

file1=${file1[0]}
file2=${file2[0]}

awk -F, -v OFS=, '
  # Прочитаме първия файл, запазваме Elapsed Time (поле 8) в секунди и оригиналния низ
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t = $8
    split(t, a, ":")
    secs = a[1]*3600 + a[2]*60 + a[3]
    t1_secs[key] = secs
    t1_str[key]  = t
    next
  }
  # Сега втория файл: пак правим ключа и взимаме време t2
  {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t2 = $8
    split(t2, b, ":")
    secs2 = b[1]*3600 + b[2]*60 + b[3]
    secs1 = (key in t1_secs ? t1_secs[key] : 0)
    delta = secs2 - secs1

    # Преобразуваме delta в HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме полета 1,2,3,4,6,7, original t1, t2 и разликата
    print $1, $2, $3, $4, $6, $7, t1_str[key], t2, diff
  }
' "$file1" "$file2"




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Usage: $0 <DATE1> <DATE2>"
  exit 1
fi

DATE1="$1"
DATE2="$2"

FILE1=$(ls JT*"$DATE1"*.CSV 2>/dev/null | head -n 1)
FILE2=$(ls JT*"$DATE2"*.CSV 2>/dev/null | head -n 1)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Missing input files for given dates."
  exit 1
fi

echo "Сравнение на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Start1,Stop1,Elapsed1,Start2,Stop2,Elapsed2,Разлика"

awk -F',' '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
{
  key = $1","$2","$3","$4;
  data[key] = $6","$7","$8;
  elapsed[key] = hms_to_minutes($8);
}
' "$FILE2" > /tmp/jt2.map

awk -F',' -v f2="/tmp/jt2.map" '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
function minutes_to_hhmm(mm,   h, m) {
  sign = (mm < 0) ? "-" : "";
  mm = (mm < 0) ? -mm : mm;
  h = int(mm);
  m = int((mm - h) * 60 + 0.5);
  return sign sprintf("%d:%02d", h, m);
}
BEGIN {
  while ((getline < f2) > 0) {
    split($0, parts, " ");
    split(parts[1], k, "=");
    split(k[2], d, ",");
    key = d[1]","d[2]","d[3]","d[4];
    info[key] = d[5]","d[6]","d[7];
    e2[key] = hms_to_minutes(d[7]);
  }
}
{
  key = $1","$2","$3","$4;
  if (key in info) {
    e1 = hms_to_minutes($8);
    diff = e1 - e2[key];
    printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", $1,$2,$3,$4,$6,$7,$8,info[key],minutes_to_hhmm(diff);
  }
}
' "$FILE1" | sort -t',' -k11,11





#!/bin/bash

d1="$1"
d2="$2"

f1=$(ls JT*${d1}*.CSV 2>/dev/null)
f2=$(ls JT*${d2}*.CSV 2>/dev/null)

if [[ -z "$f1" || -z "$f2" ]]; then
  echo "Файл(ове) не са намерени."
  exit 1
fi

echo "Сравнение на $f1 с $f2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Дата1 Elapsed,Дата2 Start,Дата2 Stop,Дата2 Elapsed,Разлика"

join -t, -1 1 -2 1 <(cut -d',' -f1-8 "$f1" | sort) <(cut -d',' -f1-8 "$f2" | sort) | awk -F',' '
function to_seconds(t,  a) {
  split(t, a, ":"); return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs) {
  sign = (secs < 0) ? "-" : "";
  secs = (secs < 0) ? -secs : secs;
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return sign h ":" (m < 10 ? "0" m : m);
}
{
  print $0 > "/tmp/jt_temp.csv"  # ако искаш да провериш
  e1 = $8; e2 = $16;
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
    $1, $2, $3, $4, $6, $7, e1, $14, $15, e2, to_hhmm(diff)
}
' | sort -t',' -k11 -r




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Използване: $0 <DATE1: YYYYMMDD> <DATE2: YYYYMMDD>"
  exit 1
fi

DATE1=$1
DATE2=$2

FILE1=$(ls JT*${DATE1}*.CSV 2>/dev/null)
FILE2=$(ls JT*${DATE2}*.CSV 2>/dev/null)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Някой от файловете липсва:"
  echo "  $FILE1"
  echo "  $FILE2"
  exit 2
fi

echo "Сравняване на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "------------------------------------------------------------------"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Elapsed1,Elapsed2,Разлика"

paste -d'\n' "$FILE1" "$FILE2" | paste - - | awk -F'\t' '
function to_seconds(t,  a) {
  split(t, a, ":");
  return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs, h, m) {
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return h ":" (m < 10 ? "0" m : m);
}
{
  split($1, f1, ",");
  split($2, f2, ",");

  e1 = f1[8]; e2 = f2[8];
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s\n", f1[1], f1[2], f1[3], f1[4], f1[6], f1[7], e1, e2, to_hhmm(diff)
}' | sort -t',' -k9 -r



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска хедърите
  const total = rows.length;
  const rawValue = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = rawValue + 1;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const total = rows.length;
  const requested = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = Math.min(requested, total); // Не позволявай да искаме повече, отколкото имаме

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // само данни
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows(days) {
  const allRows = Array.from(document.getElementById('eomTable').getElementsByTagName('tr'));
  const dataRows = allRows.slice(2); // Прескачаме заглавните два реда
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // винаги показвай заглавията
    } else {
      tr.hidden = (i - 2) < start ? false : true;
    }
  });
}




const visibleRows = Math.min(maxRows, rows.length);
rows.forEach((tr, i) => {
  tr.hidden = i < rows.length - visibleRows;
});






#!/bin/bash

main_log="main_log.txt"
rrex_log="rrex_data.txt"
output_log="merged_log.txt"

> "$output_log"

while IFS= read -r line; do
    # Извличаме датата от формата JT.20240520
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търсим съвпадащ ред в RREX таблицата по първото поле (датата)
        match=$(awk -F'|' -v d="$date" '$1 == d {print $0}' "$rrex_log")

        if [[ -n "$match" ]]; then
            # Вземаме само времената
            rrex_start=$(echo "$match" | awk -F'|' '{print $2}' | cut -d' ' -f2)
            rrex_end=$(echo "$match" | awk -F'|' '{print $3}' | cut -d' ' -f2)
            rrex_duration=$(echo "$match" | awk -F'|' '{print $4}')

            echo "$line | RREX_START: $rrex_start | RREX_END: $rrex_end | RREX_DURATION: $rrex_duration" >> "$output_log"
        else
            echo "$line | RREX: N/A" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

main_log="main_log.txt"        # лог с JT.20240520
rrex_log="rrex_log.txt"        # лог със Start/End/Duration за всяка дата
output_log="enhanced_log.txt"

> "$output_log"

while IFS= read -r line; do
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търси ред в rrex_log, започващ с датата
        rrex_info=$(awk -F'|' -v d="$date" '$1 == d { print $2, $3, $4 }' "$rrex_log")

        if [[ -n "$rrex_info" ]]; then
            echo "$line | $rrex_info" >> "$output_log"
        else
            echo "$line | [No RREX data]" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

input_log="main_log.txt"
output_log="enhanced_log.txt"
log_dir="./logs"  # директория с файловете по дати

> "$output_log"  # празно изходен файл

while IFS= read -r line; do
    # Извличане на датата след JT.
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]+')

    if [[ -n "$date" ]]; then
        file="$log_dir/$date.log"

        if [[ -f "$file" ]]; then
            # Извличане на реда със Stop, Start, Elapsed (примерна логика)
            match=$(grep -i 'Stop.*Start.*Elapsed' "$file" | head -n 1)

            # Добавяне на намереното в края на реда
            echo "$line $match" >> "$output_log"
        else
            echo "$line [No file for $date]" >> "$output_log"
        fi
    else
        echo "$line [No JT date found]" >> "$output_log"
    fi
done < "$input_log"




def run_advanced_shell_script():
    script_path = os.path.join(BASE_DIR, "scripts", "advanced_log.sh")
    try:
        output = subprocess.check_output(["bash", script_path], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("Shell скриптът за advanced лог анализ е изпълнен успешно.")
        # Ако искаш да го запишеш:
        result_file = os.path.join(RESULT_DIR, "advanced_combined.log")
        os.makedirs(RESULT_DIR, exist_ok=True)
        with open(result_file, "w") as f:
            f.write(output)
    except subprocess.CalledProcessError as e:
        logging.error(f"Shell скрипт грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"Грешка при стартиране на shell скрипта: {str(e)}")




import tempfile

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Създаваме временен shell скрипт с оригиналната логика
    script_content = f"""#!/bin/bash
LIMIT_DATE="{limit_date}"
CHAR_LIMIT={char_limit}
LOG_DIR="{log_dir}"
for f in $LOG_DIR/{log_files}; do
    awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
        /\\[ERROR\\]/ && length($0) >= {char_limit} {{
            log_date = substr($0, 2, 10)
            if (log_date >= limit) {{
                if ($0 ~ /{match_keywords}/) {{
                    match($0, /\\] .*? /, arr)
                    if (arr[1] != "" && arr[1] != "\\\\") {{
                        key = arr[1]
                        print key "|" "[" host "] [" file "] " $0
                    }}
                }}
            }}
        }}
    ' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
"""

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sh", mode="w") as tmpfile:
            tmpfile.write(script_content)
            tmpfile_path = tmpfile.name

        remote_path = f"/tmp/monitor_adv_{host}.sh"

        # Качваме скрипта на отдалечената машина
        subprocess.run(["scp", tmpfile_path, f"{user}@{host}:{remote_path}"], check=True)

        # Даваме права и го изпълняваме през ssh
        ssh_cmd = f"chmod +x {remote_path} && bash {remote_path} && rm {remote_path}"
        output = subprocess.check_output(["ssh", f"{user}@{host}", ssh_cmd], stderr=subprocess.STDOUT, timeout=60, universal_newlines=True)

        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH/Script грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Грешка при изпълнение на advanced_log_filter: {str(e)}")
    finally:
        if os.path.exists(tmpfile_path):
            os.unlink(tmpfile_path)






def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Shell скрипт, вграден в Python (точно като оригинала)
    remote_script = f'''
        LIMIT_DATE="{limit_date}"
        CHAR_LIMIT={char_limit}
        for f in {log_dir}/{{{log_files}}}; do
            awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
                /\\[ERROR\\]/ && length($0) >= {char_limit} {{
                    log_date = substr($0, 2, 10)
                    if (log_date >= limit) {{
                        if ($0 ~ /{match_keywords}/) {{
                            match($0, /\\] .*? /, arr)
                            if (arr[1] != "" && arr[1] != "\\\\") {{
                                key = arr[1]
                                print key "|" "[" host "] [" file "] " $0
                            }}
                        }}
                    }}
                }}
            ' "$f"
        done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
    '''

    ssh_cmd = ["ssh", f"{user}@{host}", remote_script]

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=40, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")







def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dirs = conf.get('log_dirs', 'paths').split(',')

    # Формируем списък от лог файлове във всички лог директории
    log_patterns = []
    for log_dir in log_dirs:
        log_dir = log_dir.rstrip('/')
        for f in log_files:
            log_patterns.append(f"{log_dir}/{f}")
    log_patterns_str = ' '.join(log_patterns)

    # awk скрипт (без външен shell parsing)
    awk_script = (
        f"""/\\[ERROR\\]/ && length($0) > {char_limit} {{
            log_date = substr($0, 2, 19);
            if (log_date >= "{limit_date}") {{
                if ($0 ~ /{match_keywords}/)
                    print host "|" file "|" $0;
            }}
        }}"""
    )

    remote_cmd = f"for file in {log_patterns_str}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"
    ssh_cmd = ["ssh", f"{user}@{host}", remote_cmd]

    logging.debug(f"[{host}] SSH команда: {' '.join(ssh_cmd)}")

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=30, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма намерени резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")






#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print host \"|\" file \"|\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=20, universal_newlines=True
        )
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()




[advanced_log_filter]
log_files = mdb.log,runtime.log*,database.log*,ejb.log*
char_limit = 1000
match_keywords = DATABASE|RUNTIME|EJB|MDB



#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break

    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print \"[advanced] |\" host \"|\" file \":\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=15, universal_newlines=True
        )
        if output:
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced log scan записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        scan_host(host, user, log_dirs, keywords)
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()





# Директории за логове
[log_dirs]
paths = /var/log,/opt/bank/logs

# Директории за файлов мониторинг (локални за бекенда)
[file_monitor]
dirs = /var/bank/inbox,/tmp/transactions

# Ключови думи за търсене
[keywords]
errors = ERROR,FATAL,EXCEPTION
warnings = WARN,DEPRECATED

# Потребители
[users]
admin = root,monitoring_user
readonly = viewer


# Monitoring Framework for Banking VMs

## Структура
- `config/`: Конфигурации (.conf и .properties)
- `hosts/`: Списък с хостове
- `logs/`: Логове от мониторинг скрипта
- `scripts/`: Python скриптове

## Конфигурация
- `common.conf`: съдържа директории, ключови думи и потребители
- `settings.properties`: лог ниво, ssh настройки, интервали
- `host_list.txt`: един ред = един hostname

## Стартиране
```bash
cd scripts
python3 monitor.py


# Логване
log.level=INFO
log.rotation=daily
log.retention_days=7

# SSH настройки
backend.host=this-backend-host
remote.user=monitoring_user
connection.timeout=10

# Сканиране
scan.interval=300        # секунди между проверки
scan.parallelism=4       # паралелни ssh задачи


#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

# Архивиране на резултатите
def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

# Мониторинг на локални директории и файлове
def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

# SSH извличане на логове
def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break  # прекъсваме ако няма SSH достъп

    # Запис в резултатен файл
    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')

    # Remote log scan
    for host in hosts:
        scan_host(host, user, log_dirs, keywords)

    # Local file check
    monitor_files(conf)

    # Archive results
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()






function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const x = cobMeta.data[i].x;
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const barVal = data.datasets[0].data[i];
              if (barVal > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(barVal);
                ctx.fillText(formatHHMM(barVal), x, y + 12);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





plugins: {
  tooltip: {
    callbacks: {
      label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
    }
  },
  title: {
    display: true,
    text: "EOM COB Elapsed Times",
    font: {
      size: 13,
      weight: "bold"
    },
    color: getTextColor()
  },
  legend: {
    labels: {
      font: { size: 13 },
      color: getTextColor()
    }
  },
  labelsInside: labelsInsidePlugin // това е ключово
}







const labelsInsidePlugin = {
  id: "labelsInside",
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const meta = chart.getDatasetMeta(0);
    const yScale = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const value = data.datasets[0].data[i];
      if (value > 0) {
        const x = meta.data[i].x;
        const y = yScale.getPixelForValue(value) + 14;
        ctx.fillText(formatHHMM(value), x, y);
      }
    });

    ctx.restore();
  }
};




<div class="chart-container" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime > 0) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const value = data.datasets[0].data[i];
              if (value > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(value) + 12;
                ctx.fillText(formatHHMM(value), x, y);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}
</script>





<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>






function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}







function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}








<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHMM(v),
            maxTicksLimit: 8
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>





function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 13,
              color: "#333"
            }
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v),
            font: {
              size: 13,
              color: "#333"
            }
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      }
    },
    plugins: [{
      id: 'labelsInside',
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const meta = chart.getDatasetMeta(0);
        const yScale = scales.y;

        ctx.save();
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const bar = meta.data[i];
          const value = data.datasets[0].data[i];
          const y = yScale.getPixelForValue(value);
          const x = bar.x;
          if (value > 0) {
            ctx.fillText(formatHMM(value), x, y + 12);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





<table class="rounded" id="eomChartTable">
  <tr>
    <th colspan="6">EOM COB & RR Elapsed Time</th>
  </tr>
  <tr>
    <td colspan="6">
      <div class="chart-container" id="eomChartWrapper">
        <canvas id="eomChart"></canvas>
      </div>
    </td>
  </tr>
</table>



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 },
            color: getTextColor()
          }
        }
      }
    },
    plugins: [
      {
        id: "labelsInside",
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const cobMeta = chart.getDatasetMeta(0);
          const rrMeta = chart.getDatasetMeta(1);
          const yScale = scales.y;

          ctx.save();
          ctx.font = "bold 11px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob = data.datasets[0].data[i] || 0;
            const rr = data.datasets[1].data[i] || 0;
            const total = cob + rr;
            const x = cobMeta.data[i].x;

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }

            if (rr > 0) {
              const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
              ctx.fillText(formatHHMM(rr), x, yRR);
            }

            if (total > 0) {
              const yTotal = yScale.getPixelForValue(total) - 6;
              ctx.fillText(formatHHMM(total), x, yTotal);
            }
          });

          ctx.restore();
        }
      }
    ]
  });

  updateChartsTheme();
}






options: {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    x: {
      stacked: true,
      ticks: {
        maxRotation: 45,
        minRotation: 45
      }
    },
    y: {
      beginAtZero: true,
      ticks: {
        callback: v => formatHHMM(v)
      }
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
      }
    },
    title: {
      display: true,
      text: "EOM COB & RR Elapsed Times",
      font: {
        size: 13,
        weight: "bold"
      },
      color: getTextColor()
    },
    legend: {
      labels: {
        font: { size: 13 }
      }
    }
  }
},
plugins: [
  {
    id: "labelsInside",
    afterDatasetsDraw(chart) {
      const { ctx, data, scales } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);
      const yScale = scales.y;

      ctx.save();
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i] || 0;
        const rr = data.datasets[1].data[i] || 0;
        const total = cob + rr;
        const x = cobMeta.data[i].x;

        if (cob > 0) {
          const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        if (rr > 0) {
          const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        if (total > 0) {
          const yTotal = yScale.getPixelForValue(total) - 6;
          ctx.fillText(formatHHMM(total), x, yTotal);
        }
      });

      ctx.restore();
    }
  }
]




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = cobElapsed[i] || 0;
              const rr = rrElapsed[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}







function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => {
              const raw = ctx.raw || 0;
              return `${ctx.dataset.label}: ${formatHHMM(raw)}`;
            }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCobMid = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCobMid);
              }

              if (rr > 0) {
                const yRRMid = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRRMid);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales: { y } } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i];
              const rr = data.datasets[1].data[i];
              const total = cob + rr;

              const cobTop = y.getPixelForValue(cob);
              const rrTop = y.getPixelForValue(rr);
              const totalTop = y.getPixelForValue(total);
              const cobBottom = y.getPixelForValue(0);
              const rrBottom = y.getPixelForValue(cob);
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (cobTop + cobBottom) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (rrTop + rrBottom) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                ctx.fillText(formatHHMM(total), x, totalTop - 6);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




plugins: [
  {
    id: 'labelsInside',
    afterDatasetsDraw(chart) {
      const { ctx, data, scales: { y } } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);

      ctx.save();
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(rr);
        const totalTop = y.getPixelForValue(total);
        const cobBottom = y.getPixelForValue(0);
        const rrBottom = y.getPixelForValue(cob);

        const x = cobMeta.data[i].x;

        // COB inside
        if (cob > 0) {
          const yCob = (cobTop + cobBottom) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        // RR inside
        if (rr > 0) {
          const yRR = (rrTop + rrBottom) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        // Total on top
        if (total > 0) {
          ctx.fillText(formatHHMM(total), x, totalTop - 6);
        }
      });

      ctx.restore();
    }
  }
]




function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 9) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();
    const rrVal = cells[6].innerText.trim();

    if (date && cobVal && rrVal) {
      dates.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
      rrElapsed.push(parseElapsedToHours(rrVal));
    }
  }

  dates.reverse();
  cobElapsed.reverse();
  rrElapsed.reverse();

  return { dates, cobElapsed, rrElapsed };
}

let eomChartInstance;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) eomChartInstance.destroy();

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
          order: 2
        },
        {
          label: "Duration Limit (2:30)",
          data: Array(dates.length).fill(2.5),
          type: "line",
          borderColor: "red",
          borderDash: [6, 4],
          pointRadius: 0,
          borderWidth: 2,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          max: 7,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: [] // Празно, без EOM маркери
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times vs Duration Limit",
          color: getTextColor(),
          font: {
            size: 13,
            weight: "bold"
          }
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [{
      id: "labelsInside",
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const cobMeta = chart.getDatasetMeta(0);
        const yScale = scales.y;
        ctx.save();
        ctx.font = "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const cob = data.datasets[0].data[i];
          const rr = data.datasets[1].data[i];
          const total = cob + rr;
          const x = cobMeta.data[i].x;

          if (cob > 0) {
            const yCob = yScale.getPixelForValue(cob);
            ctx.fillText(formatHHMM(cob), x, yCob);
          }

          if (rr > 0) {
            const yTop = yScale.getPixelForValue(cob + rr);
            const yBottom = yScale.getPixelForValue(cob);
            const yRR = (yTop + yBottom) / 2;
            ctx.fillText(formatHHMM(rr), x, yRR);
          }

          if (total > 0) {
            const yTotal = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, yTotal);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(54, 162, 235, 0.6)",
          borderColor: "rgba(54, 162, 235, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(128, 128, 128, 0.6)",
          borderColor: "rgba(128, 128, 128, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 13 },
            color: "#333"
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: formatHHMM,
            font: { size: 13 },
            color: "#333"
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 13 }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: "#222"
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        datalabels: {
          display: true,
          color: () => document.body.classList.contains("dark-mode") ? "white" : "black",
          font: {
            weight: 'bold',
            size: 11,
            family: 'sans-serif'
          },
          formatter: value => formatHHMM(value)
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [ChartDataLabels]
  });

  updateChartsTheme();
}




function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // пропускаме header

  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    const date = cells[0].innerText.trim();
    const cob = parseElapsedToHours(cells[3].innerText);
    const rr = parseElapsedToHours(cells[7].innerText);

    dates.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    dates: dates.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}





document.addEventListener("DOMContentLoaded", () => {
  const eomSlider = document.getElementById("eomRange");
  const eomInput = document.getElementById("eomValue");

  function syncEomFromSlider() {
    eomInput.value = eomSlider.value;
    updateEomTableRows();
    renderEOMChart();
  }

  function syncEomFromInput() {
    let value = parseInt(eomInput.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 12) value = 12;
    eomInput.value = value;
    eomSlider.value = value;
    syncEomFromSlider();
  }

  eomSlider.addEventListener("input", syncEomFromSlider);
  eomInput.addEventListener("input", syncEomFromInput);

  syncEomFromSlider(); // Initial load
});





<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


const eomChartWrapper = document.getElementById("eomChartWrapper");

toggleEomBtn.addEventListener("click", () => {
  eomVisible = !eomVisible;
  eomTable.classList.toggle("hidden", !eomVisible);
  eomSliderWrapper.classList.toggle("hidden", !eomVisible);
  eomChartWrapper.classList.toggle("hidden", !eomVisible);

  if (eomVisible) {
    updateEomTableRows();
    renderEOMChart();
  }
});



function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseTimeToMinutes(cells[3].innerText.trim());
    const rrTime = parseTimeToMinutes(cells[6].innerText.trim());

    if (cobTime && rrTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
      rrElapsed.push(rrTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: getEOMAnnotations(labels, cobElapsed)
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      }
    }
  });

  updateChartsTheme();
}






let eomChartInstance = null;

function parseElapsedToHours(str) {
    if (!str || str.length < 8) return 0;
    const parts = str.split(':').map(Number);
    const hours = parts[0];
    const minutes = parts[1];
    const seconds = parts[2];
    return hours + (minutes / 60) + (seconds / 3600);
}

function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 12;

    const dates = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cobTime = parseElapsedToHours(cells[3].innerText.trim());
        const rrTime = parseElapsedToHours(cells[6].innerText.trim());

        if (cobTime && rrTime) {
            dates.push(date);
            cobElapsed.push(cobTime);
            rrElapsed.push(rrTime);
        }
    }

    return {
        labels: dates.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (eomChartInstance) {
        eomChartInstance.destroy();
    }

    eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1"
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1"
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 20,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        font: {
                            size: 13,
                            weight: "bold"
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });

    updateChartsTheme();
}







<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


let eomChartInstance = null;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) {
    eomChartInstance.destroy();
  }

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: {
            stepSize: 1
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: "EOM COB + RR Elapsed Time (stacked)",
          font: {
            size: 13,
            weight: 'bold'
          },
          color: "#222"
        },
        legend: {
          display: true,
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeOutBounce'
      }
    }
  });
}


function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: 






function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
    const labels = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cob = parseTimeToMinutes(cells[3].innerText.trim());
        const rr = parseTimeToMinutes(cells[6].innerText.trim());

        if (cob > 0 || rr > 0) {
            labels.push(date);
            cobElapsed.push(cob);
            rrElapsed.push(rr);
        }
    }

    return {
        labels: labels.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (window.eomChartInstance) {
        window.eomChartInstance.destroy();
    }

    window.eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 10,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        maxTicksLimit: 8,
                        callback: v => formatHHMM(v)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });

    updateChartsTheme();
}



<script>
document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    eomTable.classList.toggle("show", eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });

  function updateEomTableRows() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // Skip headers
    const maxRows = parseInt(eomRange.value, 10);

    rows.forEach((tr, i, arr) => {
      tr.hidden = i < arr.length - maxRows;
    });
  }
});
</script>





#eomTable {
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

#eomTable.show {
  opacity: 1;
  transform: scaleY(1);
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomTable = document.getElementById("eomTable");

let isEomVisible = false;

toggleEomBtn.addEventListener("click", () => {
  isEomVisible = !isEomVisible;
  if (isEomVisible) {
    eomTable.classList.add("show");
  } else {
    eomTable.classList.remove("show");
  }
});





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <div class="daysValue" id="eomValue">10</div>
    </div>
  </div>
</div>






<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span>
      <span>&nbsp;days</span>
    </div>
  </div>
</div>




document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




<div class="tool-button" id="eomControlWrapper">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <label for="eomRange" id="eomLabel">EOM Days:</label>
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span><span>&nbsp;days</span>
    </div>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);
    
    if (eomVisible) {
      updateEomTableRows(); // Пресмята редовете, когато се показва
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
</div>
<div id="eomSliderWrapper" class="daysSliderWrapper hidden">
  <label for="eomRange" id="eomLabel">EOM Days:</label>
  <div class="daysInputWrapper">
    <input type="range" id="eomRange" min="3" max="12" value="10" />
    <span id="eomValue">10</span><span>&nbsp;days</span>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
      updateEomTableRows(); // обнови при показване
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows();
  });
});





function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3
  const totalRows = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < totalRows - maxRows; // скриваме горните
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаш заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}

if (eomVisible) {
  eomTable.classList.remove("hidden");
  eomSliderWrapper.classList.remove("hidden");
  updateEomTableRows(); // <-- Тук се вика
}



document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows();
});






document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("mousedown", (e) => {
    if (e.target.tagName === 'INPUT') return; // предотвратява затваряне от range

    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows(e.target.value); // само ако имаш функция
  });
});




<script>
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });
</script>





toggleEomBtn.addEventListener("click", (event) => {
  // Игнорирай кликове по вложени елементи вътре в бутона
  if (event.target !== toggleEomBtn && !toggleEomBtn.contains(event.target)) return;

  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});



<div class="tool-button" id="toggleEomBtn">
  <span>Show EOM COBs</span>
  <div id="eomSliderWrapper" class="hidden eom-slider">
    <label for="eomRange" id="eomLabel">EOM COB Days:</label>
    <div id="eomInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10">
      <span id="eomValue">10</span>
      <span>days</span>
    </div>
  </div>
</div>


.eom-slider {
  margin-top: 8px;
  font-size: 13px;
  text-align: center;
}

#eomInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 5px;
}

#eomInputWrapper input[type="range"] {
  width: 85px;
  accent-color: #3b8de3;
}

#eomLabel {
  color: #111;
  font-weight: bold;
}

body.dark-mode #eomLabel {
  color: #eee;
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomSliderWrapper = document.getElementById("eomSliderWrapper");
const eomTable = document.getElementById("eomTable");

toggleEomBtn.addEventListener("click", () => {
  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});

document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows(e.target.value); // ако имаш функция за обновяване
});







<div class="eom-controls">
  <button id="toggleEomTable" class="tool-button">Show EOM COBs</button>

  <div id="eomSliderWrapper" class="tool-button hidden">
    <label for="eomRange">EOM COB Days:</label>
    <span id="eomValue">10</span>
    <input type="range" id="eomRange" min="3" max="12" value="10" />
  </div>
</div>


.eom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

#eomSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  color: #333;
  margin-right: 5px;
}

#eomSliderWrapper input[type="range"] {
  width: 85px;
  accent-color: #b3e0ff;
}

#eomValue {
  font-size: 13px;
  font-weight: bold;
  color: #111;
  margin: 0 5px;
}

body.dark-mode #eomSliderWrapper label {
  color: #eee;
}
body.dark-mode #eomValue {
  color: #eee;
}


document.getElementById("toggleEomTable").addEventListener("click", () => {
  const table = document.getElementById("eomTable");
  const slider = document.getElementById("eomSliderWrapper");
  table.classList.toggle("hidden");
  slider.classList.toggle("hidden");
});


<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomDaysSliderWrapper" class="tool-button hidden">
  <label for="eomDaysRange">EOM COB Days:</label>
  <span id="eomDaysValue">10</span>
  <input type="range" min="3" max="12" value="10" id="eomDaysRange" />
</div>

document.addEventListener('DOMContentLoaded', () => {
  const eomBtn = document.getElementById('toggleEomBtn');
  const eomTable = document.getElementById('eomTable');
  const eomSlider = document.getElementById('eomDaysRange');
  const eomValue = document.getElementById('eomDaysValue');
  const eomSliderWrapper = document.getElementById('eomDaysSliderWrapper');

  eomBtn.addEventListener('click', () => {
    const isHidden = eomTable.classList.contains('hidden');
    eomTable.classList.toggle('hidden', !isHidden);
    eomSliderWrapper.classList.toggle('hidden', !isHidden);
  });

  eomSlider.addEventListener('input', () => {
    eomValue.textContent = eomSlider.value;
    updateEomTableRows(); // трябва да съществува, ще добавим логиката после
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаме заглавията
  const maxRows = parseInt(document.getElementById('eomDaysRange').value, 10);

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}




<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomSliderWrapper" class="tool-bottom hidden">
  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

#eomSliderWrapper {
  margin-top: 10px;
  font-size: 14px;
}


const toggleEomBtn = document.getElementById('toggleEomBtn');
const eomSliderWrapper = document.getElementById('eomSliderWrapper');
const eomTable = document.getElementById('eomTable'); // Увери се, че има такава таблица

toggleEomBtn.addEventListener('click', () => {
  eomTable?.classList.toggle('hidden');
  eomSliderWrapper.classList.toggle('hidden');
});

function syncEOMSliderAndInput(value) {
  const v = Math.max(1, Math.min(12, parseInt(value) || 5));
  document.getElementById('eomDaysRange').value = v;
  document.getElementById('eomDaysInput').value = v;
  updateEOMTableRows(v); // Имплементирай тази функция, ако още не съществува
}

document.getElementById('eomDaysRange').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));
document.getElementById('eomDaysInput').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));





<div id="cobToolsMenu" class="tools-menu">
  <!-- Existing tools -->
  
  <button onclick="toggleEOMTable()">Show EOM COBs</button>

  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

<table id="eomTable" style="display: none;">
  <!-- Your EOM table rows -->
</table>

<script>
  function toggleEOMTable() {
    const table = document.getElementById('eomTable');
    table.style.display = table.style.display === 'none' ? 'table' : 'none';
  }

  function syncEOMSliderAndInput(value) {
    const v = Math.max(1, Math.min(12, parseInt(value) || 5));
    document.getElementById('eomDaysRange').value = v;
    document.getElementById('eomDaysInput').value = v;
    updateEOMTableRows(v); // Трябва да имаш дефинирана тази функция
  }

  document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('eomDaysRange');
    const input = document.getElementById('eomDaysInput');
    slider.addEventListener('input', () => syncEOMSliderAndInput(slider.value));
    input.addEventListener('input', () => syncEOMSliderAndInput(input.value));
    syncEOMSliderAndInput(5);
  });
</script>




<footer>
  <p style="margin-top: 30px;">
    За идеи/бъгове, моля пишете в официалната страница на <strong>COB Analyser</strong>.<br>
    <a href="https://your-confluence-link-here" style="color: #66c1ff; text-decoration: none;" target="_blank">
      Отвори COB Analyser в Confluence
    </a>
  </p>
  <br>Поздрави,<br>
  Дилян
</footer>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7f9;
      color: #333;
      padding: 30px;
      line-height: 1.6;
    }
    .container {
      background-color: #fff;
      border: 1px solid #ddd;
      border-left: 5px solid #007ACC;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }
    h1 {
      font-size: 1.5em;
      color: #007ACC;
    }
    .section {
      margin-top: 20px;
    }
    .highlight {
      background-color: #eef;
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      display: inline-block;
    }
    footer {
      margin-top: 30px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Здравейте,</h1>

    <div class="section">
      Файлът за <strong>COB Analyser в SP24 PROD</strong> за дата <span class="highlight">today_cob_date</span> е прикрепен.
    </div>

    <div class="section">
      <strong>LOG файлът</strong>, както и изпълнението на всички функции, се намира в следната директория:
      <div class="highlight">/opt/t24/support_scripts/cob_analyser/log/</div>
    </div>

    <footer>
      Поздрави,<br>
      Диян
    </footer>
  </div>
</body>
</html>





<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }

    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* Хедър */
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* Тяло */
    .email-body {
      padding: 30px;
      text-align: center;            /* центрираме текста */
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
      text-align: center;            /* центрираме и кода */
    }

    /* Футър */
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
      text-align: center;            /* центрираме подписа */
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:</p>
              <p><code>/opt/t24/support_scripts/cob_analyser/log</code></p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>






<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }
    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }
    .email-body {
      padding: 30px;
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
    }
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:<br>
                 <code>/opt/t24/support_scripts/cob_analyser/log</code>
              </p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>



for i in {0..11}; do
  last_day=$(date -d "$current_date -$i month -1 day" +%Y%m%d)
  echo "$last_day"

  jtfind="$jt_path/JT_$last_day.csv"

  if [[ -s "$jtfind" ]]; then
    echo "COB $last_day $jtfind"
    echo "-----Started-----"
    cat "$jtfind" | grep A000 | cut -d ',' -f6 | head -1
    echo "-----Stopped-----"
    cat "$jtfind" | grep R999 | cut -d ',' -f7 | head -1
  else
    echo "File not found or empty: $jtfind, skipping..."
  fi
done





function getEOMAnnotations(labels, yData) {
  const annotations = {};
  const topY = Math.max(...yData);  // използваме масива от стойности

  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}



function getEOMAnnotations(labels, chart) {
  const annotations = {};
  const topY = Math.max(...chart.data.datasets[0].data);  // най-високата стойност по Y
  
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,  // леко над най-високата стойност
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}




function getEOMAnnotations(labels, heights) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      const height = heights?.[i] || 1; // ако няма масив, падаме на 1
      const adjustedY = height + 50; // издигаме текста с 50 над стълба

      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: adjustedY,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -10,
        rotation: 0
      };
    }
  }

  return annotations;
}





// make sure you’ve imported & registered both Chart.js and chartjs-plugin-annotation before this runs
// e.g.:
//   import { Chart, BarController, BarElement, CategoryScale, LinearScale, Title } from 'chart.js';
//   import annotationPlugin from 'chartjs-plugin-annotation';
//   Chart.register(BarController, BarElement, CategoryScale, LinearScale, Title, annotationPlugin);

let recordsChartInstance;

function renderRecordsChart() {
  // 1) pull your data
  const { labels, recordsPerMinute } = getRecordsData();  // your existing extractor

  // 2) destroy previous chart
  if (recordsChartInstance) recordsChartInstance.destroy();

  // 3) create new one
  const ctx = document.getElementById('recordsChart').getContext('2d');
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: 'rgba(54,162,235,0.6)',
        borderColor:   'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
          stacked: true,
          ticks: { font: { size: 13 }, color: '#333' }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { font: { size: 13 }, color: '#333' }
        }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 14, weight: 'bold' },
          color: '#222'
        },
        annotation: {
          // ask our helper to build a map of annotations:
          annotations: buildEOMAnnotations(recordsChartInstance)
        }
      }
    }
  });
}

/**
 * Walks the chart’s labels and data, finds month-breaks
 * and returns a map of annotation configs for line + label.
 */
function buildEOMAnnotations(chart) {
  const ann = {};
  const labels = chart.data.labels;
  const data   = chart.data.datasets[0].data;
  const yScale = chart.scales.y;

  labels.forEach((lbl, i) => {
    const next = labels[i + 1];
    // compare YYYYMM prefix of this vs next
    if (next && lbl.slice(0,6) !== next.slice(0,6)) {
      // vertical dashed line
      ann[`eomLine${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: lbl,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6,4],
        borderDashOffset: 2
      };
      // label at the top
      ann[`eomLabel${i}`] = {
        type: 'label',
        xScaleID: 'x',
        xValue: lbl,
        yScaleID: 'y',
        yValue: yScale.max,     // attach to top of the scale
        content: ['EOM'],
        font: { size: 12, weight: 'bold' },
        color: 'orange',
        textAlign: 'center',
        backgroundColor: 'transparent',
        yAdjust: -8             // shift up 8px from top
      };
    }
  });

  return ann;
}

// call on load / whenever you update your table
renderRecordsChart();




function getEOMAnnotationsWithHeights(records, labels) {
    const annotations = {};
    for (let i = 0; i < labels.length - 1; i++) {
        const current = labels[i];
        const next = labels[i + 1];

        if (current.substring(0, 6) !== next.substring(0, 6)) {
            const yVal = records[i] || 0;
            annotations[`line-eom-${i}`] = {
                type: 'line',
                scaleID: 'x',
                value: current,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [6, 4]
            };

            annotations[`text-eom-${i}`] = {
                type: 'label',
                xValue: current,
                yValue: yVal,
                backgroundColor: 'transparent',
                content: ['EOM'],
                font: {
                    size: 12,
                    weight: 'bold'
                },
                color: 'orange',
                textAlign: 'center',
                position: 'start',
                xAdjust: 0,
                yAdjust: -Math.max(20, Math.min(yVal * 0.05, 40)), // динамично позициониране
                rotation: 0
            };
        }
    }
    return annotations;
}





function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Records Per Minute',
                    data: recordsPerMinute,
                    backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                    borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                    borderRadius: 15,
                    hoverBorderWidth: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                annotation: {
                    annotations: getEOMAnnotationsWithHeights(recordsPerMinute, labels)
                },
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });

    updateChartsTheme();
}




function getEOMAnnotationsWithHeights(chart) {
  const annotations = [];
  const labels = chart.data.labels;
  const datasets = chart.data.datasets;

  // Намери последните дни от месеца
  const lastDays = [];
  for (let i = 0; i < labels.length; i++) {
    const current = labels[i].substring(0, 6);
    const next = labels[i + 1]?.substring(0, 6);
    if (current !== next) {
      lastDays.push({ index: i, date: labels[i] });
    }
  }

  // За всяка дата намери максималната стойност по Y
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(ds => {
      const val = ds.data[index];
      if (typeof val === 'number' && val > maxY) {
        maxY = val;
      }
    });

    annotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [4, 4],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: {
          x: 'end',
          y: 'start'
        },
        yAdjust: -10,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          size: 11,
          weight: 'bold'
        }
      }
    });
  });

  return annotations;
}


const annotations = getEOMAnnotationsWithHeights(chart);

options: {
  // ...
  plugins: {
    annotation: {
      annotations: annotations
    }
  }
}





function getEOMAnnotationsWithHeights(chart, labels, datasets) {
  const eomAnnotations = [];
  const lastDays = [];

  // Намираме всички последни дати за всеки месец
  for (let i = 0; i < labels.length; i++) {
    const currentDate = labels[i];
    const currentMonth = currentDate.substring(0, 6);
    const nextDate = labels[i + 1];
    const nextMonth = nextDate ? nextDate.substring(0, 6) : null;

    if (currentMonth !== nextMonth) {
      lastDays.push({ index: i, date: currentDate });
    }
  }

  // За всяка такава дата намираме най-високата стойност от всички datasets
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(dataset => {
      const value = dataset.data[index];
      if (typeof value === 'number' && value > maxY) {
        maxY = value;
      }
    });

    eomAnnotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [6, 3],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: 'end',
        yAdjust: -8,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          weight: 'bold'
        }
      },
      yMax: maxY
    });
  });

  return eomAnnotations;
}





function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };
      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: 1, // Няма значение, ще го коригираме със yAdjust
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -30, // това мести текста над графиката
        rotation: 0
      };
    }
  }
  return annotations;
}







function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          xAdjust: 30,
          yAdjust: -5,
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}





<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // Извличаме месец и година от датата (формат YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (“Close-Of-Business” or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	•	Start & Stop Times for each day’s batch run
	•	Elapsed Duration (how long the entire COB took)
	•	Throughput (records or transactions processed per minute)
	•	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	•	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	•	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	•	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	•	Bar charts for throughput (records per minute) and COB durations
	•	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	•	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	•	Automatic warnings for missing batches, slow batches, and restarts during COB
	•	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues—without manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # определяме списък от файлове
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # определяме списък от отдалечени файлове
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh — Secure Upload/Download/Cleanup wrapper with –all & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we’re in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} — Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * Променя ширината на контейнера на графиките
 * спрямо броя дни:
 *   3–10  дни → клас w-0-10
 *  11–20  дни → клас w-11-20
 *  21–31+ дни → клас w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // махаме всички предишни
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // слагаме новия
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // ограничаваме 3–31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) скриваме/показваме редове
    updateTableRows(v);
    // 2) преизчертаваме графиките
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) настройваме ширината
    updateContainerWidth(v);
  }

  // слушаме промени и от двата контрола
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // първоначално – 10 дни
  syncSliderAndInput(10);
});




// 1) Взимаме само видимите (нескрити) данни от таблцата
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите 2 header-реда и филтрираме само нескритите
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) Рендерираме (или пре-рендерираме) COB-графиката
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // ако вече имаме Chart, първо го унищожаваме
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // само видимите редове

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропусни заглавката
    const visibleRows = rows.filter(row => !row.hidden); // ВЗИМАШ САМО ВИДИМИТЕ редове

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // Пропускаме заглавието
    const selectedRows = dataRows.slice(-maxDays); // Вземаме последните N реда

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // Последните "days" реда
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // Дата
            values.push(parseElapsedTime(cells[1].innerText.trim())); // Време в секунди
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // Взимаме данните от таблицата
    const trend = calculateTrendline(values);         // Изчисляваме тренд линията
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // унищожаваме старата графика ако има
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // Вземаме последните N реда

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // Стартово състояние - 10 дни
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // При движение на слайдъра
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // При промяна на инпут
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper за стойност на слайдъра с default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- за Records per Minute графиката ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip заглавия
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice последните N елемента
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* останалите настройки по твой вкус */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- за COB elapsed графиката ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip заглавния ред
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// при всяка промяна на слайдъра
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... евентуално и другите графики
});

// при зареждане по подразбиране
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-и, ако вече нямаш такива:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // Пропускаме първите 2 (header-и)
    return getAllRows().slice(2);
  }

  // Точно твоето почистване на редовете
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // брой, който искаме да показваме
    const count = Math.max(minRows, Math.min(days, total));
    // индекс в dataRows, от който започваме да показваме
    const firstToShow = total - count;

    // винаги показваме заглавните 2 реда
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // Синхронизация slider ↔ input и initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // По подразбиране 10 дни
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // когато мърдаме слайдера
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // ако искаш да презареждаш и графиките:
      renderIDsChart();
      renderCOBChart();
    });

    // когато променим ръчно в полето
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // Слагаме по подразбиране 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // Връзка между слайдера и инпута
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // Функция, която връща всички <tr>
    const dataRows = getDataRows(); // Функция, която връща само валидните редове (без хедъра)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // Показва заглавията
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // НЕ повече от редовете
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // без заглавията
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // Първоначално показваме 10 дни
  updateTableRows(10);

  // Закачаме слушатели за промяна
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const visibleCount = Math.max(days, 3); // Минимум 3 дена
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// При зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропускаме header-ите
  const visibleCount = Math.max(days, 3); // минимум 3 дена видими
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper за да вземем стойността на слайдера (и да имаме винаги поне 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) адаптирана getRecordsData(), връща само последните N дни
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите два <tr> (header-ите)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // взимаме последните maxDays реда (обратен ред за удобно попълване)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) адаптирана getCOBDataFromTable(), връща само последните N дни
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме само заглавния <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // взимаме последните maxDays реда
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() – вече ползва dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* … */],
        borderColor:     ['rgba(255,99,132,1)',   /* … */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() – вече ползва dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) биндираме към slider-а да ре-рисува и двете
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// готово — само тези 5 блока добавяш/заместваш, останалото не се променя. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// Взимане на всички редове от таблицата
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// Обновяване на видимите редове според избраните дни
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // пропускаме заглавните редове

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Извличане на данни за COB графиката
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// Извличане на данни за ID графиката
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// Помощна функция за парсване на време
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// Рендериране на новата COB графика
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// Рендериране на новата ID графика
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Форматиране на секунди към HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Функция за синхронизация на слайдера
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Функция за синхронизация от input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Добавяне на слушатели
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// Стартиране първоначално
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // Прескачаме заглавния ред
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // Вземаме последните N дни
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // Добавяме име на таблицата
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // Празен ред между таблиците
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
  <button id="exportAllBtn" class="small-button">⬇️ Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // празен ред между таблиците
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* под "Export CSV" бутона */
  left: 180px; /* изнася се вдясно */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- Ако искаш може да добавиш още чекбоксове -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">✅ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">❌ Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- Ако имаш още таблици добавяш тук -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // Създаване на чекбокс прозорец
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // По подразбиране всички са маркирани

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Затваряне на модал прозореца
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* За светъл фон */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* За тъмен фон */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* Слайдър цветът */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // тук извикваш каквото още искаш като update на графики, таблици и т.н.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // за да се инициализира правилно при зареждане
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* Преместване заедно с текста */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = '🌙';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = '🌞';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">🌞</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // всички <tr>
  const dataRows = getDataRows();  // само <tr> за данни
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // показваме винаги header-ите
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // всички tr (вкл. th + tr)
  const dataRows = getDataRows(); // само данните
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // първите два (header) винаги да са видими
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // Обръщаме реда на масивите
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // Пропускаме първите 2 реда с <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // Пропускаме 2 заглавни реда
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // пропускаме 2 заглавни реда

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // минимум 3 дни, не 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // Минимум 3 дни
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // ако искаш и CPU графиката да се адаптира!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // Първоначално зареждане
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // За да се рендерират правилно при зареждане
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // Минимум 3 дни
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // Пропускаме заглавията

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // Минимум 3 реда
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // Първоначално показваме избрания брой дни
    daysValue.textContent = `${daysRange.value} days`;

    // Рендерираме графиките още при зареждане
    renderIDsChart();
    renderTimingChart();

    // Слушаме за промяна на плъзгача
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // Изтриваме старите графики преди да рендерираме нови
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // Рендерираме графиките отново според новата стойност
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

