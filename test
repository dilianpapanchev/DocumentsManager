#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) първо минаваме през file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) сега file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = secs1[key] - secs2
    # само ако date1 е по-бавно
    if (secs1[key] > secs2) {
      # форматираме ±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка (ще е винаги ↑ тук)
      arrow = "↑"
      # печатаме първо delta (за сортиране), после колоните
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # сортираме по delta (най-голям first)
| cut -d, -f2-          # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- първи файл (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- втори файл (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # форматираме ±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ↑ ако date1 е по-бавно (secs1 > secs2), иначе ↓
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "↑" : "↓")

    # първо delta (за сортиране), после всички полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK + SORT + CUT на един ред
awk -F, -v OFS=, '
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първа колона delta (за сортиране), после всичко останало
    print delta, arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta, add arrow, sort and drop the temp column
awk -F, -v OFS=, '
  # 1) Първо минаваме през file1 и запаметяваме:
  #      key = BATCH.STAGE FS BATCH FS JOB.NAME
  #      date1[key]    = $4
  #      elapsed1[key] = $8  (и в секунди secs1[key])
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  # 2) После минаваме file2 и за всеки същия key:
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    # форматираме diff в ±HH:MM:SS
    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # ако date1 е по-бавно (secs1 > secs2) – стрелка ↑, иначе ↓
    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първо delta (за сортиране), после стрелката+stage и останалите полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \     # сортиране по delta низходящо
| cut -d, -f2-            # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# awk + sort + cut
awk -F, -v OFS=, '
  # Четем първи файл: запазваме по ключ (1,2,3) датата и elapsed, и изчисляваме secs1
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  # Втори файл: смятаме secs2 и delta
  {
    key    = $1 FS $2 FS $3
    d2     = $4
    e2     = $8
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    # Форматираме diff като ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Първо колона с delta (за сортиране), после всичко останало
    print delta, \
          $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \
| cut -d, -f2-



#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Намери файловете по маска JT*<дата>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Заглавен ред
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

awk -F, -v OFS=, '
  # Първо минаваме през първия файл и запаметяваме за всеки ключ (1,2,3):
  #   - неговата дата (поле 4)
  #   - elapsed time (поле 8) както в оригинал, така и в секунди
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, tt, ":")
    secs1[key]    = tt[1]*3600 + tt[2]*60 + tt[3]
    next
  }

  # Сега във втория файл за всеки същия ключ:
  {
    key      = $1 FS $2 FS $3
    d2       = $4
    e2       = $8
    split(e2, tt2, ":")
    secs2    = tt2[1]*3600 + tt2[2]*60 + tt2[3]
    s1       = (key in secs1 ? secs1[key] : 0)
    delta    = secs2 - s1

    # Форматираме разликата в ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме желания ред
    print \
      $1,    $2,    $3,          \
      date1[key], elapsed1[key], \
      d2,          e2,            \
      diff
  }
' "$file1" "$file2"




#!/usr/bin/env bash

# Проверка за две дати
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Откриваме файловете по маска JT*<дата>*
files1=(JT*${d1}*)
files2=(JT*${d2}*)
if [ ! -f "${files1[0]}" ] || [ ! -f "${files2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
f1=${files1[0]}
f2=${files2[0]}

awk -F, -v OFS=, '
  #
  # Първо четем файл1 (за date1):
  #   key = комбинация от полета 1..4 (JOB fields)
  #   записваме date1, start, stop и elapsed и пресмятаме секунди
  #
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4
    date1[key]    = $5        # полe 5 е датата във входния ред
    start1[key]   = $7        # поле 7 = старт време
    stop1[key]    = $8        # поле 8 = стоп време
    elapsed1[key] = $9        # поле 9 = elapsed
    split($9, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  #
  # Сега четем файл2 (за date2) и за всеки ключ
  # ● взимаме полета 1..4
  # ● взимаме date2, start2, stop2, elapsed2
  # ● смятаме diff = elapsed2 - elapsed1
  #
  {
    key    = $1 FS $2 FS $3 FS $4
    d2     = $5
    s2     = $7
    e2     = $9
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    sign   = ""
    if (delta<0) { sign="-"; delta = -delta }
    hh     = int(delta/3600)
    mm     = int((delta%3600)/60)
    ss     = delta%60
    diff   = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме:
    #  $1,$2,$3,$4 — полета до JOB.NAME
    #  date1, start1, stop1, elapsed1
    #  date2, start2, stop2, elapsed2
    #  diff
    print \
      $1, $2, $3, $4, \
      date1[key], start1[key], stop1[key], elapsed1[key], \
      d2,       s2,         $8,        e2,        \
      diff
  }
' "$f1" "$f2"




#!/usr/bin/env bash

# Проверка на параметри
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

date1=$1
date2=$2

# Намираме имената на файловете по маска
file1=(JT*${date1}*)
file2=(JT*${date2}*)

if [ ! -f "${file1[0]}" ] || [ ! -f "${file2[0]}" ]; then
  echo "Не можаха да се намерят файлове JT*${date1}* или JT*${date2}*"
  exit 1
fi

file1=${file1[0]}
file2=${file2[0]}

awk -F, -v OFS=, '
  # Прочитаме първия файл, запазваме Elapsed Time (поле 8) в секунди и оригиналния низ
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t = $8
    split(t, a, ":")
    secs = a[1]*3600 + a[2]*60 + a[3]
    t1_secs[key] = secs
    t1_str[key]  = t
    next
  }
  # Сега втория файл: пак правим ключа и взимаме време t2
  {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t2 = $8
    split(t2, b, ":")
    secs2 = b[1]*3600 + b[2]*60 + b[3]
    secs1 = (key in t1_secs ? t1_secs[key] : 0)
    delta = secs2 - secs1

    # Преобразуваме delta в HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме полета 1,2,3,4,6,7, original t1, t2 и разликата
    print $1, $2, $3, $4, $6, $7, t1_str[key], t2, diff
  }
' "$file1" "$file2"




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Usage: $0 <DATE1> <DATE2>"
  exit 1
fi

DATE1="$1"
DATE2="$2"

FILE1=$(ls JT*"$DATE1"*.CSV 2>/dev/null | head -n 1)
FILE2=$(ls JT*"$DATE2"*.CSV 2>/dev/null | head -n 1)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Missing input files for given dates."
  exit 1
fi

echo "Сравнение на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Start1,Stop1,Elapsed1,Start2,Stop2,Elapsed2,Разлика"

awk -F',' '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
{
  key = $1","$2","$3","$4;
  data[key] = $6","$7","$8;
  elapsed[key] = hms_to_minutes($8);
}
' "$FILE2" > /tmp/jt2.map

awk -F',' -v f2="/tmp/jt2.map" '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
function minutes_to_hhmm(mm,   h, m) {
  sign = (mm < 0) ? "-" : "";
  mm = (mm < 0) ? -mm : mm;
  h = int(mm);
  m = int((mm - h) * 60 + 0.5);
  return sign sprintf("%d:%02d", h, m);
}
BEGIN {
  while ((getline < f2) > 0) {
    split($0, parts, " ");
    split(parts[1], k, "=");
    split(k[2], d, ",");
    key = d[1]","d[2]","d[3]","d[4];
    info[key] = d[5]","d[6]","d[7];
    e2[key] = hms_to_minutes(d[7]);
  }
}
{
  key = $1","$2","$3","$4;
  if (key in info) {
    e1 = hms_to_minutes($8);
    diff = e1 - e2[key];
    printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", $1,$2,$3,$4,$6,$7,$8,info[key],minutes_to_hhmm(diff);
  }
}
' "$FILE1" | sort -t',' -k11,11





#!/bin/bash

d1="$1"
d2="$2"

f1=$(ls JT*${d1}*.CSV 2>/dev/null)
f2=$(ls JT*${d2}*.CSV 2>/dev/null)

if [[ -z "$f1" || -z "$f2" ]]; then
  echo "Файл(ове) не са намерени."
  exit 1
fi

echo "Сравнение на $f1 с $f2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Дата1 Elapsed,Дата2 Start,Дата2 Stop,Дата2 Elapsed,Разлика"

join -t, -1 1 -2 1 <(cut -d',' -f1-8 "$f1" | sort) <(cut -d',' -f1-8 "$f2" | sort) | awk -F',' '
function to_seconds(t,  a) {
  split(t, a, ":"); return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs) {
  sign = (secs < 0) ? "-" : "";
  secs = (secs < 0) ? -secs : secs;
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return sign h ":" (m < 10 ? "0" m : m);
}
{
  print $0 > "/tmp/jt_temp.csv"  # ако искаш да провериш
  e1 = $8; e2 = $16;
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
    $1, $2, $3, $4, $6, $7, e1, $14, $15, e2, to_hhmm(diff)
}
' | sort -t',' -k11 -r




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Използване: $0 <DATE1: YYYYMMDD> <DATE2: YYYYMMDD>"
  exit 1
fi

DATE1=$1
DATE2=$2

FILE1=$(ls JT*${DATE1}*.CSV 2>/dev/null)
FILE2=$(ls JT*${DATE2}*.CSV 2>/dev/null)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Някой от файловете липсва:"
  echo "  $FILE1"
  echo "  $FILE2"
  exit 2
fi

echo "Сравняване на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "------------------------------------------------------------------"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Elapsed1,Elapsed2,Разлика"

paste -d'\n' "$FILE1" "$FILE2" | paste - - | awk -F'\t' '
function to_seconds(t,  a) {
  split(t, a, ":");
  return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs, h, m) {
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return h ":" (m < 10 ? "0" m : m);
}
{
  split($1, f1, ",");
  split($2, f2, ",");

  e1 = f1[8]; e2 = f2[8];
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s\n", f1[1], f1[2], f1[3], f1[4], f1[6], f1[7], e1, e2, to_hhmm(diff)
}' | sort -t',' -k9 -r



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска хедърите
  const total = rows.length;
  const rawValue = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = rawValue + 1;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const total = rows.length;
  const requested = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = Math.min(requested, total); // Не позволявай да искаме повече, отколкото имаме

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // само данни
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows(days) {
  const allRows = Array.from(document.getElementById('eomTable').getElementsByTagName('tr'));
  const dataRows = allRows.slice(2); // Прескачаме заглавните два реда
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // винаги показвай заглавията
    } else {
      tr.hidden = (i - 2) < start ? false : true;
    }
  });
}




const visibleRows = Math.min(maxRows, rows.length);
rows.forEach((tr, i) => {
  tr.hidden = i < rows.length - visibleRows;
});






#!/bin/bash

main_log="main_log.txt"
rrex_log="rrex_data.txt"
output_log="merged_log.txt"

> "$output_log"

while IFS= read -r line; do
    # Извличаме датата от формата JT.20240520
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търсим съвпадащ ред в RREX таблицата по първото поле (датата)
        match=$(awk -F'|' -v d="$date" '$1 == d {print $0}' "$rrex_log")

        if [[ -n "$match" ]]; then
            # Вземаме само времената
            rrex_start=$(echo "$match" | awk -F'|' '{print $2}' | cut -d' ' -f2)
            rrex_end=$(echo "$match" | awk -F'|' '{print $3}' | cut -d' ' -f2)
            rrex_duration=$(echo "$match" | awk -F'|' '{print $4}')

            echo "$line | RREX_START: $rrex_start | RREX_END: $rrex_end | RREX_DURATION: $rrex_duration" >> "$output_log"
        else
            echo "$line | RREX: N/A" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

main_log="main_log.txt"        # лог с JT.20240520
rrex_log="rrex_log.txt"        # лог със Start/End/Duration за всяка дата
output_log="enhanced_log.txt"

> "$output_log"

while IFS= read -r line; do
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търси ред в rrex_log, започващ с датата
        rrex_info=$(awk -F'|' -v d="$date" '$1 == d { print $2, $3, $4 }' "$rrex_log")

        if [[ -n "$rrex_info" ]]; then
            echo "$line | $rrex_info" >> "$output_log"
        else
            echo "$line | [No RREX data]" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

input_log="main_log.txt"
output_log="enhanced_log.txt"
log_dir="./logs"  # директория с файловете по дати

> "$output_log"  # празно изходен файл

while IFS= read -r line; do
    # Извличане на датата след JT.
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]+')

    if [[ -n "$date" ]]; then
        file="$log_dir/$date.log"

        if [[ -f "$file" ]]; then
            # Извличане на реда със Stop, Start, Elapsed (примерна логика)
            match=$(grep -i 'Stop.*Start.*Elapsed' "$file" | head -n 1)

            # Добавяне на намереното в края на реда
            echo "$line $match" >> "$output_log"
        else
            echo "$line [No file for $date]" >> "$output_log"
        fi
    else
        echo "$line [No JT date found]" >> "$output_log"
    fi
done < "$input_log"




def run_advanced_shell_script():
    script_path = os.path.join(BASE_DIR, "scripts", "advanced_log.sh")
    try:
        output = subprocess.check_output(["bash", script_path], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("Shell скриптът за advanced лог анализ е изпълнен успешно.")
        # Ако искаш да го запишеш:
        result_file = os.path.join(RESULT_DIR, "advanced_combined.log")
        os.makedirs(RESULT_DIR, exist_ok=True)
        with open(result_file, "w") as f:
            f.write(output)
    except subprocess.CalledProcessError as e:
        logging.error(f"Shell скрипт грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"Грешка при стартиране на shell скрипта: {str(e)}")




import tempfile

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Създаваме временен shell скрипт с оригиналната логика
    script_content = f"""#!/bin/bash
LIMIT_DATE="{limit_date}"
CHAR_LIMIT={char_limit}
LOG_DIR="{log_dir}"
for f in $LOG_DIR/{log_files}; do
    awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
        /\\[ERROR\\]/ && length($0) >= {char_limit} {{
            log_date = substr($0, 2, 10)
            if (log_date >= limit) {{
                if ($0 ~ /{match_keywords}/) {{
                    match($0, /\\] .*? /, arr)
                    if (arr[1] != "" && arr[1] != "\\\\") {{
                        key = arr[1]
                        print key "|" "[" host "] [" file "] " $0
                    }}
                }}
            }}
        }}
    ' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
"""

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sh", mode="w") as tmpfile:
            tmpfile.write(script_content)
            tmpfile_path = tmpfile.name

        remote_path = f"/tmp/monitor_adv_{host}.sh"

        # Качваме скрипта на отдалечената машина
        subprocess.run(["scp", tmpfile_path, f"{user}@{host}:{remote_path}"], check=True)

        # Даваме права и го изпълняваме през ssh
        ssh_cmd = f"chmod +x {remote_path} && bash {remote_path} && rm {remote_path}"
        output = subprocess.check_output(["ssh", f"{user}@{host}", ssh_cmd], stderr=subprocess.STDOUT, timeout=60, universal_newlines=True)

        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH/Script грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Грешка при изпълнение на advanced_log_filter: {str(e)}")
    finally:
        if os.path.exists(tmpfile_path):
            os.unlink(tmpfile_path)






def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Shell скрипт, вграден в Python (точно като оригинала)
    remote_script = f'''
        LIMIT_DATE="{limit_date}"
        CHAR_LIMIT={char_limit}
        for f in {log_dir}/{{{log_files}}}; do
            awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
                /\\[ERROR\\]/ && length($0) >= {char_limit} {{
                    log_date = substr($0, 2, 10)
                    if (log_date >= limit) {{
                        if ($0 ~ /{match_keywords}/) {{
                            match($0, /\\] .*? /, arr)
                            if (arr[1] != "" && arr[1] != "\\\\") {{
                                key = arr[1]
                                print key "|" "[" host "] [" file "] " $0
                            }}
                        }}
                    }}
                }}
            ' "$f"
        done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
    '''

    ssh_cmd = ["ssh", f"{user}@{host}", remote_script]

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=40, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")







def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dirs = conf.get('log_dirs', 'paths').split(',')

    # Формируем списък от лог файлове във всички лог директории
    log_patterns = []
    for log_dir in log_dirs:
        log_dir = log_dir.rstrip('/')
        for f in log_files:
            log_patterns.append(f"{log_dir}/{f}")
    log_patterns_str = ' '.join(log_patterns)

    # awk скрипт (без външен shell parsing)
    awk_script = (
        f"""/\\[ERROR\\]/ && length($0) > {char_limit} {{
            log_date = substr($0, 2, 19);
            if (log_date >= "{limit_date}") {{
                if ($0 ~ /{match_keywords}/)
                    print host "|" file "|" $0;
            }}
        }}"""
    )

    remote_cmd = f"for file in {log_patterns_str}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"
    ssh_cmd = ["ssh", f"{user}@{host}", remote_cmd]

    logging.debug(f"[{host}] SSH команда: {' '.join(ssh_cmd)}")

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=30, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма намерени резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")






#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print host \"|\" file \"|\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=20, universal_newlines=True
        )
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()




[advanced_log_filter]
log_files = mdb.log,runtime.log*,database.log*,ejb.log*
char_limit = 1000
match_keywords = DATABASE|RUNTIME|EJB|MDB



#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break

    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print \"[advanced] |\" host \"|\" file \":\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=15, universal_newlines=True
        )
        if output:
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced log scan записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        scan_host(host, user, log_dirs, keywords)
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()





# Директории за логове
[log_dirs]
paths = /var/log,/opt/bank/logs

# Директории за файлов мониторинг (локални за бекенда)
[file_monitor]
dirs = /var/bank/inbox,/tmp/transactions

# Ключови думи за търсене
[keywords]
errors = ERROR,FATAL,EXCEPTION
warnings = WARN,DEPRECATED

# Потребители
[users]
admin = root,monitoring_user
readonly = viewer


# Monitoring Framework for Banking VMs

## Структура
- `config/`: Конфигурации (.conf и .properties)
- `hosts/`: Списък с хостове
- `logs/`: Логове от мониторинг скрипта
- `scripts/`: Python скриптове

## Конфигурация
- `common.conf`: съдържа директории, ключови думи и потребители
- `settings.properties`: лог ниво, ssh настройки, интервали
- `host_list.txt`: един ред = един hostname

## Стартиране
```bash
cd scripts
python3 monitor.py


# Логване
log.level=INFO
log.rotation=daily
log.retention_days=7

# SSH настройки
backend.host=this-backend-host
remote.user=monitoring_user
connection.timeout=10

# Сканиране
scan.interval=300        # секунди между проверки
scan.parallelism=4       # паралелни ssh задачи


#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

# Архивиране на резултатите
def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

# Мониторинг на локални директории и файлове
def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

# SSH извличане на логове
def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break  # прекъсваме ако няма SSH достъп

    # Запис в резултатен файл
    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')

    # Remote log scan
    for host in hosts:
        scan_host(host, user, log_dirs, keywords)

    # Local file check
    monitor_files(conf)

    # Archive results
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()






function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const x = cobMeta.data[i].x;
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const barVal = data.datasets[0].data[i];
              if (barVal > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(barVal);
                ctx.fillText(formatHHMM(barVal), x, y + 12);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





plugins: {
  tooltip: {
    callbacks: {
      label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
    }
  },
  title: {
    display: true,
    text: "EOM COB Elapsed Times",
    font: {
      size: 13,
      weight: "bold"
    },
    color: getTextColor()
  },
  legend: {
    labels: {
      font: { size: 13 },
      color: getTextColor()
    }
  },
  labelsInside: labelsInsidePlugin // това е ключово
}







const labelsInsidePlugin = {
  id: "labelsInside",
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const meta = chart.getDatasetMeta(0);
    const yScale = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const value = data.datasets[0].data[i];
      if (value > 0) {
        const x = meta.data[i].x;
        const y = yScale.getPixelForValue(value) + 14;
        ctx.fillText(formatHHMM(value), x, y);
      }
    });

    ctx.restore();
  }
};




<div class="chart-container" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime > 0) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const value = data.datasets[0].data[i];
              if (value > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(value) + 12;
                ctx.fillText(formatHHMM(value), x, y);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}
</script>





<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>






function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}







function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}








<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHMM(v),
            maxTicksLimit: 8
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>





function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 13,
              color: "#333"
            }
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v),
            font: {
              size: 13,
              color: "#333"
            }
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      }
    },
    plugins: [{
      id: 'labelsInside',
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const meta = chart.getDatasetMeta(0);
        const yScale = scales.y;

        ctx.save();
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const bar = meta.data[i];
          const value = data.datasets[0].data[i];
          const y = yScale.getPixelForValue(value);
          const x = bar.x;
          if (value > 0) {
            ctx.fillText(formatHMM(value), x, y + 12);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





<table class="rounded" id="eomChartTable">
  <tr>
    <th colspan="6">EOM COB & RR Elapsed Time</th>
  </tr>
  <tr>
    <td colspan="6">
      <div class="chart-container" id="eomChartWrapper">
        <canvas id="eomChart"></canvas>
      </div>
    </td>
  </tr>
</table>



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 },
            color: getTextColor()
          }
        }
      }
    },
    plugins: [
      {
        id: "labelsInside",
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const cobMeta = chart.getDatasetMeta(0);
          const rrMeta = chart.getDatasetMeta(1);
          const yScale = scales.y;

          ctx.save();
          ctx.font = "bold 11px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob = data.datasets[0].data[i] || 0;
            const rr = data.datasets[1].data[i] || 0;
            const total = cob + rr;
            const x = cobMeta.data[i].x;

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }

            if (rr > 0) {
              const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
              ctx.fillText(formatHHMM(rr), x, yRR);
            }

            if (total > 0) {
              const yTotal = yScale.getPixelForValue(total) - 6;
              ctx.fillText(formatHHMM(total), x, yTotal);
            }
          });

          ctx.restore();
        }
      }
    ]
  });

  updateChartsTheme();
}






options: {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    x: {
      stacked: true,
      ticks: {
        maxRotation: 45,
        minRotation: 45
      }
    },
    y: {
      beginAtZero: true,
      ticks: {
        callback: v => formatHHMM(v)
      }
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
      }
    },
    title: {
      display: true,
      text: "EOM COB & RR Elapsed Times",
      font: {
        size: 13,
        weight: "bold"
      },
      color: getTextColor()
    },
    legend: {
      labels: {
        font: { size: 13 }
      }
    }
  }
},
plugins: [
  {
    id: "labelsInside",
    afterDatasetsDraw(chart) {
      const { ctx, data, scales } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);
      const yScale = scales.y;

      ctx.save();
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i] || 0;
        const rr = data.datasets[1].data[i] || 0;
        const total = cob + rr;
        const x = cobMeta.data[i].x;

        if (cob > 0) {
          const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        if (rr > 0) {
          const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        if (total > 0) {
          const yTotal = yScale.getPixelForValue(total) - 6;
          ctx.fillText(formatHHMM(total), x, yTotal);
        }
      });

      ctx.restore();
    }
  }
]




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = cobElapsed[i] || 0;
              const rr = rrElapsed[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}







function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => {
              const raw = ctx.raw || 0;
              return `${ctx.dataset.label}: ${formatHHMM(raw)}`;
            }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCobMid = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCobMid);
              }

              if (rr > 0) {
                const yRRMid = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRRMid);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales: { y } } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i];
              const rr = data.datasets[1].data[i];
              const total = cob + rr;

              const cobTop = y.getPixelForValue(cob);
              const rrTop = y.getPixelForValue(rr);
              const totalTop = y.getPixelForValue(total);
              const cobBottom = y.getPixelForValue(0);
              const rrBottom = y.getPixelForValue(cob);
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (cobTop + cobBottom) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (rrTop + rrBottom) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                ctx.fillText(formatHHMM(total), x, totalTop - 6);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




plugins: [
  {
    id: 'labelsInside',
    afterDatasetsDraw(chart) {
      const { ctx, data, scales: { y } } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);

      ctx.save();
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(rr);
        const totalTop = y.getPixelForValue(total);
        const cobBottom = y.getPixelForValue(0);
        const rrBottom = y.getPixelForValue(cob);

        const x = cobMeta.data[i].x;

        // COB inside
        if (cob > 0) {
          const yCob = (cobTop + cobBottom) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        // RR inside
        if (rr > 0) {
          const yRR = (rrTop + rrBottom) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        // Total on top
        if (total > 0) {
          ctx.fillText(formatHHMM(total), x, totalTop - 6);
        }
      });

      ctx.restore();
    }
  }
]




function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 9) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();
    const rrVal = cells[6].innerText.trim();

    if (date && cobVal && rrVal) {
      dates.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
      rrElapsed.push(parseElapsedToHours(rrVal));
    }
  }

  dates.reverse();
  cobElapsed.reverse();
  rrElapsed.reverse();

  return { dates, cobElapsed, rrElapsed };
}

let eomChartInstance;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) eomChartInstance.destroy();

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
          order: 2
        },
        {
          label: "Duration Limit (2:30)",
          data: Array(dates.length).fill(2.5),
          type: "line",
          borderColor: "red",
          borderDash: [6, 4],
          pointRadius: 0,
          borderWidth: 2,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          max: 7,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: [] // Празно, без EOM маркери
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times vs Duration Limit",
          color: getTextColor(),
          font: {
            size: 13,
            weight: "bold"
          }
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [{
      id: "labelsInside",
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const cobMeta = chart.getDatasetMeta(0);
        const yScale = scales.y;
        ctx.save();
        ctx.font = "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const cob = data.datasets[0].data[i];
          const rr = data.datasets[1].data[i];
          const total = cob + rr;
          const x = cobMeta.data[i].x;

          if (cob > 0) {
            const yCob = yScale.getPixelForValue(cob);
            ctx.fillText(formatHHMM(cob), x, yCob);
          }

          if (rr > 0) {
            const yTop = yScale.getPixelForValue(cob + rr);
            const yBottom = yScale.getPixelForValue(cob);
            const yRR = (yTop + yBottom) / 2;
            ctx.fillText(formatHHMM(rr), x, yRR);
          }

          if (total > 0) {
            const yTotal = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, yTotal);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(54, 162, 235, 0.6)",
          borderColor: "rgba(54, 162, 235, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(128, 128, 128, 0.6)",
          borderColor: "rgba(128, 128, 128, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 13 },
            color: "#333"
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: formatHHMM,
            font: { size: 13 },
            color: "#333"
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 13 }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: "#222"
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        datalabels: {
          display: true,
          color: () => document.body.classList.contains("dark-mode") ? "white" : "black",
          font: {
            weight: 'bold',
            size: 11,
            family: 'sans-serif'
          },
          formatter: value => formatHHMM(value)
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [ChartDataLabels]
  });

  updateChartsTheme();
}




function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // пропускаме header

  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    const date = cells[0].innerText.trim();
    const cob = parseElapsedToHours(cells[3].innerText);
    const rr = parseElapsedToHours(cells[7].innerText);

    dates.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    dates: dates.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}





document.addEventListener("DOMContentLoaded", () => {
  const eomSlider = document.getElementById("eomRange");
  const eomInput = document.getElementById("eomValue");

  function syncEomFromSlider() {
    eomInput.value = eomSlider.value;
    updateEomTableRows();
    renderEOMChart();
  }

  function syncEomFromInput() {
    let value = parseInt(eomInput.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 12) value = 12;
    eomInput.value = value;
    eomSlider.value = value;
    syncEomFromSlider();
  }

  eomSlider.addEventListener("input", syncEomFromSlider);
  eomInput.addEventListener("input", syncEomFromInput);

  syncEomFromSlider(); // Initial load
});





<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


const eomChartWrapper = document.getElementById("eomChartWrapper");

toggleEomBtn.addEventListener("click", () => {
  eomVisible = !eomVisible;
  eomTable.classList.toggle("hidden", !eomVisible);
  eomSliderWrapper.classList.toggle("hidden", !eomVisible);
  eomChartWrapper.classList.toggle("hidden", !eomVisible);

  if (eomVisible) {
    updateEomTableRows();
    renderEOMChart();
  }
});



function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseTimeToMinutes(cells[3].innerText.trim());
    const rrTime = parseTimeToMinutes(cells[6].innerText.trim());

    if (cobTime && rrTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
      rrElapsed.push(rrTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: getEOMAnnotations(labels, cobElapsed)
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      }
    }
  });

  updateChartsTheme();
}






let eomChartInstance = null;

function parseElapsedToHours(str) {
    if (!str || str.length < 8) return 0;
    const parts = str.split(':').map(Number);
    const hours = parts[0];
    const minutes = parts[1];
    const seconds = parts[2];
    return hours + (minutes / 60) + (seconds / 3600);
}

function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 12;

    const dates = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cobTime = parseElapsedToHours(cells[3].innerText.trim());
        const rrTime = parseElapsedToHours(cells[6].innerText.trim());

        if (cobTime && rrTime) {
            dates.push(date);
            cobElapsed.push(cobTime);
            rrElapsed.push(rrTime);
        }
    }

    return {
        labels: dates.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (eomChartInstance) {
        eomChartInstance.destroy();
    }

    eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1"
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1"
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 20,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        font: {
                            size: 13,
                            weight: "bold"
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });

    updateChartsTheme();
}







<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


let eomChartInstance = null;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) {
    eomChartInstance.destroy();
  }

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: {
            stepSize: 1
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: "EOM COB + RR Elapsed Time (stacked)",
          font: {
            size: 13,
            weight: 'bold'
          },
          color: "#222"
        },
        legend: {
          display: true,
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeOutBounce'
      }
    }
  });
}


function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: 






function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
    const labels = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cob = parseTimeToMinutes(cells[3].innerText.trim());
        const rr = parseTimeToMinutes(cells[6].innerText.trim());

        if (cob > 0 || rr > 0) {
            labels.push(date);
            cobElapsed.push(cob);
            rrElapsed.push(rr);
        }
    }

    return {
        labels: labels.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (window.eomChartInstance) {
        window.eomChartInstance.destroy();
    }

    window.eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 10,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        maxTicksLimit: 8,
                        callback: v => formatHHMM(v)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });

    updateChartsTheme();
}



<script>
document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    eomTable.classList.toggle("show", eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });

  function updateEomTableRows() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // Skip headers
    const maxRows = parseInt(eomRange.value, 10);

    rows.forEach((tr, i, arr) => {
      tr.hidden = i < arr.length - maxRows;
    });
  }
});
</script>





#eomTable {
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

#eomTable.show {
  opacity: 1;
  transform: scaleY(1);
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomTable = document.getElementById("eomTable");

let isEomVisible = false;

toggleEomBtn.addEventListener("click", () => {
  isEomVisible = !isEomVisible;
  if (isEomVisible) {
    eomTable.classList.add("show");
  } else {
    eomTable.classList.remove("show");
  }
});





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <div class="daysValue" id="eomValue">10</div>
    </div>
  </div>
</div>






<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span>
      <span>&nbsp;days</span>
    </div>
  </div>
</div>




document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




<div class="tool-button" id="eomControlWrapper">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <label for="eomRange" id="eomLabel">EOM Days:</label>
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span><span>&nbsp;days</span>
    </div>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);
    
    if (eomVisible) {
      updateEomTableRows(); // Пресмята редовете, когато се показва
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
</div>
<div id="eomSliderWrapper" class="daysSliderWrapper hidden">
  <label for="eomRange" id="eomLabel">EOM Days:</label>
  <div class="daysInputWrapper">
    <input type="range" id="eomRange" min="3" max="12" value="10" />
    <span id="eomValue">10</span><span>&nbsp;days</span>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
      updateEomTableRows(); // обнови при показване
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows();
  });
});





function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3
  const totalRows = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < totalRows - maxRows; // скриваме горните
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаш заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}

if (eomVisible) {
  eomTable.classList.remove("hidden");
  eomSliderWrapper.classList.remove("hidden");
  updateEomTableRows(); // <-- Тук се вика
}



document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows();
});






document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("mousedown", (e) => {
    if (e.target.tagName === 'INPUT') return; // предотвратява затваряне от range

    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows(e.target.value); // само ако имаш функция
  });
});




<script>
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });
</script>





toggleEomBtn.addEventListener("click", (event) => {
  // Игнорирай кликове по вложени елементи вътре в бутона
  if (event.target !== toggleEomBtn && !toggleEomBtn.contains(event.target)) return;

  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});



<div class="tool-button" id="toggleEomBtn">
  <span>Show EOM COBs</span>
  <div id="eomSliderWrapper" class="hidden eom-slider">
    <label for="eomRange" id="eomLabel">EOM COB Days:</label>
    <div id="eomInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10">
      <span id="eomValue">10</span>
      <span>days</span>
    </div>
  </div>
</div>


.eom-slider {
  margin-top: 8px;
  font-size: 13px;
  text-align: center;
}

#eomInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 5px;
}

#eomInputWrapper input[type="range"] {
  width: 85px;
  accent-color: #3b8de3;
}

#eomLabel {
  color: #111;
  font-weight: bold;
}

body.dark-mode #eomLabel {
  color: #eee;
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomSliderWrapper = document.getElementById("eomSliderWrapper");
const eomTable = document.getElementById("eomTable");

toggleEomBtn.addEventListener("click", () => {
  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});

document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows(e.target.value); // ако имаш функция за обновяване
});







<div class="eom-controls">
  <button id="toggleEomTable" class="tool-button">Show EOM COBs</button>

  <div id="eomSliderWrapper" class="tool-button hidden">
    <label for="eomRange">EOM COB Days:</label>
    <span id="eomValue">10</span>
    <input type="range" id="eomRange" min="3" max="12" value="10" />
  </div>
</div>


.eom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

#eomSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  color: #333;
  margin-right: 5px;
}

#eomSliderWrapper input[type="range"] {
  width: 85px;
  accent-color: #b3e0ff;
}

#eomValue {
  font-size: 13px;
  font-weight: bold;
  color: #111;
  margin: 0 5px;
}

body.dark-mode #eomSliderWrapper label {
  color: #eee;
}
body.dark-mode #eomValue {
  color: #eee;
}


document.getElementById("toggleEomTable").addEventListener("click", () => {
  const table = document.getElementById("eomTable");
  const slider = document.getElementById("eomSliderWrapper");
  table.classList.toggle("hidden");
  slider.classList.toggle("hidden");
});


<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomDaysSliderWrapper" class="tool-button hidden">
  <label for="eomDaysRange">EOM COB Days:</label>
  <span id="eomDaysValue">10</span>
  <input type="range" min="3" max="12" value="10" id="eomDaysRange" />
</div>

document.addEventListener('DOMContentLoaded', () => {
  const eomBtn = document.getElementById('toggleEomBtn');
  const eomTable = document.getElementById('eomTable');
  const eomSlider = document.getElementById('eomDaysRange');
  const eomValue = document.getElementById('eomDaysValue');
  const eomSliderWrapper = document.getElementById('eomDaysSliderWrapper');

  eomBtn.addEventListener('click', () => {
    const isHidden = eomTable.classList.contains('hidden');
    eomTable.classList.toggle('hidden', !isHidden);
    eomSliderWrapper.classList.toggle('hidden', !isHidden);
  });

  eomSlider.addEventListener('input', () => {
    eomValue.textContent = eomSlider.value;
    updateEomTableRows(); // трябва да съществува, ще добавим логиката после
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаме заглавията
  const maxRows = parseInt(document.getElementById('eomDaysRange').value, 10);

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}




<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomSliderWrapper" class="tool-bottom hidden">
  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

#eomSliderWrapper {
  margin-top: 10px;
  font-size: 14px;
}


const toggleEomBtn = document.getElementById('toggleEomBtn');
const eomSliderWrapper = document.getElementById('eomSliderWrapper');
const eomTable = document.getElementById('eomTable'); // Увери се, че има такава таблица

toggleEomBtn.addEventListener('click', () => {
  eomTable?.classList.toggle('hidden');
  eomSliderWrapper.classList.toggle('hidden');
});

function syncEOMSliderAndInput(value) {
  const v = Math.max(1, Math.min(12, parseInt(value) || 5));
  document.getElementById('eomDaysRange').value = v;
  document.getElementById('eomDaysInput').value = v;
  updateEOMTableRows(v); // Имплементирай тази функция, ако още не съществува
}

document.getElementById('eomDaysRange').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));
document.getElementById('eomDaysInput').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));





<div id="cobToolsMenu" class="tools-menu">
  <!-- Existing tools -->
  
  <button onclick="toggleEOMTable()">Show EOM COBs</button>

  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

<table id="eomTable" style="display: none;">
  <!-- Your EOM table rows -->
</table>

<script>
  function toggleEOMTable() {
    const table = document.getElementById('eomTable');
    table.style.display = table.style.display === 'none' ? 'table' : 'none';
  }

  function syncEOMSliderAndInput(value) {
    const v = Math.max(1, Math.min(12, parseInt(value) || 5));
    document.getElementById('eomDaysRange').value = v;
    document.getElementById('eomDaysInput').value = v;
    updateEOMTableRows(v); // Трябва да имаш дефинирана тази функция
  }

  document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('eomDaysRange');
    const input = document.getElementById('eomDaysInput');
    slider.addEventListener('input', () => syncEOMSliderAndInput(slider.value));
    input.addEventListener('input', () => syncEOMSliderAndInput(input.value));
    syncEOMSliderAndInput(5);
  });
</script>




<footer>
  <p style="margin-top: 30px;">
    За идеи/бъгове, моля пишете в официалната страница на <strong>COB Analyser</strong>.<br>
    <a href="https://your-confluence-link-here" style="color: #66c1ff; text-decoration: none;" target="_blank">
      Отвори COB Analyser в Confluence
    </a>
  </p>
  <br>Поздрави,<br>
  Дилян
</footer>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7f9;
      color: #333;
      padding: 30px;
      line-height: 1.6;
    }
    .container {
      background-color: #fff;
      border: 1px solid #ddd;
      border-left: 5px solid #007ACC;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }
    h1 {
      font-size: 1.5em;
      color: #007ACC;
    }
    .section {
      margin-top: 20px;
    }
    .highlight {
      background-color: #eef;
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      display: inline-block;
    }
    footer {
      margin-top: 30px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Здравейте,</h1>

    <div class="section">
      Файлът за <strong>COB Analyser в SP24 PROD</strong> за дата <span class="highlight">today_cob_date</span> е прикрепен.
    </div>

    <div class="section">
      <strong>LOG файлът</strong>, както и изпълнението на всички функции, се намира в следната директория:
      <div class="highlight">/opt/t24/support_scripts/cob_analyser/log/</div>
    </div>

    <footer>
      Поздрави,<br>
      Диян
    </footer>
  </div>
</body>
</html>





<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }

    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* Хедър */
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* Тяло */
    .email-body {
      padding: 30px;
      text-align: center;            /* центрираме текста */
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
      text-align: center;            /* центрираме и кода */
    }

    /* Футър */
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
      text-align: center;            /* центрираме подписа */
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:</p>
              <p><code>/opt/t24/support_scripts/cob_analyser/log</code></p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>






<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }
    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }
    .email-body {
      padding: 30px;
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
    }
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:<br>
                 <code>/opt/t24/support_scripts/cob_analyser/log</code>
              </p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>



for i in {0..11}; do
  last_day=$(date -d "$current_date -$i month -1 day" +%Y%m%d)
  echo "$last_day"

  jtfind="$jt_path/JT_$last_day.csv"

  if [[ -s "$jtfind" ]]; then
    echo "COB $last_day $jtfind"
    echo "-----Started-----"
    cat "$jtfind" | grep A000 | cut -d ',' -f6 | head -1
    echo "-----Stopped-----"
    cat "$jtfind" | grep R999 | cut -d ',' -f7 | head -1
  else
    echo "File not found or empty: $jtfind, skipping..."
  fi
done





function getEOMAnnotations(labels, yData) {
  const annotations = {};
  const topY = Math.max(...yData);  // използваме масива от стойности

  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}



function getEOMAnnotations(labels, chart) {
  const annotations = {};
  const topY = Math.max(...chart.data.datasets[0].data);  // най-високата стойност по Y
  
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,  // леко над най-високата стойност
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}




function getEOMAnnotations(labels, heights) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      const height = heights?.[i] || 1; // ако няма масив, падаме на 1
      const adjustedY = height + 50; // издигаме текста с 50 над стълба

      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: adjustedY,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -10,
        rotation: 0
      };
    }
  }

  return annotations;
}





// make sure you’ve imported & registered both Chart.js and chartjs-plugin-annotation before this runs
// e.g.:
//   import { Chart, BarController, BarElement, CategoryScale, LinearScale, Title } from 'chart.js';
//   import annotationPlugin from 'chartjs-plugin-annotation';
//   Chart.register(BarController, BarElement, CategoryScale, LinearScale, Title, annotationPlugin);

let recordsChartInstance;

function renderRecordsChart() {
  // 1) pull your data
  const { labels, recordsPerMinute } = getRecordsData();  // your existing extractor

  // 2) destroy previous chart
  if (recordsChartInstance) recordsChartInstance.destroy();

  // 3) create new one
  const ctx = document.getElementById('recordsChart').getContext('2d');
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: 'rgba(54,162,235,0.6)',
        borderColor:   'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
          stacked: true,
          ticks: { font: { size: 13 }, color: '#333' }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { font: { size: 13 }, color: '#333' }
        }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 14, weight: 'bold' },
          color: '#222'
        },
        annotation: {
          // ask our helper to build a map of annotations:
          annotations: buildEOMAnnotations(recordsChartInstance)
        }
      }
    }
  });
}

/**
 * Walks the chart’s labels and data, finds month-breaks
 * and returns a map of annotation configs for line + label.
 */
function buildEOMAnnotations(chart) {
  const ann = {};
  const labels = chart.data.labels;
  const data   = chart.data.datasets[0].data;
  const yScale = chart.scales.y;

  labels.forEach((lbl, i) => {
    const next = labels[i + 1];
    // compare YYYYMM prefix of this vs next
    if (next && lbl.slice(0,6) !== next.slice(0,6)) {
      // vertical dashed line
      ann[`eomLine${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: lbl,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6,4],
        borderDashOffset: 2
      };
      // label at the top
      ann[`eomLabel${i}`] = {
        type: 'label',
        xScaleID: 'x',
        xValue: lbl,
        yScaleID: 'y',
        yValue: yScale.max,     // attach to top of the scale
        content: ['EOM'],
        font: { size: 12, weight: 'bold' },
        color: 'orange',
        textAlign: 'center',
        backgroundColor: 'transparent',
        yAdjust: -8             // shift up 8px from top
      };
    }
  });

  return ann;
}

// call on load / whenever you update your table
renderRecordsChart();




function getEOMAnnotationsWithHeights(records, labels) {
    const annotations = {};
    for (let i = 0; i < labels.length - 1; i++) {
        const current = labels[i];
        const next = labels[i + 1];

        if (current.substring(0, 6) !== next.substring(0, 6)) {
            const yVal = records[i] || 0;
            annotations[`line-eom-${i}`] = {
                type: 'line',
                scaleID: 'x',
                value: current,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [6, 4]
            };

            annotations[`text-eom-${i}`] = {
                type: 'label',
                xValue: current,
                yValue: yVal,
                backgroundColor: 'transparent',
                content: ['EOM'],
                font: {
                    size: 12,
                    weight: 'bold'
                },
                color: 'orange',
                textAlign: 'center',
                position: 'start',
                xAdjust: 0,
                yAdjust: -Math.max(20, Math.min(yVal * 0.05, 40)), // динамично позициониране
                rotation: 0
            };
        }
    }
    return annotations;
}





function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Records Per Minute',
                    data: recordsPerMinute,
                    backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                    borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                    borderRadius: 15,
                    hoverBorderWidth: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                annotation: {
                    annotations: getEOMAnnotationsWithHeights(recordsPerMinute, labels)
                },
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });

    updateChartsTheme();
}




function getEOMAnnotationsWithHeights(chart) {
  const annotations = [];
  const labels = chart.data.labels;
  const datasets = chart.data.datasets;

  // Намери последните дни от месеца
  const lastDays = [];
  for (let i = 0; i < labels.length; i++) {
    const current = labels[i].substring(0, 6);
    const next = labels[i + 1]?.substring(0, 6);
    if (current !== next) {
      lastDays.push({ index: i, date: labels[i] });
    }
  }

  // За всяка дата намери максималната стойност по Y
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(ds => {
      const val = ds.data[index];
      if (typeof val === 'number' && val > maxY) {
        maxY = val;
      }
    });

    annotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [4, 4],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: {
          x: 'end',
          y: 'start'
        },
        yAdjust: -10,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          size: 11,
          weight: 'bold'
        }
      }
    });
  });

  return annotations;
}


const annotations = getEOMAnnotationsWithHeights(chart);

options: {
  // ...
  plugins: {
    annotation: {
      annotations: annotations
    }
  }
}





function getEOMAnnotationsWithHeights(chart, labels, datasets) {
  const eomAnnotations = [];
  const lastDays = [];

  // Намираме всички последни дати за всеки месец
  for (let i = 0; i < labels.length; i++) {
    const currentDate = labels[i];
    const currentMonth = currentDate.substring(0, 6);
    const nextDate = labels[i + 1];
    const nextMonth = nextDate ? nextDate.substring(0, 6) : null;

    if (currentMonth !== nextMonth) {
      lastDays.push({ index: i, date: currentDate });
    }
  }

  // За всяка такава дата намираме най-високата стойност от всички datasets
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(dataset => {
      const value = dataset.data[index];
      if (typeof value === 'number' && value > maxY) {
        maxY = value;
      }
    });

    eomAnnotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [6, 3],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: 'end',
        yAdjust: -8,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          weight: 'bold'
        }
      },
      yMax: maxY
    });
  });

  return eomAnnotations;
}





function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };
      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: 1, // Няма значение, ще го коригираме със yAdjust
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -30, // това мести текста над графиката
        rotation: 0
      };
    }
  }
  return annotations;
}







function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          xAdjust: 30,
          yAdjust: -5,
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}





<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // Извличаме месец и година от датата (формат YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (“Close-Of-Business” or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	•	Start & Stop Times for each day’s batch run
	•	Elapsed Duration (how long the entire COB took)
	•	Throughput (records or transactions processed per minute)
	•	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	•	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	•	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	•	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	•	Bar charts for throughput (records per minute) and COB durations
	•	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	•	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	•	Automatic warnings for missing batches, slow batches, and restarts during COB
	•	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues—without manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # определяме списък от файлове
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # определяме списък от отдалечени файлове
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh — Secure Upload/Download/Cleanup wrapper with –all & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we’re in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} — Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * Променя ширината на контейнера на графиките
 * спрямо броя дни:
 *   3–10  дни → клас w-0-10
 *  11–20  дни → клас w-11-20
 *  21–31+ дни → клас w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // махаме всички предишни
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // слагаме новия
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // ограничаваме 3–31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) скриваме/показваме редове
    updateTableRows(v);
    // 2) преизчертаваме графиките
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) настройваме ширината
    updateContainerWidth(v);
  }

  // слушаме промени и от двата контрола
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // първоначално – 10 дни
  syncSliderAndInput(10);
});




// 1) Взимаме само видимите (нескрити) данни от таблцата
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите 2 header-реда и филтрираме само нескритите
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) Рендерираме (или пре-рендерираме) COB-графиката
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // ако вече имаме Chart, първо го унищожаваме
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // само видимите редове

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропусни заглавката
    const visibleRows = rows.filter(row => !row.hidden); // ВЗИМАШ САМО ВИДИМИТЕ редове

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // Пропускаме заглавието
    const selectedRows = dataRows.slice(-maxDays); // Вземаме последните N реда

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // Последните "days" реда
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // Дата
            values.push(parseElapsedTime(cells[1].innerText.trim())); // Време в секунди
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // Взимаме данните от таблицата
    const trend = calculateTrendline(values);         // Изчисляваме тренд линията
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // унищожаваме старата графика ако има
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // Вземаме последните N реда

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // Стартово състояние - 10 дни
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // При движение на слайдъра
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // При промяна на инпут
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper за стойност на слайдъра с default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- за Records per Minute графиката ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip заглавия
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice последните N елемента
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* останалите настройки по твой вкус */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- за COB elapsed графиката ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip заглавния ред
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// при всяка промяна на слайдъра
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... евентуално и другите графики
});

// при зареждане по подразбиране
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-и, ако вече нямаш такива:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // Пропускаме първите 2 (header-и)
    return getAllRows().slice(2);
  }

  // Точно твоето почистване на редовете
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // брой, който искаме да показваме
    const count = Math.max(minRows, Math.min(days, total));
    // индекс в dataRows, от който започваме да показваме
    const firstToShow = total - count;

    // винаги показваме заглавните 2 реда
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // Синхронизация slider ↔ input и initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // По подразбиране 10 дни
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // когато мърдаме слайдера
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // ако искаш да презареждаш и графиките:
      renderIDsChart();
      renderCOBChart();
    });

    // когато променим ръчно в полето
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // Слагаме по подразбиране 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // Връзка между слайдера и инпута
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // Функция, която връща всички <tr>
    const dataRows = getDataRows(); // Функция, която връща само валидните редове (без хедъра)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // Показва заглавията
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // НЕ повече от редовете
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // без заглавията
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // Първоначално показваме 10 дни
  updateTableRows(10);

  // Закачаме слушатели за промяна
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const visibleCount = Math.max(days, 3); // Минимум 3 дена
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// При зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропускаме header-ите
  const visibleCount = Math.max(days, 3); // минимум 3 дена видими
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper за да вземем стойността на слайдера (и да имаме винаги поне 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) адаптирана getRecordsData(), връща само последните N дни
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите два <tr> (header-ите)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // взимаме последните maxDays реда (обратен ред за удобно попълване)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) адаптирана getCOBDataFromTable(), връща само последните N дни
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме само заглавния <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // взимаме последните maxDays реда
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() – вече ползва dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* … */],
        borderColor:     ['rgba(255,99,132,1)',   /* … */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() – вече ползва dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) биндираме към slider-а да ре-рисува и двете
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// готово — само тези 5 блока добавяш/заместваш, останалото не се променя. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// Взимане на всички редове от таблицата
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// Обновяване на видимите редове според избраните дни
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // пропускаме заглавните редове

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Извличане на данни за COB графиката
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// Извличане на данни за ID графиката
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// Помощна функция за парсване на време
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// Рендериране на новата COB графика
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// Рендериране на новата ID графика
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Форматиране на секунди към HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Функция за синхронизация на слайдера
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Функция за синхронизация от input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Добавяне на слушатели
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// Стартиране първоначално
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // Прескачаме заглавния ред
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // Вземаме последните N дни
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // Добавяме име на таблицата
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // Празен ред между таблиците
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
  <button id="exportAllBtn" class="small-button">⬇️ Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // празен ред между таблиците
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* под "Export CSV" бутона */
  left: 180px; /* изнася се вдясно */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- Ако искаш може да добавиш още чекбоксове -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">✅ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">❌ Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- Ако имаш още таблици добавяш тук -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // Създаване на чекбокс прозорец
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // По подразбиране всички са маркирани

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Затваряне на модал прозореца
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* За светъл фон */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* За тъмен фон */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* Слайдър цветът */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // тук извикваш каквото още искаш като update на графики, таблици и т.н.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // за да се инициализира правилно при зареждане
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* Преместване заедно с текста */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = '🌙';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = '🌞';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">🌞</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // всички <tr>
  const dataRows = getDataRows();  // само <tr> за данни
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // показваме винаги header-ите
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // всички tr (вкл. th + tr)
  const dataRows = getDataRows(); // само данните
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // първите два (header) винаги да са видими
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // Обръщаме реда на масивите
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // Пропускаме първите 2 реда с <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // Пропускаме 2 заглавни реда
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // пропускаме 2 заглавни реда

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // минимум 3 дни, не 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // Минимум 3 дни
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // ако искаш и CPU графиката да се адаптира!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // Първоначално зареждане
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // За да се рендерират правилно при зареждане
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // Минимум 3 дни
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // Пропускаме заглавията

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // Минимум 3 реда
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // Първоначално показваме избрания брой дни
    daysValue.textContent = `${daysRange.value} days`;

    // Рендерираме графиките още при зареждане
    renderIDsChart();
    renderTimingChart();

    // Слушаме за промяна на плъзгача
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // Изтриваме старите графики преди да рендерираме нови
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // Рендерираме графиките отново според новата стойност
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

