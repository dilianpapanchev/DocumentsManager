#!/usr/bin/env bash
set -euo pipefail

# Първо: местим се в директорията на самия скрипт
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Параметри (по подразбиране report.csv -> report.html)
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-report.html}"

# Проверка за CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ Не открих CSV файла '$CSV_INPUT' в папката $SCRIPT_DIR" >&2
  echo "   (Текуща папка: $(pwd))" >&2
  echo "   Съдържание на $(pwd):" >&2
  ls -1
  exit 1
fi

# Прочитаме цялото CSV и ескейпваме backticks
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# Генерираме HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // Вградeно CSV
    const rawCSV = \`
$CSV_CONTENT
\`;

    // Парсване
    function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
    function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
    function fmtDiff(n){ return (n>=0?'+':'') + n; }

    let header=[], rows=[], N;
    let columns=[], dateCols=[], elapsedCols=[];
    let data=[], currentSort={col:null,dir:'asc'};
    let cmpDates=[null,null];

    document.addEventListener('DOMContentLoaded',()=>{
      flatpickr('#start',{dateFormat:'Y-m-d'});
      flatpickr('#end',  {dateFormat:'Y-m-d'});

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search').addEventListener('input',renderFilter);
      document.getElementById('applyDates').addEventListener('click',renderFilter);
      document.getElementById('allDates').addEventListener('click',setAllDates);
      document.getElementById('compare').addEventListener('click',compareDates);
      document.getElementById('reset').addEventListener('click',resetAll);
      document.getElementById('start').addEventListener('change', ()=>storeCompare(0));
      document.getElementById('end').addEventListener('change',   ()=>storeCompare(1));
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/^[0-9]{8}$/.test(h)) dateCols.push(i);
        if(/^Elapsed/i.test(h))   elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          const s=parseSec(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const c=document.getElementById('toggles'); c.innerHTML='';
      columns.forEach((col,i)=>{
        const lbl=document.createElement('label');
        const cb=document.createElement('input');
        cb.type='checkbox'; cb.checked=!col.hidden;
        cb.onchange=()=>{ col.hidden=!cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        c.append(lbl);
      });
    }

    function renderTable(){
      const thead=document.getElementById('thead'),
            tbody=document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // Header
      const hr=document.createElement('tr');
      columns.forEach((col,i)=>{
        if(col.hidden) return;
        const th=document.createElement('th');
        th.textContent=col.name;
        th.onclick=()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // Body
      data.forEach(d=>{
        if(d.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((col,i)=>{
          if(col.hidden) return;
          const td=document.createElement('td');
          td.textContent=d.vals[i]||'';
          if(i===d.maxIdx) td.classList.add('max');
          tr.append(td);
        });
        const val = parseSec(d.vals[elapsedCols.at(-1)]) - parseSec(d.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=fmtDiff(val);
        td2.classList.add(val>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function renderFilter(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd=document.getElementById('start').value.replace(/-/g,''), 
            ed=document.getElementById('end').value.replace(/-/g,'');
      data.forEach(d=>{
        let ok=true;
        if(term)
          ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const v=d.vals[ci]||'';
            return (!sd||v>=sd) && (!ed||v<=ed);
          });
        }
        d.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds=dateCols.map(ci=>header[ci]).sort();
      const s=ds[0], e=ds.at(-1);
      document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
      document.getElementById('end'  ).value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
      renderFilter();
    }

    function storeCompare(idx){
      cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
    }

    function compareDates(){
      const [c1,c2] = cmpDates;
      if(!c1||!c2) return alert('Изберете две дати');
      const ci1 = header.indexOf(c1), ci2 = header.indexOf(c2);
      if(ci1<0||ci2<0) return alert('Дата не намерена в header');
      const ei1=ci1+1, ei2=ci2+1;
      data.forEach(d=>{
        d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(d=>{d.hidden=false; d.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран \${OUT_HTML} – отвори го в браузър!"






#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT_HTML="\${2:-report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "❌ Не открих CSV файла '\$CSV' в \$PWD" >&2
  exit 1
fi

# Escape на backticks за JS-template
CSV_CONTENT=\$(sed 's/`/\\\\`/g' "\$CSV")

cat >"\$OUT_HTML" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:10px; }
    .columns-toggle label { margin-right:10px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="apply">Apply Date Filter</button>
      <button id="all">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ─── Вградeно CSV ───────────────────────────────────────
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ────────────────────────────────────────────────────────

  function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
  function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
  function fmtDiff(n){ return (n>=0?'+':'') + n; }

  let header = [], rows = [], N;
  let columns = [], dateCols = [], elapsedCols = [], data = [];
  let currentSort = {col:null, dir:'asc'};
  let cmpDates = [null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    flatpickr('#start', {dateFormat:'Y-m-d'});
    flatpickr('#end',   {dateFormat:'Y-m-d'});

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('apply' ).addEventListener('click', filterTable);
    document.getElementById('all'   ).addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset' ).addEventListener('click', resetAll);
    document.getElementById('start' ).addEventListener('change', ()=>storeCompare(0));
    document.getElementById('end'   ).addEventListener('change', ()=>storeCompare(1));
  });

  function initData(){
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4)/2;

    // Определяме индекси
    dateCols    = header.map((h,i)=>/^[0-9]{8}\$/.test(h)?i:-1).filter(i=>i>=0);
    elapsedCols = header.map((h,i)=>/^Elapsed/i.test(h)?i:-1).filter(i=>i>=0);
    columns     = header.map(h=>({name:h,hidden:false}));

    // Подготвяме data
    data = rows.map(r=>{
      let maxIdx = elapsedCols[0], maxSec=-1;
      elapsedCols.forEach(ci=>{
        let s = parseSec(r[ci]);
        if(s>maxSec){ maxSec=s; maxIdx=ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles(){
    const ctr=document.getElementById('toggles');
    ctr.innerHTML='';
    columns.forEach((c,i)=>{
      const lbl=document.createElement('label');
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=!c.hidden;
      cb.onchange=()=>{ c.hidden=!cb.checked; renderTable(); };
      lbl.append(cb,' ',c.name);
      ctr.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML=''; tbody.innerHTML='';

    // Header + Difference
    const hr=document.createElement('tr');
    columns.forEach((c,i)=>{
      if(c.hidden) return;
      const th=document.createElement('th');
      th.textContent=c.name;
      th.onclick=()=>sortBy(i);
      if(currentSort.col===i) th.classList.add(
        currentSort.dir==='asc'?'sort-asc':'sort-desc'
      );
      hr.append(th);
    });
    const thD=document.createElement('th');
    thD.textContent='Difference';
    hr.append(thD);
    thead.append(hr);

    // Body
    data.forEach((d,ri)=>{
      if(d.hidden) return;
      const tr=document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const td=document.createElement('td');
        td.textContent = d.vals[i]||'';
        if(i===d.maxIdx) td.classList.add('max');
        tr.append(td);
      });
      const diffVal = d.diffAll;
      const td2=document.createElement('td');
      td2.textContent = fmtDiff(diffVal);
      td2.classList.add(diffVal>=0?'diff-pos':'diff-neg');
      tr.append(td2);
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col=ci;
    const th=document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci];
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp =(!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term = document.getElementById('search').value.toLowerCase();
    const sd = document.getElementById('start').value.replace(/-/g,''), 
          ed = document.getElementById('end'  ).value.replace(/-/g,'');
    data.forEach(d=>{
      let ok=true;
      if(term) ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        ok = dateCols.some(ci=>{
          const hv = d.vals[ci];
          return (!sd||hv>=sd) && (!ed||hv<=ed);
        });
      }
      d.hidden=!ok;
    });
    renderTable();
  }

  function setAllDates(){
    if(!dateCols.length) return;
    const ds = dateCols.map(ci=>header[ci]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeCompare(idx){
    const val = (idx===0?document.getElementById('start'):document.getElementById('end')).value.replace(/-/g,'');
    cmpDates[idx]=val;
  }

  function compareDates(){
    if(!cmpDates[0]||!cmpDates[1]) return alert('Изберете две дати');
    const ci1 = header.indexOf(cmpDates[0]);
    const ci2 = header.indexOf(cmpDates[1]);
    if(ci1<0||ci2<0) return alert('Не намерих колоната за избраната дата');
    const ei1 = ci1+1, ei2 = ci2+1;
    data.forEach(d=>{
      d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(d=>{d.hidden=false; d.diffAll=0;});
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>
</body>
</html>
EOF

echo "✅ Generated \$OUT_HTML – open it in your browser!"






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Вграждаме CSV-то в JS template literal (escape на backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { background:#fff; padding:20px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search…"/>
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // ─── Вградeно CSV ──────────────────────────────────────────────────────────
    const rawCSV = \`
$CSV_CONTENT
\`;
    // ────────────────────────────────────────────────────────────────────────────

    // CSV → матрица
    function parseCSV(txt) {
      return txt.trim().split('\\n').map(r=>r.split(','));
    }
    // HH:MM:SS → секунди
    function parseElapsed(s) {
      const [h,m,x] = (s||'00:00:00').split(':').map(Number);
      return h*3600 + m*60 + x;
    }
    function formatDiff(n){ return (n>=0?'+':'') + n; }

    let header, rows, N;
    let columns = [], dateCols = [], elapsedCols = [];
    let data = [], currentSort = {col:null,dir:'asc'};

    document.addEventListener('DOMContentLoaded', () => {
      // Поправена инициализация на flatpickr:
      flatpickr('#start', { dateFormat: "Y-m-d" });
      flatpickr('#end',   { dateFormat: "Y-m-d" });

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search'     ).addEventListener('input', filterTable);
      document.getElementById('applyDates').addEventListener('click', filterTable);
      document.getElementById('allDates'   ).addEventListener('click', setAllDates);
      document.getElementById('compare'    ).addEventListener('click', compareDates);
      document.getElementById('reset'      ).addEventListener('click', resetAll);
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/date/i.test(h))    dateCols.push(i);
        if(/elapsed/i.test(h)) elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          let s=parseElapsed(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const ct = document.getElementById('toggles');
      ct.innerHTML = '';
      columns.forEach((col,i)=>{
        const lbl = document.createElement('label');
        const cb  = document.createElement('input');
        cb.type='checkbox'; cb.checked = !col.hidden;
        cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        ct.append(lbl);
      });
    }

    function renderTable(){
      const thead = document.getElementById('thead');
      const tbody = document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // HEADER
      const hr = document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const th=document.createElement('th');
        th.textContent=c.name;
        th.onclick = ()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // BODY
      data.forEach((row,ri)=>{
        if(row.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((c,i)=>{
          if(c.hidden) return;
          const td=document.createElement('td');
          td.textContent = row.vals[i]||'';
          if(elapsedCols.includes(i)&&row.maxIdx===i) td.classList.add('max');
          tr.append(td);
        });
        const d = parseElapsed(row.vals[elapsedCols.at(-1)]) - parseElapsed(row.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=formatDiff(d);
        td2.classList.add(d>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function filterTable(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd  =document.getElementById('start').value;
      const ed  =document.getElementById('end').value;
      data.forEach(r=>{
        let ok=true;
        if(term) ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const d=(r.vals[ci]||'').split('T')[0];
            return (!sd||d>=sd) && (!ed||d<=ed);
          });
        }
        r.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds = dateCols.map(ci=>header[ci]).sort();
      document.getElementById('start').value=ds[0];
      document.getElementById('end'  ).value=ds.at(-1);
      filterTable();
    }

    function compareDates(){
      const sd=document.getElementById('start').value;
      const ed=document.getElementById('end').value;
      if(!sd||!ed) return alert('Изберете две дати');
      const ci1 = header.indexOf(sd);
      const ci2 = header.indexOf(ed);
      if(ci1<0||ci2<0) return alert('Няма колона с такава дата');
      const ei1 = ci1+1, ei2 = ci2+1; 
      data.forEach(r=>{
        const v1=parseElapsed(r.vals[ei1]);
        const v2=parseElapsed(r.vals[ei2]);
        r.diffAll = v2 - v1;
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(r=>{r.hidden=false; r.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – двойно клик в браузър!"




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ CSV файлът '$CSV' не е намерен в $(pwd)" >&2
  exit 1
fi

# Ескейпваме backticks, за да вградим CSV-то в JS-template
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; background:#fff; padding:20px; border-radius:6px;
                 box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    .table-wrap { background:#fff; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ↑"; }
    th.sort-desc::after { content:" ↓"; }
    td.max { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search…" />
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <div class="table-wrap">
      <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ─── Вградeно CSV ──────────────────────────────────────────────────────────
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ────────────────────────────────────────────────────────────────────────────

  // Парсване на CSV
  function parseCSV(txt) {
    return txt.trim().split('\\n').map(r => r.split(','));
  }
  function parseElapsed(s) {
    const [h,m,sec] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + sec;
  }
  function formatDiff(n) { return (n>=0?'+':'') + n; }

  // Глобално състояние
  let header, rows, N;
  let columns = [], dateCols = [], elapsedCols = [];
  let data = [], currentSort = { col:null, dir:'asc' };

  // Инициализация
  document.addEventListener('DOMContentLoaded', () => {
    flatpickr('#start,{ dateFormat:"Y-m-d" }');
    flatpickr('#end',  { dateFormat:"Y-m-d" });

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('applyDates').addEventListener('click', filterTable);
    document.getElementById('allDates').addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset').addEventListener('click', resetAll);
  });

  function initData() {
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4) / 2;

    // Дефинираме колони
    header.forEach((h,i) => {
      columns.push({ name:h, hidden:false });
      if (/date/i.test(h))    dateCols.push(i);
      if (/elapsed/i.test(h)) elapsedCols.push(i);
    });

    // Подготвяме data[] обекти
    data = rows.map(r => {
      let maxIdx = elapsedCols[0], maxSec = -1;
      elapsedCols.forEach(ci => {
        const s = parseElapsed(r[ci]);
        if (s>maxSec) { maxSec = s; maxIdx = ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles() {
    const ctr = document.getElementById('toggles');
    ctr.innerHTML = '';
    columns.forEach((col,i) => {
      const lbl = document.createElement('label');
      const cb  = document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{
        col.hidden = !cb.checked;
        renderTable();
      };
      lbl.append(cb,' ',col.name);
      ctr.append(lbl);
    });
  }

  function renderTable() {
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    thead.innerHTML = ''; tbody.innerHTML = '';

    // HEADER
    const hr = document.createElement('tr');
    columns.forEach((col,i) => {
      if (col.hidden) return;
      const th = document.createElement('th');
      th.textContent = col.name;
      th.onclick = ()=>sortBy(i);
      if (currentSort.col===i)
        th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    const thD = document.createElement('th');
    thD.textContent = 'Difference';
    hr.append(thD);
    thead.append(hr);

    // BODY
    data.forEach(row=>{
      if (row.hidden) return;
      const tr = document.createElement('tr');
      columns.forEach((col,i)=>{
        if (col.hidden) return;
        const td = document.createElement('td');
        td.textContent = row.vals[i]||'';
        if (elapsedCols.includes(i) && row.maxIdx===i)
          td.classList.add('max');
        tr.append(td);
      });
      // Difference = lastElapsed - firstElapsed
      const d = parseElapsed(row.vals[ elapsedCols[elapsedCols.length-1] ]) -
                parseElapsed(row.vals[ elapsedCols[0] ]);
      const td2 = document.createElement('td');
      td2.textContent = formatDiff(d);
      if (d>0) td2.classList.add('diff-pos');
      if (d<0) td2.classList.add('diff-neg');
      tr.append(td2);

      tbody.append(tr);
    });
  }

  function sortBy(ci) {
    // clear classes
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    // toggle dir
    if (currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col = ci;
    // mark header
    const th = document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    // sort data
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci], cmp;
      const nA=parseFloat(A), nB=parseFloat(B);
      if (!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
      else cmp=A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable() {
    const term = document.getElementById('search').value.toLowerCase();
    const sd   = document.getElementById('start').value;
    const ed   = document.getElementById('end').value;
    data.forEach(r=>{
      let ok = true;
      if (term) {
        ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      }
      if (ok && (sd||ed)) {
        ok = dateCols.some(ci=>{
          const d = (r.vals[ci]||'').split('T')[0];
          return (!sd||d>=sd) && (!ed||d<=ed);
        });
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function setAllDates() {
    if (!dateCols.length) return;
    // Извличаме header датите
    const dates = dateCols.map(ci=>header[ci]).sort();
    document.getElementById('start').value = dates[0];
    document.getElementById('end').value   = dates[dates.length-1];
    filterTable();
  }

  function compareDates() {
    const sd = document.getElementById('start').value;
    const ed = document.getElementById('end').value;
    if (!sd||!ed) return alert('Изберете две дати');
    // намираме колоните по header
    const ci1 = header.findIndex(h=>h===sd);
    const ci2 = header.findIndex(h=>h===ed);
    if (ci1<0||ci2<0) return alert('Дата не намерена в колони');
    // сравняваме Elapsed стълбовете (след всяка date колона)
    const ei1 = dateCols.indexOf(ci1)>=0 ? dateCols.indexOf(ci1)+1 : ci1+1;
    const ei2 = dateCols.indexOf(ci2)>=0 ? dateCols.indexOf(ci2)+1 : ci2+1;
    data.forEach(r=>{
      const v1=parseElapsed(r.vals[ei1]);
      const v2=parseElapsed(r.vals[ei2]);
      r.diffAll = v2 - v1;
    });
    renderTable();
  }

  function resetAll() {
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>

</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ CSV файлът '$CSV' не е намерен в $(pwd)" >&2
  exit 1
fi

# Escape двойни кавички, за да вградим CSV-то в JS
CSV_ESCAPED=$(sed 's/"/\\"/g' "$CSV")

cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Advanced Report</title>
<style>
  body { font-family:sans-serif; padding:20px; background:#f4f4f4; }
  .controls { margin-bottom:15px; display:flex; flex-wrap:wrap; gap:10px; }
  .controls input, .controls button { padding:6px 10px; }
  .columns-toggle { margin-bottom:15px; }
  .columns-toggle label { margin-right:8px; }
  .table-wrap { overflow-x:auto; background:#fff; padding:10px; border:1px solid #ccc; }
  table { border-collapse:collapse; width:100%; }
  th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
  th { background:#eee; cursor:pointer; position:relative; user-select:none; }
  th.sort-asc::after  { content:" ↑"; }
  th.sort-desc::after { content:" ↓"; }
  td.max { background:#fff9c4; }
  .hidden { display:none; }
  .diff-pos { background:#e6f4ea; }
  .diff-neg { background:#fce8e6; }
</style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search…" />
  <input id="start" type="date" />
  <input id="end"   type="date" />
  <button id="applyDates">Apply Date Filter</button>
  <button id="compare">Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<div class="table-wrap">
  <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
</div>

<script>
// Вградено CSV
const rawCSV = \`
$CSV_ESCAPED
\`.trim();

// Парсване на CSV в масив от масиви
function parseCSV(txt) {
  return txt.split('\\n').map(r => r.split(','));
}

let header, rows, N;
let columns;    // {name,hidden}[]
let dateCols;   // индексите на date колони
let elapsedCols;// индексите на elapsed колони
let data;       // {vals,hidden,maxIdx,diff:{}}[]

const thead = document.getElementById('thead');
const tbody = document.getElementById('tbody');
const toggles= document.getElementById('toggles');

function init() {
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;
  N = (header.length - 4)/2;

  // Колони
  columns = header.map((h,i) => ({
    name: h, hidden: false
  }));
  dateCols    = header.map((h,i)=>/date/i.test(h)?i:-1).filter(i=>i>=0);
  elapsedCols = header.map((h,i)=>/elapsed/i.test(h)?i:-1).filter(i=>i>=0);

  // Данни
  data = rows.map(r => {
    let maxIdx=elapsedCols[0], maxSec=-1;
    elapsedCols.forEach(ci=>{
      const [h,m,s] = (r[ci]||'00:00:00').split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      if(sec>maxSec){ maxSec=sec; maxIdx=ci; }
    });
    return { vals:r.slice(), hidden:false, maxIdx, diff:{} };
  });

  buildToggles();
  render();
}

// Създава чекбоксове за скриване/показване на колони
function buildToggles(){
  toggles.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{
      col.hidden = !cb.checked;
      render();
    };
    lbl.append(cb, ' ', col.name);
    toggles.append(lbl);
  });
}

// Рендер на таблицата
function render(){
  // Header
  thead.innerHTML = '';
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    hr.append(th);
  });
  const tdiff = document.createElement('th');
  tdiff.textContent = 'Difference';
  hr.append(tdiff);
  thead.append(hr);

  // Body
  tbody.innerHTML = '';
  data.forEach((row,ri)=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,ci)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      td.textContent = row.vals[ci]||'';
      if(elapsedCols.includes(ci) && row.maxIdx===ci) td.classList.add('max');
      // сравнение
      if(row.diff[ci]!=null){
        td.classList.add(row.diff[ci]>=0? 'diff-pos':'diff-neg');
        td.textContent += ' '+row.diff[ci];
      }
      tr.append(td);
    });
    // difference col = lastElapsed-firstElapsed
    const diffAll = elapsedCols.reduce((acc,ci)=>acc + (row.diff[ci]||0), 0);
    const td2 = document.createElement('td');
    td2.textContent = formatDiff(diffAll);
    tr.append(td2);

    tbody.append(tr);
  });
}

// Форматира разлика секунди -> +X
function formatDiff(d){ return (d>=0?'+':'')+d; }

// Сортиране
function sortBy(ci){
  const dir = thead.querySelectorAll('th')[ci].classList.toggle('sort-asc')
             ? 'asc':'desc';
  thead.querySelectorAll('th').forEach((th,i)=>i!==ci && th.classList.remove('sort-asc','sort-desc'));
  if(dir==='desc') thead.querySelectorAll('th')[ci].classList.add('sort-desc');
  data.sort((a,b)=>{
    let A=a.vals[ci], B=b.vals[ci], res=0;
    const nA=parseFloat(A), nB=parseFloat(B);
    if(!isNaN(nA) && !isNaN(nB)) res=nA-nB;
    else res= A.localeCompare(B);
    return dir==='asc'? res : -res;
  });
  render();
}

// Филтриране
function filter(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value;
  const ed   = document.getElementById('end').value;
  data.forEach(r=>{
    let ok=true;
    if(term){
      ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    }
    if(ok && (sd||ed)){
      ok = dateCols.some(ci=>{
        const d = (r.vals[ci]||'').split('T')[0];
        return (!sd||d>=sd) && (!ed||d<=ed);
      });
    }
    r.hidden = !ok;
  });
  render();
}

// Запаметява индексите на редовете за сравнение
let cmpIdx = [];
function pickCompare(){
  const sd = document.getElementById('start').value;
  const ed = document.getElementById('end').value;
  if(sd){
    cmpIdx[0] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(sd));
  }
  if(ed){
    cmpIdx[1] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(ed));
  }
}

// Сравнение
function compare(){
  if(cmpIdx.length<2) return alert('Изберете две дати');
  data.forEach(r=>{
    elapsedCols.forEach(ci=>{
      const v1=parseElapsed(data[cmpIdx[0]].vals[ci]);
      const v2=parseElapsed(data[cmpIdx[1]].vals[ci]);
      r.diff[ci] = v2 - v1;
    });
  });
  render();
}

// Парсване HH:MM:SS -> секунди
function parseElapsed(s){
  const [h,m,x]= (s||'00:00:00').split(':').map(Number);
  return h*3600+m*60+x;
}

// Reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diff={}; });
  cmpIdx=[];
  init();
}

document.getElementById('search').addEventListener('input',filter);
document.getElementById('applyDates').addEventListener('click',filter);
document.getElementById('compare').addEventListener('click',compare);
document.getElementById('reset').addEventListener('click',resetAll);
document.getElementById('start').addEventListener('change',pickCompare);
document.getElementById('end'  ).addEventListener('change',pickCompare);

init();
</script>

</body>
</html>
EOF

echo "✅ Генериран: $OUT"






#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

# Проверка за наличен CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът '$CSV_INPUT' не е намерен в $(pwd)" >&2
  exit 1
fi

# Вграждане на CSV съдържанието (escape на backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# Генерираме HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    :root {
      --primary-color: #4285f4;
      --secondary-color: #f1f3f4;
      --hover-color: #e8f0fe;
      --border-color: #dadce0;
      --text-color: #202124;
      --light-text: #5f6368;
      --max-highlight: #fff9c4;
      --diff-positive: #e6f4ea;
      --diff-negative: #fce8e6;
    }
    body {
      font-family: 'Roboto',sans-serif; margin:0; padding:20px; background:#f8f9fa; color:var(--text-color);
    }
    .container {
      background:#fff; border-radius:8px; box-shadow:0 1px 2px rgba(0,0,0,0.1); padding:20px;
    }
    h1 { color:var(--primary-color); font-weight:500; margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:20px; align-items:center }
    .controls input, .controls button { padding:8px 12px; border:1px solid var(--border-color); border-radius:4px; font-family:inherit }
    .controls button { background:var(--primary-color); color:#fff; cursor:pointer; }
    .controls button:hover { background:#3367d6; }
    .table-container { overflow-x:auto; border:1px solid var(--border-color); border-radius:4px }
    table { width:100%; border-collapse:collapse; }
    th,td { padding:12px 15px; text-align:left; border-bottom:1px solid var(--border-color) }
    th { background:var(--secondary-color); color:var(--light-text); position:relative; cursor:pointer }
    tr:hover { background:var(--hover-color) }
    th.sort-asc::after { content:" ↑"; color:var(--primary-color) }
    th.sort-desc::after { content:" ↓"; color:var(--primary-color) }
    td.max { background:var(--max-highlight); font-weight:500 }
    .column-toggle { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:15px }
    .column-toggle label { display:flex; align-items:center; gap:5px; cursor:pointer; font-size:13px; background:var(--secondary-color); padding:5px 8px; border-radius:4px }
    .hidden { display:none!important }
    .diff-positive { background:var(--diff-positive) }
    .diff-negative { background:var(--diff-negative) }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Report</h1>
    <div class="controls">
      <input type="text" id="search" placeholder="Search across all columns..."/>
      <input type="text" id="start-date" class="date-picker" placeholder="From date"/>
      <input type="text" id="end-date" class="date-picker" placeholder="To date"/>
      <button id="apply-dates">Apply</button>
      <button id="compare-dates">Compare Dates</button>
      <button id="reset-all">Reset All</button>
    </div>
    <div class="column-toggle" id="column-toggle-container"></div>
    <div class="table-container">
      <table id="data-table"><thead></thead><tbody></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

  <script>
    // Вградено CSV
    const csvData = \`
$CSV_CONTENT
\`;

    // Помощни функции
    function parseCSV(text) {
      return text.trim().split('\n').map(r=>r.split(','));
    }
    function parseElapsed(s) {
      const [h,m,sec]=s.split(':').map(Number);
      return h*3600+m*60+sec;
    }
    function formatElapsed(sec) {
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return \`\${String(h).padStart(2,'0')}:\${String(m).padStart(2,'0')}:\${String(s).padStart(2,'0')}\`;
    }

    // Глобално състояние
    let columns = [], dateCols = [], elapsedCols = [];
    let allData = [], isComparing=false, compareIdx=[];

    // Зареждане и инициализация
    \$(document).ready(function(){
      flatpickr('.date-picker',{dateFormat:'Y-m-d',allowInput:true});
      const rows = parseCSV(csvData);
      const header = rows.shift();
      const N = (header.length-4)/2;
      // Колони
      header.forEach((h,i)=>{
        const isDate = /date/i.test(h);
        const isElapsed = /elapsed/i.test(h);
        columns.push({name:h,hidden:false});
        if(isDate) dateCols.push(i);
        if(isElapsed) elapsedCols.push(i);
      });
      // Данни
      rows.forEach(r=>{
        let maxIdx=elapsedCols[0], maxVal=-1;
        r.forEach((v,i)=> {
          if(elapsedCols.includes(i) && v){
            const secs=parseElapsed(v);
            if(secs>maxVal){ maxVal=secs; maxIdx=i; }
          }
        });
        allData.push({values:r,hidden:false,maxIdx,diff:{}}); 
      });
      initToggles();
      renderTable();
      // Events
      \$('#search').on('input',filterData);
      \$('#apply-dates').click(filterData);
      \$('#compare-dates').click(doCompare);
      \$('#reset-all').click(resetAll);
      \$('#start-date, #end-date').change(storeCompareIdx);
    });

    function initToggles(){
      const ct=\$('#column-toggle-container').empty();
      columns.forEach((col,i)=>{
        const chk=\$('<input type="checkbox">').prop('checked',!col.hidden)
          .change(_=>{col.hidden=!chk.prop('checked');renderTable();});
        ct.append(\$('<label>').append(chk,document.createTextNode(col.name)));
      });
    }

    function renderTable(){
      const tbl=\$('#data-table');
      const thead=tbl.find('thead').empty().append('<tr>');
      const tbody=tbl.find('tbody').empty();
      // Header + Difference
      columns.forEach((c,i)=>!c.hidden&& thead.append(\`<th data-col="\${i}">\${c.name}</th>\`));
      thead.append('<th>Difference</th>');
      thead.find('th').click(function(){
        sortBy(+this.dataset.col);
      });
      // Body
      allData.forEach(r=>{
        if(r.hidden) return;
        const tr=\$('<tr>');
        columns.forEach((c,i)=> {
          if(c.hidden) return;
          const v=r.values[i];
          const td=\$('<td>').text(v);
          if(elapsedCols.includes(i)&&i===r.maxIdx) td.addClass('max');
          if(isComparing && r.diff[i]!=null){
            td.addClass(r.diff[i]>=0?'diff-positive':'diff-negative')
              .append(' '+(r.diff[i]>=0?'+':'')+r.diff[i]);
          }
          tr.append(td);
        });
        // difference col
        const dsum = elapsedCols.reduce((acc,i)=>acc+(r.diff[i]||0),0);
        tr.append(\`<td>\${formatElapsed(dsum)}</td>\`);
        tbody.append(tr);
      });
      // DataTable
      tbl.DataTable({destroy:true,paging:false,scrollX:true,searching:true,dom:'Bfrtip',buttons:['colvis'],order:[]});
    }

    function sortBy(col){
      allData.sort((a,b)=>{
        const A=a.values[col], B=b.values[col];
        const nA=parseFloat(A),nB=parseFloat(B);
        let cmp=0;
        if(!isNaN(nA)&&!isNaN(nB)){ cmp=nA-nB; }
        else { cmp=A.localeCompare(B); }
        return cmp;
      });
      renderTable();
    }

    function filterData(){
      const term=\$('#search').val().toLowerCase();
      const sD=\$('#start-date').val(), eD=\$('#end-date').val();
      allData.forEach(r=>{
        const bySearch=term? r.values.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term)) : true;
        const byDate=(sD||eD)? dateCols.some(i=>{
          const d=r.values[i]; if(!d) return false;
          const dd=d.split('T')[0];
          return (!sD||dd>=sD)&&(!eD||dd<=eD);
        }):true;
        r.hidden=!(bySearch&&byDate);
      });
      renderTable();
    }

    function storeCompareIdx(){
      const dval=this.value;
      if(!dval) return;
      const col=dateCols[0];
      const idx=allData.findIndex(r=>r.values[col].startsWith(dval));
      if(this.id==='start-date') compareIdx[0]=idx;
      else compareIdx[1]=idx;
    }

    function doCompare(){
      if(compareIdx.length<2||compareIdx[0]==null||compareIdx[1]==null){
        alert('Изберете две дати!');
        return;
      }
      allData.forEach(r=>{
        r.diff={};
        elapsedCols.forEach(i=>{
          const v1=parseElapsed(allData[compareIdx[0]].values[i]);
          const v2=parseElapsed(allData[compareIdx[1]].values[i]);
          r.diff[i]=v2-v1;
        });
      });
      isComparing=true;
      renderTable();
    }

    function resetAll(){
      \$('#search,#start-date,#end-date').val('');
      columns.forEach(c=>c.hidden=false);
      allData.forEach(r=>{r.hidden=false; r.diff={}}); 
      isComparing=false; compareIdx=[];
      initToggles();
      renderTable();
    }
  </script>
</body>
</html>
EOF

echo "✅ Генериран $OUT_HTML – отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Четем цялото CSV в една променлива (escape на backticks само)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    /* ...твоя CSS от примера... */
    .dataTables_scrollBody { overflow-x:auto!important; }
    td.max { background: var(--max-highlight) !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  <!-- ... твоя HTML за controls, toggles и т.н. ... -->
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ─── ВГРАДЕНО CSV ───────────────────────────────────────────────────────────
const csvData = \`
$CSV_CONTENT
\`;
// ──────────────────────────────────────────────────────────────────────────────

function parseCSV(text){
  return text.trim().split('\\n').map(r => r.split(','));
}

$(function(){
  const header = parseCSV(csvData).shift();
  const data   = parseCSV(csvData).slice(1);
  const N      = (header.length - 4) / 2;

  // … тук пълниш columns[], dateColumns[], elapsedColumns[] както преди …

  // Рендер на хедъра + Difference
  const thead = $('#data-table thead tr');
  header.forEach(h => thead.append('<th>' + h + '</th>'));
  thead.append('<th>Difference</th>');

  // Рендер на body
  data.forEach(row => {
    // … същата логика за изчисляване на maxIdx и diffStr …
    const tr = $('<tr>');
    // първите 4 поли
    row.slice(0,4).forEach(v => tr.append('<td>'+v+'</td>'));
    // date/elapsed двойки + highlight
    for(let j=0;j<N;j++){
      tr.append('<td>'+row[4+2*j]+'</td>');
      const cls = (j===maxIdx?'max':'');
      tr.append('<td class="'+cls+'">'+row[4+2*j+1]+'</td>');
    }
    tr.append('<td>'+diffStr+'</td>');
    $('#data-table tbody').append(tr);
  });

  // Инициализиране на DataTable
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging:   false,
    scrollX:  true,
    searching:true,
    buttons: ['colvis'],
    order:   [],
    columnDefs:[{ targets:[0], orderable:false }]
  });
});
</script>

</body>
</html>
EOF

echo "✅ Генериран $OUT – отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# Генерираме HTML с модерен дизайн и всички функционалности
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Report</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --primary-color: #4285f4;
    --secondary-color: #f1f3f4;
    --hover-color: #e8f0fe;
    --border-color: #dadce0;
    --text-color: #202124;
    --light-text: #5f6368;
    --max-highlight: #fff9c4;
    --diff-positive: #e6f4ea;
    --diff-negative: #fce8e6;
  }
  
  body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 20px;
    color: var(--text-color);
    background-color: #f8f9fa;
  }
  
  .container {
    max-width: 100%;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    padding: 20px;
  }
  
  h1 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 500;
  }
  
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    align-items: center;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--secondary-color);
    padding: 8px 12px;
    border-radius: 4px;
  }
  
  label {
    font-size: 14px;
    color: var(--light-text);
  }
  
  input, button, select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: inherit;
  }
  
  button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background-color: #3367d6;
  }
  
  #search {
    flex-grow: 1;
    min-width: 200px;
  }
  
  .table-container {
    overflow-x: auto;
    margin-top: 20px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }
  
  th {
    background-color: var(--secondary-color);
    color: var(--light-text);
    font-weight: 500;
    position: relative;
    cursor: pointer;
    user-select: none;
  }
  
  th:hover {
    background-color: var(--hover-color);
  }
  
  th.sort-asc::after {
    content: " ↑";
    color: var(--primary-color);
  }
  
  th.sort-desc::after {
    content: " ↓";
    color: var(--primary-color);
  }
  
  tr:hover {
    background-color: var(--hover-color);
  }
  
  .max {
    background-color: var(--max-highlight);
    font-weight: 500;
  }
  
  .column-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 15px;
  }
  
  .column-toggle label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    padding: 5px 8px;
    background: var(--secondary-color);
    border-radius: 4px;
  }
  
  .hidden {
    display: none !important;
  }
  
  .date-range {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .date-range input {
    width: 150px;
  }
  
  .diff-positive {
    background-color: var(--diff-positive);
  }
  
  .diff-negative {
    background-color: var(--diff-negative);
  }
  
  @media (max-width: 768px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
    
    #search {
      width: 100%;
    }
  }
</style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  
  <div class="controls">
    <input type="text" id="search" placeholder="Search across all columns...">
    
    <div class="control-group date-range">
      <label for="start-date">From:</label>
      <input type="text" id="start-date" class="date-picker" placeholder="Start date">
      <label for="end-date">To:</label>
      <input type="text" id="end-date" class="date-picker" placeholder="End date">
      <button id="apply-dates">Apply</button>
    </div>
    
    <button id="compare-dates">Compare Dates</button>
    <button id="reset-all">Reset All</button>
  </div>
  
  <div class="column-toggle" id="column-toggle-container">
    <!-- Column toggles will be inserted here by JavaScript -->
  </div>
  
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
// Глобални променливи за състоянието
let allData = [];
let columns = [];
let dateColumns = [];
let elapsedColumns = [];
let currentSort = { column: null, direction: 'asc' };
let isComparing = false;
let comparedDateIndices = [];

// Инициализация на календарите
flatpickr(".date-picker", {
  dateFormat: "Y-m-d",
  allowInput: true
});

// Зареждане на данните от CSV таблицата в HTML
function loadData() {
  const table = document.getElementById('data-table');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  // Изчистване на текущите данни
  thead.innerHTML = '';
  tbody.innerHTML = '';
  
  // Създаване на заглавния ред
  const headerRow = document.createElement('tr');
  columns.forEach((col, index) => {
    if (col.hidden) return;
    
    const th = document.createElement('th');
    th.textContent = col.name;
    th.dataset.columnIndex = index;
    th.addEventListener('click', () => sortData(index));
    
    if (currentSort.column === index) {
      th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  
  // Попълване на данните
  allData.forEach(row => {
    if (row.hidden) return;
    
    const tr = document.createElement('tr');
    columns.forEach((col, colIndex) => {
      if (col.hidden) return;
      
      const td = document.createElement('td');
      td.textContent = row.values[colIndex];
      
      // Маркиране на максималните стойности в Elapsed колоните
      if (elapsedColumns.includes(colIndex) && row.maxElapsedIndex === colIndex) {
        td.classList.add('max');
      }
      
      // Маркиране на разликите при сравнение на дати
      if (isComparing && row.diffValues && row.diffValues[colIndex] !== undefined) {
        const diff = row.diffValues[colIndex];
        if (diff > 0) {
          td.classList.add('diff-positive');
          td.textContent += ` (+${diff})`;
        } else if (diff < 0) {
          td.classList.add('diff-negative');
          td.textContent += ` (${diff})`;
        }
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// Функция за сортиране
function sortData(columnIndex) {
  if (currentSort.column === columnIndex) {
    // Промяна на посоката, ако вече сме сортирали по тази колона
    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
  } else {
    // Сортиране по нова колона във възходящ ред
    currentSort.column = columnIndex;
    currentSort.direction = 'asc';
  }
  
  allData.sort((a, b) => {
    const valA = a.values[columnIndex];
    const valB = b.values[columnIndex];
    
    // Опит за разпознаване на числа и дати
    const numA = parseFloat(valA);
    const numB = parseFloat(valB);
    const dateA = new Date(valA);
    const dateB = new Date(valB);
    
    let comparison = 0;
    
    if (!isNaN(numA) {
      // Числено сравнение
      comparison = numA - numB;
    } else if (dateA instanceof Date && !isNaN(dateA) {
      // Сравнение на дати
      comparison = dateA - dateB;
    } else {
      // Текстово сравнение
      comparison = valA.localeCompare(valB);
    }
    
    return currentSort.direction === 'asc' ? comparison : -comparison;
  });
  
  loadData();
}

// Филтриране на данните
function filterData() {
  const searchTerm = document.getElementById('search').value.toLowerCase();
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  
  allData.forEach(row => {
    let matchesSearch = true;
    let matchesDate = true;
    
    // Филтриране по търсене
    if (searchTerm) {
      matchesSearch = columns.some((col, index) => {
        if (col.hidden) return false;
        return row.values[index].toLowerCase().includes(searchTerm);
      });
    }
    
    // Филтриране по дати
    if (startDate || endDate) {
      matchesDate = dateColumns.some(dateCol => {
        const dateStr = row.values[dateCol];
        if (!dateStr) return false;
        
        const rowDate = new Date(dateStr);
        if (isNaN(rowDate)) return false;
        
        const compareDate = rowDate.toISOString().split('T')[0];
        
        if (startDate && endDate) {
          return compareDate >= startDate && compareDate <= endDate;
        } else if (startDate) {
          return compareDate >= startDate;
        } else if (endDate) {
          return compareDate <= endDate;
        }
        return true;
      });
    }
    
    row.hidden = !(matchesSearch && matchesDate);
  });
  
  loadData();
}

// Сравнение на дати
function compareDates() {
  if (comparedDateIndices.length < 2) {
    alert('Please select two different dates first by using the date filters.');
    return;
  }
  
  const [firstIndex, secondIndex] = comparedDateIndices;
  const firstRow = allData[firstIndex];
  const secondRow = allData[secondIndex];
  
  allData.forEach(row => {
    row.diffValues = [];
    
    columns.forEach((col, colIndex) => {
      if (elapsedColumns.includes(colIndex)) {
        // Изчисляване на разликата за Elapsed времето
        const time1 = parseElapsedTime(firstRow.values[colIndex]);
        const time2 = parseElapsedTime(secondRow.values[colIndex]);
        row.diffValues[colIndex] = time2 - time1;
      } else if (!isNaN(parseFloat(row.values[colIndex]))) {
        // Изчисляване на разликата за числови стойности
        const num1 = parseFloat(firstRow.values[colIndex]);
        const num2 = parseFloat(secondRow.values[colIndex]);
        row.diffValues[colIndex] = num2 - num1;
      }
    });
  });
  
  isComparing = true;
  loadData();
}

// Парсване на Elapsed време във секунди
function parseElapsedTime(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
  }
  return 0;
}

// Форматиране на секунди обратно във формат HH:MM:SS
function formatElapsedTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// Инициализация на колоните за скриване/показване
function initColumnToggles() {
  const container = document.getElementById('column-toggle-container');
  container.innerHTML = '';
  
  columns.forEach((col, index) => {
    const checkboxId = `col-toggle-${index}`;
    const label = document.createElement('label');
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.checked = !col.hidden;
    checkbox.addEventListener('change', () => {
      col.hidden = !checkbox.checked;
      loadData();
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(col.name));
    container.appendChild(label);
  });
}

// Зареждане на CSV данните
function parseCSV(csv) {
  const lines = csv.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  // Инициализиране на колоните
  columns = headers.map((header, index) => {
    const isDate = header.toLowerCase().includes('date');
    const isElapsed = header.toLowerCase().includes('elapsed');
    
    if (isDate) dateColumns.push(index);
    if (isElapsed) elapsedColumns.push(index);
    
    return {
      name: header,
      hidden: false,
      isDate,
      isElapsed
    };
  });
  
  // Парсване на редовете
  allData = lines.slice(1).map(line => {
    const values = line.split(',');
    let maxElapsedIndex = -1;
    let maxElapsed = -1;
    
    // Намиране на максималното Elapsed време
    elapsedColumns.forEach(colIndex => {
      if (values[colIndex]) {
        const seconds = parseElapsedTime(values[colIndex]);
        if (seconds > maxElapsed) {
          maxElapsed = seconds;
          maxElapsedIndex = colIndex;
        }
      }
    });
    
    return {
      values,
      hidden: false,
      maxElapsedIndex,
      diffValues: null
    };
  });
  
  // Инициализиране на UI елементите
  initColumnToggles();
  loadData();
}

// Зареждане на CSV файла
function loadCSV() {
  return fetch(window.location.href)
    .then(response => response.text())
    .then(csv => {
      // Премахване на BOM символа, ако има такъв
      if (csv.charCodeAt(0) === 0xFEFF) {
        csv = csv.substring(1);
      }
      parseCSV(csv);
    })
    .catch(error => {
      console.error('Error loading CSV:', error);
      alert('Error loading CSV data. Please check console for details.');
    });
}

// Инициализация на event listeners
function initEventListeners() {
  document.getElementById('search').addEventListener('input', filterData);
  document.getElementById('apply-dates').addEventListener('click', filterData);
  document.getElementById('compare-dates').addEventListener('click', compareDates);
  
  document.getElementById('reset-all').addEventListener('click', () => {
    // Нулиране на всички филтри
    document.getElementById('search').value = '';
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    
    // Нулиране на скритите колони
    columns.forEach(col => col.hidden = false);
    
    // Нулиране на сравнението
    isComparing = false;
    comparedDateIndices = [];
    
    // Нулиране на сортирането
    currentSort = { column: null, direction: 'asc' };
    
    // Нулиране на скриването на редове
    allData.forEach(row => row.hidden = false);
    
    // Презареждане на UI
    initColumnToggles();
    filterData();
  });
  
  // Запазване на индексите на избраните дати
  document.getElementById('start-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // Намиране на първия ред, който съвпада с избраната дата
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[0] = index;
    }
  });
  
  document.getElementById('end-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // Намиране на първия ред, който съвпада с избраната дата
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[1] = index;
    }
  });
}

// Стартиране на приложението при зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  initEventListeners();
  loadCSV();
});
</script>
</body>
</html>
EOF

# Вмъкване на CSV данните директно в HTML като JavaScript променлива
echo "<script>" >> "$OUT"
echo "// CSV data" >> "$OUT"
echo "const csvData = \`" >> "$OUT"
cat "$CSV" >> "$OUT"
echo "\`;" >> "$OUT"
echo "// End of CSV data" >> "$OUT"
echo "</script>" >> "$OUT"

echo "✅ Готово! Отвори '$OUT' в браузър."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Записваме началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси…">
EOF

# 2) Генерираме <table> с оцветяване на максимума и кликаеми <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # правим колоната сортиращ бутон
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, маркираме class="max" само на maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за търсене и сортиране
cat >>"$OUT" <<'EOF'
<script>
// Живо филтриране:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// Сортиране при клик на заглавие:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // Определяме посока (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // Сортиране
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // Ребилд на tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // Запомняме състоянието
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    .dataTables_wrapper .dataTables_scroll { overflow-x: auto; }
    th { background: #f0f0f0; white-space: nowrap; }
    td { white-space: nowrap; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x:auto;">
      <table id="data-table" class="table table-striped table-bordered" style="width:100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# Вкарваме CSV съдържанието
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th>${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    scrollX: true,
    paging: false,
    ordering: false,
    info: false
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX:true, paging:false, ordering:false, info:false, buttons:['colvis'] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    paging: false,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, paging: false, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    .dataTables_wrapper .dataTables_scroll { overflow: auto; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <div class="table-responsive">
      <table id="data-table" class="table table-striped table-bordered w-100">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: false,
    paging: false,
    scrollX: true,
    order: [],
    columnDefs: [{ targets:[0], orderable:false }]
  });

  table.columns().every(function(){
    const col = this;
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ 
        dom:'Bfrtip', 
        buttons:['colvis'], 
        responsive:false, 
        paging:false, 
        scrollX:true, 
        order:[] 
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# Escape backticks in CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Start HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# CSV content
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# JavaScript end
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  // Header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Body
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    paging: false,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  // Филтри
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Дата филтър
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        paging: false,
        order: []
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."




CSV_ESCAPED=$(sed \
  -e 's/\\/\\\\/g' \
  -e 's/"/\\"/g' \
  -e 's/`/\\`/g' \
  -e 's/<\/script>/<\/scr"+"ipt>/g' \
  "$CSV")



#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# Escape само backticks от CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Начало на HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    th button { float:right; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# Инжектирай CSV съдържание
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# Финална HTML част с JS логика
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      const time = row[4+2*j+1];
      let [h,m,s] = time.split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    paging: false
  });

  table.columns().every(function(){
    const col = this, idx = col.index();
    const inp = $('<input>').attr('placeholder','filter')
      .addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    const btn = $('<button class="btn btn-sm btn-outline-secondary ml-1">Hide</button>');
    btn.on('click',()=>{
      const visible = table.column(idx).visible();
      table.column(idx).visible(!visible);
      btn.text(visible ? 'Show' : 'Hide');
    });
    $(col.header()).empty().append(inp).append(btn);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);

    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    const sel = dates.map((d,i)=>({date: d, index: i}))
                     .filter(d=>!min||d.date>=min)
                     .filter(d=>!max||d.date<=max);
    $('#table-header th:last-child:contains("Difference")').remove();
    $('#table-body tr').each((_,tr)=>$(tr).find('td:last').remove());

    if(sel.length === 2){
      let i1 = sel[0].index, i2 = sel[1].index;
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2];
        let delta = d2 - d1;
        let sign = delta < 0 ? '-' : '';
        let abs = Math.abs(delta);
        let hh = Math.floor(abs/3600), mm = Math.floor((abs%3600)/60), ss = abs%60;
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        order: [],
        paging: false
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

# 1) Проверка
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът ‘$CSV_INPUT’ не е намерен в $(pwd)" >&2
  exit 1
fi

# 2) Прочитаме header и data
IFS= read -r header_line < "$CSV_INPUT"
IFS=',' read -r -a header_arr <<< "$header_line"
mapfile -t data_lines < <(tail -n +2 "$CSV_INPUT")

# 3) Писане на статичната част (HEAD) – single-quoted so nothing expands
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Вграден CSV → JS масиви
HTML_HEAD

# 4) Вмъкване на header[] масива
echo "    const header = [" >>"$OUT_HTML"
for i in "${!header_arr[@]}"; do
  # escape двойни кавички в стойността
  col=${header_arr[i]//\"/\\\"}
  if (( i < ${#header_arr[@]}-1 )); then
    printf '      "%s",\n' "$col" >>"$OUT_HTML"
  else
    printf '      "%s"\n' "$col" >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 5) Вмъкване на data[] масива
echo "    const data = [" >>"$OUT_HTML"
for idx in "${!data_lines[@]}"; do
  line=${data_lines[idx]}
  # split by comma
  IFS=',' read -r -a cells <<< "$line"
  printf '      [' >>"$OUT_HTML"
  for j in "${!cells[@]}"; do
    cell=${cells[j]//\"/\\\"}
    if (( j < ${#cells[@]}-1 )); then
      printf "\"%s\"," "$cell" >>"$OUT_HTML"
    else
      printf "\"%s\"" "$cell" >>"$OUT_HTML"
    fi
  done
  if (( idx < ${#data_lines[@]}-1 )); then
    printf '],\n' >>"$OUT_HTML"
  else
    printf ']\n' >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 6) Писане на статичната част (TAIL) – също single-quoted
cat >>"$OUT_HTML" <<'HTML_TAIL'
    // Document ready → render таблицата
    $(document).ready(function(){
      const N = (header.length - 4) / 2; // брой Date/Elapsed двойки

      // Рендер на хедъра + колона Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендер на body и highlight max
      data.forEach(row => {
        // парсиме elapsed в секунди и мерим max
        const secs = [], tr = $('<tr>');
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = (j === maxIdx ? 'max' : '');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = последно − първо
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? '-' : '';
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // Инициализация на DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,      // без страници
        scrollX:  true,       // хоризонтално скролване
        searching:true,       // глобална търсачка
        buttons: ['colvis'],  // бутон hide/show
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих CSV файла '$CSV' в $(pwd)" >&2
  exit 1
fi

# Прочитаме header (първи ред)
IFS= read -r header_line < "$CSV"
IFS=',' read -r -a header_arr <<< "$header_line"

# Прочитаме data (всичко след първия ред)
data_lines=()
while IFS= read -r line; do
  data_lines+=("$line")
done < <(tail -n +2 "$CSV")

# Функция за превръщане на CSV-ред в JS-стринг-арей
to_js_array(){
  local line="$1"
  IFS=',' read -r -a cells <<< "$line"
  printf '['
  local first=1
  for cell in "${cells[@]}"; do
    # ескейпваме евентуални двойни кавички в cell
    esc=${cell//\"/\\\"}
    if (( first )); then
      printf "\"%s\"" "$esc"
      first=0
    else
      printf ",\"%s\"" "$esc"
    fi
  done
  printf ']'
}

# ГЕНЕРИРАМЕ HTML
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Header и data вградени като JS масиви
    const header = [
EOF

# Вмъкваме header
first=1
for col in "${header_arr[@]}"; do
  esc=${col//\"/\\\"}
  if (( first )); then
    printf '      "%s"\n' "$esc" >>"$OUT"
    first=0
  else
    printf '     ,"%s"\n' "$esc" >>"$OUT"
  fi
done

cat >>"$OUT" <<EOF
    ];

    const data = [
EOF

# Вмъкваме data ред по ред
for i in "${!data_lines[@]}"; do
  line=${data_lines[i]}
  jsarr=$(to_js_array "$line")
  if (( i < ${#data_lines[@]} - 1 )); then
    printf '      %s,\n' "$jsarr" >>"$OUT"
  else
    printf '      %s\n' "$jsarr" >>"$OUT"
  fi
done

cat >>"$OUT" <<'EOF'
    ];

    $(document).ready(function(){
      const N = (header.length - 4)/2; // брой Date/Elapsed двойки

      // Рисуваме header + добавяме Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рисуваме body + highlight max
      data.forEach(row => {
        // парсиме Elapsed в секунди и търсим max
        const secs = [], tr = $('<tr>'), LENGTH=N;
        let maxSec=-1, maxIdx=0;
        for(let j=0;j<LENGTH;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j; }
        }
        // STATUS..JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for(let j=0;j<LENGTH;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls=(j===maxIdx?'max':'');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0],
              sign = diff<0?'-':'',
              sabs = Math.abs(diff),
              h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60,
              dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);
        $('#table-body').append(tr);
      });

      // Инициализираме DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,   // без страници
        scrollX:  true,    // хоризонтално скролване
        searching:true,    // глобална търсачка
        buttons: ['colvis'],
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
EOF

echo "✅ Генериран: $OUT (от $CSV)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# 1) Проверка за CSV-то
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в: $(pwd)" >&2
  exit 1
fi

# 2) Експейпваме само backticks (ако ги има)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 3) Писане на началото на HTML-а
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* хоризонтално скролване */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS Libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ——— ВГРАДЕНО CSV —————————————————————————————
    const rawCSV = `
HTML_START

# 4) Вкарваме съдържанието на CSV-то
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 5) Писане на останалата част от HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // колко date/elapsed двойки

      // Рендер: хедър + разлика
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендер: body + highlight max
      data.forEach(row => {
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // Инициализация на DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // без страници
        scrollX: true,      // хоризонтално скролване
        searching: true,    // глобална търсачка
        buttons: ['colvis'],// бутон hide/show колони
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT)"





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в: $(pwd)" >&2
  exit 1
fi

# Екранираме само backticks, останалото оставяме непроменено
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) Писане на началото на HTML-а (single-quoted here-doc за да не разширява $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* хоризонтално скролване на таблицата */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ——— ВГРАДЕНО CSV —————————————————————————————
    const rawCSV = `
HTML_START

# 2) Добавяме съдържанието на CSV-то
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) Писане на останалата част от HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // брой Date/Elapsed двойки

      // Рендиране на хедъра + разлика
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // Рендиране на body + highlight max
      data.forEach(row => {
        // изчисляваме секунди и намираме максимума
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }

        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed двойки
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // Инициализация на DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // без страници
        scrollX: true,      // хоризонтално скролване
        searching: true,    // глобална търсачка
        buttons: ['colvis'],// бутон hide/show колони
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "✅ Генериран: $OUT_HTML (от $CSV_INPUT). Отвори го директно в браузър."








#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# Диагностика
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "❌ CSV файлът “$CSV_INPUT” не е намерен в:" >&2
  echo "   $(pwd)" >&2
  exit 1
fi

# Екранираме само backticks (ако ги има в CSV-то)
ESCAPED_CSV=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) Печатаме първата (статична) част от HTML-а
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css">
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ВГРАДЕНО CSV
    const rawCSV = `
HTML_HEAD

# 2) Вкарваме съдържанието на CSV-то
printf '%s\n' "$ESCAPED_CSV" >> "$OUT_HTML"

# 3) Печатаме останалата (статична) част от HTML + JS
cat >>"$OUT_HTML" <<'HTML_TAIL'
`;
    function parseCSV(txt) {
      return txt.trim().split("\n").map(r=>r.split(","));
    }
    $(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4)/2;  // колко date/elapsed двойки

      // header + Difference
      header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // body
      data.forEach(row=>{
        // изчисляваме секунди и най-голямо Elapsed
        let secs = [], maxSec=-1, maxIdx=0;
        for(let j=0;j<N;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(":").map(Number);
          const s = hh*3600+mm*60+ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j }
        }
        const tr = $("<tr>");
        // първи 4 колони
        row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
        // date/elapsed двойки
        for(let j=0;j<N;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = j===maxIdx?"max":"";
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff<0?"-":"";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // Инициализираме DataTable без paging + бутон за hide/show
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging: false,
        searching: true,
        buttons: ['colvis'],
        responsive: true,
        order: []
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "✅ Готово – генериран $OUT_HTML (от $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Ако подадеш път към CSV, го ползваме, иначе – report.csv до скрипта
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CSV_INPUT="${1:-report.csv}"
# Ако пътът към CSV не е абсолютен, го допълваме с директорията на скрипта
if [[ "$CSV_INPUT" != /* ]]; then
  CSV_PATH="$SCRIPT_DIR/$CSV_INPUT"
else
  CSV_PATH="$CSV_INPUT"
fi

# Изходният HTML
OUT_HTML="${2:-interactive_report.html}"

# Диагностика: има ли CSV
if [[ ! -f "$CSV_PATH" ]]; then
  echo "❌ Не мога да открия CSV файла:" >&2
  echo "   Изглежда, че търся тук: $CSV_PATH" >&2
  echo "   Текуща директория: $(pwd)"   >&2
  echo "   Съдържание на $SCRIPT_DIR:"   >&2
  ls -1 "$SCRIPT_DIR" >&2 || true
  exit 1
fi

# Екранираме само backticks (останалият JS/HTML код не се пипа)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_PATH")

# 1) Първа част на HTML (single-quoted за да не се разширяват $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ——— ВГРАДЕНО CSV —————————————————————————————
const rawCSV = `
HTML_START

# 2) Вкарваме съдържанието на report.csv
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) Останалата част от HTML+JS
cat >>"$OUT_HTML" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;  // брой Date/Elapsed двойки

  // header + Difference
  header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // body
  data.forEach(row=>{
    let secsRow=[], maxSec=-1, maxIdx=0;
    for(let j=0;j<N;j++){
      let [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0;j<N;j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = j===maxIdx?'max':'';
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let diff = secsRow[secsRow.length-1] - secsRow[0],
        sign = diff<0?'-':'',
        s    = Math.abs(diff),
        h2   = Math.floor(s/3600), m2=Math.floor((s%3600)/60), s2=s%60,
        str  = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
    tr.append(`<td>${str}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // DataTable без paging
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Успешно: генериран $OUT_HTML (чете $CSV_PATH)"





#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT="\${2:-interactive_report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "❌ Не открих \$CSV" >&2
  exit 1
fi

# Експейпваме само backticks
CSV_ESCAPED=\$(sed 's/`/\\\\`/g' "\$CSV")

# 1) HTML старт (нищо не се разширява тук, заради single-quoted here-doc)
cat >"\$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <!-- Bootstrap -->
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

<script>
// ——— ВГРАДЕНО CSV като многострочен string —————————————————
const rawCSV = \`
HTML_START

# 2) Вкарваме самото съдържание на CSV
printf '%s\n' "\$CSV_ESCAPED" >> "\$OUT"

# 3) Останалата част от HTML+JS (пак без разширявания)
cat >>"\$OUT" <<'HTML_END'
\`;
function parseCSV(text){
  return text.trim().split("\\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  // брой Date/Elapsed двойки
  const N      = (header.length - 4) / 2;

  // --- Рисуваме header + добавяме Difference ---
  header.forEach(h => {
    $('#table-header').append(`<th>\${h}</th>`);
  });
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // --- Попълваме body + highlight максимума ---
  data.forEach(row => {
    // Парсваме секунди и търсим max
    let secsRow = [], maxSec=-1, maxIdx=0;
    for(let j=0; j<N; j++){
      let [hh,mm,ss] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec=sec; maxIdx=j; }
    }

    // Създаваме ред
    const tr = $('<tr>');
    // STATUS, STAGE, BATCH, JOB.NAME
    row.slice(0,4).forEach(cell => tr.append(`<td>\${cell}</td>`));
    // Date/Elapsed двойки
    for(let j=0; j<N; j++){
      tr.append(`<td>\${row[4 + 2*j]}</td>`);
      let cls = (j===maxIdx ? 'max' : '');
      tr.append(`<td class="\${cls}">\${row[4 + 2*j + 1]}</td>`);
    }
    // Разлика = last - first
    let diffSec = secsRow[secsRow.length-1] - secsRow[0],
        sign    = diffSec<0 ? '-' : '',
        s       = Math.abs(diffSec),
        hh2     = Math.floor(s/3600),
        mm2     = Math.floor((s%3600)/60),
        ss2     = s%60,
        diffStr = `${sign}${String(hh2).padStart(2,'0')}:${String(mm2).padStart(2,'0')}:${String(ss2).padStart(2,'0')}`;
    tr.append(`<td>\${diffStr}</td>`);

    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // --- Инициализираме DataTable без страници и с бутон за hide/show ---
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово! Отвори '\$OUT' в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "❌ Не открих $CSV" >&2
  exit 1
fi

# 1) Прочитаме CSV и escape-аме само backticks
#    (останалите $ нямат значение, защото тук само
#     ще го inserтим)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) Първа част от HTML (без да се разширяват никакви $)
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
// ——— ВГРАДЕНО CSV ————————————————————————————————
const rawCSV = `
HTML_START

# 3) Инжектираме самото съдържание на report.csv
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# 4) Останалата част от HTML + JS logic
cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2; // двойките Date/Elapsed

  // Render header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Render body + highlight max
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    // STATUS,STAGE,BATCH,JOB.NAME
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    // Date/Elapsed pairs
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    // Average
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // Init DataTables
  const table = $('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });
  // Column filters
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Date-range filter + Difference
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ dom:'Bfrtip',buttons:['colvis'],responsive:true,order:[] });
    }
  }
  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "✅ Готово – генерирано $OUT (от $CSV). Отвори го директно в браузър."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

# 1) Прочитаме CSV и го екранираме за backticks
if [ ! -f "$CSV" ]; then
  echo "Не открих $CSV" >&2
  exit 1
fi
# Slurp whole file, избягваме backtick „`“
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) Генерираме HTML-а
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
    th { cursor: pointer; background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
// ——— ВГРАДЕНО CSV —————————————————————————————————————————
const rawCSV = \`
${CSV_ESCAPED}
\`;
// ————————————————————————————————————————————————————————

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

\$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2; // броят двойки Date/Elapsed

  // Рисуваме header
  header.forEach((h,i)=>{
    \$('#table-header').append(
      `<th data-col="\${i}">\${h}</th>`
    );
  });

  const secsData = [];

  // Попълваме body
  data.forEach((row,ridx)=>{
    const tr = \$('<tr>');
    const secsRow = [];
    let maxSec = -1, maxIdx = -1;

    // изчисляваме секунди и намираме max
    for(let j=0;j<N;j++){
      const val = row[4+2*j+1];
      const [h,m,s] = val.split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }

    // STATUS..JOB.NAME
    for(let c=0;c<4;c++){
      tr.append(`<td>\${row[c]}</td>`);
    }
    // Date/Elapsed
    for(let j=0;j<N;j++){
      tr.append(`<td>\${row[4+2*j]}</td>`);
      const cls = j===maxIdx ? 'max' : '';
      tr.append(`<td class="\${cls}">\${row[4+2*j+1]}</td>`);
    }
    // AVERAGE
    const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
    const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

    secsData.push(secsRow);
    \$('#table-body').append(tr);
  });

  // Init DataTable
  const table = \$('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });

  // Column filters
  table.columns().every(function(){
    const col=this;
    const idx=col.index();
    const inp=\$('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    \$(col.header()).empty().append(inp);
  });

  // Date-range filter
  function applyDateFilter(){
    const min=\$('#min-date').val();
    const max=\$('#max-date').val();
    const dates=header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      const show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    // ако точно 2 дати – Difference
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !table.column(':contains("Difference")').nodes().length){
      const i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      table.column.adjust().draw(false);
      \$('#table-header').append('<th>Difference</th>');
      \$('#table-body tr').each((ri,tr)=>{
        const d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        const s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        const sign=delta<0?'-':'';
        \$(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  \$('#clear-dates').on('click',()=>{
    \$('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
  </script>
</body>
</html>
EOF

echo "✅ Генерирано: $OUT (от $CSV). Отвори в браузър — вече работи без fetch!"







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />

  <!-- DataTables + Buttons + Responsive -->
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />

  <!-- Flatpickr за календар -->
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />

  <style>
    /* Жълто highlight за max */
    td.max { background-color: #ffeb3b !important; }
    /* Малко padding на date-range полето */
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <!-- Date range pickers -->
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>От дата:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>До дата:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">Изчисти филтъра</button>
      </div>
    </div>

    <!-- Table -->
    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
  // 1) Зареждаме CSV
  async function loadCSV(path) {
    const resp = await fetch(path);
    const text = await resp.text();
    return text.trim().split('\n').map(r => r.split(','));
  }

  $(document).ready(async function(){
    const data = await loadCSV('${CSV}');
    const header = data.shift();
    const N = (header.length - 5) / 2; // броят двойки Date/Elapsed (после има AVERAGE)

    // Рисуваме header
    header.forEach((h,i) => {
      $('#table-header').append(
        `<th data-col="\${i}" class="text-nowrap">${h}</th>`
      );
    });

    // Попълваме body и изчисляваме secsData
    const secsData = [];
    data.forEach((row, ridx) => {
      const tr = $('<tr>');
      const secsRow = [];

      // изолираме Elapsed колони (index: 5,7,9,...)
      let maxSec = -1, maxIdx = -1;
      for(let j=0; j<N; j++){
        const val = row[4 + 2*j + 1];
        const [h,m,s] = val.split(':').map(Number);
        const sec = h*3600 + m*60 + s;
        secsRow.push(sec);
        if(sec > maxSec){ maxSec=sec; maxIdx=j; }
      }

      // STATUS, STAGE, BATCH, JOB.NAME (0..3)
      for(let c=0; c<4; c++){
        tr.append(`<td>\${row[c]}</td>`);
      }
      // Date/Elapsed двойки
      for(let j=0; j<N; j++){
        tr.append(`<td>\${row[4 + 2*j]}</td>`);
        const cls = (j===maxIdx ? 'max' : '');
        tr.append(`<td class="\${cls}">\${row[4 + 2*j +1]}</td>`);
      }
      // AVERAGE
      const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
      const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
      tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

      secsData.push(secsRow);
      $('#table-body').append(tr);
    });

    // Инициализираме DataTable
    const table = $('#data-table').DataTable({
      dom: 'Bfrtip',
      buttons: [ 'colvis' ],
      responsive: true,
      order: [],
      columnDefs: [{ targets: [0], orderable: false }]
    });

    // Колонни филтри
    table.columns().every(function(){
      const col = this;
      const idx = col.index();
      const inp = $('<input>')
        .attr('placeholder','filter')
        .addClass('form-control form-control-sm')
        .on('keyup change clear', ()=>col.search(inp.val()).draw());
      $(col.header()).empty().append(inp);
    });

    // Date range филтър
    function applyDateFilter() {
      const min = $('#min-date').val();
      const max = $('#max-date').val();
      const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
      dates.forEach((d,i)=>{
        const show = (!min||d>=min) && (!max||d<=max);
        table.column(4+2*i).visible(show);
        table.column(4+2*i+1).visible(show);
      });

      // точно две дати => разлика
      const selected = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
      if(selected.length===2 && !table.column(':contains("Difference")').nodes().length) {
        const i1 = dates.indexOf(selected[0]);
        const i2 = dates.indexOf(selected[1]);
        // добавяме колона Difference
        table.column.adjust().draw(false);
        $('#table-header').append('<th>Difference</th>');
        $('#table-body tr').each((ri,tr)=>{
          const sec1 = secsData[ri][i1], sec2 = secsData[ri][i2];
          const dsec = sec2 - sec1, s = Math.abs(dsec);
          const hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60), ss = s%60;
          const sign = dsec<0?'-':'';
          $(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
        });
      }
    }

    // flatpickr за date inputs
    flatpickr(".flatpickr", { dateFormat: "Y-m-d", onChange: applyDateFilter });
    $('#clear-dates').on('click', ()=>{
      $('#min-date,#max-date').val('');
      applyDateFilter();
    });
  });
  </script>
</body>
</html>
EOF

echo "✅ Генерирано: $OUT (чете $CSV). Отвори го в браузър."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Записваме началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси…">
EOF

# 2) Генерираме <table> с оцветяване на максимума и кликаеми <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # правим колоната сортиращ бутон
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, маркираме class="max" само на maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за търсене и сортиране
cat >>"$OUT" <<'EOF'
<script>
// Живо филтриране:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// Сортиране при клик на заглавие:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // Определяме посока (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // Сортиране
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // Ребилд на tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // Запомняме състоянието
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) Пишем началото на HTML + стилове + търсачка
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="Търси в таблицата…">
EOF

# 2) Генерираме самата <table> от CSV, като оцветяваме max Elapsed на ред
awk -F, '
BEGIN {
  OFS="";
  print "<table>";
}
NR==1 {
  # header
  print "<tr>";
  for(i=1;i<=NF;i++){
    header[i]=$i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    print "<th>"$i"</th>";
  }
  print "</tr>";
  next;
}
{
  # намираме max сред Elapsed колоните
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600+T[2]*60+T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # отпечатваме реда, като само при maxcol добавяме class="max"
  print "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    print "<td" cls ">" , $i , "</td>";
  }
  print "</tr>";
}
END {
  print "</table>";
}' "$CSV" >> "$OUT"

# 3) Добавяме JS за живото филтриране при писане в полето #search
cat >>"$OUT" <<'EOF'
<script>
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("table tr").forEach(function(row, i) {
    if(i === 0) return; // skip header
    var text = row.textContent.toLowerCase();
    row.style.display = text.includes(filter) ? "" : "none";
  });
});
</script>
</body>
</html>
EOF

echo "✅ Готово! Отвори '$OUT' в браузър, за да видиш търсачката и оцветения максимум."




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

awk -F, '
BEGIN {
  OFS=""
  # Начало на HTML-а и стилистика
  print "<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><style>"
  print "table, th, td { border: 1px solid #ccc; border-collapse: collapse; }"
  print "th, td { padding: 4px 8px; }"
  print ".max { background-color: #ffeb3b; }"
  print "</style></head><body><table>"
}
NR==1 {
  # Хедър-ред: намираме индексите на Elapsed колоните
  printf "<tr>"
  for(i=1;i<=NF;i++){
    header[i]=$i
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    printf "<th>%s</th>", $i
  }
  print "</tr>"
  next
}
{
  # За всеки ред намираме коя от Elapsed колоните е максимална
  maxsec = -1; maxcol = 0
  for(j=1;j<=ecount;j++){
    idx = elapsed_idx[j]
    split($idx, T, ":")
    sec = T[1]*3600 + T[2]*60 + T[3]
    if(sec > maxsec){
      maxsec = sec
      maxcol = idx
    }
  }
  # Отпечатваме реда, като cell i=maxcol получава клас="max"
  printf "<tr>"
  for(i=1;i<=NF;i++){
    if(i==maxcol)
      printf "<td class=\"max\">%s</td>", $i
    else
      printf "<td>%s</td>", $i
  }
  print "</tr>"
}
END {
  print "</table></body></html>"
}' "$CSV" > "$OUT"

echo "✅ Готово! Отвори $OUT в браузър, за да видиш оцветените максимуми."






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """Превръща 'HH:MM:SS' в секунди."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- Настройка на директория и брой дни назад ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# Смяна на работната директория
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"Не мога да вляза в директория '{files_dir}': {e}")

# --- Вземаме последните N файла JT* по дата на промяна ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files     = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("Няма намерени файлове JT* в текущата папка.")

# --- Парсваме всеки файл и пълним data[key][idx] ---
data  = {}                           # data[(stage,batch,job)] = { idx0: {...}, idx1: {...}, ... }
dates = [None]*len(files)            # dates[i] = дата от файл i

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date              = parts[3]
            elapsed           = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # Запаметяваме датата за този файл
    if dates[idx] is None:
        dates[idx] = date

# --- Писане на CSV на stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")

# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
header.append("AVERAGE")
out.writerow(header)

# За всеки JOB ключ генерираме по един ред
for key in sorted(data.keys()):
    rec = []
    d   = data[key]
    # STATUS: сравняваме първо (idx=0) и последно (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "↑"
    elif sN < s1: status = "↓"
    else:          status = "="

    # Първите 4 полета
    rec = [status, *key]

    # Списък за всички secs, за смятане на средно
    secs_list = []

    # По двойки Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", ""]

    # Изчисляваме AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh  = avg // 3600
        mm  = (avg % 3600) // 60
        ss  = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out.writerow(rec)






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """Превръща 'HH:MM:SS' в секунди."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- Настройка на директория и брой дни назад ---
# Ако има аргументи, проверяваме дали първият е директория:
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# Сменяме работната директория
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"Не мога да вляза в директория '{files_dir}': {e}")

# --- Събираме последните N файла JT* по време на промяна ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("Няма намерени файлове JT* в текущата папка.")

# --- Парсиме всеки ред и градим структурата data[key][idx] ---
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date    = parts[3]
            elapsed = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # Запазваме датата на idx-тия файл
    if dates[idx] is None:
        dates[idx] = date

# --- Пишем CSV на stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")
# Заглавен ред
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
out.writerow(header)

# За всеки job (сортираме по STAGE,BATCH,JOB)
for key in sorted(data.keys()):
    rec = []
    d = data[key]
    # STATUS = ↑ ако последният e по-бавен, ↓ ако последният e е по-бърз, = ако еднакви
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "↑"
    elif sN < s1: status = "↓"
    else:          status = "="

    rec = [status, *key]
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec += [info["date"], info["elapsed"]]
        else:
            rec += ["", ""]
    out.writerow(rec)





#!/usr/bin/env bash
set -euo pipefail

# Брой файла назад (по подразбиране 31)
N=${1:-31}

# Вземаме последните N файла (по modification time)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")
if [ "${#files[@]}" -lt 1 ]; then
  echo "Няма намерени JT* файлове."
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS=","
    # Заглавен ред
    printf "STATUS,STAGE,BATCH,JOB.NAME"
    for(i=1;i<=N;i++){
      printf ",Date%d,Elapsed%d", i, i
    }
    print ""
    idx=0
  }
  # За всеки файл увеличаваме idx
  FNR==1 { idx++ }
  {
    # ключ за JOB
    key = $1 SUBSEP $2 SUBSEP $3
    if (!(key in seen)) {
      seen[key]=1
      keys[++K]=key
    }
    # запомняме датата за този файл (една и съща per файл)
    if (!(idx in dates)) {
      dates[idx] = $4
    }
    # Elapsed и в секунди
    elapsed[key,idx] = $8
    split($8, T, ":")
    secs[key,idx]    = T[1]*3600 + T[2]*60 + T[3]
  }
  END {
    # за всеки JOB ключ
    for(j=1;j<=K;j++){
      key = keys[j]
      # статус: сравняваме първи vs последен ден
      s1 = (key,1 in secs ? secs[key,1] : 0)
      sN = (key,N in secs ? secs[key,N] : 0)
      status = (sN > s1 ? "↑" : (sN < s1 ? "↓" : "="))
      # разбиваме ключа обратно на STAGE,BATCH,JOB.NAME
      split(key, F, SUBSEP)
      printf "%s,%s,%s,%s", status, F[1], F[2], F[3]
      # и за всеки ден Datei, Elapsedi
      for(i=1;i<=N;i++){
        d = (i in dates ? dates[i] : "")
        e = ((key,i) in elapsed ? elapsed[key,i] : "")
        printf ",%s,%s", d, e
      }
      print ""
    }
  }
' "${files[@]}"







#!/usr/bin/env bash
set -euo pipefail

# Брой дни назад (по подразбиране 31; можеш да подадеш друго число като първи аргумент)
N=${1:-31}

# Вземаме последните N файла по modification time
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -eq 0 ]; then
  echo "Няма намерени файлове JT*"
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS = ",";
    idx = 0;
  }
  # Всеки път, когато започва нов файл, вдигаме брояча
  FNR==1 { idx++; }
  {
    # Строим ключа от BATCH.STAGE,BATCH,JOB.NAME
    key = $1 FS $2 FS $3;
    # Пази списък с уникални ключове за крайното обхождане
    if (!(key in seen)) {
      seen[key]=1;
      keys[++K]=key;
    }
    # Запиши датата за този файл (файлът съдържа същата дата на всеки ред)
    if (!(idx in dates)) {
      dates[idx] = $4;
    }
    # Запази elapsed и секунди
    elapsed[key","idx] = $8;
    split($8, T, ":");
    secs[key","idx] = T[1]*3600 + T[2]*60 + T[3];
  }
  END {
    # 1) Заглавен ред
    printf "BATCH.STAGE,BATCH,JOB.NAME";
    for (i=1; i<=N; i++) {
      printf ",Date%d,Elapsed%d", i, i;
    }
    print "";

    # 2) За всеки ключ – изписваме ред
    for (r=1; r<=K; r++) {
      key = keys[r];
      split(key, F, FS);
      # първите три полета
      printf "%s,%s,%s", F[1], F[2], F[3];
      # след това за всеки от N-те дни
      for (i=1; i<=N; i++) {
        d = dates[i];
        e = elapsed[key","i] ? elapsed[key","i] : "";
        arrow = "";
        if (i>1 && e!="") {
          prev = secs[key","i-1];
          curr = secs[key","i];
          if (curr > prev)   arrow = "↑";  # забавяне
          else if (curr < prev) arrow = "↓";  # ускояване
        }
        printf ",%s,%s%s", d, arrow, e;
      }
      print "";
    }
  }
' "${files[@]}"






#!/usr/bin/env bash
set -euo pipefail

# ако подадеш един аргумент, това е броят дни назад; иначе – 31
N=${1:-31}

# 1) събираме последните N файла по modification time (ls -1tr стартира старо->ново)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -lt 2 ]; then
  echo "Няма достатъчно файлове в JT* (трябват поне 2 от последните $N)."
  exit 1
fi

# Печатаме header само веднъж
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# 2) за всеки два поредни файла – старият и следващия
for ((i=1; i<${#files[@]}; i++)); do
  f1=${files[i-1]}
  f2=${files[i]}

  # стартираме awk за сравнение и филтриране
  awk -F, -v OFS=, '
    FNR==NR {
      # четем file1
      key            = $1 FS $2 FS $3
      date1[key]     = $4
      elapsed1[key]  = $8
      split($8, t1, ":")
      secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
      next
    }
    {
      # четем file2
      key            = $1 FS $2 FS $3
      d2             = $4
      e2             = $8
      split(e2, t2, ":")
      secs2          = t2[1]*3600 + t2[2]*60 + t2[3]

      # delta = secs1 - secs2 (в полза на date1)
      delta          = (key in secs1 ? secs1[key] : 0) - secs2

      # печатаме само ако secs1 > secs2 (т.е. date1 е по-бавно)
      if (secs1[key] > secs2) {
        # форматираме Diff като HH:MM:SS (положително число)
        hh   = int(delta/3600)
        mm   = int((delta%3600)/60)
        ss   = delta % 60
        diff = sprintf("%02d:%02d:%02d", hh, mm, ss)

        # стрелката винаги ↑ (date1 е по-бавно)
        arrow = "↑"

        # отпечатваме:
        #   arrow+stage, batch, job.name,
        #   date1, elapsed1,
        #   date2, elapsed2,
        #   diff
        print arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
      }
    }
  ' "${f1}" "${f2}"
done




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- първи файл (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- втори файл (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # форматираме ±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ↑ ако date1 е по-бавно (secs1 > secs2), иначе ↓
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "↑" : "↓")

    # първо delta (за сортиране), после всички полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-







#!/usr/bin/env bash
set -euo pipefail

if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# намери файловете JT*<дата>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# печатаме header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# правим awk и веднага pipe към sort и cut
awk -F, -v OFS=, '
  # Първо: зареждаме данните от file1 (date1)
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t1, ":")
    secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # След това file2 (date2)
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    # delta = secs1 - secs2 (в полза на date1)
    delta          = secs1[key] - secs2
    # филтрираме само ако date1 е по-бавно (secs1 > secs2)
    if (secs1[key] > secs2) {
      # форматираме Diff като HH:MM:SS (без знак, винаги положително)
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta % 60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка винаги ↑ (date1 по-бавно)
      arrow = "↑"
      # първо delta (за сортиране), после всичко останало
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) първо минаваме през file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) сега file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = secs1[key] - secs2
    # само ако date1 е по-бавно
    if (secs1[key] > secs2) {
      # форматираме ±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка (ще е винаги ↑ тук)
      arrow = "↑"
      # печатаме първо delta (за сортиране), после колоните
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # сортираме по delta (най-голям first)
| cut -d, -f2-          # махаме временната numeric delta-колона




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) първо минаваме през file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) сега file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = secs1[key] - secs2
    # само ако date1 е по-бавно
    if (secs1[key] > secs2) {
      # форматираме ±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # стрелка (ще е винаги ↑ тук)
      arrow = "↑"
      # печатаме първо delta (за сортиране), после колоните
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # сортираме по delta (най-голям first)
| cut -d, -f2-          # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- първи файл (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- втори файл (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (в полза на date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # форматираме ±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ↑ ако date1 е по-бавно (secs1 > secs2), иначе ↓
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "↑" : "↓")

    # първо delta (за сортиране), после всички полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK + SORT + CUT на един ред
awk -F, -v OFS=, '
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първа колона delta (за сортиране), после всичко останало
    print delta, arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta, add arrow, sort and drop the temp column
awk -F, -v OFS=, '
  # 1) Първо минаваме през file1 и запаметяваме:
  #      key = BATCH.STAGE FS BATCH FS JOB.NAME
  #      date1[key]    = $4
  #      elapsed1[key] = $8  (и в секунди secs1[key])
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  # 2) После минаваме file2 и за всеки същия key:
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    # форматираме diff в ±HH:MM:SS
    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # ако date1 е по-бавно (secs1 > secs2) – стрелка ↑, иначе ↓
    arrow          = (secs1[key] > secs2 ? "↑" : "↓")

    # Първо delta (за сортиране), после стрелката+stage и останалите полета
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \     # сортиране по delta низходящо
| cut -d, -f2-            # махаме временната numeric delta-колона





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# awk + sort + cut
awk -F, -v OFS=, '
  # Четем първи файл: запазваме по ключ (1,2,3) датата и elapsed, и изчисляваме secs1
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  # Втори файл: смятаме secs2 и delta
  {
    key    = $1 FS $2 FS $3
    d2     = $4
    e2     = $8
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    # Форматираме diff като ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Първо колона с delta (за сортиране), после всичко останало
    print delta, \
          $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \
| cut -d, -f2-



#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Намери файловете по маска JT*<дата>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Заглавен ред
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

awk -F, -v OFS=, '
  # Първо минаваме през първия файл и запаметяваме за всеки ключ (1,2,3):
  #   - неговата дата (поле 4)
  #   - elapsed time (поле 8) както в оригинал, така и в секунди
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, tt, ":")
    secs1[key]    = tt[1]*3600 + tt[2]*60 + tt[3]
    next
  }

  # Сега във втория файл за всеки същия ключ:
  {
    key      = $1 FS $2 FS $3
    d2       = $4
    e2       = $8
    split(e2, tt2, ":")
    secs2    = tt2[1]*3600 + tt2[2]*60 + tt2[3]
    s1       = (key in secs1 ? secs1[key] : 0)
    delta    = secs2 - s1

    # Форматираме разликата в ±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме желания ред
    print \
      $1,    $2,    $3,          \
      date1[key], elapsed1[key], \
      d2,          e2,            \
      diff
  }
' "$file1" "$file2"




#!/usr/bin/env bash

# Проверка за две дати
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Откриваме файловете по маска JT*<дата>*
files1=(JT*${d1}*)
files2=(JT*${d2}*)
if [ ! -f "${files1[0]}" ] || [ ! -f "${files2[0]}" ]; then
  echo "Не намерих файлове JT*${d1}* или JT*${d2}*"
  exit 1
fi
f1=${files1[0]}
f2=${files2[0]}

awk -F, -v OFS=, '
  #
  # Първо четем файл1 (за date1):
  #   key = комбинация от полета 1..4 (JOB fields)
  #   записваме date1, start, stop и elapsed и пресмятаме секунди
  #
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4
    date1[key]    = $5        # полe 5 е датата във входния ред
    start1[key]   = $7        # поле 7 = старт време
    stop1[key]    = $8        # поле 8 = стоп време
    elapsed1[key] = $9        # поле 9 = elapsed
    split($9, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  #
  # Сега четем файл2 (за date2) и за всеки ключ
  # ● взимаме полета 1..4
  # ● взимаме date2, start2, stop2, elapsed2
  # ● смятаме diff = elapsed2 - elapsed1
  #
  {
    key    = $1 FS $2 FS $3 FS $4
    d2     = $5
    s2     = $7
    e2     = $9
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    sign   = ""
    if (delta<0) { sign="-"; delta = -delta }
    hh     = int(delta/3600)
    mm     = int((delta%3600)/60)
    ss     = delta%60
    diff   = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме:
    #  $1,$2,$3,$4 — полета до JOB.NAME
    #  date1, start1, stop1, elapsed1
    #  date2, start2, stop2, elapsed2
    #  diff
    print \
      $1, $2, $3, $4, \
      date1[key], start1[key], stop1[key], elapsed1[key], \
      d2,       s2,         $8,        e2,        \
      diff
  }
' "$f1" "$f2"




#!/usr/bin/env bash

# Проверка на параметри
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

date1=$1
date2=$2

# Намираме имената на файловете по маска
file1=(JT*${date1}*)
file2=(JT*${date2}*)

if [ ! -f "${file1[0]}" ] || [ ! -f "${file2[0]}" ]; then
  echo "Не можаха да се намерят файлове JT*${date1}* или JT*${date2}*"
  exit 1
fi

file1=${file1[0]}
file2=${file2[0]}

awk -F, -v OFS=, '
  # Прочитаме първия файл, запазваме Elapsed Time (поле 8) в секунди и оригиналния низ
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t = $8
    split(t, a, ":")
    secs = a[1]*3600 + a[2]*60 + a[3]
    t1_secs[key] = secs
    t1_str[key]  = t
    next
  }
  # Сега втория файл: пак правим ключа и взимаме време t2
  {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t2 = $8
    split(t2, b, ":")
    secs2 = b[1]*3600 + b[2]*60 + b[3]
    secs1 = (key in t1_secs ? t1_secs[key] : 0)
    delta = secs2 - secs1

    # Преобразуваме delta в HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # Печатаме полета 1,2,3,4,6,7, original t1, t2 и разликата
    print $1, $2, $3, $4, $6, $7, t1_str[key], t2, diff
  }
' "$file1" "$file2"




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Usage: $0 <DATE1> <DATE2>"
  exit 1
fi

DATE1="$1"
DATE2="$2"

FILE1=$(ls JT*"$DATE1"*.CSV 2>/dev/null | head -n 1)
FILE2=$(ls JT*"$DATE2"*.CSV 2>/dev/null | head -n 1)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Missing input files for given dates."
  exit 1
fi

echo "Сравнение на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Start1,Stop1,Elapsed1,Start2,Stop2,Elapsed2,Разлика"

awk -F',' '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
{
  key = $1","$2","$3","$4;
  data[key] = $6","$7","$8;
  elapsed[key] = hms_to_minutes($8);
}
' "$FILE2" > /tmp/jt2.map

awk -F',' -v f2="/tmp/jt2.map" '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
function minutes_to_hhmm(mm,   h, m) {
  sign = (mm < 0) ? "-" : "";
  mm = (mm < 0) ? -mm : mm;
  h = int(mm);
  m = int((mm - h) * 60 + 0.5);
  return sign sprintf("%d:%02d", h, m);
}
BEGIN {
  while ((getline < f2) > 0) {
    split($0, parts, " ");
    split(parts[1], k, "=");
    split(k[2], d, ",");
    key = d[1]","d[2]","d[3]","d[4];
    info[key] = d[5]","d[6]","d[7];
    e2[key] = hms_to_minutes(d[7]);
  }
}
{
  key = $1","$2","$3","$4;
  if (key in info) {
    e1 = hms_to_minutes($8);
    diff = e1 - e2[key];
    printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", $1,$2,$3,$4,$6,$7,$8,info[key],minutes_to_hhmm(diff);
  }
}
' "$FILE1" | sort -t',' -k11,11





#!/bin/bash

d1="$1"
d2="$2"

f1=$(ls JT*${d1}*.CSV 2>/dev/null)
f2=$(ls JT*${d2}*.CSV 2>/dev/null)

if [[ -z "$f1" || -z "$f2" ]]; then
  echo "Файл(ове) не са намерени."
  exit 1
fi

echo "Сравнение на $f1 с $f2 по Elapsed Time (поле 8)"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Дата1 Elapsed,Дата2 Start,Дата2 Stop,Дата2 Elapsed,Разлика"

join -t, -1 1 -2 1 <(cut -d',' -f1-8 "$f1" | sort) <(cut -d',' -f1-8 "$f2" | sort) | awk -F',' '
function to_seconds(t,  a) {
  split(t, a, ":"); return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs) {
  sign = (secs < 0) ? "-" : "";
  secs = (secs < 0) ? -secs : secs;
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return sign h ":" (m < 10 ? "0" m : m);
}
{
  print $0 > "/tmp/jt_temp.csv"  # ако искаш да провериш
  e1 = $8; e2 = $16;
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
    $1, $2, $3, $4, $6, $7, e1, $14, $15, e2, to_hhmm(diff)
}
' | sort -t',' -k11 -r




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Използване: $0 <DATE1: YYYYMMDD> <DATE2: YYYYMMDD>"
  exit 1
fi

DATE1=$1
DATE2=$2

FILE1=$(ls JT*${DATE1}*.CSV 2>/dev/null)
FILE2=$(ls JT*${DATE2}*.CSV 2>/dev/null)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Някой от файловете липсва:"
  echo "  $FILE1"
  echo "  $FILE2"
  exit 2
fi

echo "Сравняване на $FILE1 с $FILE2 по Elapsed Time (поле 8)"
echo "------------------------------------------------------------------"
echo "Поле1,Поле2,Поле3,Поле4,Поле6,Поле7,Elapsed1,Elapsed2,Разлика"

paste -d'\n' "$FILE1" "$FILE2" | paste - - | awk -F'\t' '
function to_seconds(t,  a) {
  split(t, a, ":");
  return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs, h, m) {
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return h ":" (m < 10 ? "0" m : m);
}
{
  split($1, f1, ",");
  split($2, f2, ",");

  e1 = f1[8]; e2 = f2[8];
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s\n", f1[1], f1[2], f1[3], f1[4], f1[6], f1[7], e1, e2, to_hhmm(diff)
}' | sort -t',' -k9 -r



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска хедърите
  const total = rows.length;
  const rawValue = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = rawValue + 1;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const total = rows.length;
  const requested = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = Math.min(requested, total); // Не позволявай да искаме повече, отколкото имаме

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // само данни
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows(days) {
  const allRows = Array.from(document.getElementById('eomTable').getElementsByTagName('tr'));
  const dataRows = allRows.slice(2); // Прескачаме заглавните два реда
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // винаги показвай заглавията
    } else {
      tr.hidden = (i - 2) < start ? false : true;
    }
  });
}




const visibleRows = Math.min(maxRows, rows.length);
rows.forEach((tr, i) => {
  tr.hidden = i < rows.length - visibleRows;
});






#!/bin/bash

main_log="main_log.txt"
rrex_log="rrex_data.txt"
output_log="merged_log.txt"

> "$output_log"

while IFS= read -r line; do
    # Извличаме датата от формата JT.20240520
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търсим съвпадащ ред в RREX таблицата по първото поле (датата)
        match=$(awk -F'|' -v d="$date" '$1 == d {print $0}' "$rrex_log")

        if [[ -n "$match" ]]; then
            # Вземаме само времената
            rrex_start=$(echo "$match" | awk -F'|' '{print $2}' | cut -d' ' -f2)
            rrex_end=$(echo "$match" | awk -F'|' '{print $3}' | cut -d' ' -f2)
            rrex_duration=$(echo "$match" | awk -F'|' '{print $4}')

            echo "$line | RREX_START: $rrex_start | RREX_END: $rrex_end | RREX_DURATION: $rrex_duration" >> "$output_log"
        else
            echo "$line | RREX: N/A" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

main_log="main_log.txt"        # лог с JT.20240520
rrex_log="rrex_log.txt"        # лог със Start/End/Duration за всяка дата
output_log="enhanced_log.txt"

> "$output_log"

while IFS= read -r line; do
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # Търси ред в rrex_log, започващ с датата
        rrex_info=$(awk -F'|' -v d="$date" '$1 == d { print $2, $3, $4 }' "$rrex_log")

        if [[ -n "$rrex_info" ]]; then
            echo "$line | $rrex_info" >> "$output_log"
        else
            echo "$line | [No RREX data]" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

input_log="main_log.txt"
output_log="enhanced_log.txt"
log_dir="./logs"  # директория с файловете по дати

> "$output_log"  # празно изходен файл

while IFS= read -r line; do
    # Извличане на датата след JT.
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]+')

    if [[ -n "$date" ]]; then
        file="$log_dir/$date.log"

        if [[ -f "$file" ]]; then
            # Извличане на реда със Stop, Start, Elapsed (примерна логика)
            match=$(grep -i 'Stop.*Start.*Elapsed' "$file" | head -n 1)

            # Добавяне на намереното в края на реда
            echo "$line $match" >> "$output_log"
        else
            echo "$line [No file for $date]" >> "$output_log"
        fi
    else
        echo "$line [No JT date found]" >> "$output_log"
    fi
done < "$input_log"




def run_advanced_shell_script():
    script_path = os.path.join(BASE_DIR, "scripts", "advanced_log.sh")
    try:
        output = subprocess.check_output(["bash", script_path], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("Shell скриптът за advanced лог анализ е изпълнен успешно.")
        # Ако искаш да го запишеш:
        result_file = os.path.join(RESULT_DIR, "advanced_combined.log")
        os.makedirs(RESULT_DIR, exist_ok=True)
        with open(result_file, "w") as f:
            f.write(output)
    except subprocess.CalledProcessError as e:
        logging.error(f"Shell скрипт грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"Грешка при стартиране на shell скрипта: {str(e)}")




import tempfile

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Създаваме временен shell скрипт с оригиналната логика
    script_content = f"""#!/bin/bash
LIMIT_DATE="{limit_date}"
CHAR_LIMIT={char_limit}
LOG_DIR="{log_dir}"
for f in $LOG_DIR/{log_files}; do
    awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
        /\\[ERROR\\]/ && length($0) >= {char_limit} {{
            log_date = substr($0, 2, 10)
            if (log_date >= limit) {{
                if ($0 ~ /{match_keywords}/) {{
                    match($0, /\\] .*? /, arr)
                    if (arr[1] != "" && arr[1] != "\\\\") {{
                        key = arr[1]
                        print key "|" "[" host "] [" file "] " $0
                    }}
                }}
            }}
        }}
    ' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
"""

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sh", mode="w") as tmpfile:
            tmpfile.write(script_content)
            tmpfile_path = tmpfile.name

        remote_path = f"/tmp/monitor_adv_{host}.sh"

        # Качваме скрипта на отдалечената машина
        subprocess.run(["scp", tmpfile_path, f"{user}@{host}:{remote_path}"], check=True)

        # Даваме права и го изпълняваме през ssh
        ssh_cmd = f"chmod +x {remote_path} && bash {remote_path} && rm {remote_path}"
        output = subprocess.check_output(["ssh", f"{user}@{host}", ssh_cmd], stderr=subprocess.STDOUT, timeout=60, universal_newlines=True)

        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH/Script грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Грешка при изпълнение на advanced_log_filter: {str(e)}")
    finally:
        if os.path.exists(tmpfile_path):
            os.unlink(tmpfile_path)






def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Shell скрипт, вграден в Python (точно като оригинала)
    remote_script = f'''
        LIMIT_DATE="{limit_date}"
        CHAR_LIMIT={char_limit}
        for f in {log_dir}/{{{log_files}}}; do
            awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
                /\\[ERROR\\]/ && length($0) >= {char_limit} {{
                    log_date = substr($0, 2, 10)
                    if (log_date >= limit) {{
                        if ($0 ~ /{match_keywords}/) {{
                            match($0, /\\] .*? /, arr)
                            if (arr[1] != "" && arr[1] != "\\\\") {{
                                key = arr[1]
                                print key "|" "[" host "] [" file "] " $0
                            }}
                        }}
                    }}
                }}
            ' "$f"
        done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
    '''

    ssh_cmd = ["ssh", f"{user}@{host}", remote_script]

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=40, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма резултати.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")







def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] липсва секция [advanced_log_filter]")
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dirs = conf.get('log_dirs', 'paths').split(',')

    # Формируем списък от лог файлове във всички лог директории
    log_patterns = []
    for log_dir in log_dirs:
        log_dir = log_dir.rstrip('/')
        for f in log_files:
            log_patterns.append(f"{log_dir}/{f}")
    log_patterns_str = ' '.join(log_patterns)

    # awk скрипт (без външен shell parsing)
    awk_script = (
        f"""/\\[ERROR\\]/ && length($0) > {char_limit} {{
            log_date = substr($0, 2, 19);
            if (log_date >= "{limit_date}") {{
                if ($0 ~ /{match_keywords}/)
                    print host "|" file "|" $0;
            }}
        }}"""
    )

    remote_cmd = f"for file in {log_patterns_str}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"
    ssh_cmd = ["ssh", f"{user}@{host}", remote_cmd]

    logging.debug(f"[{host}] SSH команда: {' '.join(ssh_cmd)}")

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=30, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
        else:
            logging.info(f"[{host}] Няма намерени резултати от advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH грешка: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")






#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print host \"|\" file \"|\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=20, universal_newlines=True
        )
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced лог резултат записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()




[advanced_log_filter]
log_files = mdb.log,runtime.log*,database.log*,ejb.log*
char_limit = 1000
match_keywords = DATABASE|RUNTIME|EJB|MDB



#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break

    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print \"[advanced] |\" host \"|\" file \":\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=15, universal_newlines=True
        )
        if output:
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced log scan записан.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan неуспешен: {str(e)}")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        scan_host(host, user, log_dirs, keywords)
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()





# Директории за логове
[log_dirs]
paths = /var/log,/opt/bank/logs

# Директории за файлов мониторинг (локални за бекенда)
[file_monitor]
dirs = /var/bank/inbox,/tmp/transactions

# Ключови думи за търсене
[keywords]
errors = ERROR,FATAL,EXCEPTION
warnings = WARN,DEPRECATED

# Потребители
[users]
admin = root,monitoring_user
readonly = viewer


# Monitoring Framework for Banking VMs

## Структура
- `config/`: Конфигурации (.conf и .properties)
- `hosts/`: Списък с хостове
- `logs/`: Логове от мониторинг скрипта
- `scripts/`: Python скриптове

## Конфигурация
- `common.conf`: съдържа директории, ключови думи и потребители
- `settings.properties`: лог ниво, ssh настройки, интервали
- `host_list.txt`: един ред = един hostname

## Стартиране
```bash
cd scripts
python3 monitor.py


# Логване
log.level=INFO
log.rotation=daily
log.retention_days=7

# SSH настройки
backend.host=this-backend-host
remote.user=monitoring_user
connection.timeout=10

# Сканиране
scan.interval=300        # секунди между проверки
scan.parallelism=4       # паралелни ssh задачи


#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# Пътища
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# Зареждане на конфигурации
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

# Архивиране на резултатите
def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"Резултатите архивирани в {archive_path}.zip")

# Мониторинг на локални директории и файлове
def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] Стартира проверка на директории за файлове.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] Няма зададени директории за наблюдение.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] Директорията не съществува: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} в {directory} е на {int(age.total_seconds()//60)} минути.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] Няма файлове в {directory}.")

# SSH извличане на логове
def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] Започва сканиране...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[Грешка при търсене в {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] Грешка при търсене в {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] Време за търсене изтече в {log_dir}")
            logging.warning(f"[{host}] Време за търсене изтече в {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH грешка: {str(e)}")
            logging.error(f"[{host}] SSH връзка неуспешна: {str(e)}")
            break  # прекъсваме ако няма SSH достъп

    # Запис в резултатен файл
    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] Няма открити резултати или няма достъп до лог директории.")

    logging.info(f"[{host}] Сканиране завърши.")

def main():
    logging.info("Monitoring стартира.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')

    # Remote log scan
    for host in hosts:
        scan_host(host, user, log_dirs, keywords)

    # Local file check
    monitor_files(conf)

    # Archive results
    archive_results()

    logging.info("Monitoring приключи.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()






function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const x = cobMeta.data[i].x;
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const barVal = data.datasets[0].data[i];
              if (barVal > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(barVal);
                ctx.fillText(formatHHMM(barVal), x, y + 12);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





plugins: {
  tooltip: {
    callbacks: {
      label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
    }
  },
  title: {
    display: true,
    text: "EOM COB Elapsed Times",
    font: {
      size: 13,
      weight: "bold"
    },
    color: getTextColor()
  },
  legend: {
    labels: {
      font: { size: 13 },
      color: getTextColor()
    }
  },
  labelsInside: labelsInsidePlugin // това е ключово
}







const labelsInsidePlugin = {
  id: "labelsInside",
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const meta = chart.getDatasetMeta(0);
    const yScale = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const value = data.datasets[0].data[i];
      if (value > 0) {
        const x = meta.data[i].x;
        const y = yScale.getPixelForValue(value) + 14;
        ctx.fillText(formatHHMM(value), x, y);
      }
    });

    ctx.restore();
  }
};




<div class="chart-container" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime > 0) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const value = data.datasets[0].data[i];
              if (value > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(value) + 12;
                ctx.fillText(formatHHMM(value), x, y);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}
</script>





<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>






function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}







function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}








<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHMM(v),
            maxTicksLimit: 8
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>





function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 13,
              color: "#333"
            }
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v),
            font: {
              size: 13,
              color: "#333"
            }
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      }
    },
    plugins: [{
      id: 'labelsInside',
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const meta = chart.getDatasetMeta(0);
        const yScale = scales.y;

        ctx.save();
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const bar = meta.data[i];
          const value = data.datasets[0].data[i];
          const y = yScale.getPixelForValue(value);
          const x = bar.x;
          if (value > 0) {
            ctx.fillText(formatHMM(value), x, y + 12);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





<table class="rounded" id="eomChartTable">
  <tr>
    <th colspan="6">EOM COB & RR Elapsed Time</th>
  </tr>
  <tr>
    <td colspan="6">
      <div class="chart-container" id="eomChartWrapper">
        <canvas id="eomChart"></canvas>
      </div>
    </td>
  </tr>
</table>



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 },
            color: getTextColor()
          }
        }
      }
    },
    plugins: [
      {
        id: "labelsInside",
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const cobMeta = chart.getDatasetMeta(0);
          const rrMeta = chart.getDatasetMeta(1);
          const yScale = scales.y;

          ctx.save();
          ctx.font = "bold 11px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob = data.datasets[0].data[i] || 0;
            const rr = data.datasets[1].data[i] || 0;
            const total = cob + rr;
            const x = cobMeta.data[i].x;

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }

            if (rr > 0) {
              const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
              ctx.fillText(formatHHMM(rr), x, yRR);
            }

            if (total > 0) {
              const yTotal = yScale.getPixelForValue(total) - 6;
              ctx.fillText(formatHHMM(total), x, yTotal);
            }
          });

          ctx.restore();
        }
      }
    ]
  });

  updateChartsTheme();
}






options: {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    x: {
      stacked: true,
      ticks: {
        maxRotation: 45,
        minRotation: 45
      }
    },
    y: {
      beginAtZero: true,
      ticks: {
        callback: v => formatHHMM(v)
      }
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
      }
    },
    title: {
      display: true,
      text: "EOM COB & RR Elapsed Times",
      font: {
        size: 13,
        weight: "bold"
      },
      color: getTextColor()
    },
    legend: {
      labels: {
        font: { size: 13 }
      }
    }
  }
},
plugins: [
  {
    id: "labelsInside",
    afterDatasetsDraw(chart) {
      const { ctx, data, scales } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);
      const yScale = scales.y;

      ctx.save();
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i] || 0;
        const rr = data.datasets[1].data[i] || 0;
        const total = cob + rr;
        const x = cobMeta.data[i].x;

        if (cob > 0) {
          const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        if (rr > 0) {
          const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        if (total > 0) {
          const yTotal = yScale.getPixelForValue(total) - 6;
          ctx.fillText(formatHHMM(total), x, yTotal);
        }
      });

      ctx.restore();
    }
  }
]




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = cobElapsed[i] || 0;
              const rr = rrElapsed[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}







function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => {
              const raw = ctx.raw || 0;
              return `${ctx.dataset.label}: ${formatHHMM(raw)}`;
            }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCobMid = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCobMid);
              }

              if (rr > 0) {
                const yRRMid = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRRMid);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales: { y } } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i];
              const rr = data.datasets[1].data[i];
              const total = cob + rr;

              const cobTop = y.getPixelForValue(cob);
              const rrTop = y.getPixelForValue(rr);
              const totalTop = y.getPixelForValue(total);
              const cobBottom = y.getPixelForValue(0);
              const rrBottom = y.getPixelForValue(cob);
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (cobTop + cobBottom) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (rrTop + rrBottom) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                ctx.fillText(formatHHMM(total), x, totalTop - 6);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




plugins: [
  {
    id: 'labelsInside',
    afterDatasetsDraw(chart) {
      const { ctx, data, scales: { y } } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);

      ctx.save();
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(rr);
        const totalTop = y.getPixelForValue(total);
        const cobBottom = y.getPixelForValue(0);
        const rrBottom = y.getPixelForValue(cob);

        const x = cobMeta.data[i].x;

        // COB inside
        if (cob > 0) {
          const yCob = (cobTop + cobBottom) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        // RR inside
        if (rr > 0) {
          const yRR = (rrTop + rrBottom) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        // Total on top
        if (total > 0) {
          ctx.fillText(formatHHMM(total), x, totalTop - 6);
        }
      });

      ctx.restore();
    }
  }
]




function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 9) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();
    const rrVal = cells[6].innerText.trim();

    if (date && cobVal && rrVal) {
      dates.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
      rrElapsed.push(parseElapsedToHours(rrVal));
    }
  }

  dates.reverse();
  cobElapsed.reverse();
  rrElapsed.reverse();

  return { dates, cobElapsed, rrElapsed };
}

let eomChartInstance;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) eomChartInstance.destroy();

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
          order: 2
        },
        {
          label: "Duration Limit (2:30)",
          data: Array(dates.length).fill(2.5),
          type: "line",
          borderColor: "red",
          borderDash: [6, 4],
          pointRadius: 0,
          borderWidth: 2,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          max: 7,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: [] // Празно, без EOM маркери
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times vs Duration Limit",
          color: getTextColor(),
          font: {
            size: 13,
            weight: "bold"
          }
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [{
      id: "labelsInside",
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const cobMeta = chart.getDatasetMeta(0);
        const yScale = scales.y;
        ctx.save();
        ctx.font = "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const cob = data.datasets[0].data[i];
          const rr = data.datasets[1].data[i];
          const total = cob + rr;
          const x = cobMeta.data[i].x;

          if (cob > 0) {
            const yCob = yScale.getPixelForValue(cob);
            ctx.fillText(formatHHMM(cob), x, yCob);
          }

          if (rr > 0) {
            const yTop = yScale.getPixelForValue(cob + rr);
            const yBottom = yScale.getPixelForValue(cob);
            const yRR = (yTop + yBottom) / 2;
            ctx.fillText(formatHHMM(rr), x, yRR);
          }

          if (total > 0) {
            const yTotal = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, yTotal);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(54, 162, 235, 0.6)",
          borderColor: "rgba(54, 162, 235, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(128, 128, 128, 0.6)",
          borderColor: "rgba(128, 128, 128, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 13 },
            color: "#333"
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: formatHHMM,
            font: { size: 13 },
            color: "#333"
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 13 }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: "#222"
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        datalabels: {
          display: true,
          color: () => document.body.classList.contains("dark-mode") ? "white" : "black",
          font: {
            weight: 'bold',
            size: 11,
            family: 'sans-serif'
          },
          formatter: value => formatHHMM(value)
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [ChartDataLabels]
  });

  updateChartsTheme();
}




function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // пропускаме header

  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    const date = cells[0].innerText.trim();
    const cob = parseElapsedToHours(cells[3].innerText);
    const rr = parseElapsedToHours(cells[7].innerText);

    dates.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    dates: dates.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}





document.addEventListener("DOMContentLoaded", () => {
  const eomSlider = document.getElementById("eomRange");
  const eomInput = document.getElementById("eomValue");

  function syncEomFromSlider() {
    eomInput.value = eomSlider.value;
    updateEomTableRows();
    renderEOMChart();
  }

  function syncEomFromInput() {
    let value = parseInt(eomInput.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 12) value = 12;
    eomInput.value = value;
    eomSlider.value = value;
    syncEomFromSlider();
  }

  eomSlider.addEventListener("input", syncEomFromSlider);
  eomInput.addEventListener("input", syncEomFromInput);

  syncEomFromSlider(); // Initial load
});





<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


const eomChartWrapper = document.getElementById("eomChartWrapper");

toggleEomBtn.addEventListener("click", () => {
  eomVisible = !eomVisible;
  eomTable.classList.toggle("hidden", !eomVisible);
  eomSliderWrapper.classList.toggle("hidden", !eomVisible);
  eomChartWrapper.classList.toggle("hidden", !eomVisible);

  if (eomVisible) {
    updateEomTableRows();
    renderEOMChart();
  }
});



function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseTimeToMinutes(cells[3].innerText.trim());
    const rrTime = parseTimeToMinutes(cells[6].innerText.trim());

    if (cobTime && rrTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
      rrElapsed.push(rrTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: getEOMAnnotations(labels, cobElapsed)
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      }
    }
  });

  updateChartsTheme();
}






let eomChartInstance = null;

function parseElapsedToHours(str) {
    if (!str || str.length < 8) return 0;
    const parts = str.split(':').map(Number);
    const hours = parts[0];
    const minutes = parts[1];
    const seconds = parts[2];
    return hours + (minutes / 60) + (seconds / 3600);
}

function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 12;

    const dates = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cobTime = parseElapsedToHours(cells[3].innerText.trim());
        const rrTime = parseElapsedToHours(cells[6].innerText.trim());

        if (cobTime && rrTime) {
            dates.push(date);
            cobElapsed.push(cobTime);
            rrElapsed.push(rrTime);
        }
    }

    return {
        labels: dates.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (eomChartInstance) {
        eomChartInstance.destroy();
    }

    eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1"
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1"
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 20,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        font: {
                            size: 13,
                            weight: "bold"
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });

    updateChartsTheme();
}







<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


let eomChartInstance = null;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) {
    eomChartInstance.destroy();
  }

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: {
            stepSize: 1
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: "EOM COB + RR Elapsed Time (stacked)",
          font: {
            size: 13,
            weight: 'bold'
          },
          color: "#222"
        },
        legend: {
          display: true,
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeOutBounce'
      }
    }
  });
}


function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: 






function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
    const labels = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cob = parseTimeToMinutes(cells[3].innerText.trim());
        const rr = parseTimeToMinutes(cells[6].innerText.trim());

        if (cob > 0 || rr > 0) {
            labels.push(date);
            cobElapsed.push(cob);
            rrElapsed.push(rr);
        }
    }

    return {
        labels: labels.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (window.eomChartInstance) {
        window.eomChartInstance.destroy();
    }

    window.eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 10,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        maxTicksLimit: 8,
                        callback: v => formatHHMM(v)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });

    updateChartsTheme();
}



<script>
document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    eomTable.classList.toggle("show", eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });

  function updateEomTableRows() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // Skip headers
    const maxRows = parseInt(eomRange.value, 10);

    rows.forEach((tr, i, arr) => {
      tr.hidden = i < arr.length - maxRows;
    });
  }
});
</script>





#eomTable {
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

#eomTable.show {
  opacity: 1;
  transform: scaleY(1);
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomTable = document.getElementById("eomTable");

let isEomVisible = false;

toggleEomBtn.addEventListener("click", () => {
  isEomVisible = !isEomVisible;
  if (isEomVisible) {
    eomTable.classList.add("show");
  } else {
    eomTable.classList.remove("show");
  }
});





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <div class="daysValue" id="eomValue">10</div>
    </div>
  </div>
</div>






<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span>
      <span>&nbsp;days</span>
    </div>
  </div>
</div>




document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




<div class="tool-button" id="eomControlWrapper">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <label for="eomRange" id="eomLabel">EOM Days:</label>
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span><span>&nbsp;days</span>
    </div>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);
    
    if (eomVisible) {
      updateEomTableRows(); // Пресмята редовете, когато се показва
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}





<div class="tool-button">
  <button id="toggleEomBtn">🔴 Show EOM COBs</button>
</div>
<div id="eomSliderWrapper" class="daysSliderWrapper hidden">
  <label for="eomRange" id="eomLabel">EOM Days:</label>
  <div class="daysInputWrapper">
    <input type="range" id="eomRange" min="3" max="12" value="10" />
    <span id="eomValue">10</span><span>&nbsp;days</span>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
      updateEomTableRows(); // обнови при показване
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows();
  });
});





function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропуска заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3
  const totalRows = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < totalRows - maxRows; // скриваме горните
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаш заглавията
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}

if (eomVisible) {
  eomTable.classList.remove("hidden");
  eomSliderWrapper.classList.remove("hidden");
  updateEomTableRows(); // <-- Тук се вика
}



document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows();
});






document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("mousedown", (e) => {
    if (e.target.tagName === 'INPUT') return; // предотвратява затваряне от range

    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows(e.target.value); // само ако имаш функция
  });
});




<script>
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });
</script>





toggleEomBtn.addEventListener("click", (event) => {
  // Игнорирай кликове по вложени елементи вътре в бутона
  if (event.target !== toggleEomBtn && !toggleEomBtn.contains(event.target)) return;

  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});



<div class="tool-button" id="toggleEomBtn">
  <span>Show EOM COBs</span>
  <div id="eomSliderWrapper" class="hidden eom-slider">
    <label for="eomRange" id="eomLabel">EOM COB Days:</label>
    <div id="eomInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10">
      <span id="eomValue">10</span>
      <span>days</span>
    </div>
  </div>
</div>


.eom-slider {
  margin-top: 8px;
  font-size: 13px;
  text-align: center;
}

#eomInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 5px;
}

#eomInputWrapper input[type="range"] {
  width: 85px;
  accent-color: #3b8de3;
}

#eomLabel {
  color: #111;
  font-weight: bold;
}

body.dark-mode #eomLabel {
  color: #eee;
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomSliderWrapper = document.getElementById("eomSliderWrapper");
const eomTable = document.getElementById("eomTable");

toggleEomBtn.addEventListener("click", () => {
  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});

document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows(e.target.value); // ако имаш функция за обновяване
});







<div class="eom-controls">
  <button id="toggleEomTable" class="tool-button">Show EOM COBs</button>

  <div id="eomSliderWrapper" class="tool-button hidden">
    <label for="eomRange">EOM COB Days:</label>
    <span id="eomValue">10</span>
    <input type="range" id="eomRange" min="3" max="12" value="10" />
  </div>
</div>


.eom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

#eomSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  color: #333;
  margin-right: 5px;
}

#eomSliderWrapper input[type="range"] {
  width: 85px;
  accent-color: #b3e0ff;
}

#eomValue {
  font-size: 13px;
  font-weight: bold;
  color: #111;
  margin: 0 5px;
}

body.dark-mode #eomSliderWrapper label {
  color: #eee;
}
body.dark-mode #eomValue {
  color: #eee;
}


document.getElementById("toggleEomTable").addEventListener("click", () => {
  const table = document.getElementById("eomTable");
  const slider = document.getElementById("eomSliderWrapper");
  table.classList.toggle("hidden");
  slider.classList.toggle("hidden");
});


<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomDaysSliderWrapper" class="tool-button hidden">
  <label for="eomDaysRange">EOM COB Days:</label>
  <span id="eomDaysValue">10</span>
  <input type="range" min="3" max="12" value="10" id="eomDaysRange" />
</div>

document.addEventListener('DOMContentLoaded', () => {
  const eomBtn = document.getElementById('toggleEomBtn');
  const eomTable = document.getElementById('eomTable');
  const eomSlider = document.getElementById('eomDaysRange');
  const eomValue = document.getElementById('eomDaysValue');
  const eomSliderWrapper = document.getElementById('eomDaysSliderWrapper');

  eomBtn.addEventListener('click', () => {
    const isHidden = eomTable.classList.contains('hidden');
    eomTable.classList.toggle('hidden', !isHidden);
    eomSliderWrapper.classList.toggle('hidden', !isHidden);
  });

  eomSlider.addEventListener('input', () => {
    eomValue.textContent = eomSlider.value;
    updateEomTableRows(); // трябва да съществува, ще добавим логиката после
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропускаме заглавията
  const maxRows = parseInt(document.getElementById('eomDaysRange').value, 10);

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}




<button id="toggleEomBtn" class="tool-button">📅 Show EOM COBs</button>

<div id="eomSliderWrapper" class="tool-bottom hidden">
  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

#eomSliderWrapper {
  margin-top: 10px;
  font-size: 14px;
}


const toggleEomBtn = document.getElementById('toggleEomBtn');
const eomSliderWrapper = document.getElementById('eomSliderWrapper');
const eomTable = document.getElementById('eomTable'); // Увери се, че има такава таблица

toggleEomBtn.addEventListener('click', () => {
  eomTable?.classList.toggle('hidden');
  eomSliderWrapper.classList.toggle('hidden');
});

function syncEOMSliderAndInput(value) {
  const v = Math.max(1, Math.min(12, parseInt(value) || 5));
  document.getElementById('eomDaysRange').value = v;
  document.getElementById('eomDaysInput').value = v;
  updateEOMTableRows(v); // Имплементирай тази функция, ако още не съществува
}

document.getElementById('eomDaysRange').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));
document.getElementById('eomDaysInput').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));





<div id="cobToolsMenu" class="tools-menu">
  <!-- Existing tools -->
  
  <button onclick="toggleEOMTable()">Show EOM COBs</button>

  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

<table id="eomTable" style="display: none;">
  <!-- Your EOM table rows -->
</table>

<script>
  function toggleEOMTable() {
    const table = document.getElementById('eomTable');
    table.style.display = table.style.display === 'none' ? 'table' : 'none';
  }

  function syncEOMSliderAndInput(value) {
    const v = Math.max(1, Math.min(12, parseInt(value) || 5));
    document.getElementById('eomDaysRange').value = v;
    document.getElementById('eomDaysInput').value = v;
    updateEOMTableRows(v); // Трябва да имаш дефинирана тази функция
  }

  document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('eomDaysRange');
    const input = document.getElementById('eomDaysInput');
    slider.addEventListener('input', () => syncEOMSliderAndInput(slider.value));
    input.addEventListener('input', () => syncEOMSliderAndInput(input.value));
    syncEOMSliderAndInput(5);
  });
</script>




<footer>
  <p style="margin-top: 30px;">
    За идеи/бъгове, моля пишете в официалната страница на <strong>COB Analyser</strong>.<br>
    <a href="https://your-confluence-link-here" style="color: #66c1ff; text-decoration: none;" target="_blank">
      Отвори COB Analyser в Confluence
    </a>
  </p>
  <br>Поздрави,<br>
  Дилян
</footer>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7f9;
      color: #333;
      padding: 30px;
      line-height: 1.6;
    }
    .container {
      background-color: #fff;
      border: 1px solid #ddd;
      border-left: 5px solid #007ACC;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }
    h1 {
      font-size: 1.5em;
      color: #007ACC;
    }
    .section {
      margin-top: 20px;
    }
    .highlight {
      background-color: #eef;
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      display: inline-block;
    }
    footer {
      margin-top: 30px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Здравейте,</h1>

    <div class="section">
      Файлът за <strong>COB Analyser в SP24 PROD</strong> за дата <span class="highlight">today_cob_date</span> е прикрепен.
    </div>

    <div class="section">
      <strong>LOG файлът</strong>, както и изпълнението на всички функции, се намира в следната директория:
      <div class="highlight">/opt/t24/support_scripts/cob_analyser/log/</div>
    </div>

    <footer>
      Поздрави,<br>
      Диян
    </footer>
  </div>
</body>
</html>





<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }

    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* Хедър */
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* Тяло */
    .email-body {
      padding: 30px;
      text-align: center;            /* центрираме текста */
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
      text-align: center;            /* центрираме и кода */
    }

    /* Футър */
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
      text-align: center;            /* центрираме подписа */
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:</p>
              <p><code>/opt/t24/support_scripts/cob_analyser/log</code></p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>






<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* Общ стил за имейла */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }
    /* Центрираща таблица */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }
    .email-body {
      padding: 30px;
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
    }
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>Здравейте,</p>
              <p>📂 Файлът за <strong>COB Analyser</strong> в <strong>SP24 PROD</strong> за дата <em>today_cob_date</em> е прикачен.</p>
              <p>📂 LOG файлът, както и изпълнението на всички функции, се намира в следната директория:<br>
                 <code>/opt/t24/support_scripts/cob_analyser/log</code>
              </p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>Поздрави,<br>Дилян</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>



for i in {0..11}; do
  last_day=$(date -d "$current_date -$i month -1 day" +%Y%m%d)
  echo "$last_day"

  jtfind="$jt_path/JT_$last_day.csv"

  if [[ -s "$jtfind" ]]; then
    echo "COB $last_day $jtfind"
    echo "-----Started-----"
    cat "$jtfind" | grep A000 | cut -d ',' -f6 | head -1
    echo "-----Stopped-----"
    cat "$jtfind" | grep R999 | cut -d ',' -f7 | head -1
  else
    echo "File not found or empty: $jtfind, skipping..."
  fi
done





function getEOMAnnotations(labels, yData) {
  const annotations = {};
  const topY = Math.max(...yData);  // използваме масива от стойности

  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}



function getEOMAnnotations(labels, chart) {
  const annotations = {};
  const topY = Math.max(...chart.data.datasets[0].data);  // най-високата стойност по Y
  
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,  // леко над най-високата стойност
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}




function getEOMAnnotations(labels, heights) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      const height = heights?.[i] || 1; // ако няма масив, падаме на 1
      const adjustedY = height + 50; // издигаме текста с 50 над стълба

      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: adjustedY,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -10,
        rotation: 0
      };
    }
  }

  return annotations;
}





// make sure you’ve imported & registered both Chart.js and chartjs-plugin-annotation before this runs
// e.g.:
//   import { Chart, BarController, BarElement, CategoryScale, LinearScale, Title } from 'chart.js';
//   import annotationPlugin from 'chartjs-plugin-annotation';
//   Chart.register(BarController, BarElement, CategoryScale, LinearScale, Title, annotationPlugin);

let recordsChartInstance;

function renderRecordsChart() {
  // 1) pull your data
  const { labels, recordsPerMinute } = getRecordsData();  // your existing extractor

  // 2) destroy previous chart
  if (recordsChartInstance) recordsChartInstance.destroy();

  // 3) create new one
  const ctx = document.getElementById('recordsChart').getContext('2d');
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: 'rgba(54,162,235,0.6)',
        borderColor:   'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
          stacked: true,
          ticks: { font: { size: 13 }, color: '#333' }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { font: { size: 13 }, color: '#333' }
        }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 14, weight: 'bold' },
          color: '#222'
        },
        annotation: {
          // ask our helper to build a map of annotations:
          annotations: buildEOMAnnotations(recordsChartInstance)
        }
      }
    }
  });
}

/**
 * Walks the chart’s labels and data, finds month-breaks
 * and returns a map of annotation configs for line + label.
 */
function buildEOMAnnotations(chart) {
  const ann = {};
  const labels = chart.data.labels;
  const data   = chart.data.datasets[0].data;
  const yScale = chart.scales.y;

  labels.forEach((lbl, i) => {
    const next = labels[i + 1];
    // compare YYYYMM prefix of this vs next
    if (next && lbl.slice(0,6) !== next.slice(0,6)) {
      // vertical dashed line
      ann[`eomLine${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: lbl,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6,4],
        borderDashOffset: 2
      };
      // label at the top
      ann[`eomLabel${i}`] = {
        type: 'label',
        xScaleID: 'x',
        xValue: lbl,
        yScaleID: 'y',
        yValue: yScale.max,     // attach to top of the scale
        content: ['EOM'],
        font: { size: 12, weight: 'bold' },
        color: 'orange',
        textAlign: 'center',
        backgroundColor: 'transparent',
        yAdjust: -8             // shift up 8px from top
      };
    }
  });

  return ann;
}

// call on load / whenever you update your table
renderRecordsChart();




function getEOMAnnotationsWithHeights(records, labels) {
    const annotations = {};
    for (let i = 0; i < labels.length - 1; i++) {
        const current = labels[i];
        const next = labels[i + 1];

        if (current.substring(0, 6) !== next.substring(0, 6)) {
            const yVal = records[i] || 0;
            annotations[`line-eom-${i}`] = {
                type: 'line',
                scaleID: 'x',
                value: current,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [6, 4]
            };

            annotations[`text-eom-${i}`] = {
                type: 'label',
                xValue: current,
                yValue: yVal,
                backgroundColor: 'transparent',
                content: ['EOM'],
                font: {
                    size: 12,
                    weight: 'bold'
                },
                color: 'orange',
                textAlign: 'center',
                position: 'start',
                xAdjust: 0,
                yAdjust: -Math.max(20, Math.min(yVal * 0.05, 40)), // динамично позициониране
                rotation: 0
            };
        }
    }
    return annotations;
}





function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Records Per Minute',
                    data: recordsPerMinute,
                    backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                    borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                    borderRadius: 15,
                    hoverBorderWidth: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                annotation: {
                    annotations: getEOMAnnotationsWithHeights(recordsPerMinute, labels)
                },
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });

    updateChartsTheme();
}




function getEOMAnnotationsWithHeights(chart) {
  const annotations = [];
  const labels = chart.data.labels;
  const datasets = chart.data.datasets;

  // Намери последните дни от месеца
  const lastDays = [];
  for (let i = 0; i < labels.length; i++) {
    const current = labels[i].substring(0, 6);
    const next = labels[i + 1]?.substring(0, 6);
    if (current !== next) {
      lastDays.push({ index: i, date: labels[i] });
    }
  }

  // За всяка дата намери максималната стойност по Y
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(ds => {
      const val = ds.data[index];
      if (typeof val === 'number' && val > maxY) {
        maxY = val;
      }
    });

    annotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [4, 4],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: {
          x: 'end',
          y: 'start'
        },
        yAdjust: -10,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          size: 11,
          weight: 'bold'
        }
      }
    });
  });

  return annotations;
}


const annotations = getEOMAnnotationsWithHeights(chart);

options: {
  // ...
  plugins: {
    annotation: {
      annotations: annotations
    }
  }
}





function getEOMAnnotationsWithHeights(chart, labels, datasets) {
  const eomAnnotations = [];
  const lastDays = [];

  // Намираме всички последни дати за всеки месец
  for (let i = 0; i < labels.length; i++) {
    const currentDate = labels[i];
    const currentMonth = currentDate.substring(0, 6);
    const nextDate = labels[i + 1];
    const nextMonth = nextDate ? nextDate.substring(0, 6) : null;

    if (currentMonth !== nextMonth) {
      lastDays.push({ index: i, date: currentDate });
    }
  }

  // За всяка такава дата намираме най-високата стойност от всички datasets
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(dataset => {
      const value = dataset.data[index];
      if (typeof value === 'number' && value > maxY) {
        maxY = value;
      }
    });

    eomAnnotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [6, 3],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: 'end',
        yAdjust: -8,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          weight: 'bold'
        }
      },
      yMax: maxY
    });
  });

  return eomAnnotations;
}





function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };
      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: 1, // Няма значение, ще го коригираме със yAdjust
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -30, // това мести текста над графиката
        rotation: 0
      };
    }
  }
  return annotations;
}







function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          xAdjust: 30,
          yAdjust: -5,
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}





<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // Извличаме месец и година от датата (формат YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (“Close-Of-Business” or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	•	Start & Stop Times for each day’s batch run
	•	Elapsed Duration (how long the entire COB took)
	•	Throughput (records or transactions processed per minute)
	•	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	•	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	•	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	•	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	•	Bar charts for throughput (records per minute) and COB durations
	•	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	•	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	•	Automatic warnings for missing batches, slow batches, and restarts during COB
	•	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues—without manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # определяме списък от файлове
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # определяме списък от отдалечени файлове
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh — Secure Upload/Download/Cleanup wrapper with –all & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we’re in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} — Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' → '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * Променя ширината на контейнера на графиките
 * спрямо броя дни:
 *   3–10  дни → клас w-0-10
 *  11–20  дни → клас w-11-20
 *  21–31+ дни → клас w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // махаме всички предишни
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // слагаме новия
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // ограничаваме 3–31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) скриваме/показваме редове
    updateTableRows(v);
    // 2) преизчертаваме графиките
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) настройваме ширината
    updateContainerWidth(v);
  }

  // слушаме промени и от двата контрола
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // първоначално – 10 дни
  syncSliderAndInput(10);
});




// 1) Взимаме само видимите (нескрити) данни от таблцата
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите 2 header-реда и филтрираме само нескритите
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) Рендерираме (или пре-рендерираме) COB-графиката
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // ако вече имаме Chart, първо го унищожаваме
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // само видимите редове

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // пропусни заглавката
    const visibleRows = rows.filter(row => !row.hidden); // ВЗИМАШ САМО ВИДИМИТЕ редове

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // както горе
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // Пропускаме заглавието
    const selectedRows = dataRows.slice(-maxDays); // Вземаме последните N реда

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // Последните "days" реда
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // Дата
            values.push(parseElapsedTime(cells[1].innerText.trim())); // Време в секунди
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // Взимаме данните от таблицата
    const trend = calculateTrendline(values);         // Изчисляваме тренд линията
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // унищожаваме старата графика ако има
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // Вземаме последните N реда

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // При първоначално зареждане
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // Стартово състояние - 10 дни
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // При движение на слайдъра
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // При промяна на инпут
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper за стойност на слайдъра с default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- за Records per Minute графиката ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip заглавия
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice последните N елемента
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* останалите настройки по твой вкус */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- за COB elapsed графиката ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip заглавния ред
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// при всяка промяна на слайдъра
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... евентуално и другите графики
});

// при зареждане по подразбиране
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-и, ако вече нямаш такива:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // Пропускаме първите 2 (header-и)
    return getAllRows().slice(2);
  }

  // Точно твоето почистване на редовете
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // брой, който искаме да показваме
    const count = Math.max(minRows, Math.min(days, total));
    // индекс в dataRows, от който започваме да показваме
    const firstToShow = total - count;

    // винаги показваме заглавните 2 реда
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // Синхронизация slider ↔ input и initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // По подразбиране 10 дни
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // когато мърдаме слайдера
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // ако искаш да презареждаш и графиките:
      renderIDsChart();
      renderCOBChart();
    });

    // когато променим ръчно в полето
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // Слагаме по подразбиране 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // Връзка между слайдера и инпута
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // Функция, която връща всички <tr>
    const dataRows = getDataRows(); // Функция, която връща само валидните редове (без хедъра)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // Показва заглавията
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // НЕ повече от редовете
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // без заглавията
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // Първоначално показваме 10 дни
  updateTableRows(10);

  // Закачаме слушатели за промяна
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // Пропускаме заглавията
  const visibleCount = Math.max(days, 3); // Минимум 3 дена
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// При зареждане на страницата
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропускаме header-ите
  const visibleCount = Math.max(days, 3); // минимум 3 дена видими
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper за да вземем стойността на слайдера (и да имаме винаги поне 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) адаптирана getRecordsData(), връща само последните N дни
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // пропускаме първите два <tr> (header-ите)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // взимаме последните maxDays реда (обратен ред за удобно попълване)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) адаптирана getCOBDataFromTable(), връща само последните N дни
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // пропускаме само заглавния <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // взимаме последните maxDays реда
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() – вече ползва dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* … */],
        borderColor:     ['rgba(255,99,132,1)',   /* … */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() – вече ползва dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) биндираме към slider-а да ре-рисува и двете
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// готово — само тези 5 блока добавяш/заместваш, останалото не се променя. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// при зареждане:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // без заглавния ред

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // без заглавния ред
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// Обновява таблицата с новите дни
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // пропусни header редовете
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Синхронизира слайдера -> input и рендерира графики
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Синхронизира input -> слайдера и рендерира графики
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // твоята оригинална функция
    renderIDChart();  // твоята оригинална функция
}

// Закачане на слушатели
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// Първоначално при зареждане
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// Взимане на всички редове от таблицата
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// Обновяване на видимите редове според избраните дни
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // пропускаме заглавните редове

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// Извличане на данни за COB графиката
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// Извличане на данни за ID графиката
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// Помощна функция за парсване на време
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// Рендериране на новата COB графика
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// Рендериране на новата ID графика
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Форматиране на секунди към HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Функция за синхронизация на слайдера
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Функция за синхронизация от input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// Добавяне на слушатели
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// Стартиране първоначално
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // ново!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // Прескачаме заглавния ред
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // Вземаме последните N дни
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '☀️';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // Добавяме име на таблицата
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // Празен ред между таблиците
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
  <button id="exportAllBtn" class="small-button">⬇️ Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // празен ред между таблиците
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">✅ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">❌ Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* под "Export CSV" бутона */
  left: 180px; /* изнася се вдясно */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">📄 Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- Ако искаш може да добавиш още чекбоксове -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">✅ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">❌ Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- Ако имаш още таблици добавяш тук -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // Създаване на чекбокс прозорец
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // По подразбиране всички са маркирани

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Затваряне на модал прозореца
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* За светъл фон */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* За тъмен фон */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* Слайдър цветът */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // тук извикваш каквото още искаш като update на графики, таблици и т.н.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // за да се инициализира правилно при зареждане
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? '🌙' : '🌞';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* Преместване заедно с текста */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = '🌙';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = '🌞';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">🌞</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">☀️</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? '🌙' : '☀️';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // всички <tr>
  const dataRows = getDataRows();  // само <tr> за данни
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // показваме винаги header-ите
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // всички tr (вкл. th + tr)
  const dataRows = getDataRows(); // само данните
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // първите два (header) винаги да са видими
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // Обръщаме реда на масивите
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // Обръщаме реда на масивите
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // Пропускаме първите 2 реда с <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // Пропускаме 2 заглавни реда
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // Минимално 3 дни
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // Заглавните редове винаги да са видими
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // пропускаме 2 заглавни реда

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // минимум 3 дни, не 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // Минимум 3 дни
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // ако искаш и CPU графиката да се адаптира!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // Първоначално зареждане
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // За да се рендерират правилно при зареждане
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // Минимум 3 дни
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // Пропускаме заглавията

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // Минимум 3 реда
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // Първоначално показваме избрания брой дни
    daysValue.textContent = `${daysRange.value} days`;

    // Рендерираме графиките още при зареждане
    renderIDsChart();
    renderTimingChart();

    // Слушаме за промяна на плъзгача
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // Изтриваме старите графики преди да рендерираме нови
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // Рендерираме графиките отново според новата стойност
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

