#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>
#include <iomanip>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    if (depth > max_depth) return 0;
    std::uintmax_t size = 0;
    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir, int max_depth, std::uintmax_t min_size_bytes) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, max_depth);
            if (total >= min_size_bytes)
                raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::string current_path = fs::current_path().string();

    while (true) {
        std::vector<std::string> entries;
        entries.push_back(".. (Back)");
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin() + 1, entries.end());

        int highlight = 0, start = 0;
        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter = open)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);
                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";
                mvprintw(i + 1, 0, "%s", display.c_str());
                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {
                if (highlight == 0) {
                    current_path = fs::path(current_path).parent_path().string();
                    break;
                } else {
                    current_path = entries[highlight];
                    break;
                }
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }

        // Confirm selection
        clear();
        mvprintw(0, 0, "Use this directory? %s [y/n]", current_path.c_str());
        int ch = getch();
        if (ch == 'y' || ch == 'Y')
            return current_path;
    }
}

int choose_depth() {
    int depth = 2;
    while (true) {
        clear();
        mvprintw(0, 0, "Select analysis depth (1‚Äì5): Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current depth: %d", depth);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') depth = std::min(depth + 1, 5);
        else if (ch == '-') depth = std::max(depth - 1, 1);
    }
    return depth;
}

int choose_min_size() {
    int size_mb = 0;
    while (true) {
        clear();
        mvprintw(0, 0, "Filter directories smaller than X MB. Use '+' and '-' keys. Press Enter to confirm.");
        mvprintw(2, 0, "Current minimum size: %d MB", size_mb);
        int ch = getch();
        if (ch == 10) break;
        else if (ch == '+') size_mb = std::min(size_mb + 10, 10000);
        else if (ch == '-') size_mb = std::max(size_mb - 10, 0);
    }
    return size_mb;
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Results (press q to quit)");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;
            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        int depth = choose_depth();
        int min_mb = choose_min_size();
        auto data = analyze_dir(selected, depth, static_cast<std::uintmax_t>(min_mb) * 1024 * 1024);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No directories matched the criteria.");
            getch();
        }
    }

    endwin();
    return 0;
}







#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = {"B", "KB", "MB", "GB", "TB"};
    double readable = static_cast<double>(size);
    int i = 0;
    while (readable >= 1024 && i < 4) {
        readable /= 1024;
        ++i;
    }
    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_size(const fs::path& dir, int depth, int max_depth) {
    std::uintmax_t size = 0;
    if (depth > max_depth) return 0;

    for (const auto& entry : fs::directory_iterator(dir, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_directory(entry))
                size += get_size(entry.path(), depth + 1, max_depth);
            else if (fs::is_regular_file(entry))
                size += fs::file_size(entry);
        } catch (...) {}
    }
    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_dir(const fs::path& base_dir) {
    std::vector<std::pair<std::string, std::uintmax_t>> raw_data;

    for (const auto& entry : fs::directory_iterator(base_dir, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            std::uintmax_t total = get_size(entry.path(), 1, 2);
            raw_data.emplace_back(entry.path().string(), total);
        }
    }

    std::sort(raw_data.begin(), raw_data.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : raw_data)
        result.emplace_back(path, human_readable(size));

    return result;
}

std::string choose_directory() {
    std::vector<std::string> entries;
    std::string current_path = ".";

    while (true) {
        entries.clear();
        for (const auto& entry : fs::directory_iterator(current_path)) {
            if (fs::is_directory(entry))
                entries.push_back(entry.path().string());
        }

        std::sort(entries.begin(), entries.end());
        int highlight = 0, start = 0;

        while (true) {
            clear();
            int h, w;
            getmaxyx(stdscr, h, w);
            mvprintw(0, 0, "Select directory to analyze (Enter to select, q to quit)");

            for (int i = 0; i < h - 2 && (start + i) < (int)entries.size(); ++i) {
                if (highlight == start + i)
                    attron(A_REVERSE);

                std::string display = entries[start + i];
                if ((int)display.length() > w - 2)
                    display = display.substr(0, w - 5) + "...";

                mvprintw(i + 1, 0, "%s", display.c_str());

                if (highlight == start + i)
                    attroff(A_REVERSE);
            }

            int ch = getch();
            if (ch == 'q') return "";
            else if (ch == KEY_UP && highlight > 0) --highlight;
            else if (ch == KEY_DOWN && highlight < (int)entries.size() - 1) ++highlight;
            else if (ch == 10) {  // Enter
                current_path = entries[highlight];
                return current_path;
            }

            if (highlight < start) start = highlight;
            else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
        }
    }
}

void show_results(const std::vector<std::pair<std::string, std::string>>& data) {
    int highlight = 0, start = 0;

    while (true) {
        clear();
        int h, w;
        getmaxyx(stdscr, h, w);
        mvprintw(0, 0, "Linux Disk Usage - q to quit");

        for (int i = 0; i < h - 2 && (start + i) < (int)data.size(); ++i) {
            if (highlight == start + i)
                attron(A_REVERSE);

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > w - 15)
                name = name.substr(0, w - 18) + "...";

            mvprintw(i + 1, 0, "%-*s %12s", w - 15, name.c_str(), size.c_str());

            if (highlight == start + i)
                attroff(A_REVERSE);
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + (h - 2)) start = highlight - (h - 3);
    }
}

int main() {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    std::string selected = choose_directory();
    if (!selected.empty()) {
        auto data = analyze_dir(selected);
        if (!data.empty())
            show_results(data);
        else {
            clear();
            mvprintw(0, 0, "No subdirectories found.");
            getch();
        }
    }

    endwin();
    return 0;
}





g++ -std=c++17 -o disk_usage file.cpp -lncurses -lstdc++fs






#include <iostream>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <ncurses.h>
#include <iomanip>
#include <sstream>

namespace fs = std::filesystem;

std::string human_readable(std::uintmax_t size) {
    const char* suffixes[] = { "B", "KB", "MB", "GB", "TB" };
    double readable_size = static_cast<double>(size);
    int i = 0;

    while (readable_size >= 1024 && i < 4) {
        readable_size /= 1024;
        ++i;
    }

    std::ostringstream out;
    out << std::fixed << std::setprecision(2) << readable_size << " " << suffixes[i];
    return out.str();
}

std::uintmax_t get_directory_size(const fs::path& dir_path) {
    std::uintmax_t size = 0;

    for (const auto& entry : fs::recursive_directory_iterator(dir_path, fs::directory_options::skip_permission_denied)) {
        try {
            if (fs::is_regular_file(entry.status()))
                size += fs::file_size(entry.path());
        } catch (...) {}
    }

    return size;
}

std::vector<std::pair<std::string, std::string>> analyze_usage(const fs::path& root) {
    std::vector<std::pair<std::string, std::uintmax_t>> dir_sizes;

    for (const auto& entry : fs::directory_iterator(root, fs::directory_options::skip_permission_denied)) {
        if (fs::is_directory(entry)) {
            auto size = get_directory_size(entry.path());
            dir_sizes.emplace_back(entry.path().string(), size);
        }
    }

    std::sort(dir_sizes.begin(), dir_sizes.end(),
              [](const auto& a, const auto& b) { return a.second < b.second; });

    std::vector<std::pair<std::string, std::string>> result;
    for (const auto& [path, size] : dir_sizes)
        result.emplace_back(path, human_readable(size));

    return result;
}

void draw_ui(const std::vector<std::pair<std::string, std::string>>& data) {
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, TRUE);

    int height, width;
    getmaxyx(stdscr, height, width);

    int start = 0;
    int highlight = 0;

    while (true) {
        clear();
        mvprintw(0, 0, "Linux Disk Usage Analyzer - Press 'q' to Quit");
        mvhline(1, 0, '-', width);

        int visible_lines = height - 3;
        for (int i = 0; i < visible_lines && (start + i) < (int)data.size(); ++i) {
            if (highlight == (start + i)) {
                attron(A_REVERSE);
            }

            std::string name = data[start + i].first;
            std::string size = data[start + i].second;

            if ((int)name.length() > width - 15)
                name = name.substr(0, width - 18) + "...";

            mvprintw(i + 2, 0, "%-*s %12s", width - 15, name.c_str(), size.c_str());

            if (highlight == (start + i)) {
                attroff(A_REVERSE);
            }
        }

        int ch = getch();
        if (ch == 'q') break;
        else if (ch == KEY_UP && highlight > 0) --highlight;
        else if (ch == KEY_DOWN && highlight < (int)data.size() - 1) ++highlight;

        if (highlight < start) start = highlight;
        else if (highlight >= start + visible_lines) start = highlight - visible_lines + 1;
    }

    endwin();
}

int main(int argc, char* argv[]) {
    fs::path target_dir = ".";

    if (argc > 1)
        target_dir = argv[1];

    if (!fs::exists(target_dir) || !fs::is_directory(target_dir)) {
        std::cerr << "Invalid directory: " << target_dir << "\n";
        return 1;
    }

    auto data = analyze_usage(target_dir);
    draw_ui(data);
    return 0;
}






body {
    font-family: 'Segoe UI', sans-serif;
    margin: 0;
    padding: 20px;
    background: #f4f469;
    color: #333;
    transition: background 0.3s ease;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    font-size: 2.2em;
    text-shadow: 1px 1px 2px #ccc;
}

.toolbar {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}

.toolbar input[type="text"],
.toolbar input[type="date"] {
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    width: 200px;
    background: #fff;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    transition: all 0.2s ease-in-out;
}

.toolbar input[type="text"]:focus,
.toolbar input[type="date"]:focus {
    outline: none;
    border-color: #b3e0ff;
    box-shadow: 0 0 5px #b3e0ff;
}

.toolbar label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
}

.toolbar input[type="checkbox"] {
    transform: scale(1.2);
    transition: transform 0.2s ease-in-out;
}

table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    border: 1px solid #b3e0ff;
    overflow: hidden;
    transition: box-shadow 0.3s ease;
}

th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #b3e0ff;
    border-right: 1px solid #b3e0ff;
}

th {
    background-color: #b3e0ff;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: background 0.2s ease;
    white-space: nowrap;
}

th:hover {
    background-color: #e9f0f9;
}

th.sorted-asc::after,
th.sorted-desc::after {
    content: ' ‚ñº';
    font-weight: bold;
    font-size: 12px;
    margin-left: 4px;
    vertical-align: middle;
    line-height: 1;
}

th.sorted-desc::after {
    content: ' ‚ñ≤';
}

td.diff-positive {
    background-color: #daedda;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.diff-negative {
    background-color: #e8d7da;
    font-weight: bold;
    border-radius: 4px;
    transition: transform 0.2s ease;
}

td.max-elapsed {
    background-color: #fff3cd;
    font-weight: bold;
}

.page-title {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
}

.page-title .title-icon {
    width: 30px;
    height: 30px;
    position: absolute;
    left: 20px;
    top: 10px;
}

.page-title h1 {
    margin: 0;
    font-size: 28px;
}

/* Responsive */
@media (max-width: 769px) {
    .toolbar {
        flex-direction: column;
        align-items: center;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
    }
}





#!/usr/bin/env bash
set -euo pipefail

HTML_FILE="${1:-interactive_report.html}"

if [[ ! -f "$HTML_FILE" ]]; then
  echo "‚ùå HTML —Ñ–∞–π–ª—ä—Ç –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: $HTML_FILE" >&2
  exit 1
fi

# –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç HTML-–∞
csv=$(awk '/^const rawCSV = `$/,/^`;$/' "$HTML_FILE" | sed '1d;$d')

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –∏–º–∞ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ
if [[ -z "$csv" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV –¥–∞–Ω–Ω–∏ –≤—ä–≤ —Ñ–∞–π–ª–∞." >&2
  exit 1
fi

# –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–Ω–µ –≤ –º–∞—Å–∏–≤
IFS=$'\n' read -rd '' -a lines <<< "$csv"

# –ó–∞–≥–ª–∞–≤–∏—è
IFS=',' read -r -a headers <<< "${lines[0]}"
N_HEADERS=${#headers[@]}
N_JOBS=$(( ${#lines[@]} - 1 ))
N_DATES=$(( (N_HEADERS - 4) / 2 ))

echo "üìä Summary –∑–∞: $HTML_FILE"
echo "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî"
echo "–û–±—â–æ jobs:         $N_JOBS"
echo "–ë—Ä–æ–π –¥–∞—Ç–∏:         $N_DATES"
echo "–ö–æ–ª–æ–Ω–∏ (–æ–±—â–æ):     $N_HEADERS"
echo

# –°—É–º–∞—Ä–Ω–∏ –≤—Ä–µ–º–µ–Ω–∞ –ø–æ DateX
for ((d=0; d<N_DATES; d++)); do
  elapsed_idx=$((4 + 2*d + 1))
  total_sec=0
  count=0

  for ((i=1; i<=N_JOBS; i++)); do
    line="${lines[i]}"
    IFS=',' read -r -a fields <<< "$line"
    time="${fields[elapsed_idx]}"
    if [[ "$time" =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
      IFS=: read -r h m s <<< "$time"
      total_sec=$(( total_sec + h*3600 + m*60 + s ))
      ((count++))
    fi
  done

  if (( count > 0 )); then
    avg_sec=$(( total_sec / count ))
    hh=$(( avg_sec / 3600 ))
    mm=$(( (avg_sec % 3600) / 60 ))
    ss=$(( avg_sec % 60 ))
    printf "Date %d average:   %02d:%02d:%02d\n" "$((d+1))" "$hh" "$mm" "$ss"
  fi
done





#!/bin/bash

CONFIG_FILE="./config/hosts.list"
LOG_DIR="./logs/$(date +%F)"
USER="your_ssh_user"  # –ó–∞–º–µ–Ω–∏ —Å —Ä–µ–∞–ª–µ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∑–∞ SSH

mkdir -p "$LOG_DIR"

if [ ! -f "$CONFIG_FILE" ]; then
  echo "‚õî –ù–µ –µ –Ω–∞–º–µ—Ä–µ–Ω —Ñ–∞–π–ª: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  # –ü—Ä–æ–ø—É—Å–∫–∞ –ø—Ä–∞–∑–Ω–∏ —Ä–µ–¥–æ–≤–µ –∏ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏
  [[ -z "$HOST" || "$HOST" =~ ^# ]] && continue

  echo "üëâ –°–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST..."
  OUTPUT=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "–£—Å–ø–µ—à–Ω–æ –í–ª–∏–∑–∞–Ω–µ"' 2>&1)

  if [[ $? -eq 0 ]]; then
    echo "$HOST: ‚úÖ $OUTPUT"
    echo "$OUTPUT" > "$LOG_DIR/$HOST.log"
  else
    echo "$HOST: ‚ùå –ù–µ—É—Å–ø–µ—à–Ω–æ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ"
    echo "–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ: $OUTPUT" > "$LOG_DIR/$HOST.log"
  fi

done < "$CONFIG_FILE"






#!/bin/bash

CONFIG_FILE="./config/hosts.list"
USER="your_ssh_user"  # –°–º–µ–Ω–∏ —Ç–æ–≤–∞ —Å –≤–∞–ª–∏–¥–Ω–æ SSH –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –∏–º–µ

if [ ! -f "$CONFIG_FILE" ]; then
  echo "‚õî –ù–µ –µ –Ω–∞–º–µ—Ä–µ–Ω —Ñ–∞–π–ª: $CONFIG_FILE"
  exit 1
fi

while IFS= read -r HOST; do
  if [ -z "$HOST" ]; then continue; fi
  echo "üëâ –°–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST..."

  ssh -o BatchMode=yes -o ConnectTimeout=5 "$USER@$HOST" 'echo "–£—Å–ø–µ—à–Ω–æ –í–ª–∏–∑–∞–Ω–µ"' 2>/dev/null

  if [ $? -ne 0 ]; then
    echo "‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤—ä—Ä–∑–≤–∞–Ω–µ —Å $HOST"
  fi

done < "$CONFIG_FILE"





# –°—ä–∑–¥–∞–π –≥–ª–∞–≤–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
mkdir -p monitoring/{config,logs,tmp,scripts,results}

# –°—ä–∑–¥–∞–π –ø—Ä–∏–º–µ—Ä–Ω–∞ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ç–µ–∫—É—â–∞—Ç–∞ –¥–∞—Ç–∞ (–∑–∞ –ª–æ–≥–æ–≤–µ –∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏)
TODAY=$(date +%F)
mkdir -p monitoring/logs/$TODAY
mkdir -p monitoring/results/$TODAY

# –°—ä–∑–¥–∞–π –ø—Ä–∏–º–µ—Ä–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ config
touch monitoring/config/{main.conf,hosts.list,keywords.conf,env.properties}

# –°—ä–∑–¥–∞–π –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç–æ–≤–∏ —Ñ–∞–π–ª–æ–≤–µ
touch monitoring/scripts/{monitor_main.sh,ssh_runner.sh,check_disk.sh,check_memory.sh,check_services.sh,report_generator.sh}

# –°—ä–∑–¥–∞–π README —Ñ–∞–π–ª
touch monitoring/README.md

# –î–æ–±–∞–≤–∏ –ø—Ä–∞–≤–∞ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤–µ—Ç–µ
chmod +x monitoring/scripts/*.sh

# –ü–æ—Ç–≤—ä—Ä–∂–¥–µ–Ω–∏–µ
echo "‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ –Ω–∞ monitoring –µ —Å—ä–∑–¥–∞–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ."





const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

let fromx = null;
let tox = null;

for (let j = 1; j <= 35; j++) {
    const idx = headers.indexOf(`DateS${j}`);
    if (idx === -1) continue;

    if (fromx === null && row[idx] && parseInt(row[idx]) === fromval) fromx = j;
    if (tox === null && row[idx] && parseInt(row[idx]) === toval) tox = j;
    if (fromx !== null && tox !== null) break;
}

if (fromx !== null && tox !== null) {
    visibleCols.push(
        `DateS${fromx}`, `StartS${fromx}`, `StopS${fromx}`, `ElapsedS${fromx}`,
        `DateS${tox}`, `StartS${tox}`, `StopS${tox}`, `ElapsedS${tox}`
    );
    insertDiffAfter = headers.indexOf(`ElapsedS${tox}`);
}






function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromRaw = datefrom.value;
    const toRaw = dateto.value;
    const compare = compareCheckbox.checked;

    let filtered = csvData.filter(row =>
        row.join(" ").toLowerCase().includes(keyword)
    );

    const baseCols = headers.slice(0, 5);
    let visibleCols = [...baseCols];
    let insertDiffAfter = null;

    if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        let fromIdx = -1;
        let toIdx = -1;

        for (let i = 0; i < 35; i++) {
            const idx = headers.indexOf(`DateS${i}`);
            if (idx === -1) continue;

            if (fromIdx === -1 && filtered.some(row => parseInt(row[idx]) === fromval)) fromIdx = i;
            if (toIdx === -1 && filtered.some(row => parseInt(row[idx]) === toval)) toIdx = i;
            if (fromIdx !== -1 && toIdx !== -1) break;
        }

        if (fromIdx !== -1 && toIdx !== -1) {
            visibleCols.push(
                `DateS${fromIdx}`, `StartS${fromIdx}`, `StopS${fromIdx}`, `ElapsedS${fromIdx}`,
                `DateS${toIdx}`, `StartS${toIdx}`, `StopS${toIdx}`, `ElapsedS${toIdx}`
            );
            insertDiffAfter = headers.indexOf(`ElapsedS${toIdx}`);
        }
    } else if (fromRaw || toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10) || null;
        const toval = parseInt(toRaw.replaceAll("-", ""), 10) || null;

        for (let i = 0; i < 35; i++) {
            const dateKey = `DateS${i}`;
            const idx = headers.indexOf(dateKey);
            if (idx === -1) continue;

            const col = dateKey;
            const rowVal = row => parseInt(row[idx]);

            let hasMatch = false;

            if (fromval && toval) {
                hasMatch = row => {
                    const val = rowVal(row);
                    return val >= fromval && val <= toval;
                };
            } else if (fromval) {
                hasMatch = row => rowVal(row) === fromval;
            } else if (toval) {
                hasMatch = row => rowVal(row) === toval;
            }

            if (hasMatch && filtered.some(hasMatch)) {
                visibleCols.push(`DateS${i}`, `StartS${i}`, `StopS${i}`, `ElapsedS${i}`);
            }
        }
    } else {
        visibleCols = headers;
    }

    if (currentSort.index >= 0) {
        filtered.sort((a, b) => {
            const valA = a[currentSort.index] || "";
            const valB = b[currentSort.index] || "";
            return currentSort.direction === 1
                ? valA.localeCompare(valB)
                : valB.localeCompare(valA);
        });
    } else if (compare && fromRaw && toRaw) {
        const fromval = parseInt(fromRaw.replaceAll("-", ""), 10);
        const toval = parseInt(toRaw.replaceAll("-", ""), 10);
        const from = Math.min(fromval, toval);
        const to = Math.max(fromval, toval);

        const idx = headers.indexOf("DateS3");
        if (idx === -1) return;

        for (let i = 0; i < 35; i++) {
            const testIdx = headers.indexOf(`DateS${i}`);
            if (testIdx === -1) continue;

            filtered = filtered.map(row => {
                const fromIdx = headers.indexOf(`ElapsedS${from}`);
                const toIdx = headers.indexOf(`ElapsedS${to}`);
                const fromElapsed = row[fromIdx] || null;
                const toElapsed = row[toIdx] || null;

                let diff = null;
                if (fromElapsed && toElapsed) {
                    diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                }

                return {
                    row,
                    diff
                };
            });

            filtered.sort((a, b) =>
                currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff
            );

            filtered = filtered.map(obj => obj.row);
        }
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}






const valFrom = parseInt(datefrom.value.replaceAll("-", ""), 10);
const valTo = parseInt(dateto.value.replaceAll("-", ""), 10);

// –û—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
let fromval = valFrom;
let toval = valTo;

// –ó–∞ –¥–∞ —Ä–∞–±–æ—Ç–∏ range –ø—Ä–∞–≤–∏–ª–Ω–æ
const from = Math.min(valFrom, valTo);
const to = Math.max(valFrom, valTo);





let fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
let toval = parseInt(dateto.value.replaceAll("-", ""), 10);

if (fromval > toval) {
    [fromval, toval] = [toval, fromval];
}







<script>



const csvData = 'UI_DATA';

let data = [];
let headers = [];
let currentSort = {
    index: -1,
    direction: 1
};

const textFilter = document.getElementById("textFilter");
const datefrom = document.getElementById("datefrom");
const dateto = document.getElementById("dateto");
const compareCheckbox = document.getElementById("compareCheckbox");
const dataTable = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function msToSeconds(ms) {
    const [h, m, s] = ms.split(':').map(Number);
    return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
    const negative = sec < 0;
    sec = Math.abs(sec);
    const h = String(Math.floor(sec / 3600)).padStart(2, '0');
    const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
    const s = String(sec % 60).padStart(2, '0');
    return (negative ? '-' : '') + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
    const fromval = datefrom.value;
    const toval = dateto.value;
    const enabled = !!(fromval && toval);
    compareCheckbox.disabled = !enabled;

    if (!enabled) {
        compareCheckbox.checked = false;
        currentSort.index = -1;
        direction = 1;
    }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
    dataTable.innerHTML = "";
    headerRow.innerHTML = "";

    const visibleIndexes = visibleCols.map(col => headers.indexOf(col));

    visibleCols.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;
        const idx = headers.indexOf(col);
        th.classList.add("sortable");
        if (idx === currentSort.index) {
            th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        }
        th.onclick = () => {
            if (idx === currentSort.index) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = idx;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(th);
    });

    if (compareCheckbox.checked && currentSort.index === -1) {
        const thDiff = document.createElement("th");
        thDiff.textContent = "Difference";
        thDiff.classList.add("sortable");
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
        thDiff.onclick = () => {
            if (currentSort.index === -1) {
                currentSort.direction = (currentSort.direction * -1);
            } else {
                currentSort.index = -1;
                currentSort.direction = 1;
            }
            filterData();
        };
        headerRow.appendChild(thDiff);
    }

    rows.forEach(row => {
        const tr = document.createElement("tr");

        let maxElapsed = 0;
        let maxIndexes = [];

        headers.forEach((head, i) => {
            if (/Elapsed\d+/.test(head) && row[i]) {
                const sec = msToSeconds(row[i]);
                if (sec > maxElapsed) {
                    maxElapsed = sec;
                    maxIndexes = [i];
                } else if (sec === maxElapsed) {
                    maxIndexes.push(i);
                }
            }
        });

        visibleIndexes.forEach(i => {
            const td = document.createElement("td");
            td.textContent = row[i];
            if (maxIndexes.includes(i)) {
                td.classList.add("max-elapsed");
            }
            tr.appendChild(td);
        });

        if (compareCheckbox.checked && diffAfterIndex) {
            const idx = headers.indexOf("DateS(3)");
            if (idx === -1) return;

            const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
            const toval = parseInt(dateto.value.replaceAll("-", ""), 10);
            const dateval = parseInt(row[idx].replaceAll("-", ""), 10);
            if (isNaN(dateval) || dateval < fromval || dateval > toval) return;

            const fromIdx = headers.indexOf(`Elapsed${fromval}`);
            const toIdx = headers.indexOf(`Elapsed${toval}`);
            const fromElapsed = fromIdx >= 0 ? row[fromIdx] : null;
            const toElapsed = toIdx >= 0 ? row[toIdx] : null;

            const tdDiff = document.createElement("td");
            if (fromElapsed && toElapsed) {
                const diff = msToSeconds(toElapsed) - msToSeconds(fromElapsed);
                tdDiff.textContent = secondsToHMS(diff);
                tdDiff.classList.add(diff < 0 ? "diff-negative" : "diff-positive");
            }
            tr.appendChild(tdDiff);
        }

        dataTable.appendChild(tr);
    });
}

function filterData() {
    updateCompareCheckbox();

    const keyword = textFilter.value.toLowerCase();
    const fromval = parseInt(datefrom.value.replaceAll("-", ""), 10);
    const toval = parseInt(dateto.value.replaceAll("-", ""), 10);

    let from = Math.min(fromval, toval);
    let to = Math.max(fromval, toval);

    let visibleCols = headers.slice(0, 5); // –ø—ä—Ä–≤–∏—Ç–µ 5 (DateS, Start, Stop, Elapsed)

    const dateIndexes = [];
    for (let i = 0; i < 35; i++) {
        const colDate = new Date();
        colDate.setDate(colDate.getDate() - i);
        const dateStr = colDate.toISOString().slice(0, 10).replaceAll("-", "");
        dateIndexes.push(dateStr);
    }

    if (compareCheckbox.checked && from && to) {
        const filteredDates = dateIndexes.filter(date => {
            const val = parseInt(date);
            return val >= from && val <= to;
        });

        visibleCols = [];

        filteredDates.forEach(d => {
            visibleCols.push(`DateS(${d})`, `StartS(${d})`, `StopS(${d})`, `ElapsedS(${d})`);
        });
    } else {
        visibleCols = headers;
    }

    const filtered = data.filter(row => {
        const rowStr = row.join(" ").toLowerCase();
        return rowStr.includes(keyword);
    });

    const insertDiffAfter = headers.indexOf(`ElapsedS(${toval})`);

    if (compareCheckbox.checked && from && to) {
        filtered.sort((a, b) => {
            const fromIdx = headers.indexOf(`Elapsed${from}`);
            const toIdx = headers.indexOf(`Elapsed${to}`);
            const aDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(a[toIdx]) - msToSeconds(a[fromIdx]) : 0;
            const bDiff = fromIdx >= 0 && toIdx >= 0 ? msToSeconds(b[toIdx]) - msToSeconds(b[fromIdx]) : 0;
            return (currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff);
        });
    }

    buildTable(filtered, visibleCols, insertDiffAfter);
}

function parseCSV(csv) {
    const lines = csv.trim().split('\n');
    headers = lines[0].split(',');
    data = lines.slice(1).map(line => line.split(','));
}

textFilter.addEventListener("input", filterData);
datefrom.addEventListener("input", filterData);
dateto.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
    if (compareCheckbox.checked && currentSort.index === -1) {
        currentSort.direction = 1;
    }
    filterData();
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
parseCSV(csvData);
filterData();
</script>





const row = data[0]; // only the first row
const val = row[dateIndex];
let hasMatch = false;

if (val && /^\d{8}$/.test(val)) {
  const valInt = parseInt(val);
  if (fromInt && toInt) {
    hasMatch = valInt >= fromInt && valInt <= toInt;
  } else if (fromInt) {
    hasMatch = valInt === fromInt;
  } else if (toInt) {
    hasMatch = valInt === toInt;
  }
}





const hasMatch = data.some(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  return (
    (fromInt && !toInt && valInt === fromInt) ||
    (!fromInt && toInt && valInt === toInt) ||
    (fromInt && toInt && valInt >= fromInt && valInt <= toInt)
  );
});




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2
Running,Load,202405,JobA,20250429,10:00,10:30,00:30:00,20250430,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20250429,11:00,11:30,00:30:00,20250430,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20250429,12:00,12:20,00:20:00,20250430,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function buildTable(rows, visibleCols, diffColIndex = null, diffs = []) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const index = headers.indexOf(col);
    if (index === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === index) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (diffColIndex !== null && index === diffColIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");
    visibleCols.forEach((col, colIdx) => {
      const i = headers.indexOf(col);
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      tr.appendChild(td);

      if (diffColIndex !== null && i === diffColIndex) {
        const tdDiff = document.createElement("td");
        const diffVal = diffs[idx];
        if (diffVal !== null) {
          tdDiff.textContent = secondsToHMS(diffVal);
          tdDiff.className = diffVal < 0 ? "diff-negative" : "diff-positive";
        }
        tr.appendChild(tdDiff);
      }
    });
    table.appendChild(tr);
  });
}

function filterData() {
  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;
  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let diffIndex = null;
  let diffs = [];

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const fromDate = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
  const toDate = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

  if (compare && fromDate && toDate) {
    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
    }
    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      diffIndex = headers.indexOf(`Elapsed${toX}`);
      diffs = filtered.map(row => {
        const from = row[headers.indexOf(`Elapsed${fromX}`)];
        const to = row[headers.indexOf(`Elapsed${toX}`)];
        return (from && to) ? hmsToSeconds(to) - hmsToSeconds(from) : null;
      });
    }
  } else if (fromDate || toDate) {
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      const valid = data.every(row => {
        const val = row[idx];
        if (!val) return false;
        const valInt = parseInt(val);
        if (fromDate && !toDate) return valInt === fromDate;
        if (!fromDate && toDate) return valInt === toDate;
        return valInt >= fromDate && valInt <= toDate;
      });
      if (valid) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.index >= 0 && currentSort.direction > 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2 && currentSort.direction > 0) {
    filtered = filtered
      .map((row, i) => ({ row, diff: diffs[i] || 0 }))
      .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
      .map(obj => obj.row);
  }

  buildTable(filtered, visibleCols, diffIndex, diffs);
}

parseCSV(csvData);
textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

filterData();
</script>

</body>
</html>






const valid = data.every(row => {
  const val = row[dateIndex];
  if (!val || !/^\d{8}$/.test(val)) return false;
  const valInt = parseInt(val);
  if (fromInt && !toInt) return valInt === fromInt;
  if (!fromInt && toInt) return valInt === toInt;
  return valInt >= fromInt && valInt <= toInt;
});






#!/usr/bin/env python3

import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º—è–Ω–∞ –Ω–∞ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# –í–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –¥–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞
all_files = [f for f in glob.glob("JT*.csv") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]

if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# –ü–∞—Ä—Å–≤–∞–º–µ –≤—Å–∏—á–∫–∏ —Ñ–∞–π–ª–æ–≤–µ –∏ –ø—ä–ª–Ω–∏–º data[key][idx]
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue

            stage, batch, job = parts[0], parts[1], parts[2]
            date   = parts[3]
            start  = parts[4]
            stop   = parts[5]
            elapsed = parts[6]

            try:
                secs = parse_time(elapsed)
            except:
                continue

            key = (stage, batch, job)
            d = data.setdefault(key, {})
            d.setdefault(idx, {})["date"] = date
            d[idx]["start"] = start
            d[idx]["stop"] = stop
            d[idx]["elapsed"] = elapsed
            d[idx]["secs"] = secs

            if dates[idx] is None:
                dates[idx] = date

# –ü–∏—à–µ–º –Ω–∞ CSV –Ω–∞ stdout ‚Äî
out = csv.writer(sys.stdout, lineterminator="\n")

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME", "AVERAGE"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Start{i}", f"Stop{i}", f"Elapsed{i}"]
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á –≥–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –ø–æ –µ–¥–∏–Ω —Ä–µ–¥
for key in sorted(data.keys()):
    rec = ["" for _ in range(5)]  # STATUS, STAGE, BATCH, JOB.NAME, AVERAGE
    rec[1:4] = list(key)

    d = data[key]

    # –°—Ç–∞—Ç—É—Å: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–æ (idx=0) –∏ –ø–æ—Å–ª–µ–¥–Ω–æ (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)

    if s1 and sN:
        if sN > s1:
            status = "‚Üë"
        elif sN < s1:
            status = "‚Üì"
        else:
            status = "="
    else:
        status = "-"
    rec[0] = status

    # –°–ø–∏—Å—ä–∫ –∑–∞ –≤—Å–∏—á–∫–∏ secs, –∑–∞ —Å–º—è—Ç–∞–Ω–µ –Ω–∞ —Å—Ä–µ–¥–Ω–æ
    secs_list = []

    # –ü–æ –¥–≤–æ–π–∫–∏ Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["start"])
            rec.append(info["stop"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", "", "", ""]

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh = avg // 3600
        mm = (avg % 3600) // 60
        ss = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""

    rec[4] = avg_str  # –í–º—ä–∫–≤–∞–º–µ —Å–ª–µ–¥ "JOB.NAME"

    out.writerow(rec)






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Viewer</title>
  <link rel="icon" href="https://jobmarketforyoungresearchers.be/files/attachments/.2877641!320h320!0853_kbc!openduw_pmF" />
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #f4f4f4;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    .table-wrapper {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      border: 1px solid #dee2ff;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border: 1px solid #dee2ff;
    }

    th {
      background-color: #b0c8ff;
      cursor: pointer;
      user-select: none;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    th.sorted.asc::after,
    th.sorted.desc::after {
      content: "";
      display: inline-block;
      width: 0;
      height: 0;
      margin-left: 10px;
      vertical-align: middle;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
    }

    th.sorted.asc::after {
      border-bottom: 5px solid black;
    }

    th.sorted.desc::after {
      border-top: 5px solid black;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d6f0da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f7d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff6cd;
      font-weight: bold;
      border-radius: 4px;
    }

    /* Sticky column styles */
    th.sticky-col, td.sticky-col {
      position: sticky;
      background: white;
      z-index: 2;
    }

    th.sticky-0, td.sticky-0 { left: 0; }
    th.sticky-1, td.sticky-1 { left: 120px; }
    th.sticky-2, td.sticky-2 { left: 240px; }
    th.sticky-3, td.sticky-3 { left: 360px; }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <h1>JST Advanced Viewer</h1>

  <div class="toolbar">
    <label>
      <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job..." />
    </label>
    <label>
      <input type="date" id="dateFrom" />
    </label>
    <label>
      <input type="checkbox" id="compareCheckbox" /> Compare
    </label>
  </div>

  <div class="table-wrapper">
    <table id="dataTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const csvData = `Status,Stage,Batch,Job.name,Date1,Start1,Stop1,Elapsed1
OK,Stage1,BatchA,JobX,2025-05-20,10:00,10:05,00:05
FAIL,Stage2,BatchB,JobY,2025-05-20,09:00,09:30,00:30
OK,Stage1,BatchA,JobX,2025-05-21,10:00,10:07,00:07
FAIL,Stage2,BatchB,JobY,2025-05-21,09:00,09:20,00:20`;

    let data = [];
    let currentSort = { index: null, direction: 1 };

    const textFilter = document.getElementById("textFilter");
    const dateFrom = document.getElementById("dateFrom");
    const compareCheckbox = document.getElementById("compareCheckbox");
    const table = document.getElementById("dataTable");
    const headerRow = document.getElementById("headerRow");
    const tbody = table.querySelector("tbody");

    function msToSeconds(ms) {
      const [m, s] = ms.split(":").map(Number);
      return m * 60 + s;
    }

    function secondsToHMS(sec) {
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2, "0")}`;
    }

    function buildTable(headers, visibleRows, diffAfter) {
      headerRow.innerHTML = "";
      tbody.innerHTML = "";

      headers.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;

        if (["Status", "Stage", "Batch", "Job.name"].includes(col)) {
          th.classList.add("sticky-col", `sticky-${i}`);
        }

        if (currentSort.index === i) {
          th.classList.add("sorted", currentSort.direction === 1 ? "asc" : "desc");
        }

        th.onclick = () => {
          if (currentSort.index === i) {
            currentSort.direction *= -1;
          } else {
            currentSort.index = i;
            currentSort.direction = 1;
          }
          filterData();
        };

        headerRow.appendChild(th);
      });

      visibleRows.forEach((row, rIndex) => {
        const tr = document.createElement("tr");

        row.forEach((cell, i) => {
          const td = document.createElement("td");
          td.textContent = cell;

          if (["Status", "Stage", "Batch", "Job.name"].includes(headers[i])) {
            td.classList.add("sticky-col", `sticky-${i}`);
          }

          if (i === diffAfter?.index && diffAfter[rIndex]?.diff != null) {
            td.classList.add(diffAfter[rIndex].diff > 0 ? "diff-positive" : "diff-negative");
          }

          if (diffAfter?.max === msToSeconds(cell)) {
            td.classList.add("max-elapsed");
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });
    }

    function filterData() {
      const keyword = textFilter.value.toLowerCase();
      const from = dateFrom.value;
      const compare = compareCheckbox.checked;

      let filtered = data.filter(row => row.join(",").toLowerCase().includes(keyword));
      if (from) {
        filtered = filtered.filter(row => row[4] >= from);
      }

      let diffAfter = null;
      if (compare) {
        diffAfter = [];
        const grouped = {};
        filtered.forEach(r => {
          const key = `${r[0]}-${r[1]}-${r[2]}-${r[3]}`;
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(r);
        });

        filtered = [];
        for (const key in grouped) {
          const group = grouped[key];
          if (group.length >= 2) {
            const g = group.slice(-2);
            const v1 = msToSeconds(g[0][7]);
            const v2 = msToSeconds(g[1][7]);
            const diff = v2 - v1;

            diffAfter.push({ index: 7, diff, max: Math.max(v1, v2) });
            filtered.push(...g);
          }
        }
      }

      if (currentSort.index !== null) {
        filtered.sort((a, b) => {
          const valA = a[currentSort.index];
          const valB = b[currentSort.index];
          return currentSort.direction * valA.localeCompare(valB);
        });
      }

      buildTable(data[0], filtered, diffAfter);
    }

    function parseCSV(csv) {
      return csv.split("\n").map(row => row.split(","));
    }

    data = parseCSV(csvData);
    buildTable(data[0], data.slice(1));
    
    textFilter.addEventListener("input", filterData);
    dateFrom.addEventListener("input", filterData);
    compareCheckbox.addEventListener("change", filterData);
  </script>
</body>
</html>






csv_file = 'your_file.csv'
html_file = 'your_file.html'
output_file = 'output.html'

# Read the CSV content
with open(csv_file, 'r', encoding='utf-8') as f:
    csv_content = f.read()

# Escape for JavaScript
escaped_csv = csv_content.replace('\\', '\\\\') \
                         .replace('\n', '\\n') \
                         .replace('"', '\\"')

# Read the HTML file
with open(html_file, 'r', encoding='utf-8') as f:
    html_content = f.read()

# Replace fancy quotes with standard and inject CSV
html_content = html_content.replace("‚Äò", "'").replace("‚Äô", "'")
updated_html = html_content.replace("'JT_DATA'", f'"{escaped_csv}"')

# Save to output
with open(output_file, 'w', encoding='utf-8') as f:
    f.write(updated_html)

print(f"Injected CSV data into '{output_file}' successfully.")





#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# Parse arguments
if len(sys.argv) < 4:
    print("Usage: python3 monitor.py <jt_dir> <days> <html_template_file>")
    sys.exit(1)

files_dir = sys.argv[1]
try:
    n = int(sys.argv[2])
except ValueError:
    n = 31
template_path = sys.argv[3]

# Collect .jt files
files = []
if os.path.isdir(files_dir):
    files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
    files = sorted(files, key=os.path.getmtime)[-n:]
    if not files:
        sys.exit("No JT files found.")
else:
    sys.exit("Invalid directory.")

# Extract and collect data
data = {}
dates = [None] * len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            key = (parts[0], parts[1], parts[2])
            date = parts[3]
            start, stop, elapsed = parts[5], parts[6], parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            data.setdefault(key, {})[idx] = {
                "date": date, "start": start, "stop": stop,
                "elapsed": elapsed, "secs": secs
            }
            if dates[idx] is None:
                dates[idx] = date

# Create output lines
out_lines = []

header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

for key in sorted(data.keys()):
    status = "-"
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0: status = "NEW"
    elif s > 0 and e == 0: status = "LOST"
    elif s > 0 and e > s: status = "SLOW"
    elif s == e and s > 0: status = "STABLE"

    rec = [status, *key]
    secs_list = []

    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""),
                    info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    if secs_list:
        total = sum(secs_list)
        avg = total // len(secs_list)
        avg_str = f"{avg//3600:02d}:{(avg%3600)//60:02d}:{avg%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)
    out_lines.append(','.join(str(x) for x in rec))

# Escape lines and join with JS newline
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

# Replace in HTML template
with open(template_path, 'r', encoding='utf-8') as f:
    html_content = f.read()

new_content = html_content.replace(
    "const csvData = '';",
    f"const csvData = '{csv_string}';"
)

with open(template_path, 'w', encoding='utf-8') as f:
    f.write(new_content)

print(f"Injected data into: {template_path}")







#!/usr/bin/env python3
import os, sys, csv
import glob
import html

def parse_time(t):
    """–ü—Ä–µ–æ–±—Ä–∞–∑ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.strip().split(':')
    return (int(h) * 3600 + int(m) * 60 + int(s))

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

files_dir = arg1
try:
    n = int(arg2) if arg2 else 31
except ValueError:
    n = 31

# –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ
files = []
if os.path.isdir(files_dir):
    try:
        files = [f for f in glob.glob(os.path.join(files_dir, "*")) if os.path.isfile(f)]
        files = sorted(files, key=os.path.getmtime)[-n:]
        if not files:
            sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ .JT –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")
    except Exception as e:
        sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è {files_dir}: {e}")
else:
    sys.exit("–ù–µ–≤–∞–ª–∏–¥–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è.")

# –î–∞–Ω–Ω–∏
data = {}
dates = [None] * len(files)

# –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª
for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage_batch_job = (parts[0], parts[1], parts[2])
            date     = parts[3]
            start    = parts[5]
            stop     = parts[6]
            elapsed  = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0

            key = stage_batch_job
            data.setdefault(key, {})[idx] = {
                "start": start,
                "stop": stop,
                "elapsed": elapsed,
                "secs": secs,
                "date": date
            }

            if dates[idx] is None:
                dates[idx] = date

# --- –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ CSV —Ä–µ–¥–æ–≤–µ ---
out_lines = []

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(len(files)):
    header += [f"Date({i})", f"Start({i})", f"Stop({i})", f"Elapsed({i})"]
header += ["AVERAGE"]
out_lines.append(','.join(header))

# –ü–æ –∫–ª—é—á
for key in sorted(data.keys()):
    status = ""
    secs_list = []

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ STATUS
    s = data.get(key, {}).get(0, {}).get("secs", 0)
    e = data.get(key, {}).get(len(files)-1, {}).get("secs", 0)
    if s == 0 and e > 0:
        status = "NEW"
    elif s > 0 and e == 0:
        status = "LOST"
    elif s > 0 and e > s:
        status = "SLOW"
    elif s == e and s > 0:
        status = "STABLE"
    else:
        status = "-"

    rec = [status, *key]

    # –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
    for idx in range(len(files)):
        info = data.get(key, {}).get(idx)
        if info:
            rec += [info.get("date", ""), info.get("start", ""), info.get("stop", ""), info.get("elapsed", "")]
            secs_list.append(info.get("secs", 0))
        else:
            rec += ["", "", "", ""]
            secs_list.append(0)

    # –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ AVERAGE
    if secs_list:
        s = sum(secs_list)
        m = s // len(secs_list)
        avg_str = f"{m//3600:02d}:{(m%3600)//60:02d}:{m%60:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out_lines.append(','.join(str(x) for x in rec))

# --- –ó–∞–ø–∏—Å –∫–∞—Ç–æ JS –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ ---
csv_string = '\\n'.join(html.escape(line) for line in out_lines)

with open("csv_output.js", 'w', encoding='utf-8') as f:
    f.write(f"const csvData = '{csv_string}';\n")

print("–ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω —Ñ–∞–π–ª: csv_output.js")





import os
import csv
import sys
import html

def find_all_files(root_dir):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    try:
        with open(file_path, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile)
            for i, row in enumerate(reader, start=1):
                if i in rows_to_print:
                    line = ','.join(row)
                    output_lines.append(line)
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python csv_to_js_var.py <root_directory> <output_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    output_file = sys.argv[2]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_all_files(root_directory)

    if not files:
        print("No files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"Output written to {output_file}")






import os
import csv
import sys
import html

def find_files_by_date(root_dir, date_mask):
    matches = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if date_mask in filename:
                matches.append(os.path.join(dirpath, filename))
    return matches

def extract_csv_rows(file_path, rows_to_print):
    output_lines = []
    with open(file_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        for i, row in enumerate(reader, start=1):
            if i in rows_to_print:
                line = ','.join(row)
                output_lines.append(line)
    return output_lines

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python csv_to_js_var.py <root_directory> <date_mask> <output_html_file>")
        sys.exit(1)

    root_directory = sys.argv[1]
    date_mask = sys.argv[2]
    output_html_file = sys.argv[3]

    rows_to_print = {1, 2, 3, 4, 6, 7, 8}
    files = find_files_by_date(root_directory, date_mask)

    if not files:
        print("No matching files found.")
        sys.exit(0)

    csv_lines = []
    for file in files:
        csv_lines += extract_csv_rows(file, rows_to_print)

    csv_string = '\\n'.join(html.escape(line) for line in csv_lines)
    js_line = f"const csvData = '{csv_string}';\n"

    with open(output_html_file, 'w', encoding='utf-8') as f:
        f.write(js_line)

    print(f"JavaScript CSV data written to {output_html_file}")




.page-title {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 20px;
}

.page-title .title-icon {
  width: 36px;
  height: 36px;
}

.page-title h1 {
  margin: 0;
  font-size: 28px;
  color: #0059b3;
}




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach((col) => {
    const th = document.createElement("th");
    const colIndex = headers.indexOf(col);
    th.textContent = col;
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach(row => {
    const tr = document.createElement("tr");

    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          tdDiff.setAttribute("data-diff", diff);
        }
        tr.appendChild(tdDiff);
      }
    });

    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = data.filter(row =>
    row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
  );

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromVal = parseInt(fromRaw.replaceAll("-", ""));
    const toVal = parseInt(toRaw.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromVal)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toVal)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      const rowsWithDiff = filtered.map(row => {
        const fromVal = parseInt(dateFrom.value.replaceAll("-", ""));
        const toVal = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;
        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromVal) fromX = j;
          if (toX === null && parseInt(row[idx]) === toVal) toX = j;
        }
        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;
        let diff = 0;
        if (fromElapsed && toElapsed) {
          diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
        }
        return { row, diff };
      });

      filtered = rowsWithDiff
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(obj => obj.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>








} else if (currentSort.index === -2) {
  const diffs = [];
  filtered.forEach(row => {
    const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
    const toDate = parseInt(dateTo.value.replaceAll("-", ""));
    let fromX = null, toX = null;

    for (let j = 1; j <= 31; j++) {
      const idx = headers.indexOf(`Date${j}`);
      if (idx === -1) continue;
      if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
      if (toX === null && parseInt(row[idx]) === toDate) toX = j;
    }

    const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
    const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

    let diff = 0;
    if (fromElapsed && toElapsed) {
      diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
    }

    diffs.push({ row, diff });
  });

  filtered = diffs
    .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
    .map(item => item.row);
}






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #e6f2fb;
      color: #003366;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #0059b3;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #99ccf3;
      border-radius: 6px;
      width: 200px;
      background: #ffffff;
      color: #003366;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      color: #003366;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.2);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #cce5ff;
    }

    th {
      background: #cce5ff;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      color: #003366;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
      display: inline-block;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1;
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-asc::after { content: " ü°ª"; }
    th.sorted-desc::after { content: " ü°π"; }

    tr:hover {
      background-color: #f0f8ff;
    }

    td.diff-positive {
      background-color: #d0f0ff;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #ffd6d6;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff4cc;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date7,Start7,Stop7,Elapsed7,Date12,Start12,Stop12,Elapsed12
Running,Load,202405,JobA,20240501,10:00,10:30,00:30:00,20250501,10:00,10:40,00:40:00,20250507,10:00,11:00,01:00:00
Success,Transform,202405,JobB,20240501,11:00,11:30,00:30:00,20250501,11:00,11:45,00:45:00,20250507,11:00,12:00,01:00:00
Failed,Load,202405,JobC,20240501,12:00,12:20,00:20:00,20250501,12:00,12:30,00:30:00,20250507,12:00,13:00,01:00:00`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");
const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols, diffAfterIndex) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;
  currentDiffs = [];

  visibleCols.forEach((col, colIdx) => {
    const th = document.createElement("th");
    th.textContent = col;
    const colIndex = headers.indexOf(col);
    if (colIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === colIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: colIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && colIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  rows.forEach((row, rowIndex) => {
    const tr = document.createElement("tr");
    let maxElapsed = -1;
    let maxIndexes = [];

    headers.forEach((h, i) => {
      if (/^Elapsed\d+$/.test(h) && row[i]) {
        const sec = hmsToSeconds(row[i]);
        if (sec > maxElapsed) {
          maxElapsed = sec;
          maxIndexes = [i];
        } else if (sec === maxElapsed) {
          maxIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] || "";
      if (maxIndexes.includes(i)) td.classList.add("max-elapsed");
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDate = parseInt(dateFrom.value.replaceAll("-", ""));
        const toDate = parseInt(dateTo.value.replaceAll("-", ""));
        let fromX = null, toX = null;

        for (let j = 1; j <= 31; j++) {
          const idx = headers.indexOf(`Date${j}`);
          if (idx === -1) continue;
          if (fromX === null && parseInt(row[idx]) === fromDate) fromX = j;
          if (toX === null && parseInt(row[idx]) === toDate) toX = j;
        }

        const fromElapsed = fromX ? row[headers.indexOf(`Elapsed${fromX}`)] : null;
        const toElapsed = toX ? row[headers.indexOf(`Elapsed${toX}`)] : null;

        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diff = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          tdDiff.textContent = secondsToHMS(diff);
          tdDiff.className = diff < 0 ? "diff-negative" : "diff-positive";
          diffValue = diff;
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[rowIndex] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];
  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromDate = parseInt(fromRaw.replaceAll("-", ""));
    const toDate = parseInt(toRaw.replaceAll("-", ""));

    let fromX = null, toX = null;
    for (let i = 1; i <= 31; i++) {
      const idx = headers.indexOf(`Date${i}`);
      if (idx === -1) continue;
      if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) fromX = i;
      if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) toX = i;
      if (fromX && toX) break;
    }

    if (fromX && toX) {
      visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
      visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
      insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
    }
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction !== 0) {
    if (currentSort.index >= 0) {
      filtered.sort((a, b) => {
        const valA = a[currentSort.index] || "";
        const valB = b[currentSort.index] || "";
        return currentSort.direction === 1 ? valA.localeCompare(valB) : valB.localeCompare(valA);
      });
    } else if (currentSort.index === -2) {
      filtered = filtered
        .map((row, i) => ({ row, diff: currentDiffs[i] || 0 }))
        .sort((a, b) => currentSort.direction === 1 ? a.diff - b.diff : b.diff - a.diff)
        .map(item => item.row);
    }
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>

</body>
</html>





const fromDate = parseInt(fromRaw.replaceAll("-", ""));
const toDate = parseInt(toRaw.replaceAll("-", ""));

let fromX = null, toX = null;

for (let i = 1; i <= 31; i++) {
  const idx = headers.indexOf(`Date${i}`);
  if (idx === -1) continue;

  if (fromX === null && data.some(row => parseInt(row[idx]) === fromDate)) {
    fromX = i;
  }

  if (toX === null && data.some(row => parseInt(row[idx]) === toDate)) {
    toX = i;
  }

  if (fromX !== null && toX !== null) break;
}

if (fromX !== null && toX !== null) {
  visibleCols.push(...[`Date${fromX}`, `Start${fromX}`, `Stop${fromX}`, `Elapsed${fromX}`]);
  visibleCols.push(...[`Date${toX}`, `Start${toX}`, `Stop${toX}`, `Elapsed${toX}`]);
  insertDiffAfter = headers.indexOf(`Elapsed${toX}`);
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Viewer with Compare</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #f4f6f9;
      color: #333;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toolbar input[type="text"],
    .toolbar input[type="date"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 200px;
      background: #fff;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }

    .toolbar input[type="checkbox"] {
      transform: scale(1.2);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    th {
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
    }

    th.sorted-asc::after {
      content: " ü°ª";
      font-weight: bold;
      font-size: 12px;
    }

    th.sorted-desc::after {
      content: " ü°π";
      font-weight: bold;
      font-size: 12px;
    }

    tr:hover {
      background-color: #f9f9f9;
    }

    td.diff-positive {
      background-color: #d4edda;
      font-weight: bold;
      border-radius: 4px;
    }

    td.diff-negative {
      background-color: #f8d7da;
      font-weight: bold;
      border-radius: 4px;
    }

    td.max-elapsed {
      background-color: #fff3cd;
      font-weight: bold;
    }
    
    th {
        white-space: nowrap;
    }

    th.sorted-asc::after,
    th.sorted-desc::after {
        display: inline-block;
        margin-left: 4px;
        vertical-align: middle;
        line-height: 1;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: center;
      }

      .toolbar input[type="text"],
      .toolbar input[type="date"] {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

<h1>CSV Viewer with Compare</h1>

<div class="toolbar">
  <input type="text" id="textFilter" placeholder="Filter: Status, Stage, Batch, Job Name">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <label><input type="checkbox" id="compareCheckbox"> Compare</label>
</div>

<table id="dataTable">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<script>
const csvData = `STATUS,STAGE,BATCH,JOB.NAME,Date1,Start1,Stop1,Elapsed1,Date2,Start2,Stop2,Elapsed2,Date3,Start3,Stop3,Elapsed3,Date4,Start4,Stop4,Elapsed4,Date5,Start5,Stop5,Elapsed5,Date6,Start6,Stop6,Elapsed6,Date7,Start7,Stop7,Elapsed7,Date8,Start8,Stop8,Elapsed8,Date9,Start9,Stop9,Elapsed9,Date10,Start10,Stop10,Elapsed10,Date11,Start11,Stop11,Elapsed11,Date12,Start12,Stop12,Elapsed12,Date13,Start13,Stop13,Elapsed13,Date14,Start14,Stop14,Elapsed14,Date15,Start15,Stop15,Elapsed15,Date16,Start16,Stop16,Elapsed16,Date17,Start17,Stop17,Elapsed17,Date18,Start18,Stop18,Elapsed18,Date19,Start19,Stop19,Elapsed19,Date20,Start20,Stop20,Elapsed20,Date21,Start21,Stop21,Elapsed21,Date22,Start22,Stop22,Elapsed22,Date23,Start23,Stop23,Elapsed23,Date24,Start24,Stop24,Elapsed24,Date25,Start25,Stop25,Elapsed25,Date26,Start26,Stop26,Elapsed26,Date27,Start27,Stop27,Elapsed27,Date28,Start28,Stop28,Elapsed28,Date29,Start29,Stop29,Elapsed29,Date30,Start30,Stop30,Elapsed30,Date31,Start31,Stop31,Elapsed31,AVERAGE
OK,C,BATCH716,Job_1,20240501,00:00:00,00:01:06,00:01:06,20250502,00:00:00,00:02:18,00:02:18,20250503,00:00:00,00:01:33,00:01:33,20250504,00:00:00,00:01:12,00:01:12,20250505,00:00:00,00:02:05,00:02:05,20250506,00:00:00,00:05:18,00:05:18,20250507,00:00:00,00:01:56,00:01:56,20250508,00:00:00,00:00:38,00:00:38,20250509,00:00:00,00:03:34,00:03:34,20250510,00:00:00,00:02:25,00:02:25,20250511,00:00:00,00:04:14,00:04:14,20250512,00:00:00,00:01:47,00:01:47,20250513,00:00:00,00:00:34,00:00:34,20250514,00:00:00,00:03:33,00:03:33,20250515,00:00:00,00:02:31,00:02:31,20250516,00:00:00,00:02:17,00:02:17,20250517,00:00:00,00:04:46,00:04:46,20250518,00:00:00,00:01:16,00:01:16,20250519,00:00:00,00:00:29,00:00:29,20250520,00:00:00,00:03:53,00:03:53,20250521,00:00:00,00:01:29,00:01:29,20250522,00:00:00,00:03:54,00:03:54,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:03:33,00:03:33,20250525,00:00:00,00:05:42,00:05:42,20250526,00:00:00,00:03:27,00:03:27,20250527,00:00:00,00:05:20,00:05:20,20250528,00:00:00,00:05:14,00:05:14,20250529,00:00:00,00:04:29,00:04:29,20250530,00:00:00,00:02:53,00:02:53,20250531,00:00:00,00:04:30,00:04:30,00:03:00
OK,A,BATCH716,Job_2,20240501,00:00:00,00:01:39,00:01:39,20250502,00:00:00,00:00:55,00:00:55,20250503,00:00:00,00:04:43,00:04:43,20250504,00:00:00,00:01:27,00:01:27,20250505,00:00:00,00:03:26,00:03:26,20250506,00:00:00,00:01:49,00:01:49,20250507,00:00:00,00:05:23,00:05:23,20250508,00:00:00,00:01:54,00:01:54,20250509,00:00:00,00:04:54,00:04:54,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:00:38,00:00:38,20250512,00:00:00,00:02:26,00:02:26,20250513,00:00:00,00:03:01,00:03:01,20250514,00:00:00,00:03:14,00:03:14,20250515,00:00:00,00:02:16,00:02:16,20250516,00:00:00,00:04:06,00:04:06,20250517,00:00:00,00:03:43,00:03:43,20250518,00:00:00,00:01:28,00:01:28,20250519,00:00:00,00:05:20,00:05:20,20250520,00:00:00,00:03:25,00:03:25,20250521,00:00:00,00:05:06,00:05:06,20250522,00:00:00,00:00:08,00:00:08,20250523,00:00:00,00:00:46,00:00:46,20250524,00:00:00,00:05:45,00:05:45,20250525,00:00:00,00:03:55,00:03:55,20250526,00:00:00,00:03:06,00:03:06,20250527,00:00:00,00:03:13,00:03:13,20250528,00:00:00,00:04:13,00:04:13,20250529,00:00:00,00:04:01,00:04:01,20250530,00:00:00,00:00:03,00:00:03,20250531,00:00:00,00:03:44,00:03:44,00:02:58
OK,C,BATCH440,Job_3,20240501,00:00:00,00:02:56,00:02:56,20250502,00:00:00,00:01:19,00:01:19,20250503,00:00:00,00:01:13,00:01:13,20250504,00:00:00,00:05:52,00:05:52,20250505,00:00:00,00:04:46,00:04:46,20250506,00:00:00,00:02:19,00:02:19,20250507,00:00:00,00:02:53,00:02:53,20250508,00:00:00,00:01:43,00:01:43,20250509,00:00:00,00:01:29,00:01:29,20250510,00:00:00,00:01:05,00:01:05,20250511,00:00:00,00:00:56,00:00:56,20250512,00:00:00,00:02:57,00:02:57,20250513,00:00:00,00:04:51,00:04:51,20250514,00:00:00,00:03:42,00:03:42,20250515,00:00:00,00:01:31,00:01:31,20250516,00:00:00,00:01:17,00:01:17,20250517,00:00:00,00:02:17,00:02:17,20250518,00:00:00,00:00:17,00:00:17,20250519,00:00:00,00:00:24,00:00:24,20250520,00:00:00,00:00:31,00:00:31,20250521,00:00:00,00:04:11,00:04:11,20250522,00:00:00,00:04:24,00:04:24,20250523,00:00:00,00:05:30,00:05:30,20250524,00:00:00,00:04:03,00:04:03,20250525,00:00:00,00:01:59,00:01:59,20250526,00:00:00,00:01:39,00:01:39,20250527,00:00:00,00:00:32,00:00:32,20250528,00:00:00,00:00:32,00:00:32,20250529,00:00:00,00:03:47,00:03:47,20250530,00:00:00,00:03:57,00:03:57,20250531,00:00:00,00:01:43,00:01:43,00:02:28
ERROR,C,BATCH740,Job_4,20240501,00:00:00,00:04:31,00:04:31,20250502,00:00:00,00:00:22,00:00:22,20250503,00:00:00,00:00:33,00:00:33,20250504,00:00:00,00:02:23,00:02:23,20250505,00:00:00,00:02:47,00:02:47,20250506,00:00:00,00:04:11,00:04:11,20250507,00:00:00,00:01:10,00:01:10,20250508,00:00:00,00:03:24,00:03:24,20250509,00:00:00,00:05:35,00:05:35,20250510,00:00:00,00:02:15,00:02:15,20250511,00:00:00,00:03:34,00:03:34,20250512,00:00:00,00:04:42,00:04:42,20250513,00:00:00,00:05:18,00:05:18,20250514,00:00:00,00:05:00,00:05:00,20250515,00:00:00,00:04:12,00:04:12,20250516,00:00:00,00:05:13,00:05:13,20250517,00:00:00,00:01:14,00:01:14,20250518,00:00:00,00:05:05,00:05:05,20250519,00:00:00,00:02:03,00:02:03,20250520,00:00:00,00:05:13,00:05:13,20250521,00:00:00,00:05:00,00:05:00,20250522,00:00:00,00:01:01,00:01:01,20250523,00:00:00,00:01:15,00:01:15,20250524,00:00:00,00:05:27,00:05:27,20250525,00:00:00,00:00:53,00:00:53,20250526,00:00:00,00:03:59,00:03:59,20250527,00:00:00,00:05:55,00:05:55,20250528,00:00:00,00:02:13,00:02:13,20250529,00:00:00,00:00:18,00:00:18,20250530,00:00:00,00:00:12,00:00:12,20250531,00:00:00,00:02:55,00:02:55,00:03:09
OK,C,BATCH966,Job_5,20240501,00:00:00,00:05:44,00:05:44,20250502,00:00:00,00:00:58,00:00:58,20250503,00:00:00,00:03:09,00:03:09,20250504,00:00:00,00:03:53,00:03:53,20250505,00:00:00,00:03:33,00:03:33,20250506,00:00:00,00:02:08,00:02:08,20250507,00:00:00,00:04:22,00:04:22,20250508,00:00:00,00:02:51,00:02:51,20250509,00:00:00,00:04:24,00:04:24,20250510,00:00:00,00:02:40,00:02:40,20250511,00:00:00,00:03:54,00:03:54,20250512,00:00:00,00:00:46,00:00:46,20250513,00:00:00,00:01:45,00:01:45,20250514,00:00:00,00:00:11,00:00:11,20250515,00:00:00,00:04:58,00:04:58,20250516,00:00:00,00:03:42,00:03:42,20250517,00:00:00,00:03:13,00:03:13,20250518,00:00:00,00:02:05,00:02:05,20250519,00:00:00,00:02:33,00:02:33,20250520,00:00:00,00:00:46,00:00:46,20250521,00:00:00,00:04:58,00:04:58,20250522,00:00:00,00:05:06,00:05:06,20250523,00:00:00,00:02:17,00:02:17,20250524,00:00:00,00:02:47,00:02:47,20250525,00:00:00,00:01:37,00:01:37,20250526,00:00:00,00:04:03,00:04:03,20250527,00:00:00,00:03:57,00:03:57,20250528,00:00:00,00:04:24,00:04:24,20250529,00:00:00,00:05:07,00:05:07,20250530,00:00:00,00:05:52,00:05:52,20250531,00:00:00,00:01:23,00:01:23,00:03:11`;

let data = [], headers = [], currentDiffs = [];
let currentSort = { index: -1, direction: 0 };

const textFilter = document.getElementById("textFilter");
const dateFrom = document.getElementById("dateFrom");
const dateTo = document.getElementById("dateTo");
const compareCheckbox = document.getElementById("compareCheckbox");

const table = document.getElementById("dataTable").getElementsByTagName("tbody")[0];
const headerRow = document.getElementById("headerRow");

function parseCSV(text) {
  const lines = text.trim().split("\n");
  headers = lines[0].split(",");
  data = lines.slice(1).map(line => line.split(","));
}

function hmsToSeconds(hms) {
  const [h, m, s] = hms.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToHMS(sec) {
  const negative = sec < 0;
  sec = Math.abs(sec);
  const h = String(Math.floor(sec / 3600)).padStart(2, '0');
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
  const s = String(sec % 60).padStart(2, '0');
  return (negative ? "- " : "") + `${h}:${m}:${s}`;
}

function updateCompareCheckbox() {
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;
  const enabled = fromVal && toVal;
  compareCheckbox.disabled = !enabled;
  if (!enabled) {
    compareCheckbox.checked = false;
    if (currentSort.index === -2) {
      currentSort = { index: -1, direction: 0 };
    }
  }
}

function buildTable(rows, visibleCols = headers, diffAfterIndex = null) {
  table.innerHTML = "";
  headerRow.innerHTML = "";

  const visibleIndexes = visibleCols.map(col => headers.indexOf(col));
  const showDiff = diffAfterIndex !== null;

  visibleCols.forEach(col => {
    const th = document.createElement("th");
    th.textContent = col;
    const originalIndex = headers.indexOf(col);
    if (originalIndex === currentSort.index) {
      th.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
    }
    th.onclick = () => {
      if (currentSort.index === originalIndex) {
        currentSort.direction = (currentSort.direction + 1) % 3;
        if (currentSort.direction === 0) currentSort.index = -1;
      } else {
        currentSort = { index: originalIndex, direction: 1 };
      }
      filterData();
    };
    headerRow.appendChild(th);

    if (showDiff && originalIndex === diffAfterIndex) {
      const thDiff = document.createElement("th");
      thDiff.textContent = "Difference";
      if (currentSort.index === -2) {
        thDiff.classList.add(currentSort.direction === 1 ? "sorted-asc" : "sorted-desc");
      }
      thDiff.onclick = () => {
        if (currentSort.index === -2) {
          currentSort.direction = (currentSort.direction + 1) % 3;
          if (currentSort.direction === 0) currentSort.index = -1;
        } else {
          currentSort = { index: -2, direction: 1 };
        }
        filterData();
      };
      headerRow.appendChild(thDiff);
    }
  });

  const elapsedIndexes = headers
    .map((h, i) => ({ h, i }))
    .filter(obj => /^Elapsed\d+$/.test(obj.h))
    .map(obj => obj.i);

  currentDiffs = [];

  rows.forEach((row, idx) => {
    const tr = document.createElement("tr");

    let maxElapsedSec = -1;
    let maxElapsedIndexes = [];

    elapsedIndexes.forEach(i => {
      const val = row[i];
      if (val && /^\d{2}:\d{2}:\d{2}$/.test(val)) {
        const sec = hmsToSeconds(val);
        if (sec > maxElapsedSec) {
          maxElapsedSec = sec;
          maxElapsedIndexes = [i];
        } else if (sec === maxElapsedSec) {
          maxElapsedIndexes.push(i);
        }
      }
    });

    let diffValue = null;

    visibleIndexes.forEach(i => {
      const td = document.createElement("td");
      td.textContent = row[i] !== undefined ? row[i] : "";
      if (maxElapsedIndexes.includes(i)) {
        td.style.backgroundColor = "yellow";
        td.style.fontWeight = "bold";
      }
      tr.appendChild(td);

      if (showDiff && i === diffAfterIndex) {
        const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
        const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
        const fromElapsed = row[headers.indexOf(`Elapsed${fromDay}`)];
        const toElapsed = row[headers.indexOf(`Elapsed${toDay}`)];
        const tdDiff = document.createElement("td");
        if (fromElapsed && toElapsed) {
          const diffSec = hmsToSeconds(toElapsed) - hmsToSeconds(fromElapsed);
          diffValue = diffSec;
          tdDiff.textContent = secondsToHMS(diffSec);
          tdDiff.style.backgroundColor = diffSec < 0 ? "#f88" : "#8f8";
          tdDiff.style.fontWeight = "bold";
        }
        tr.appendChild(tdDiff);
      }
    });

    if (showDiff) currentDiffs[idx] = diffValue;
    table.appendChild(tr);
  });
}

function filterData() {
  updateCompareCheckbox();

  const keyword = textFilter.value.toLowerCase();
  const fromRaw = dateFrom.value;
  const toRaw = dateTo.value;
  const compare = compareCheckbox.checked;

  let filtered = [...data];

  if (keyword) {
    filtered = filtered.filter(row =>
      row.slice(0, 4).join(" ").toLowerCase().includes(keyword)
    );
  }

  const baseCols = headers.slice(0, 4);
  let visibleCols = [...baseCols];
  let insertDiffAfter = null;

  if (compare && fromRaw && toRaw) {
    const fromParsed = fromRaw.replaceAll("-", "");
    const toParsed = toRaw.replaceAll("-", "");
    const fromDay = parseInt(fromParsed.slice(-2));
    const toDay = parseInt(toParsed.slice(-2));
    visibleCols.push(...[`Date${fromDay}`, `Start${fromDay}`, `Stop${fromDay}`, `Elapsed${fromDay}`]);
    visibleCols.push(...[`Date${toDay}`, `Start${toDay}`, `Stop${toDay}`, `Elapsed${toDay}`]);
    insertDiffAfter = headers.indexOf(`Elapsed${toDay}`);
  } else if (fromRaw || toRaw) {
    const fromInt = fromRaw ? parseInt(fromRaw.replaceAll("-", "")) : null;
    const toInt = toRaw ? parseInt(toRaw.replaceAll("-", "")) : null;

    for (let i = 1; i <= 31; i++) {
      const dateKey = `Date${i}`;
      const dateIndex = headers.indexOf(dateKey);
      if (dateIndex === -1) continue;

      const hasMatch = data.some(row => {
        const val = row[dateIndex];
        if (!val || !/^\d{8}$/.test(val)) return false;
        const valInt = parseInt(val);
        if (fromInt && !toInt) return valInt === fromInt;
        if (!fromInt && toInt) return valInt === toInt;
        return valInt >= fromInt && valInt <= toInt;
      });

      if (hasMatch) {
        visibleCols.push(...[`Date${i}`, `Start${i}`, `Stop${i}`, `Elapsed${i}`]);
      }
    }
  } else {
    visibleCols = headers;
  }

  if (currentSort.direction === 0) {
    filtered = [...filtered];
  } else if (currentSort.index >= 0) {
    filtered.sort((a, b) => {
      const valA = a[currentSort.index] || "";
      const valB = b[currentSort.index] || "";
      return currentSort.direction === 1
        ? valA.localeCompare(valB)
        : valB.localeCompare(valA);
    });
  } else if (currentSort.index === -2) {
    const fromDay = parseInt(dateFrom.value.replaceAll("-", "").slice(-2));
    const toDay = parseInt(dateTo.value.replaceAll("-", "").slice(-2));
    const fromIdx = headers.indexOf(`Elapsed${fromDay}`);
    const toIdx = headers.indexOf(`Elapsed${toDay}`);
    filtered.sort((a, b) => {
      const aFrom = a[fromIdx], aTo = a[toIdx];
      const bFrom = b[fromIdx], bTo = b[toIdx];
      const aDiff = (aTo && aFrom) ? hmsToSeconds(aTo) - hmsToSeconds(aFrom) : 0;
      const bDiff = (bTo && bFrom) ? hmsToSeconds(bTo) - hmsToSeconds(bFrom) : 0;
      return currentSort.direction === 1 ? aDiff - bDiff : bDiff - aDiff;
    });
  }

  buildTable(filtered, visibleCols, insertDiffAfter);
}

textFilter.addEventListener("input", filterData);
dateFrom.addEventListener("input", filterData);
dateTo.addEventListener("input", filterData);
compareCheckbox.addEventListener("change", () => {
  if (!compareCheckbox.checked && currentSort.index === -2) {
    currentSort = { index: -1, direction: 0 };
  }
  filterData();
});

parseCSV(csvData);
filterData();
</script>
</body>
</html>








#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ —Å–∫—Ä–∏–ø—Ç—ä—Ç –µ –≤ —Ä–∞–∑–ª–∏—á–Ω–∞ –ø–∞–ø–∫–∞, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç–∏–≤–∞–º–µ —Ç–∞–º
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# Escape-–≤–∞–º–µ —Å–∞–º–æ backticks, –∑–∞ –¥–∞ –≥–∏ –≤–≥—Ä–∞–¥–∏–º –±–µ–∑–æ–ø–∞—Å–Ω–æ –≤ JS template
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .toggles { margin-bottom:10px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

  <div class="controls">
    <input id="search"    placeholder="Global search‚Ä¶"/>
    <input id="start" type="date"/>
    <input id="end"   type="date"/>
    <button id="apply" >Apply Date Filter</button>
    <button id="all"   >All Dates</button>
    <button id="cmp"   >Compare Dates</button>
    <button id="reset" >Reset All</button>
  </div>

  <div class="toggles" id="toggles"></div>

  <table id="report">
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>

  <script>
  // ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_ESCAPED
\`.trim();
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function parseCSV(txt) {
    return txt.split('\\n').map(r => r.split(','));
  }
  function toSec(s) {
    const [h,m,x] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + x;
  }
  function fmt(n){ return (n>=0?'+':'')+n; }

  let header = [],       // —Ñ–∏–Ω–∞–ª–Ω–∏—è—Ç header
      cols   = [],       // {name,hidden}
      rows   = [],       // {vals,hidden,maxIdx,diff}
      sortState={col:null,dir:'asc'},
      cmpDates=[null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    init();
    renderToggles();
    renderTable();

    document.getElementById('search' ).addEventListener('input', filterTable);
    document.getElementById('apply'  ).addEventListener('click', filterTable);
    document.getElementById('all'    ).addEventListener('click', allDates);
    document.getElementById('cmp'    ).addEventListener('click', compareDates);
    document.getElementById('reset'  ).addEventListener('click', resetAll);
    document.getElementById('start'  ).addEventListener('change', ()=>cmpDates[0]=document.getElementById('start').value.replace(/-/g,''));
    document.getElementById('end'    ).addEventListener('change', ()=>cmpDates[1]=document.getElementById('end').value.replace(/-/g,''));
  });

  function init(){
    const arr = parseCSV(rawCSV);
    const origH = arr.shift();   // –æ—Ä–∏–≥–∏–Ω–∞–ª–µ–Ω header: [STATUS,STAGE,BATCH,JOB.NAME,Date1,Elapsed1,...,AVERAGE]
    const dataArr = arr;         // –≤—Å–∏—á–∫–∏ data —Ä–µ–¥–æ–≤–µ
    const staticCnt = 4;
    const summaryCnt = 1;        // —Å–∞–º–æ AVERAGE
    const pairCnt = (origH.length - staticCnt - summaryCnt) / 2;

    // –ü–æ—Å—Ç—Ä–æ—è–≤–∞–º–µ —Ñ–∏–Ω–∞–ª–µ–Ω header:
    header = [
      ...origH.slice(0,staticCnt),
      // –∑–∞ –≤—Å—è–∫–∞ –¥–≤–æ–π–∫–∞ DateX,ElapsedX ‚Äì –≤–∑–∏–º–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç –ø—ä—Ä–≤–∏—è data-—Ä–µ–¥
      ...Array.from({length:pairCnt}, (_,i)=> dataArr[0][ staticCnt + 2*i ]),
      origH[ staticCnt + 2*pairCnt ], // AVERAGE
      'Difference'
    ];

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ cols
    cols = header.map(h=>({name:h, hidden:false}));

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ rows
    rows = dataArr.map(r=>{
      const vals = [];
      // 4 —Å—Ç–∞—Ç–∏—á–Ω–∏
      for(let i=0;i<staticCnt;i++) vals.push(r[i]);
      // N elapsed-–æ–≤–µ
      for(let i=0;i<pairCnt;i++){
        vals.push(r[ staticCnt+2*i+1 ]||'');
      }
      // AVERAGE
      vals.push(r[ staticCnt+2*pairCnt ]||'');
      // –©–µ –¥–æ–±–∞–≤–∏–º Difference –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä
      return { vals, hidden:false, maxIdx:staticCnt, diff:0 };
    });

    // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ maxIdx –∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ diff –∑–∞ –≤—Å–µ–∫–∏ row
    rows.forEach(row=>{
      let maxSec=-1, mi=staticCnt;
      for(let i=0;i<pairCnt;i++){
        const sec = toSec(row.vals[staticCnt+i]);
        if(sec>maxSec){ maxSec=sec; mi=staticCnt+i; }
      }
      row.maxIdx = mi;
      const first = toSec(row.vals[staticCnt+0]);
      const last  = toSec(row.vals[staticCnt+pairCnt-1]);
      row.diff = last-first;
    });
  }

  function renderToggles(){
    const c = document.getElementById('toggles');
    c.innerHTML='';
    cols.forEach((col,i)=>{
      const lbl=document.createElement('label');
      const cb =document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
      lbl.append(cb,' ',col.name);
      c.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML='';
    tbody.innerHTML='';

    // HEADER
    const hr=document.createElement('tr');
    cols.forEach((col,i)=>{
      if(col.hidden) return;
      const th=document.createElement('th');
      th.textContent=col.name;
      th.onclick=()=>sortBy(i);
      if(sortState.col===i)
        th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    thead.append(hr);

    // BODY
    rows.forEach(r=>{
      if(r.hidden) return;
      const tr=document.createElement('tr');
      cols.forEach((col,i)=>{
        if(col.hidden) return;
        const td=document.createElement('td');
        td.textContent = r.vals[i]||'';
        if(i===r.maxIdx) td.classList.add('max');
        if(i===cols.length-1){
          // Difference –∫–æ–ª–æ–Ω–∞
          td.textContent = fmt(r.diff);
          td.classList.add(r.diff>=0?'diff-pos':'diff-neg');
        }
        tr.append(td);
      });
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
    else sortState.dir='asc';
    sortState.col=ci;
    const th=document.querySelectorAll('th')[ci];
    th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    rows.sort((a,b)=>{
      const A=a.vals[ci]||'', B=b.vals[ci]||'';
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return sortState.dir==='asc'? cmp : -cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term=document.getElementById('search').value.toLowerCase();
    const sd=document.getElementById('start').value.replace(/-/g,''), 
          ed=document.getElementById('end').value.replace(/-/g,'');
    rows.forEach(r=>{
      let ok=true;
      if(term) ok = r.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        const d = r.vals[4]; // –¥–∞—Ç–∞—Ç–∞ –µ –Ω–∞ –ø–æ–∑–∏—Ü–∏—è 4
        ok = (!sd||d>=sd) && (!ed||d<=ed);
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function allDates(){
    // –≤–∑–∏–º–∞–º–µ –≤—Å–∏—á–∫–∏ –¥–∞—Ç–∏ –æ—Ç –∫–æ–ª–æ–Ω–∞ 4
    const ds = rows.map(r=>r.vals[4]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end').value   = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeDate(idx){
    // –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ start/end –∑–∞–ø–æ–º–Ω—è–º–µ YYYYMMDD
    cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
  }

  function compareDates(){
    const [d1,d2] = cmpDates;
    if(!d1||!d2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏.');
    const i1 = rows.findIndex(r=>r.vals[4]===d1);
    const i2 = rows.findIndex(r=>r.vals[4]===d2);
    if(i1<0||i2<0) return alert('–ù—è–º–∞ —Ç–∞–∫—ä–≤ —Ä–µ–¥.');
    rows.forEach(r=>{
      const f = toSec(r.vals[4]),
            l = toSec(r.vals[4 + parseInt((header.length-5)/2)]); // –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç elapsed
      r.diff = l - f;
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    cols.forEach(c=>c.hidden=false);
    rows.forEach(r=>{ r.hidden=false; });
    sortState={col:null,dir:'asc'};
    renderToggles();
    renderTable();
  }
  </script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä!"







#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ —Å–∫—Ä–∏–ø—Ç—ä—Ç –µ –≤ –¥—Ä—É–≥–∞ –ø–∞–ø–∫–∞, —Å–µ –º–µ—Å—Ç–∏–º —Ç–∞–º
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-output.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  ls -1 >&2
  exit 1
fi

# –ß–µ—Ç–µ–º —Ü–µ–ª–∏—è CSV –≤ –º–∞—Å–∏–≤ –æ—Ç —Ä–µ–¥–æ–≤–µ
mapfile -t lines < "$CSV"
# –ü—ä—Ä–≤–∏—è—Ç —Ä–µ–¥ –µ header
IFS=',' read -r -a hdr <<< "${lines[0]}"
# –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ N = –±—Ä–æ–π date/elapsed –¥–≤–æ–π–∫–∏
len=${#hdr[@]}
N=$(( (len - 4 - 2) / 2 ))
# –í–∑–µ–º–∞–º–µ –∏—Å—Ç–∏–Ω—Å–∫–∏—Ç–µ –¥–∞—Ç–∏ –æ—Ç –ø—ä—Ä–≤–∏—è data-—Ä–µ–¥
IFS=',' read -r -a firstRow <<< "${lines[1]}"
dateLabels=()
for i in $(seq 0 $((N-1))); do
  idx=$((4 + 2*i))
  dateLabels+=("${firstRow[idx]}")
done
# –°—Ä–µ–¥–Ω–∏—è—Ç –∏ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ —Å–∞ —Å–ª–µ–¥ —Ç—è—Ö
avgLabel="${hdr[4 + 2*N]}"
diffLabel="${hdr[5 + 2*N]}"
# –ü—ä—Ä–≤–∏—Ç–µ 4 –∫–æ–ª–æ–Ω–∏
staticLabels=( "${hdr[0]}" "${hdr[1]}" "${hdr[2]}" "${hdr[3]}" )
# –§–∏–Ω–∞–ª–µ–Ω header
finalHeader=( "${staticLabels[@]}" "${dateLabels[@]}" "$avgLabel" "$diffLabel" )

# –°–≥–ª–æ–±—è–≤–∞–º–µ data –º–∞—Å–∏–≤: –∑–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥ ‚Äì 4 —Å—Ç–∞—Ç–∏—á–Ω–∏, N elapsed, AVG, DIFF
dataRows=()
for ((r=1; r<${#lines[@]}; r++)); do
  IFS=',' read -r -a row <<< "${lines[r]}"
  # —Å—Ç–∞—Ç–∏—á–Ω–∏
  out=( "${row[0]}" "${row[1]}" "${row[2]}" "${row[3]}" )
  # elapsed
  for i in $(seq 0 $((N-1))); do
    out+=( "${row[4 + 2*i + 1]}" )
  done
  # average & difference
  out+=( "${row[4 + 2*N]}" "${row[5 + 2*N]}" )
  # join —Å—ä—Å ‚Äò|‚Äô (—â–µ split-–Ω–µ–º –≤ JS)
  dataRows+=( "$(IFS='|'; echo "${out[*]}")" )
done

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Report</title>
<style>
  body{margin:0;padding:20px;font-family:sans-serif;overflow-x:auto;}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:15px}
  .controls input,.controls button{padding:6px 10px;}
  .toggles{margin-bottom:15px}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ccc;padding:8px;white-space:nowrap}
  th{background:#f0f0f0;cursor:pointer;position:relative}
  th.sort-asc::after{content:" ‚Üë"} th.sort-desc::after{content:" ‚Üì"}
  td.max{background:#fff9c4} td.diff-pos{background:#e6f4ea}
  td.diff-neg{background:#fce8e6}
</style>
</head>
<body>

<div class="controls">
  <input id="search"    placeholder="Global search‚Ä¶"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply" >Apply Date Filter</button>
  <button id="all"   >All Dates</button>
  <button id="cmp"   >Compare Dates</button>
  <button id="reset" >Reset All</button>
</div>

<div class="toggles" id="toggles"></div>
<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// header –∏ data –≥–∏ –≤–≥—Ä–∞–∂–¥–∞–º–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –æ—Ç bash-–∞
const header = [$(printf '"%s",' "${finalHeader[@]}" )].map(h=>h.replace(/",$/,''));
const rawData = [
$(printf "  '%s',\n" "${dataRows[@]}")
].map(r=>r.split('|'));

let cols = header.map((name,i)=>({name,idx:i,hidden:false}));
let rows = rawData.map(r=>({vals:r,hidden:false}));
let sortState={col:null,dir:'asc'};
let cmpDates=[null,null];

// init
document.addEventListener('DOMContentLoaded',()=>{
  renderToggles();
  renderTable();
  document.getElementById('search').addEventListener('input',filter);
  document.getElementById('apply').addEventListener('click',filter);
  document.getElementById('all').addEventListener('click',allDates);
  document.getElementById('cmp').addEventListener('click',compare);
  document.getElementById('reset').addEventListener('click',resetAll);
  document.getElementById('start').addEventListener('change',()=>cmpDates[0]=this.value.replace(/-/g,''));
  document.getElementById('end').addEventListener('change',()=>cmpDates[1]=this.value.replace(/-/g,''));
});

// —Ä–µ–Ω–¥–µ—Ä —á–µ–∫–±–æ–∫—Å–æ–≤–µ
function renderToggles(){
  const c=document.getElementById('toggles'); c.innerHTML='';
  cols.forEach((cdef,i)=>{
    const lbl=document.createElement('label');
    const cb=document.createElement('input');
    cb.type='checkbox'; cb.checked=!cdef.hidden;
    cb.onchange=()=>{ cdef.hidden=!cb.checked; renderTable(); };
    lbl.append(cb,' ',cdef.name);
    c.append(lbl);
  });
}

// —Ä–µ–Ω–¥–µ—Ä –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞
function renderTable(){
  const thead=document.getElementById('thead'),
        tbody=document.getElementById('tbody');
  thead.innerHTML=''; tbody.innerHTML='';

  // –∑–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
  const trh=document.createElement('tr');
  cols.forEach((cdef,i)=>{
    if(cdef.hidden) return;
    const th=document.createElement('th');
    th.textContent=cdef.name;
    th.onclick=()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    trh.append(th);
  });
  thead.append(trh);

  // –¥–∞–Ω–Ω–∏
  rows.forEach(rdef=>{
    if(rdef.hidden) return;
    const tr=document.createElement('tr');
    cols.forEach((cdef,i)=>{
      if(cdef.hidden) return;
      const td=document.createElement('td');
      td.textContent = rdef.vals[i]||'';
      // mark max (–ø—ä—Ä–≤–∏ –¥–∏–Ω–∞–º–∏—á–µ–Ω >4)
      if(i>=4 && i<4+dateLabels.length && +parseSec(rdef.vals[i])===Math.max(...dateLabels.map((_,j)=>parseSec(rdef.vals[4+j]))))
        td.classList.add('max');
      tr.append(td);
    });
    tbody.append(tr);
  });
}

// —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ toggle asc/desc
function sortBy(ci){
  document.querySelectorAll('th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc'; sortState.col=ci;
  const ths=document.querySelectorAll('th')[ci];
  ths.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
  rows.sort((a,b)=>{
    const A=a.vals[ci], B=b.vals[ci];
    const nA=parseFloat(A), nB=parseFloat(B);
    let cmp=!isNaN(nA)&&!isNaN(nB)? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'?cmp:-cmp;
  });
  renderTable();
}

// —Ñ–∏–ª—Ç—ä—Ä
function filter(){
  const term=document.getElementById('search').value.toLowerCase();
  const sd=document.getElementById('start').value.replace(/-/g,''),
        ed=document.getElementById('end'  ).value.replace(/-/g,'');
  rows.forEach(rdef=>{
    let ok=true;
    if(term) ok = rdef.vals.some((v,i)=>!cols[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      const v=rdef.vals[4];
      ok = (!sd||v>=sd) && (!ed||v<=ed);
    }
    rdef.hidden=!ok;
  });
  renderTable();
}

// All Dates
function allDates(){
  const dates = rows.map(r=>r.vals[4]).sort();
  const s=dates[0], e=dates.at(-1);
  document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end')  .value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filter();
}

// Compare Dates
function compare(){
  if(!cmpDates[0]||!cmpDates[1]) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
  const idx1=rows.findIndex(r=>r.vals[4]===cmpDates[0]),
        idx2=rows.findIndex(r=>r.vals[4]===cmpDates[1]);
  if(idx1<0||idx2<0) return alert('–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω —Ä–µ–¥');
  rows.forEach((r,i)=>{
    const v1=parseSec(rows[idx1].vals[5]),
          v2=parseSec(rows[idx2].vals[5]);
    r.diffAll=v2-v1;
    const tdDiff=document.querySelectorAll('tbody tr')[i]
             .appendChild(document.createElement('td'));
    tdDiff.textContent = fmtDiff(r.diffAll);
    tdDiff.classList.add(r.diffAll>=0?'diff-pos':'diff-neg');
  });
}

// reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  cols.forEach(c=>c.hidden=false);
  rows.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  renderToggles();
  renderTable();
}

// parse HH:MM:SS
function parseSec(s){ const [h,m,x]=(s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
function fmtDiff(n){ return (n>=0?'+':'')+n; }

</script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä!"







#!/usr/bin/env bash
set -euo pipefail

# –û—Ç–∏–≤–∞–º–µ –≤ –ø–∞–ø–∫–∞—Ç–∞ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞
cd "$(dirname "${BASH_SOURCE[0]}")"

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö '$CSV' –≤ $(pwd)" >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $(pwd):" >&2
  ls -1
  exit 1
fi

# –ï—Å–∫–µ–π–ø –Ω–∞ backticks, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search‚Ä¶"/>
  <input id="start" type="date"/>
  <input id="end"   type="date"/>
  <button id="apply">Apply Date Filter</button>
  <button id="all"  >All Dates</button>
  <button id="cmp"  >Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<table id="report">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
// ‚îÄ‚îÄ‚îÄ –í–ì–†–ê–î–ï–ù–û CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const rawCSV = `
$CSV_ESCAPED
`.trim();
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function parseCSV(txt){
  return txt.split('\n').map(r=>r.split(','));
}
function parseSec(s){
  const [h,m,x] = (s||'00:00:00').split(':').map(Number);
  return h*3600 + m*60 + x;
}
function fmtDiff(n){ return (n>=0?'+':'') + n; }

let header, rows, N;
let columns   = [];    // {name, idx, hidden}
let data      = [];    // {vals, hidden, maxIdx, diffVal}
let sortState = {col:null,dir:'asc'};
let cmpDates  = [null,null];

document.addEventListener('DOMContentLoaded',()=>{
  // Flatpickr –∑–∞–º–µ—Å—Ç–≤–∞–º–µ input[type=date] –∞–∫–æ –µ –Ω—É–∂–Ω–æ, –∏–Ω–∞—á–µ native.
  initData();
  buildToggles();
  renderTable();

  // –°–ª—É—à–∞—Ç–µ–ª–∏
  document.getElementById('search').addEventListener('input', filterTable);
  document.getElementById('apply' ).addEventListener('click', filterTable);
  document.getElementById('all'   ).addEventListener('click', setAllDates);
  document.getElementById('cmp'   ).addEventListener('click', compareDates);
  document.getElementById('reset' ).addEventListener('click', resetAll);
  document.getElementById('start' ).addEventListener('change', ()=>storeDate(0));
  document.getElementById('end'   ).addEventListener('change', ()=>storeDate(1));
});

function initData(){
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;

  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ N = –±—Ä–æ–π –¥–≤–æ–π–∫–∏ Date/Elapsed
  // –ß–∞–∫–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ –∫–æ–ª–æ–Ω–∞ –¥–∞ –µ "AVERAGE" –∏–ª–∏ –Ω—è–º–∞ ‚Äì –∏–≥–Ω–æ—Ä–∏—Ä–∞–º–µ —è
  const totalCols = header.length;
  const hasAvg = header[totalCols-1]==='AVERAGE';
  N = (totalCols - 4 - (hasAvg?1:0)) / 2;

  // –ü—ä—Ä–≤–∏—Ç–µ 4 —Å—Ç–∞—Ç–∏—á–Ω–∏
  columns = [];
  for(let i=0;i<4;i++){
    columns.push({name: header[i], idx:i, hidden:false});
  }
  // –°–ª–µ–¥ —Ç–æ–≤–∞ –≤–∑–µ–º–∞–º–µ —Å–∞–º–æ Elapsed –∫–æ–ª–æ–Ω–∏, –Ω–æ –∏–º–µ–Ω—É–≤–∞–º–µ –ø–æ —Ä–µ–∞–ª–Ω–∏—Ç–µ –¥–∞—Ç–∏
  for(let j=0;j<N;j++){
    const dateIdx    = 4 + 2*j;
    const elapsedIdx = dateIdx + 1;
    const dateLabel  = rows[0][dateIdx];  // –≤–∑–∏–º–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç –ø—ä—Ä–≤–∏—è —Ä–µ–¥
    columns.push({name: dateLabel, idx: elapsedIdx, hidden:false});
  }
  // –ò –Ω–∞–∫—Ä–∞—è Difference
  columns.push({name:'Difference', idx:null, hidden:false});

  // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data[]
  data = rows.map(r=>{
    const vals = [];
    // —Å—Ç–∞—Ç–∏—á–Ω–∏
    for(let i=0;i<4;i++) vals.push(r[i]);
    // Elapsed —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
    for(let j=0;j<N;j++){
      vals.push(r[4 + 2*j + 1] || '');
    }
    // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ maxIdx —Å—Ä–µ–¥ –Ω–æ–≤–∏—Ç–µ –∫–æ–ª–æ–Ω–∏ (0..3 + j)
    let maxIdx = 4, maxSec=-1;
    for(let k=0;k<N;k++){
      const s = parseSec(vals[4+k]);
      if(s>maxSec){ maxSec=s; maxIdx=4+k; }
    }
    return {vals, hidden:false, maxIdx, diffVal:0};
  });
}

function buildToggles(){
  const c = document.getElementById('toggles');
  c.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
    lbl.append(cb,' ',col.name);
    c.append(lbl);
  });
}

function renderTable(){
  const thead = document.getElementById('thead'),
        tbody = document.getElementById('tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // HEADER
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    if(sortState.col===i)
      th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');
    hr.append(th);
  });
  thead.append(hr);

  // BODY
  data.forEach(row=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,i)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      // –°—Ç–æ–π–Ω–æ—Å—Ç: –∞–∫–æ idx=null (Difference), —â–µ –¥–æ–±–∞–≤–∏–º –ø–æ-–¥–æ–ª—É
      if(col.idx!==null) td.textContent = row.vals[col.idx] || '';
      if(col.idx!==null && col.idx >= 4 && col.idx < 4+N) {
        // highlight max
        if(i===row.maxIdx) td.classList.add('max');
      }
      tr.append(td);
    });
    // Difference = lastElap - firstElap
    const firstSec = parseSec(row.vals[4]);
    const lastSec  = parseSec(row.vals[4+N-1]);
    const d        = lastSec - firstSec;
    const td2      = document.createElement('td');
    td2.textContent = fmtDiff(d);
    td2.classList.add(d>=0?'diff-pos':'diff-neg');
    tr.append(td2);

    tbody.append(tr);
  });
}

function sortBy(ci){
  document.querySelectorAll('#thead th')
    .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
  if(sortState.col===ci && sortState.dir==='asc') sortState.dir='desc';
  else sortState.dir='asc';
  sortState.col=ci;
  const th = document.querySelectorAll('#thead th')[ci];
  th.classList.add(sortState.dir==='asc'?'sort-asc':'sort-desc');

  data.sort((a,b)=>{
    const A = a.vals[ columns[ci].idx ] || '',
          B = b.vals[ columns[ci].idx ] || '';
    const nA = parseFloat(A), nB = parseFloat(B);
    let cmp = (!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
    return sortState.dir==='asc'? cmp : -cmp;
  });
  renderTable();
}

function filterTable(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value.replace(/-/g,'');
  const ed   = document.getElementById('end').value.replace(/-/g,'');

  data.forEach(r=>{
    let ok = true;
    if(term) ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    if(ok && (sd||ed)){
      ok = r.vals[4] && (!sd||r.vals[4]>=sd) && (!ed||r.vals[4]<=ed);
    }
    r.hidden = !ok;
  });
  renderTable();
}

// –ó–∞–¥–∞–≤–∞ "All Dates" –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç–∞ YYYY-MM-DD
function setAllDates(){
  if(N<1) return;
  const dates = rows.map(r=>r[4]).sort(); // –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å –¥–∞—Ç–∏
  const s = dates[0], e = dates.at(-1);
  document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
  document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
  filterTable();
}

// –ó–∞–ø–∞–∑–≤–∞ –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞ (YYYY-MM-DD ‚Üí YYYYMMDD)
function storeDate(i){
  const v = document.getElementById(i? 'end':'start').value.replace(/-/g,'');
  cmpDates[i] = v || null;
}

function compareDates(){
  const [d1,d2] = cmpDates;
  if(!d1||!d2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –∏ –¥–≤–µ—Ç–µ –¥–∞—Ç–∏.');
  // –Ω–∞–º–∏—Ä–∞–º–µ —Ä–µ–¥, —á–∏–π—Ç–æ –¥–∞—Ç–∞= d1/d2
  const idx1 = rows.findIndex(r=>r[4]===d1);
  const idx2 = rows.findIndex(r=>r[4]===d2);
  if(idx1<0||idx2<0) return alert('–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ä–µ–¥ –∑–∞ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–∞—Ç–∏.');
  data.forEach((r,i)=>{
    const s1 = parseSec(rows[idx1][5]),  // Elapsed –µ –≤ –∫–æ–ª–æ–Ω–∞ 5 (4+1)
          s2 = parseSec(rows[idx2][5]);
    r.diffAll = s2 - s1;
  });
  renderTable();
}

function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start' ).value='';
  document.getElementById('end'   ).value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
  sortState={col:null,dir:'asc'};
  buildToggles();
  renderTable();
}
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä!"






#!/usr/bin/env bash
set -euo pipefail

# –ü—ä—Ä–≤–æ: –º–µ—Å—Ç–∏–º —Å–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å–∞–º–∏—è —Å–∫—Ä–∏–ø—Ç
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ report.csv -> report.html)
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-report.html}"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV_INPUT' –≤ –ø–∞–ø–∫–∞—Ç–∞ $SCRIPT_DIR" >&2
  echo "   (–¢–µ–∫—É—â–∞ –ø–∞–ø–∫–∞: $(pwd))" >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $(pwd):" >&2
  ls -1
  exit 1
fi

# –ü—Ä–æ—á–∏—Ç–∞–º–µ —Ü—è–ª–æ—Ç–æ CSV –∏ –µ—Å–∫–µ–π–ø–≤–∞–º–µ backticks
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:15px; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // –í–≥—Ä–∞–¥e–Ω–æ CSV
    const rawCSV = \`
$CSV_CONTENT
\`;

    // –ü–∞—Ä—Å–≤–∞–Ω–µ
    function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
    function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
    function fmtDiff(n){ return (n>=0?'+':'') + n; }

    let header=[], rows=[], N;
    let columns=[], dateCols=[], elapsedCols=[];
    let data=[], currentSort={col:null,dir:'asc'};
    let cmpDates=[null,null];

    document.addEventListener('DOMContentLoaded',()=>{
      flatpickr('#start',{dateFormat:'Y-m-d'});
      flatpickr('#end',  {dateFormat:'Y-m-d'});

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search').addEventListener('input',renderFilter);
      document.getElementById('applyDates').addEventListener('click',renderFilter);
      document.getElementById('allDates').addEventListener('click',setAllDates);
      document.getElementById('compare').addEventListener('click',compareDates);
      document.getElementById('reset').addEventListener('click',resetAll);
      document.getElementById('start').addEventListener('change', ()=>storeCompare(0));
      document.getElementById('end').addEventListener('change',   ()=>storeCompare(1));
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/^[0-9]{8}$/.test(h)) dateCols.push(i);
        if(/^Elapsed/i.test(h))   elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          const s=parseSec(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const c=document.getElementById('toggles'); c.innerHTML='';
      columns.forEach((col,i)=>{
        const lbl=document.createElement('label');
        const cb=document.createElement('input');
        cb.type='checkbox'; cb.checked=!col.hidden;
        cb.onchange=()=>{ col.hidden=!cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        c.append(lbl);
      });
    }

    function renderTable(){
      const thead=document.getElementById('thead'),
            tbody=document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // Header
      const hr=document.createElement('tr');
      columns.forEach((col,i)=>{
        if(col.hidden) return;
        const th=document.createElement('th');
        th.textContent=col.name;
        th.onclick=()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // Body
      data.forEach(d=>{
        if(d.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((col,i)=>{
          if(col.hidden) return;
          const td=document.createElement('td');
          td.textContent=d.vals[i]||'';
          if(i===d.maxIdx) td.classList.add('max');
          tr.append(td);
        });
        const val = parseSec(d.vals[elapsedCols.at(-1)]) - parseSec(d.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=fmtDiff(val);
        td2.classList.add(val>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function renderFilter(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd=document.getElementById('start').value.replace(/-/g,''), 
            ed=document.getElementById('end').value.replace(/-/g,'');
      data.forEach(d=>{
        let ok=true;
        if(term)
          ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const v=d.vals[ci]||'';
            return (!sd||v>=sd) && (!ed||v<=ed);
          });
        }
        d.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds=dateCols.map(ci=>header[ci]).sort();
      const s=ds[0], e=ds.at(-1);
      document.getElementById('start').value=s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
      document.getElementById('end'  ).value=e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
      renderFilter();
    }

    function storeCompare(idx){
      cmpDates[idx] = document.getElementById(idx? 'end':'start').value.replace(/-/g,'');
    }

    function compareDates(){
      const [c1,c2] = cmpDates;
      if(!c1||!c2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
      const ci1 = header.indexOf(c1), ci2 = header.indexOf(c2);
      if(ci1<0||ci2<0) return alert('–î–∞—Ç–∞ –Ω–µ –Ω–∞–º–µ—Ä–µ–Ω–∞ –≤ header');
      const ei1=ci1+1, ei2=ci2+1;
      data.forEach(d=>{
        d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(d=>{d.hidden=false; d.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω \${OUT_HTML} ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä!"






#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT_HTML="\${2:-report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '\$CSV' –≤ \$PWD" >&2
  exit 1
fi

# Escape –Ω–∞ backticks –∑–∞ JS-template
CSV_CONTENT=\$(sed 's/`/\\\\`/g' "\$CSV")

cat >"\$OUT_HTML" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; margin:0 auto; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 12px; }
    .columns-toggle { margin-bottom:10px; }
    .columns-toggle label { margin-right:10px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" class="date-picker" placeholder="From date"/>
      <input id="end"   class="date-picker" placeholder="To date"/>
      <button id="apply">Apply Date Filter</button>
      <button id="all">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report">
      <thead id="thead"></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function parseCSV(txt){ return txt.trim().split('\\n').map(r=>r.split(',')); }
  function parseSec(s){ const [h,m,x]= (s||'00:00:00').split(':').map(Number); return h*3600+m*60+x; }
  function fmtDiff(n){ return (n>=0?'+':'') + n; }

  let header = [], rows = [], N;
  let columns = [], dateCols = [], elapsedCols = [], data = [];
  let currentSort = {col:null, dir:'asc'};
  let cmpDates = [null,null];

  document.addEventListener('DOMContentLoaded', ()=>{
    flatpickr('#start', {dateFormat:'Y-m-d'});
    flatpickr('#end',   {dateFormat:'Y-m-d'});

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('apply' ).addEventListener('click', filterTable);
    document.getElementById('all'   ).addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset' ).addEventListener('click', resetAll);
    document.getElementById('start' ).addEventListener('change', ()=>storeCompare(0));
    document.getElementById('end'   ).addEventListener('change', ()=>storeCompare(1));
  });

  function initData(){
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4)/2;

    // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –∏–Ω–¥–µ–∫—Å–∏
    dateCols    = header.map((h,i)=>/^[0-9]{8}\$/.test(h)?i:-1).filter(i=>i>=0);
    elapsedCols = header.map((h,i)=>/^Elapsed/i.test(h)?i:-1).filter(i=>i>=0);
    columns     = header.map(h=>({name:h,hidden:false}));

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data
    data = rows.map(r=>{
      let maxIdx = elapsedCols[0], maxSec=-1;
      elapsedCols.forEach(ci=>{
        let s = parseSec(r[ci]);
        if(s>maxSec){ maxSec=s; maxIdx=ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles(){
    const ctr=document.getElementById('toggles');
    ctr.innerHTML='';
    columns.forEach((c,i)=>{
      const lbl=document.createElement('label');
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=!c.hidden;
      cb.onchange=()=>{ c.hidden=!cb.checked; renderTable(); };
      lbl.append(cb,' ',c.name);
      ctr.append(lbl);
    });
  }

  function renderTable(){
    const thead=document.getElementById('thead'),
          tbody=document.getElementById('tbody');
    thead.innerHTML=''; tbody.innerHTML='';

    // Header + Difference
    const hr=document.createElement('tr');
    columns.forEach((c,i)=>{
      if(c.hidden) return;
      const th=document.createElement('th');
      th.textContent=c.name;
      th.onclick=()=>sortBy(i);
      if(currentSort.col===i) th.classList.add(
        currentSort.dir==='asc'?'sort-asc':'sort-desc'
      );
      hr.append(th);
    });
    const thD=document.createElement('th');
    thD.textContent='Difference';
    hr.append(thD);
    thead.append(hr);

    // Body
    data.forEach((d,ri)=>{
      if(d.hidden) return;
      const tr=document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const td=document.createElement('td');
        td.textContent = d.vals[i]||'';
        if(i===d.maxIdx) td.classList.add('max');
        tr.append(td);
      });
      const diffVal = d.diffAll;
      const td2=document.createElement('td');
      td2.textContent = fmtDiff(diffVal);
      td2.classList.add(diffVal>=0?'diff-pos':'diff-neg');
      tr.append(td2);
      tbody.append(tr);
    });
  }

  function sortBy(ci){
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col=ci;
    const th=document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci];
      const nA=parseFloat(A), nB=parseFloat(B);
      let cmp =(!isNaN(nA)&&!isNaN(nB))? nA-nB : A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable(){
    const term = document.getElementById('search').value.toLowerCase();
    const sd = document.getElementById('start').value.replace(/-/g,''), 
          ed = document.getElementById('end'  ).value.replace(/-/g,'');
    data.forEach(d=>{
      let ok=true;
      if(term) ok = d.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      if(ok && (sd||ed)){
        ok = dateCols.some(ci=>{
          const hv = d.vals[ci];
          return (!sd||hv>=sd) && (!ed||hv<=ed);
        });
      }
      d.hidden=!ok;
    });
    renderTable();
  }

  function setAllDates(){
    if(!dateCols.length) return;
    const ds = dateCols.map(ci=>header[ci]).sort();
    const s=ds[0], e=ds.at(-1);
    document.getElementById('start').value = s.slice(0,4)+'-'+s.slice(4,6)+'-'+s.slice(6);
    document.getElementById('end'  ).value = e.slice(0,4)+'-'+e.slice(4,6)+'-'+e.slice(6);
    filterTable();
  }

  function storeCompare(idx){
    const val = (idx===0?document.getElementById('start'):document.getElementById('end')).value.replace(/-/g,'');
    cmpDates[idx]=val;
  }

  function compareDates(){
    if(!cmpDates[0]||!cmpDates[1]) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
    const ci1 = header.indexOf(cmpDates[0]);
    const ci2 = header.indexOf(cmpDates[1]);
    if(ci1<0||ci2<0) return alert('–ù–µ –Ω–∞–º–µ—Ä–∏—Ö –∫–æ–ª–æ–Ω–∞—Ç–∞ –∑–∞ –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞');
    const ei1 = ci1+1, ei2 = ci2+1;
    data.forEach(d=>{
      d.diffAll = parseSec(d.vals[ei2]) - parseSec(d.vals[ei1]);
    });
    renderTable();
  }

  function resetAll(){
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(d=>{d.hidden=false; d.diffAll=0;});
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>
</body>
</html>
EOF

echo "‚úÖ Generated \$OUT_HTML ‚Äì open it in your browser!"






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –í–≥—Ä–∞–∂–¥–∞–º–µ CSV-—Ç–æ –≤ JS template literal (escape –Ω–∞ backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { background:#fff; padding:20px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max      { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶"/>
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const rawCSV = \`
$CSV_CONTENT
\`;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // CSV ‚Üí –º–∞—Ç—Ä–∏—Ü–∞
    function parseCSV(txt) {
      return txt.trim().split('\\n').map(r=>r.split(','));
    }
    // HH:MM:SS ‚Üí —Å–µ–∫—É–Ω–¥–∏
    function parseElapsed(s) {
      const [h,m,x] = (s||'00:00:00').split(':').map(Number);
      return h*3600 + m*60 + x;
    }
    function formatDiff(n){ return (n>=0?'+':'') + n; }

    let header, rows, N;
    let columns = [], dateCols = [], elapsedCols = [];
    let data = [], currentSort = {col:null,dir:'asc'};

    document.addEventListener('DOMContentLoaded', () => {
      // –ü–æ–ø—Ä–∞–≤–µ–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ flatpickr:
      flatpickr('#start', { dateFormat: "Y-m-d" });
      flatpickr('#end',   { dateFormat: "Y-m-d" });

      initData();
      buildToggles();
      renderTable();

      document.getElementById('search'     ).addEventListener('input', filterTable);
      document.getElementById('applyDates').addEventListener('click', filterTable);
      document.getElementById('allDates'   ).addEventListener('click', setAllDates);
      document.getElementById('compare'    ).addEventListener('click', compareDates);
      document.getElementById('reset'      ).addEventListener('click', resetAll);
    });

    function initData(){
      const arr = parseCSV(rawCSV);
      header = arr.shift();
      rows   = arr;
      N = (header.length - 4)/2;

      header.forEach((h,i)=>{
        columns.push({name:h,hidden:false});
        if(/date/i.test(h))    dateCols.push(i);
        if(/elapsed/i.test(h)) elapsedCols.push(i);
      });

      data = rows.map(r=>{
        let maxIdx=elapsedCols[0], maxSec=-1;
        elapsedCols.forEach(ci=>{
          let s=parseElapsed(r[ci]);
          if(s>maxSec){ maxSec=s; maxIdx=ci; }
        });
        return { vals:r, hidden:false, maxIdx, diffAll:0 };
      });
    }

    function buildToggles(){
      const ct = document.getElementById('toggles');
      ct.innerHTML = '';
      columns.forEach((col,i)=>{
        const lbl = document.createElement('label');
        const cb  = document.createElement('input');
        cb.type='checkbox'; cb.checked = !col.hidden;
        cb.onchange = ()=>{ col.hidden = !cb.checked; renderTable(); };
        lbl.append(cb,' ',col.name);
        ct.append(lbl);
      });
    }

    function renderTable(){
      const thead = document.getElementById('thead');
      const tbody = document.getElementById('tbody');
      thead.innerHTML=''; tbody.innerHTML='';

      // HEADER
      const hr = document.createElement('tr');
      columns.forEach((c,i)=>{
        if(c.hidden) return;
        const th=document.createElement('th');
        th.textContent=c.name;
        th.onclick = ()=>sortBy(i);
        if(currentSort.col===i)
          th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
        hr.append(th);
      });
      const thD=document.createElement('th');
      thD.textContent='Difference'; hr.append(thD);
      thead.append(hr);

      // BODY
      data.forEach((row,ri)=>{
        if(row.hidden) return;
        const tr=document.createElement('tr');
        columns.forEach((c,i)=>{
          if(c.hidden) return;
          const td=document.createElement('td');
          td.textContent = row.vals[i]||'';
          if(elapsedCols.includes(i)&&row.maxIdx===i) td.classList.add('max');
          tr.append(td);
        });
        const d = parseElapsed(row.vals[elapsedCols.at(-1)]) - parseElapsed(row.vals[elapsedCols[0]]);
        const td2=document.createElement('td');
        td2.textContent=formatDiff(d);
        td2.classList.add(d>=0?'diff-pos':'diff-neg');
        tr.append(td2);
        tbody.append(tr);
      });
    }

    function sortBy(ci){
      document.querySelectorAll('#thead th').forEach(th=>th.classList.remove('sort-asc','sort-desc'));
      if(currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
      else currentSort.dir='asc';
      currentSort.col=ci;
      const th=document.querySelectorAll('#thead th')[ci];
      th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      data.sort((a,b)=>{
        let A=a.vals[ci], B=b.vals[ci], cmp=0;
        const nA=parseFloat(A), nB=parseFloat(B);
        if(!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
        else cmp=A.localeCompare(B);
        return currentSort.dir==='asc'?cmp:-cmp;
      });
      renderTable();
    }

    function filterTable(){
      const term=document.getElementById('search').value.toLowerCase();
      const sd  =document.getElementById('start').value;
      const ed  =document.getElementById('end').value;
      data.forEach(r=>{
        let ok=true;
        if(term) ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
        if(ok && (sd||ed)){
          ok = dateCols.some(ci=>{
            const d=(r.vals[ci]||'').split('T')[0];
            return (!sd||d>=sd) && (!ed||d<=ed);
          });
        }
        r.hidden=!ok;
      });
      renderTable();
    }

    function setAllDates(){
      if(!dateCols.length) return;
      const ds = dateCols.map(ci=>header[ci]).sort();
      document.getElementById('start').value=ds[0];
      document.getElementById('end'  ).value=ds.at(-1);
      filterTable();
    }

    function compareDates(){
      const sd=document.getElementById('start').value;
      const ed=document.getElementById('end').value;
      if(!sd||!ed) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
      const ci1 = header.indexOf(sd);
      const ci2 = header.indexOf(ed);
      if(ci1<0||ci2<0) return alert('–ù—è–º–∞ –∫–æ–ª–æ–Ω–∞ —Å —Ç–∞–∫–∞–≤–∞ –¥–∞—Ç–∞');
      const ei1 = ci1+1, ei2 = ci2+1; 
      data.forEach(r=>{
        const v1=parseElapsed(r.vals[ei1]);
        const v2=parseElapsed(r.vals[ei2]);
        r.diffAll = v2 - v1;
      });
      renderTable();
    }

    function resetAll(){
      document.getElementById('search').value='';
      document.getElementById('start').value='';
      document.getElementById('end').value='';
      columns.forEach(c=>c.hidden=false);
      data.forEach(r=>{r.hidden=false; r.diffAll=0;});
      currentSort={col:null,dir:'asc'};
      initData(); buildToggles(); renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –¥–≤–æ–π–Ω–æ –∫–ª–∏–∫ –≤ –±—Ä–∞—É–∑—ä—Ä!"




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# –ï—Å–∫–µ–π–ø–≤–∞–º–µ backticks, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS-template
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Interactive JT Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    body { margin:0; padding:20px; font-family:sans-serif; overflow-x:auto; }
    .container { max-width:100%; background:#fff; padding:20px; border-radius:6px;
                 box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    h1 { margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; }
    .controls input, .controls button { padding:6px 10px; font-size:14px; }
    .columns-toggle { margin-bottom:15px; }
    .columns-toggle label { margin-right:8px; user-select:none; }
    .table-wrap { background:#fff; }
    table { border-collapse:collapse; width:100%; }
    th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
    th { background:#f0f0f0; cursor:pointer; position:relative; }
    th.sort-asc::after  { content:" ‚Üë"; }
    th.sort-desc::after { content:" ‚Üì"; }
    td.max { background:#fff9c4; }
    td.diff-pos { background:#e6f4ea; }
    td.diff-neg { background:#fce8e6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive JT Report</h1>
    <div class="controls">
      <input id="search" placeholder="Global search‚Ä¶" />
      <input id="start" type="date"/>
      <input id="end"   type="date"/>
      <button id="applyDates">Apply Date Filter</button>
      <button id="allDates">All Dates</button>
      <button id="compare">Compare Dates</button>
      <button id="reset">Reset All</button>
    </div>
    <div class="columns-toggle" id="toggles"></div>
    <div class="table-wrap">
      <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
  // ‚îÄ‚îÄ‚îÄ –í–≥—Ä–∞–¥e–Ω–æ CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawCSV = \`
$CSV_CONTENT
\`;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ CSV
  function parseCSV(txt) {
    return txt.trim().split('\\n').map(r => r.split(','));
  }
  function parseElapsed(s) {
    const [h,m,sec] = (s||'00:00:00').split(':').map(Number);
    return h*3600 + m*60 + sec;
  }
  function formatDiff(n) { return (n>=0?'+':'') + n; }

  // –ì–ª–æ–±–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ
  let header, rows, N;
  let columns = [], dateCols = [], elapsedCols = [];
  let data = [], currentSort = { col:null, dir:'asc' };

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  document.addEventListener('DOMContentLoaded', () => {
    flatpickr('#start,{ dateFormat:"Y-m-d" }');
    flatpickr('#end',  { dateFormat:"Y-m-d" });

    initData();
    buildToggles();
    renderTable();

    document.getElementById('search').addEventListener('input', filterTable);
    document.getElementById('applyDates').addEventListener('click', filterTable);
    document.getElementById('allDates').addEventListener('click', setAllDates);
    document.getElementById('compare').addEventListener('click', compareDates);
    document.getElementById('reset').addEventListener('click', resetAll);
  });

  function initData() {
    const arr = parseCSV(rawCSV);
    header = arr.shift();
    rows   = arr;
    N = (header.length - 4) / 2;

    // –î–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∏
    header.forEach((h,i) => {
      columns.push({ name:h, hidden:false });
      if (/date/i.test(h))    dateCols.push(i);
      if (/elapsed/i.test(h)) elapsedCols.push(i);
    });

    // –ü–æ–¥–≥–æ—Ç–≤—è–º–µ data[] –æ–±–µ–∫—Ç–∏
    data = rows.map(r => {
      let maxIdx = elapsedCols[0], maxSec = -1;
      elapsedCols.forEach(ci => {
        const s = parseElapsed(r[ci]);
        if (s>maxSec) { maxSec = s; maxIdx = ci; }
      });
      return { vals:r, hidden:false, maxIdx, diffAll:0 };
    });
  }

  function buildToggles() {
    const ctr = document.getElementById('toggles');
    ctr.innerHTML = '';
    columns.forEach((col,i) => {
      const lbl = document.createElement('label');
      const cb  = document.createElement('input');
      cb.type='checkbox'; cb.checked = !col.hidden;
      cb.onchange = ()=>{
        col.hidden = !cb.checked;
        renderTable();
      };
      lbl.append(cb,' ',col.name);
      ctr.append(lbl);
    });
  }

  function renderTable() {
    const thead = document.getElementById('thead');
    const tbody = document.getElementById('tbody');
    thead.innerHTML = ''; tbody.innerHTML = '';

    // HEADER
    const hr = document.createElement('tr');
    columns.forEach((col,i) => {
      if (col.hidden) return;
      const th = document.createElement('th');
      th.textContent = col.name;
      th.onclick = ()=>sortBy(i);
      if (currentSort.col===i)
        th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
      hr.append(th);
    });
    const thD = document.createElement('th');
    thD.textContent = 'Difference';
    hr.append(thD);
    thead.append(hr);

    // BODY
    data.forEach(row=>{
      if (row.hidden) return;
      const tr = document.createElement('tr');
      columns.forEach((col,i)=>{
        if (col.hidden) return;
        const td = document.createElement('td');
        td.textContent = row.vals[i]||'';
        if (elapsedCols.includes(i) && row.maxIdx===i)
          td.classList.add('max');
        tr.append(td);
      });
      // Difference = lastElapsed - firstElapsed
      const d = parseElapsed(row.vals[ elapsedCols[elapsedCols.length-1] ]) -
                parseElapsed(row.vals[ elapsedCols[0] ]);
      const td2 = document.createElement('td');
      td2.textContent = formatDiff(d);
      if (d>0) td2.classList.add('diff-pos');
      if (d<0) td2.classList.add('diff-neg');
      tr.append(td2);

      tbody.append(tr);
    });
  }

  function sortBy(ci) {
    // clear classes
    document.querySelectorAll('#thead th')
      .forEach(th=>th.classList.remove('sort-asc','sort-desc'));
    // toggle dir
    if (currentSort.col===ci && currentSort.dir==='asc') currentSort.dir='desc';
    else currentSort.dir='asc';
    currentSort.col = ci;
    // mark header
    const th = document.querySelectorAll('#thead th')[ci];
    th.classList.add(currentSort.dir==='asc'?'sort-asc':'sort-desc');
    // sort data
    data.sort((a,b)=>{
      let A=a.vals[ci], B=b.vals[ci], cmp;
      const nA=parseFloat(A), nB=parseFloat(B);
      if (!isNaN(nA)&&!isNaN(nB)) cmp=nA-nB;
      else cmp=A.localeCompare(B);
      return currentSort.dir==='asc'?cmp:-cmp;
    });
    renderTable();
  }

  function filterTable() {
    const term = document.getElementById('search').value.toLowerCase();
    const sd   = document.getElementById('start').value;
    const ed   = document.getElementById('end').value;
    data.forEach(r=>{
      let ok = true;
      if (term) {
        ok = r.vals.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term));
      }
      if (ok && (sd||ed)) {
        ok = dateCols.some(ci=>{
          const d = (r.vals[ci]||'').split('T')[0];
          return (!sd||d>=sd) && (!ed||d<=ed);
        });
      }
      r.hidden = !ok;
    });
    renderTable();
  }

  function setAllDates() {
    if (!dateCols.length) return;
    // –ò–∑–≤–ª–∏—á–∞–º–µ header –¥–∞—Ç–∏—Ç–µ
    const dates = dateCols.map(ci=>header[ci]).sort();
    document.getElementById('start').value = dates[0];
    document.getElementById('end').value   = dates[dates.length-1];
    filterTable();
  }

  function compareDates() {
    const sd = document.getElementById('start').value;
    const ed = document.getElementById('end').value;
    if (!sd||!ed) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
    // –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ–ª–æ–Ω–∏—Ç–µ –ø–æ header
    const ci1 = header.findIndex(h=>h===sd);
    const ci2 = header.findIndex(h=>h===ed);
    if (ci1<0||ci2<0) return alert('–î–∞—Ç–∞ –Ω–µ –Ω–∞–º–µ—Ä–µ–Ω–∞ –≤ –∫–æ–ª–æ–Ω–∏');
    // —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ Elapsed —Å—Ç—ä–ª–±–æ–≤–µ—Ç–µ (—Å–ª–µ–¥ –≤—Å—è–∫–∞ date –∫–æ–ª–æ–Ω–∞)
    const ei1 = dateCols.indexOf(ci1)>=0 ? dateCols.indexOf(ci1)+1 : ci1+1;
    const ei2 = dateCols.indexOf(ci2)>=0 ? dateCols.indexOf(ci2)+1 : ci2+1;
    data.forEach(r=>{
      const v1=parseElapsed(r.vals[ei1]);
      const v2=parseElapsed(r.vals[ei2]);
      r.diffAll = v2 - v1;
    });
    renderTable();
  }

  function resetAll() {
    document.getElementById('search').value='';
    document.getElementById('start').value='';
    document.getElementById('end').value='';
    columns.forEach(c=>c.hidden=false);
    data.forEach(r=>{ r.hidden=false; r.diffAll=0; });
    currentSort={col:null,dir:'asc'};
    initData(); buildToggles(); renderTable();
  }
  </script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# Escape –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏, –∑–∞ –¥–∞ –≤–≥—Ä–∞–¥–∏–º CSV-—Ç–æ –≤ JS
CSV_ESCAPED=$(sed 's/"/\\"/g' "$CSV")

cat > "$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Advanced Report</title>
<style>
  body { font-family:sans-serif; padding:20px; background:#f4f4f4; }
  .controls { margin-bottom:15px; display:flex; flex-wrap:wrap; gap:10px; }
  .controls input, .controls button { padding:6px 10px; }
  .columns-toggle { margin-bottom:15px; }
  .columns-toggle label { margin-right:8px; }
  .table-wrap { overflow-x:auto; background:#fff; padding:10px; border:1px solid #ccc; }
  table { border-collapse:collapse; width:100%; }
  th,td { border:1px solid #ddd; padding:8px; white-space:nowrap; }
  th { background:#eee; cursor:pointer; position:relative; user-select:none; }
  th.sort-asc::after  { content:" ‚Üë"; }
  th.sort-desc::after { content:" ‚Üì"; }
  td.max { background:#fff9c4; }
  .hidden { display:none; }
  .diff-pos { background:#e6f4ea; }
  .diff-neg { background:#fce8e6; }
</style>
</head>
<body>

<div class="controls">
  <input id="search" placeholder="Global search‚Ä¶" />
  <input id="start" type="date" />
  <input id="end"   type="date" />
  <button id="applyDates">Apply Date Filter</button>
  <button id="compare">Compare Dates</button>
  <button id="reset">Reset All</button>
</div>

<div class="columns-toggle" id="toggles"></div>

<div class="table-wrap">
  <table id="report"><thead id="thead"></thead><tbody id="tbody"></tbody></table>
</div>

<script>
// –í–≥—Ä–∞–¥–µ–Ω–æ CSV
const rawCSV = \`
$CSV_ESCAPED
\`.trim();

// –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ CSV –≤ –º–∞—Å–∏–≤ –æ—Ç –º–∞—Å–∏–≤–∏
function parseCSV(txt) {
  return txt.split('\\n').map(r => r.split(','));
}

let header, rows, N;
let columns;    // {name,hidden}[]
let dateCols;   // –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ date –∫–æ–ª–æ–Ω–∏
let elapsedCols;// –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ elapsed –∫–æ–ª–æ–Ω–∏
let data;       // {vals,hidden,maxIdx,diff:{}}[]

const thead = document.getElementById('thead');
const tbody = document.getElementById('tbody');
const toggles= document.getElementById('toggles');

function init() {
  const arr = parseCSV(rawCSV);
  header = arr.shift();
  rows   = arr;
  N = (header.length - 4)/2;

  // –ö–æ–ª–æ–Ω–∏
  columns = header.map((h,i) => ({
    name: h, hidden: false
  }));
  dateCols    = header.map((h,i)=>/date/i.test(h)?i:-1).filter(i=>i>=0);
  elapsedCols = header.map((h,i)=>/elapsed/i.test(h)?i:-1).filter(i=>i>=0);

  // –î–∞–Ω–Ω–∏
  data = rows.map(r => {
    let maxIdx=elapsedCols[0], maxSec=-1;
    elapsedCols.forEach(ci=>{
      const [h,m,s] = (r[ci]||'00:00:00').split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      if(sec>maxSec){ maxSec=sec; maxIdx=ci; }
    });
    return { vals:r.slice(), hidden:false, maxIdx, diff:{} };
  });

  buildToggles();
  render();
}

// –°—ä–∑–¥–∞–≤–∞ —á–µ–∫–±–æ–∫—Å–æ–≤–µ –∑–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ/–ø–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –∫–æ–ª–æ–Ω–∏
function buildToggles(){
  toggles.innerHTML = '';
  columns.forEach((col,i)=>{
    const lbl = document.createElement('label');
    const cb  = document.createElement('input');
    cb.type='checkbox'; cb.checked = !col.hidden;
    cb.onchange = ()=>{
      col.hidden = !cb.checked;
      render();
    };
    lbl.append(cb, ' ', col.name);
    toggles.append(lbl);
  });
}

// –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
function render(){
  // Header
  thead.innerHTML = '';
  const hr = document.createElement('tr');
  columns.forEach((col,i)=>{
    if(col.hidden) return;
    const th = document.createElement('th');
    th.textContent = col.name;
    th.onclick = ()=>sortBy(i);
    hr.append(th);
  });
  const tdiff = document.createElement('th');
  tdiff.textContent = 'Difference';
  hr.append(tdiff);
  thead.append(hr);

  // Body
  tbody.innerHTML = '';
  data.forEach((row,ri)=>{
    if(row.hidden) return;
    const tr = document.createElement('tr');
    columns.forEach((col,ci)=>{
      if(col.hidden) return;
      const td = document.createElement('td');
      td.textContent = row.vals[ci]||'';
      if(elapsedCols.includes(ci) && row.maxIdx===ci) td.classList.add('max');
      // —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      if(row.diff[ci]!=null){
        td.classList.add(row.diff[ci]>=0? 'diff-pos':'diff-neg');
        td.textContent += ' '+row.diff[ci];
      }
      tr.append(td);
    });
    // difference col = lastElapsed-firstElapsed
    const diffAll = elapsedCols.reduce((acc,ci)=>acc + (row.diff[ci]||0), 0);
    const td2 = document.createElement('td');
    td2.textContent = formatDiff(diffAll);
    tr.append(td2);

    tbody.append(tr);
  });
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞ —Ä–∞–∑–ª–∏–∫–∞ —Å–µ–∫—É–Ω–¥–∏ -> +X
function formatDiff(d){ return (d>=0?'+':'')+d; }

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
function sortBy(ci){
  const dir = thead.querySelectorAll('th')[ci].classList.toggle('sort-asc')
             ? 'asc':'desc';
  thead.querySelectorAll('th').forEach((th,i)=>i!==ci && th.classList.remove('sort-asc','sort-desc'));
  if(dir==='desc') thead.querySelectorAll('th')[ci].classList.add('sort-desc');
  data.sort((a,b)=>{
    let A=a.vals[ci], B=b.vals[ci], res=0;
    const nA=parseFloat(A), nB=parseFloat(B);
    if(!isNaN(nA) && !isNaN(nB)) res=nA-nB;
    else res= A.localeCompare(B);
    return dir==='asc'? res : -res;
  });
  render();
}

// –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ
function filter(){
  const term = document.getElementById('search').value.toLowerCase();
  const sd   = document.getElementById('start').value;
  const ed   = document.getElementById('end').value;
  data.forEach(r=>{
    let ok=true;
    if(term){
      ok = r.vals.some((v,i)=> !columns[i].hidden && v.toLowerCase().includes(term));
    }
    if(ok && (sd||ed)){
      ok = dateCols.some(ci=>{
        const d = (r.vals[ci]||'').split('T')[0];
        return (!sd||d>=sd) && (!ed||d<=ed);
      });
    }
    r.hidden = !ok;
  });
  render();
}

// –ó–∞–ø–∞–º–µ—Ç—è–≤–∞ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
let cmpIdx = [];
function pickCompare(){
  const sd = document.getElementById('start').value;
  const ed = document.getElementById('end').value;
  if(sd){
    cmpIdx[0] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(sd));
  }
  if(ed){
    cmpIdx[1] = data.findIndex(r=>r.vals[dateCols[0]].startsWith(ed));
  }
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ
function compare(){
  if(cmpIdx.length<2) return alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏');
  data.forEach(r=>{
    elapsedCols.forEach(ci=>{
      const v1=parseElapsed(data[cmpIdx[0]].vals[ci]);
      const v2=parseElapsed(data[cmpIdx[1]].vals[ci]);
      r.diff[ci] = v2 - v1;
    });
  });
  render();
}

// –ü–∞—Ä—Å–≤–∞–Ω–µ HH:MM:SS -> —Å–µ–∫—É–Ω–¥–∏
function parseElapsed(s){
  const [h,m,x]= (s||'00:00:00').split(':').map(Number);
  return h*3600+m*60+x;
}

// Reset
function resetAll(){
  document.getElementById('search').value='';
  document.getElementById('start').value='';
  document.getElementById('end').value='';
  columns.forEach(c=>c.hidden=false);
  data.forEach(r=>{ r.hidden=false; r.diff={}; });
  cmpIdx=[];
  init();
}

document.getElementById('search').addEventListener('input',filter);
document.getElementById('applyDates').addEventListener('click',filter);
document.getElementById('compare').addEventListener('click',compare);
document.getElementById('reset').addEventListener('click',resetAll);
document.getElementById('start').addEventListener('change',pickCompare);
document.getElementById('end'  ).addEventListener('change',pickCompare);

init();
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT"






#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-report.html}"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –Ω–∞–ª–∏—á–µ–Ω CSV
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç '$CSV_INPUT' –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# –í–≥—Ä–∞–∂–¥–∞–Ω–µ –Ω–∞ CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ (escape –Ω–∞ backticks)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV_INPUT")

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML
cat >"$OUT_HTML" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    :root {
      --primary-color: #4285f4;
      --secondary-color: #f1f3f4;
      --hover-color: #e8f0fe;
      --border-color: #dadce0;
      --text-color: #202124;
      --light-text: #5f6368;
      --max-highlight: #fff9c4;
      --diff-positive: #e6f4ea;
      --diff-negative: #fce8e6;
    }
    body {
      font-family: 'Roboto',sans-serif; margin:0; padding:20px; background:#f8f9fa; color:var(--text-color);
    }
    .container {
      background:#fff; border-radius:8px; box-shadow:0 1px 2px rgba(0,0,0,0.1); padding:20px;
    }
    h1 { color:var(--primary-color); font-weight:500; margin-top:0; }
    .controls { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:20px; align-items:center }
    .controls input, .controls button { padding:8px 12px; border:1px solid var(--border-color); border-radius:4px; font-family:inherit }
    .controls button { background:var(--primary-color); color:#fff; cursor:pointer; }
    .controls button:hover { background:#3367d6; }
    .table-container { overflow-x:auto; border:1px solid var(--border-color); border-radius:4px }
    table { width:100%; border-collapse:collapse; }
    th,td { padding:12px 15px; text-align:left; border-bottom:1px solid var(--border-color) }
    th { background:var(--secondary-color); color:var(--light-text); position:relative; cursor:pointer }
    tr:hover { background:var(--hover-color) }
    th.sort-asc::after { content:" ‚Üë"; color:var(--primary-color) }
    th.sort-desc::after { content:" ‚Üì"; color:var(--primary-color) }
    td.max { background:var(--max-highlight); font-weight:500 }
    .column-toggle { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:15px }
    .column-toggle label { display:flex; align-items:center; gap:5px; cursor:pointer; font-size:13px; background:var(--secondary-color); padding:5px 8px; border-radius:4px }
    .hidden { display:none!important }
    .diff-positive { background:var(--diff-positive) }
    .diff-negative { background:var(--diff-negative) }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Report</h1>
    <div class="controls">
      <input type="text" id="search" placeholder="Search across all columns..."/>
      <input type="text" id="start-date" class="date-picker" placeholder="From date"/>
      <input type="text" id="end-date" class="date-picker" placeholder="To date"/>
      <button id="apply-dates">Apply</button>
      <button id="compare-dates">Compare Dates</button>
      <button id="reset-all">Reset All</button>
    </div>
    <div class="column-toggle" id="column-toggle-container"></div>
    <div class="table-container">
      <table id="data-table"><thead></thead><tbody></tbody></table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

  <script>
    // –í–≥—Ä–∞–¥–µ–Ω–æ CSV
    const csvData = \`
$CSV_CONTENT
\`;

    // –ü–æ–º–æ—â–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏
    function parseCSV(text) {
      return text.trim().split('\n').map(r=>r.split(','));
    }
    function parseElapsed(s) {
      const [h,m,sec]=s.split(':').map(Number);
      return h*3600+m*60+sec;
    }
    function formatElapsed(sec) {
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return \`\${String(h).padStart(2,'0')}:\${String(m).padStart(2,'0')}:\${String(s).padStart(2,'0')}\`;
    }

    // –ì–ª–æ–±–∞–ª–Ω–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ
    let columns = [], dateCols = [], elapsedCols = [];
    let allData = [], isComparing=false, compareIdx=[];

    // –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    \$(document).ready(function(){
      flatpickr('.date-picker',{dateFormat:'Y-m-d',allowInput:true});
      const rows = parseCSV(csvData);
      const header = rows.shift();
      const N = (header.length-4)/2;
      // –ö–æ–ª–æ–Ω–∏
      header.forEach((h,i)=>{
        const isDate = /date/i.test(h);
        const isElapsed = /elapsed/i.test(h);
        columns.push({name:h,hidden:false});
        if(isDate) dateCols.push(i);
        if(isElapsed) elapsedCols.push(i);
      });
      // –î–∞–Ω–Ω–∏
      rows.forEach(r=>{
        let maxIdx=elapsedCols[0], maxVal=-1;
        r.forEach((v,i)=> {
          if(elapsedCols.includes(i) && v){
            const secs=parseElapsed(v);
            if(secs>maxVal){ maxVal=secs; maxIdx=i; }
          }
        });
        allData.push({values:r,hidden:false,maxIdx,diff:{}}); 
      });
      initToggles();
      renderTable();
      // Events
      \$('#search').on('input',filterData);
      \$('#apply-dates').click(filterData);
      \$('#compare-dates').click(doCompare);
      \$('#reset-all').click(resetAll);
      \$('#start-date, #end-date').change(storeCompareIdx);
    });

    function initToggles(){
      const ct=\$('#column-toggle-container').empty();
      columns.forEach((col,i)=>{
        const chk=\$('<input type="checkbox">').prop('checked',!col.hidden)
          .change(_=>{col.hidden=!chk.prop('checked');renderTable();});
        ct.append(\$('<label>').append(chk,document.createTextNode(col.name)));
      });
    }

    function renderTable(){
      const tbl=\$('#data-table');
      const thead=tbl.find('thead').empty().append('<tr>');
      const tbody=tbl.find('tbody').empty();
      // Header + Difference
      columns.forEach((c,i)=>!c.hidden&& thead.append(\`<th data-col="\${i}">\${c.name}</th>\`));
      thead.append('<th>Difference</th>');
      thead.find('th').click(function(){
        sortBy(+this.dataset.col);
      });
      // Body
      allData.forEach(r=>{
        if(r.hidden) return;
        const tr=\$('<tr>');
        columns.forEach((c,i)=> {
          if(c.hidden) return;
          const v=r.values[i];
          const td=\$('<td>').text(v);
          if(elapsedCols.includes(i)&&i===r.maxIdx) td.addClass('max');
          if(isComparing && r.diff[i]!=null){
            td.addClass(r.diff[i]>=0?'diff-positive':'diff-negative')
              .append(' '+(r.diff[i]>=0?'+':'')+r.diff[i]);
          }
          tr.append(td);
        });
        // difference col
        const dsum = elapsedCols.reduce((acc,i)=>acc+(r.diff[i]||0),0);
        tr.append(\`<td>\${formatElapsed(dsum)}</td>\`);
        tbody.append(tr);
      });
      // DataTable
      tbl.DataTable({destroy:true,paging:false,scrollX:true,searching:true,dom:'Bfrtip',buttons:['colvis'],order:[]});
    }

    function sortBy(col){
      allData.sort((a,b)=>{
        const A=a.values[col], B=b.values[col];
        const nA=parseFloat(A),nB=parseFloat(B);
        let cmp=0;
        if(!isNaN(nA)&&!isNaN(nB)){ cmp=nA-nB; }
        else { cmp=A.localeCompare(B); }
        return cmp;
      });
      renderTable();
    }

    function filterData(){
      const term=\$('#search').val().toLowerCase();
      const sD=\$('#start-date').val(), eD=\$('#end-date').val();
      allData.forEach(r=>{
        const bySearch=term? r.values.some((v,i)=>!columns[i].hidden && v.toLowerCase().includes(term)) : true;
        const byDate=(sD||eD)? dateCols.some(i=>{
          const d=r.values[i]; if(!d) return false;
          const dd=d.split('T')[0];
          return (!sD||dd>=sD)&&(!eD||dd<=eD);
        }):true;
        r.hidden=!(bySearch&&byDate);
      });
      renderTable();
    }

    function storeCompareIdx(){
      const dval=this.value;
      if(!dval) return;
      const col=dateCols[0];
      const idx=allData.findIndex(r=>r.values[col].startsWith(dval));
      if(this.id==='start-date') compareIdx[0]=idx;
      else compareIdx[1]=idx;
    }

    function doCompare(){
      if(compareIdx.length<2||compareIdx[0]==null||compareIdx[1]==null){
        alert('–ò–∑–±–µ—Ä–µ—Ç–µ –¥–≤–µ –¥–∞—Ç–∏!');
        return;
      }
      allData.forEach(r=>{
        r.diff={};
        elapsedCols.forEach(i=>{
          const v1=parseElapsed(allData[compareIdx[0]].values[i]);
          const v2=parseElapsed(allData[compareIdx[1]].values[i]);
          r.diff[i]=v2-v1;
        });
      });
      isComparing=true;
      renderTable();
    }

    function resetAll(){
      \$('#search,#start-date,#end-date').val('');
      columns.forEach(c=>c.hidden=false);
      allData.forEach(r=>{r.hidden=false; r.diff={}}); 
      isComparing=false; compareIdx=[];
      initToggles();
      renderTable();
    }
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –ß–µ—Ç–µ–º —Ü—è–ª–æ—Ç–æ CSV –≤ –µ–¥–Ω–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ (escape –Ω–∞ backticks —Å–∞–º–æ)
CSV_CONTENT=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Advanced Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    /* ...—Ç–≤–æ—è CSS –æ—Ç –ø—Ä–∏–º–µ—Ä–∞... */
    .dataTables_scrollBody { overflow-x:auto!important; }
    td.max { background: var(--max-highlight) !important; }
  </style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  <!-- ... —Ç–≤–æ—è HTML –∑–∞ controls, toggles –∏ —Ç.–Ω. ... -->
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ‚îÄ‚îÄ‚îÄ –í–ì–†–ê–î–ï–ù–û CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const csvData = \`
$CSV_CONTENT
\`;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function parseCSV(text){
  return text.trim().split('\\n').map(r => r.split(','));
}

$(function(){
  const header = parseCSV(csvData).shift();
  const data   = parseCSV(csvData).slice(1);
  const N      = (header.length - 4) / 2;

  // ‚Ä¶ —Ç—É–∫ –ø—ä–ª–Ω–∏—à columns[], dateColumns[], elapsedColumns[] –∫–∞–∫—Ç–æ –ø—Ä–µ–¥–∏ ‚Ä¶

  // –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + Difference
  const thead = $('#data-table thead tr');
  header.forEach(h => thead.append('<th>' + h + '</th>'));
  thead.append('<th>Difference</th>');

  // –†–µ–Ω–¥–µ—Ä –Ω–∞ body
  data.forEach(row => {
    // ‚Ä¶ —Å—ä—â–∞—Ç–∞ –ª–æ–≥–∏–∫–∞ –∑–∞ –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ maxIdx –∏ diffStr ‚Ä¶
    const tr = $('<tr>');
    // –ø—ä—Ä–≤–∏—Ç–µ 4 –ø–æ–ª–∏
    row.slice(0,4).forEach(v => tr.append('<td>'+v+'</td>'));
    // date/elapsed –¥–≤–æ–π–∫–∏ + highlight
    for(let j=0;j<N;j++){
      tr.append('<td>'+row[4+2*j]+'</td>');
      const cls = (j===maxIdx?'max':'');
      tr.append('<td class="'+cls+'">'+row[4+2*j+1]+'</td>');
    }
    tr.append('<td>'+diffStr+'</td>');
    $('#data-table tbody').append(tr);
  });

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ DataTable
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging:   false,
    scrollX:  true,
    searching:true,
    buttons: ['colvis'],
    order:   [],
    columnDefs:[{ targets:[0], orderable:false }]
  });
});
</script>

</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT ‚Äì –æ—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML —Å –º–æ–¥–µ—Ä–µ–Ω –¥–∏–∑–∞–π–Ω –∏ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç–∏
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Report</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --primary-color: #4285f4;
    --secondary-color: #f1f3f4;
    --hover-color: #e8f0fe;
    --border-color: #dadce0;
    --text-color: #202124;
    --light-text: #5f6368;
    --max-highlight: #fff9c4;
    --diff-positive: #e6f4ea;
    --diff-negative: #fce8e6;
  }
  
  body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 20px;
    color: var(--text-color);
    background-color: #f8f9fa;
  }
  
  .container {
    max-width: 100%;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    padding: 20px;
  }
  
  h1 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 500;
  }
  
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 20px;
    align-items: center;
  }
  
  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--secondary-color);
    padding: 8px 12px;
    border-radius: 4px;
  }
  
  label {
    font-size: 14px;
    color: var(--light-text);
  }
  
  input, button, select {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: inherit;
  }
  
  button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background-color: #3367d6;
  }
  
  #search {
    flex-grow: 1;
    min-width: 200px;
  }
  
  .table-container {
    overflow-x: auto;
    margin-top: 20px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid var(--border-color);
  }
  
  th {
    background-color: var(--secondary-color);
    color: var(--light-text);
    font-weight: 500;
    position: relative;
    cursor: pointer;
    user-select: none;
  }
  
  th:hover {
    background-color: var(--hover-color);
  }
  
  th.sort-asc::after {
    content: " ‚Üë";
    color: var(--primary-color);
  }
  
  th.sort-desc::after {
    content: " ‚Üì";
    color: var(--primary-color);
  }
  
  tr:hover {
    background-color: var(--hover-color);
  }
  
  .max {
    background-color: var(--max-highlight);
    font-weight: 500;
  }
  
  .column-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 15px;
  }
  
  .column-toggle label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    padding: 5px 8px;
    background: var(--secondary-color);
    border-radius: 4px;
  }
  
  .hidden {
    display: none !important;
  }
  
  .date-range {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .date-range input {
    width: 150px;
  }
  
  .diff-positive {
    background-color: var(--diff-positive);
  }
  
  .diff-negative {
    background-color: var(--diff-negative);
  }
  
  @media (max-width: 768px) {
    .controls {
      flex-direction: column;
      align-items: stretch;
    }
    
    #search {
      width: 100%;
    }
  }
</style>
</head>
<body>
<div class="container">
  <h1>Advanced Report</h1>
  
  <div class="controls">
    <input type="text" id="search" placeholder="Search across all columns...">
    
    <div class="control-group date-range">
      <label for="start-date">From:</label>
      <input type="text" id="start-date" class="date-picker" placeholder="Start date">
      <label for="end-date">To:</label>
      <input type="text" id="end-date" class="date-picker" placeholder="End date">
      <button id="apply-dates">Apply</button>
    </div>
    
    <button id="compare-dates">Compare Dates</button>
    <button id="reset-all">Reset All</button>
  </div>
  
  <div class="column-toggle" id="column-toggle-container">
    <!-- Column toggles will be inserted here by JavaScript -->
  </div>
  
  <div class="table-container">
    <table id="data-table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
// –ì–ª–æ–±–∞–ª–Ω–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –∑–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
let allData = [];
let columns = [];
let dateColumns = [];
let elapsedColumns = [];
let currentSort = { column: null, direction: 'asc' };
let isComparing = false;
let comparedDateIndices = [];

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–∏—Ç–µ
flatpickr(".date-picker", {
  dateFormat: "Y-m-d",
  allowInput: true
});

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç CSV —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –≤ HTML
function loadData() {
  const table = document.getElementById('data-table');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  // –ò–∑—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ —Ç–µ–∫—É—â–∏—Ç–µ –¥–∞–Ω–Ω–∏
  thead.innerHTML = '';
  tbody.innerHTML = '';
  
  // –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
  const headerRow = document.createElement('tr');
  columns.forEach((col, index) => {
    if (col.hidden) return;
    
    const th = document.createElement('th');
    th.textContent = col.name;
    th.dataset.columnIndex = index;
    th.addEventListener('click', () => sortData(index));
    
    if (currentSort.column === index) {
      th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
    }
    
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  
  // –ü–æ–ø—ä–ª–≤–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
  allData.forEach(row => {
    if (row.hidden) return;
    
    const tr = document.createElement('tr');
    columns.forEach((col, colIndex) => {
      if (col.hidden) return;
      
      const td = document.createElement('td');
      td.textContent = row.values[colIndex];
      
      // –ú–∞—Ä–∫–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –≤ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
      if (elapsedColumns.includes(colIndex) && row.maxElapsedIndex === colIndex) {
        td.classList.add('max');
      }
      
      // –ú–∞—Ä–∫–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∏—Ç–µ –ø—Ä–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
      if (isComparing && row.diffValues && row.diffValues[colIndex] !== undefined) {
        const diff = row.diffValues[colIndex];
        if (diff > 0) {
          td.classList.add('diff-positive');
          td.textContent += ` (+${diff})`;
        } else if (diff < 0) {
          td.classList.add('diff-negative');
          td.textContent += ` (${diff})`;
        }
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
function sortData(columnIndex) {
  if (currentSort.column === columnIndex) {
    // –ü—Ä–æ–º—è–Ω–∞ –Ω–∞ –ø–æ—Å–æ–∫–∞—Ç–∞, –∞–∫–æ –≤–µ—á–µ —Å–º–µ —Å–æ—Ä—Ç–∏—Ä–∞–ª–∏ –ø–æ —Ç–∞–∑–∏ –∫–æ–ª–æ–Ω–∞
    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
  } else {
    // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø–æ –Ω–æ–≤–∞ –∫–æ–ª–æ–Ω–∞ –≤—ä–≤ –≤—ä–∑—Ö–æ–¥—è—â —Ä–µ–¥
    currentSort.column = columnIndex;
    currentSort.direction = 'asc';
  }
  
  allData.sort((a, b) => {
    const valA = a.values[columnIndex];
    const valB = b.values[columnIndex];
    
    // –û–ø–∏—Ç –∑–∞ —Ä–∞–∑–ø–æ–∑–Ω–∞–≤–∞–Ω–µ –Ω–∞ —á–∏—Å–ª–∞ –∏ –¥–∞—Ç–∏
    const numA = parseFloat(valA);
    const numB = parseFloat(valB);
    const dateA = new Date(valA);
    const dateB = new Date(valB);
    
    let comparison = 0;
    
    if (!isNaN(numA) {
      // –ß–∏—Å–ª–µ–Ω–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      comparison = numA - numB;
    } else if (dateA instanceof Date && !isNaN(dateA) {
      // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
      comparison = dateA - dateB;
    } else {
      // –¢–µ–∫—Å—Ç–æ–≤–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
      comparison = valA.localeCompare(valB);
    }
    
    return currentSort.direction === 'asc' ? comparison : -comparison;
  });
  
  loadData();
}

// –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
function filterData() {
  const searchTerm = document.getElementById('search').value.toLowerCase();
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  
  allData.forEach(row => {
    let matchesSearch = true;
    let matchesDate = true;
    
    // –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø–æ —Ç—ä—Ä—Å–µ–Ω–µ
    if (searchTerm) {
      matchesSearch = columns.some((col, index) => {
        if (col.hidden) return false;
        return row.values[index].toLowerCase().includes(searchTerm);
      });
    }
    
    // –§–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø–æ –¥–∞—Ç–∏
    if (startDate || endDate) {
      matchesDate = dateColumns.some(dateCol => {
        const dateStr = row.values[dateCol];
        if (!dateStr) return false;
        
        const rowDate = new Date(dateStr);
        if (isNaN(rowDate)) return false;
        
        const compareDate = rowDate.toISOString().split('T')[0];
        
        if (startDate && endDate) {
          return compareDate >= startDate && compareDate <= endDate;
        } else if (startDate) {
          return compareDate >= startDate;
        } else if (endDate) {
          return compareDate <= endDate;
        }
        return true;
      });
    }
    
    row.hidden = !(matchesSearch && matchesDate);
  });
  
  loadData();
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞—Ç–∏
function compareDates() {
  if (comparedDateIndices.length < 2) {
    alert('Please select two different dates first by using the date filters.');
    return;
  }
  
  const [firstIndex, secondIndex] = comparedDateIndices;
  const firstRow = allData[firstIndex];
  const secondRow = allData[secondIndex];
  
  allData.forEach(row => {
    row.diffValues = [];
    
    columns.forEach((col, colIndex) => {
      if (elapsedColumns.includes(colIndex)) {
        // –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –∑–∞ Elapsed –≤—Ä–µ–º–µ—Ç–æ
        const time1 = parseElapsedTime(firstRow.values[colIndex]);
        const time2 = parseElapsedTime(secondRow.values[colIndex]);
        row.diffValues[colIndex] = time2 - time1;
      } else if (!isNaN(parseFloat(row.values[colIndex]))) {
        // –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –∑–∞ —á–∏—Å–ª–æ–≤–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
        const num1 = parseFloat(firstRow.values[colIndex]);
        const num2 = parseFloat(secondRow.values[colIndex]);
        row.diffValues[colIndex] = num2 - num1;
      }
    });
  });
  
  isComparing = true;
  loadData();
}

// –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ Elapsed –≤—Ä–µ–º–µ –≤—ä–≤ —Å–µ–∫—É–Ω–¥–∏
function parseElapsedTime(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
  }
  return 0;
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–µ–∫—É–Ω–¥–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤—ä–≤ —Ñ–æ—Ä–º–∞—Ç HH:MM:SS
function formatElapsedTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ –∑–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ/–ø–æ–∫–∞–∑–≤–∞–Ω–µ
function initColumnToggles() {
  const container = document.getElementById('column-toggle-container');
  container.innerHTML = '';
  
  columns.forEach((col, index) => {
    const checkboxId = `col-toggle-${index}`;
    const label = document.createElement('label');
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.checked = !col.hidden;
    checkbox.addEventListener('change', () => {
      col.hidden = !checkbox.checked;
      loadData();
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(col.name));
    container.appendChild(label);
  });
}

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ
function parseCSV(csv) {
  const lines = csv.split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –∫–æ–ª–æ–Ω–∏—Ç–µ
  columns = headers.map((header, index) => {
    const isDate = header.toLowerCase().includes('date');
    const isElapsed = header.toLowerCase().includes('elapsed');
    
    if (isDate) dateColumns.push(index);
    if (isElapsed) elapsedColumns.push(index);
    
    return {
      name: header,
      hidden: false,
      isDate,
      isElapsed
    };
  });
  
  // –ü–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
  allData = lines.slice(1).map(line => {
    const values = line.split(',');
    let maxElapsedIndex = -1;
    let maxElapsed = -1;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ Elapsed –≤—Ä–µ–º–µ
    elapsedColumns.forEach(colIndex => {
      if (values[colIndex]) {
        const seconds = parseElapsedTime(values[colIndex]);
        if (seconds > maxElapsed) {
          maxElapsed = seconds;
          maxElapsedIndex = colIndex;
        }
      }
    });
    
    return {
      values,
      hidden: false,
      maxElapsedIndex,
      diffValues: null
    };
  });
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ UI –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ
  initColumnToggles();
  loadData();
}

// –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ CSV —Ñ–∞–π–ª–∞
function loadCSV() {
  return fetch(window.location.href)
    .then(response => response.text())
    .then(csv => {
      // –ü—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –Ω–∞ BOM —Å–∏–º–≤–æ–ª–∞, –∞–∫–æ –∏–º–∞ —Ç–∞–∫—ä–≤
      if (csv.charCodeAt(0) === 0xFEFF) {
        csv = csv.substring(1);
      }
      parseCSV(csv);
    })
    .catch(error => {
      console.error('Error loading CSV:', error);
      alert('Error loading CSV data. Please check console for details.');
    });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ event listeners
function initEventListeners() {
  document.getElementById('search').addEventListener('input', filterData);
  document.getElementById('apply-dates').addEventListener('click', filterData);
  document.getElementById('compare-dates').addEventListener('click', compareDates);
  
  document.getElementById('reset-all').addEventListener('click', () => {
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ–∏–ª—Ç—Ä–∏
    document.getElementById('search').value = '';
    document.getElementById('start-date').value = '';
    document.getElementById('end-date').value = '';
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–∫—Ä–∏—Ç–∏—Ç–µ –∫–æ–ª–æ–Ω–∏
    columns.forEach(col => col.hidden = false);
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ—Ç–æ
    isComparing = false;
    comparedDateIndices = [];
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ
    currentSort = { column: null, direction: 'asc' };
    
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å–∫—Ä–∏–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Ä–µ–¥–æ–≤–µ
    allData.forEach(row => row.hidden = false);
    
    // –ü—Ä–µ–∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ UI
    initColumnToggles();
    filterData();
  });
  
  // –ó–∞–ø–∞–∑–≤–∞–Ω–µ –Ω–∞ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–∞—Ç–∏
  document.getElementById('start-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø—ä—Ä–≤–∏—è —Ä–µ–¥, –∫–æ–π—Ç–æ —Å—ä–≤–ø–∞–¥–∞ —Å –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[0] = index;
    }
  });
  
  document.getElementById('end-date').addEventListener('change', function() {
    const date = this.value;
    if (!date) return;
    
    // –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø—ä—Ä–≤–∏—è —Ä–µ–¥, –∫–æ–π—Ç–æ —Å—ä–≤–ø–∞–¥–∞ —Å –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞
    const index = allData.findIndex(row => {
      return dateColumns.some(colIndex => {
        const rowDate = new Date(row.values[colIndex]);
        return !isNaN(rowDate) && rowDate.toISOString().split('T')[0] === date;
      });
    });
    
    if (index !== -1) {
      comparedDateIndices[1] = index;
    }
  });
}

// –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
document.addEventListener('DOMContentLoaded', () => {
  initEventListeners();
  loadCSV();
});
</script>
</body>
</html>
EOF

# –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ CSV –¥–∞–Ω–Ω–∏—Ç–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ HTML –∫–∞—Ç–æ JavaScript –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞
echo "<script>" >> "$OUT"
echo "// CSV data" >> "$OUT"
echo "const csvData = \`" >> "$OUT"
cat "$CSV" >> "$OUT"
echo "\`;" >> "$OUT"
echo "// End of CSV data" >> "$OUT"
echo "</script>" >> "$OUT"

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ó–∞–ø–∏—Å–≤–∞–º–µ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ <table> —Å –æ—Ü–≤–µ—Ç—è–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º—É–º–∞ –∏ –∫–ª–∏–∫–∞–µ–º–∏ <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # –ø—Ä–∞–≤–∏–º –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å–æ—Ä—Ç–∏—Ä–∞—â –±—É—Ç–æ–Ω
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –º–∞—Ä–∫–∏—Ä–∞–º–µ class="max" —Å–∞–º–æ –Ω–∞ maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
cat >>"$OUT" <<'EOF'
<script>
// –ñ–∏–≤–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø—Ä–∏ –∫–ª–∏–∫ –Ω–∞ –∑–∞–≥–ª–∞–≤–∏–µ:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –ø–æ—Å–æ–∫–∞ (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // –†–µ–±–∏–ª–¥ –Ω–∞ tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // –ó–∞–ø–æ–º–Ω—è–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    .dataTables_wrapper .dataTables_scroll { overflow-x: auto; }
    th { background: #f0f0f0; white-space: nowrap; }
    td { white-space: nowrap; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x:auto;">
      <table id="data-table" class="table table-striped table-bordered" style="width:100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# –í–∫–∞—Ä–≤–∞–º–µ CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th>${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    scrollX: true,
    paging: false,
    ordering: false,
    info: false
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX:true, paging:false, ordering:false, info:false, buttons:['colvis'] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    paging: false,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, paging: false, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div style="overflow-x: auto; width: 100%;">
      <table id="data-table" class="table table-striped table-bordered nowrap" style="width: 100%">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec = -1, maxIdx = -1, secsRow = [];
    for(let j = 0; j < N; j++){
      let [h,m,s] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec = sec; maxIdx = j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j = 0; j < N; j++){
      tr.append(`<td>${row[4 + 2*j]}</td>`);
      let cls = (j === maxIdx ? 'max' : '');
      tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg / 3600), mm = Math.floor((avg % 3600) / 60), ss = avg % 60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    scrollX: true,
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4, 4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1 = dates.indexOf(sel[0]), i2 = dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2], delta = d2 - d1;
        let s = Math.abs(delta);
        let hh = Math.floor(s / 3600), mm = Math.floor((s % 3600) / 60), ss = s % 60;
        let sign = delta < 0 ? '-' : '';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ scrollX: true, dom:'Bfrtip', buttons:['colvis'], responsive:true, order:[] });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    .dataTables_wrapper .dataTables_scroll { overflow: auto; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <div class="table-responsive">
      <table id="data-table" class="table table-striped table-bordered w-100">
        <thead><tr id="table-header"></tr></thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5)/2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: false,
    paging: false,
    scrollX: true,
    order: [],
    columnDefs: [{ targets:[0], orderable:false }]
  });

  table.columns().every(function(){
    const col = this;
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ 
        dom:'Bfrtip', 
        buttons:['colvis'], 
        responsive:false, 
        paging:false, 
        scrollX:true, 
        order:[] 
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# Escape backticks in CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# Start HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# CSV content
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# JavaScript end
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2;

  // Header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Body
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    paging: false,
    order: [],
    columnDefs: [{ targets: [0], orderable: false }]
  });

  // –§–∏–ª—Ç—Ä–∏
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // –î–∞—Ç–∞ —Ñ–∏–ª—Ç—ä—Ä
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        paging: false,
        order: []
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."




CSV_ESCAPED=$(sed \
  -e 's/\\/\\\\/g' \
  -e 's/"/\\"/g' \
  -e 's/`/\\`/g' \
  -e 's/<\/script>/<\/scr"+"ipt>/g' \
  "$CSV")



#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# Escape —Å–∞–º–æ backticks –æ—Ç CSV
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# –ù–∞—á–∞–ª–æ –Ω–∞ HTML
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
    th button { float:right; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
const rawCSV = `
HTML_START

# –ò–Ω–∂–µ–∫—Ç–∏—Ä–∞–π CSV —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# –§–∏–Ω–∞–ª–Ω–∞ HTML —á–∞—Å—Ç —Å JS –ª–æ–≥–∏–∫–∞
cat >>"$OUT" <<'HTML_END'
`;

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;

  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      const time = row[4+2*j+1];
      let [h,m,s] = time.split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let sum = secsRow.reduce((a,b)=>a+b,0);
    let avg = Math.floor(sum / secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  const table = $('#data-table').DataTable({
    dom: 'Bfrtip',
    buttons: ['colvis'],
    responsive: true,
    order: [],
    paging: false
  });

  table.columns().every(function(){
    const col = this, idx = col.index();
    const inp = $('<input>').attr('placeholder','filter')
      .addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    const btn = $('<button class="btn btn-sm btn-outline-secondary ml-1">Hide</button>');
    btn.on('click',()=>{
      const visible = table.column(idx).visible();
      table.column(idx).visible(!visible);
      btn.text(visible ? 'Show' : 'Hide');
    });
    $(col.header()).empty().append(inp).append(btn);
  });

  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);

    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    const sel = dates.map((d,i)=>({date: d, index: i}))
                     .filter(d=>!min||d.date>=min)
                     .filter(d=>!max||d.date<=max);
    $('#table-header th:last-child:contains("Difference")').remove();
    $('#table-body tr').each((_,tr)=>$(tr).find('td:last').remove());

    if(sel.length === 2){
      let i1 = sel[0].index, i2 = sel[1].index;
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1 = secsData[ri][i1], d2 = secsData[ri][i2];
        let delta = d2 - d1;
        let sign = delta < 0 ? '-' : '';
        let abs = Math.abs(delta);
        let hh = Math.floor(abs/3600), mm = Math.floor((abs%3600)/60), ss = abs%60;
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        buttons: ['colvis'],
        responsive: true,
        order: [],
        paging: false
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

# 1) –ü—Ä–æ–≤–µ—Ä–∫–∞
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äò$CSV_INPUT‚Äô –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤ $(pwd)" >&2
  exit 1
fi

# 2) –ü—Ä–æ—á–∏—Ç–∞–º–µ header –∏ data
IFS= read -r header_line < "$CSV_INPUT"
IFS=',' read -r -a header_arr <<< "$header_line"
mapfile -t data_lines < <(tail -n +2 "$CSV_INPUT")

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω–∞—Ç–∞ —á–∞—Å—Ç (HEAD) ‚Äì single-quoted so nothing expands
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // –í–≥—Ä–∞–¥–µ–Ω CSV ‚Üí JS –º–∞—Å–∏–≤–∏
HTML_HEAD

# 4) –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ header[] –º–∞—Å–∏–≤–∞
echo "    const header = [" >>"$OUT_HTML"
for i in "${!header_arr[@]}"; do
  # escape –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏ –≤ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞
  col=${header_arr[i]//\"/\\\"}
  if (( i < ${#header_arr[@]}-1 )); then
    printf '      "%s",\n' "$col" >>"$OUT_HTML"
  else
    printf '      "%s"\n' "$col" >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 5) –í–º—ä–∫–≤–∞–Ω–µ –Ω–∞ data[] –º–∞—Å–∏–≤–∞
echo "    const data = [" >>"$OUT_HTML"
for idx in "${!data_lines[@]}"; do
  line=${data_lines[idx]}
  # split by comma
  IFS=',' read -r -a cells <<< "$line"
  printf '      [' >>"$OUT_HTML"
  for j in "${!cells[@]}"; do
    cell=${cells[j]//\"/\\\"}
    if (( j < ${#cells[@]}-1 )); then
      printf "\"%s\"," "$cell" >>"$OUT_HTML"
    else
      printf "\"%s\"" "$cell" >>"$OUT_HTML"
    fi
  done
  if (( idx < ${#data_lines[@]}-1 )); then
    printf '],\n' >>"$OUT_HTML"
  else
    printf ']\n' >>"$OUT_HTML"
  fi
done
echo "    ];" >>"$OUT_HTML"

# 6) –ü–∏—Å–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω–∞—Ç–∞ —á–∞—Å—Ç (TAIL) ‚Äì —Å—ä—â–æ single-quoted
cat >>"$OUT_HTML" <<'HTML_TAIL'
    // Document ready ‚Üí render —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
    $(document).ready(function(){
      const N = (header.length - 4) / 2; // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–µ—Ä –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + –∫–æ–ª–æ–Ω–∞ Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–µ—Ä –Ω–∞ body –∏ highlight max
      data.forEach(row => {
        // –ø–∞—Ä—Å–∏–º–µ elapsed –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ –º–µ—Ä–∏–º max
        const secs = [], tr = $('<tr>');
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = (j === maxIdx ? 'max' : '');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = –ø–æ—Å–ª–µ–¥–Ω–æ ‚àí –ø—ä—Ä–≤–æ
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? '-' : '';
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX:  true,       // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching:true,       // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],  // –±—É—Ç–æ–Ω hide/show
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö CSV —Ñ–∞–π–ª–∞ '$CSV' –≤ $(pwd)" >&2
  exit 1
fi

# –ü—Ä–æ—á–∏—Ç–∞–º–µ header (–ø—ä—Ä–≤–∏ —Ä–µ–¥)
IFS= read -r header_line < "$CSV"
IFS=',' read -r -a header_arr <<< "$header_line"

# –ü—Ä–æ—á–∏—Ç–∞–º–µ data (–≤—Å–∏—á–∫–æ —Å–ª–µ–¥ –ø—ä—Ä–≤–∏—è —Ä–µ–¥)
data_lines=()
while IFS= read -r line; do
  data_lines+=("$line")
done < <(tail -n +2 "$CSV")

# –§—É–Ω–∫—Ü–∏—è –∑–∞ –ø—Ä–µ–≤—Ä—ä—â–∞–Ω–µ –Ω–∞ CSV-—Ä–µ–¥ –≤ JS-—Å—Ç—Ä–∏–Ω–≥-–∞—Ä–µ–π
to_js_array(){
  local line="$1"
  IFS=',' read -r -a cells <<< "$line"
  printf '['
  local first=1
  for cell in "${cells[@]}"; do
    # –µ—Å–∫–µ–π–ø–≤–∞–º–µ –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–∏ –¥–≤–æ–π–Ω–∏ –∫–∞–≤–∏—á–∫–∏ –≤ cell
    esc=${cell//\"/\\\"}
    if (( first )); then
      printf "\"%s\"" "$esc"
      first=0
    else
      printf ",\"%s\"" "$esc"
    fi
  done
  printf ']'
}

# –ì–ï–ù–ï–†–ò–†–ê–ú–ï HTML
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
    .dataTables_scrollBody { overflow-x:auto!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // Header –∏ data –≤–≥—Ä–∞–¥–µ–Ω–∏ –∫–∞—Ç–æ JS –º–∞—Å–∏–≤–∏
    const header = [
EOF

# –í–º—ä–∫–≤–∞–º–µ header
first=1
for col in "${header_arr[@]}"; do
  esc=${col//\"/\\\"}
  if (( first )); then
    printf '      "%s"\n' "$esc" >>"$OUT"
    first=0
  else
    printf '     ,"%s"\n' "$esc" >>"$OUT"
  fi
done

cat >>"$OUT" <<EOF
    ];

    const data = [
EOF

# –í–º—ä–∫–≤–∞–º–µ data —Ä–µ–¥ –ø–æ —Ä–µ–¥
for i in "${!data_lines[@]}"; do
  line=${data_lines[i]}
  jsarr=$(to_js_array "$line")
  if (( i < ${#data_lines[@]} - 1 )); then
    printf '      %s,\n' "$jsarr" >>"$OUT"
  else
    printf '      %s\n' "$jsarr" >>"$OUT"
  fi
done

cat >>"$OUT" <<'EOF'
    ];

    $(document).ready(function(){
      const N = (header.length - 4)/2; // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–∏—Å—É–≤–∞–º–µ header + –¥–æ–±–∞–≤—è–º–µ Difference
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–∏—Å—É–≤–∞–º–µ body + highlight max
      data.forEach(row => {
        // –ø–∞—Ä—Å–∏–º–µ Elapsed –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ —Ç—ä—Ä—Å–∏–º max
        const secs = [], tr = $('<tr>'), LENGTH=N;
        let maxSec=-1, maxIdx=0;
        for(let j=0;j<LENGTH;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j; }
        }
        // STATUS..JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for(let j=0;j<LENGTH;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls=(j===maxIdx?'max':'');
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0],
              sign = diff<0?'-':'',
              sabs = Math.abs(diff),
              h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60,
              dstr = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
        tr.append(`<td>${dstr}</td>`);
        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging:   false,   // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX:  true,    // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching:true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],
        order:   [],
        columnDefs:[{ targets:[0], orderable:false }]
      });
    });
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT (–æ—Ç $CSV)"






#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# 1) –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ CSV-—Ç–æ
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤: $(pwd)" >&2
  exit 1
fi

# 2) –ï–∫—Å–ø–µ–π–ø–≤–∞–º–µ —Å–∞–º–æ backticks (–∞–∫–æ –≥–∏ –∏–º–∞)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML-–∞
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS Libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const rawCSV = `
HTML_START

# 4) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 5) –ü–∏—Å–∞–Ω–µ –Ω–∞ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // –∫–æ–ª–∫–æ date/elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–µ—Ä: —Ö–µ–¥—ä—Ä + —Ä–∞–∑–ª–∏–∫–∞
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–µ—Ä: body + highlight max
      data.forEach(row => {
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }
        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX: true,      // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching: true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],// –±—É—Ç–æ–Ω hide/show –∫–æ–ª–æ–Ω–∏
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT)"





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV_INPUT="${1:-report.csv}"
OUT_HTML  ="${2:-interactive_report.html}"

if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤: $(pwd)" >&2
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks, –æ—Å—Ç–∞–Ω–∞–ª–æ—Ç–æ –æ—Å—Ç–∞–≤—è–º–µ –Ω–µ–ø—Ä–æ–º–µ–Ω–µ–Ω–æ
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) –ü–∏—Å–∞–Ω–µ –Ω–∞ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML-–∞ (single-quoted here-doc –∑–∞ –¥–∞ –Ω–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞ $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>

  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    /* —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ */
    .dataTables_scrollBody { overflow-x: auto !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered" style="width:100%">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    const rawCSV = `
HTML_START

# 2) –î–æ–±–∞–≤—è–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) –ü–∏—Å–∞–Ω–µ –Ω–∞ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT_HTML" <<'HTML_END'
`;
    function parseCSV(text) {
      return text.trim().split("\n").map(r => r.split(","));
    }

    $(document).ready(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4) / 2;  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

      // –†–µ–Ω–¥–∏—Ä–∞–Ω–µ –Ω–∞ —Ö–µ–¥—ä—Ä–∞ + —Ä–∞–∑–ª–∏–∫–∞
      header.forEach(h => $('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // –†–µ–Ω–¥–∏—Ä–∞–Ω–µ –Ω–∞ body + highlight max
      data.forEach(row => {
        // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–º–∏—Ä–∞–º–µ –º–∞–∫—Å–∏–º—É–º–∞
        const secs = [];
        let maxSec = -1, maxIdx = 0;
        for (let j = 0; j < N; j++) {
          const [hh, mm, ss] = row[4 + 2*j + 1].split(":").map(Number);
          const s = hh*3600 + mm*60 + ss;
          secs.push(s);
          if (s > maxSec) { maxSec = s; maxIdx = j; }
        }

        const tr = $("<tr>");
        // STATUS, STAGE, BATCH, JOB.NAME
        row.slice(0,4).forEach(c => tr.append(`<td>${c}</td>`));
        // Date/Elapsed –¥–≤–æ–π–∫–∏
        for (let j = 0; j < N; j++) {
          tr.append(`<td>${row[4 + 2*j]}</td>`);
          const cls = (j === maxIdx ? "max" : "");
          tr.append(`<td class="${cls}">${row[4 + 2*j + 1]}</td>`);
        }
        // Difference = last - first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff < 0 ? "-" : "";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs % 60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $("#table-body").append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ DataTable
      $("#data-table").DataTable({
        dom: 'Bfrtip',
        paging: false,      // –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏
        scrollX: true,      // —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ —Å–∫—Ä–æ–ª–≤–∞–Ω–µ
        searching: true,    // –≥–ª–æ–±–∞–ª–Ω–∞ —Ç—ä—Ä—Å–∞—á–∫–∞
        buttons: ['colvis'],// –±—É—Ç–æ–Ω hide/show –∫–æ–ª–æ–Ω–∏
        order: [],
        columnDefs: [
          { targets: [0], orderable: false }
        ]
      });
    });
  </script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω: $OUT_HTML (–æ—Ç $CSV_INPUT). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."








#!/usr/bin/env bash
set -euo pipefail

CSV_INPUT="${1:-report.csv}"
OUT_HTML="${2:-interactive_report.html}"

# –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
if [[ ! -f "$CSV_INPUT" ]]; then
  echo "‚ùå CSV —Ñ–∞–π–ª—ä—Ç ‚Äú$CSV_INPUT‚Äù –Ω–µ –µ –Ω–∞–º–µ—Ä–µ–Ω –≤:" >&2
  echo "   $(pwd)" >&2
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks (–∞–∫–æ –≥–∏ –∏–º–∞ –≤ CSV-—Ç–æ)
ESCAPED_CSV=$(sed 's/`/\\`/g' "$CSV_INPUT")

# 1) –ü–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–∞—Ç–∞ (—Å—Ç–∞—Ç–∏—á–Ω–∞) —á–∞—Å—Ç –æ—Ç HTML-–∞
cat >"$OUT_HTML" <<'HTML_HEAD'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css">
  <style>
    table, th, td { border:1px solid #ccc; border-collapse:collapse; }
    th, td       { padding:4px 8px; }
    th            { cursor:pointer; background:#f0f0f0; }
    td.max        { background:#ffeb3b !important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

  <script>
    // –í–ì–†–ê–î–ï–ù–û CSV
    const rawCSV = `
HTML_HEAD

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ CSV-—Ç–æ
printf '%s\n' "$ESCAPED_CSV" >> "$OUT_HTML"

# 3) –ü–µ—á–∞—Ç–∞–º–µ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ (—Å—Ç–∞—Ç–∏—á–Ω–∞) —á–∞—Å—Ç –æ—Ç HTML + JS
cat >>"$OUT_HTML" <<'HTML_TAIL'
`;
    function parseCSV(txt) {
      return txt.trim().split("\n").map(r=>r.split(","));
    }
    $(function(){
      const data   = parseCSV(rawCSV);
      const header = data.shift();
      const N      = (header.length - 4)/2;  // –∫–æ–ª–∫–æ date/elapsed –¥–≤–æ–π–∫–∏

      // header + Difference
      header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
      $('#table-header').append('<th>Difference</th>');

      // body
      data.forEach(row=>{
        // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–π-–≥–æ–ª—è–º–æ Elapsed
        let secs = [], maxSec=-1, maxIdx=0;
        for(let j=0;j<N;j++){
          const [hh,mm,ss] = row[4+2*j+1].split(":").map(Number);
          const s = hh*3600+mm*60+ss;
          secs.push(s);
          if(s>maxSec){ maxSec=s; maxIdx=j }
        }
        const tr = $("<tr>");
        // –ø—ä—Ä–≤–∏ 4 –∫–æ–ª–æ–Ω–∏
        row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
        // date/elapsed –¥–≤–æ–π–∫–∏
        for(let j=0;j<N;j++){
          tr.append(`<td>${row[4+2*j]}</td>`);
          const cls = j===maxIdx?"max":"";
          tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
        }
        // Difference = last-first
        const diff = secs[secs.length-1] - secs[0];
        const sign = diff<0?"-":"";
        const sabs = Math.abs(diff);
        const h2   = Math.floor(sabs/3600),
              m2   = Math.floor((sabs%3600)/60),
              s2   = sabs%60;
        const dstr = `${sign}${String(h2).padStart(2,"0")}:${String(m2).padStart(2,"0")}:${String(s2).padStart(2,"0")}`;
        tr.append(`<td>${dstr}</td>`);

        $('#table-body').append(tr);
      });

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable –±–µ–∑ paging + –±—É—Ç–æ–Ω –∑–∞ hide/show
      $('#data-table').DataTable({
        dom: 'Bfrtip',
        paging: false,
        searching: true,
        buttons: ['colvis'],
        responsive: true,
        order: []
      });
    });
  </script>
</body>
</html>
HTML_TAIL

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML (–æ—Ç $CSV_INPUT)"






#!/usr/bin/env bash
set -euo pipefail

# –ê–∫–æ –ø–æ–¥–∞–¥–µ—à –ø—ä—Ç –∫—ä–º CSV, –≥–æ –ø–æ–ª–∑–≤–∞–º–µ, –∏–Ω–∞—á–µ ‚Äì report.csv –¥–æ —Å–∫—Ä–∏–ø—Ç–∞
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CSV_INPUT="${1:-report.csv}"
# –ê–∫–æ –ø—ä—Ç—ä—Ç –∫—ä–º CSV –Ω–µ –µ –∞–±—Å–æ–ª—é—Ç–µ–Ω, –≥–æ –¥–æ–ø—ä–ª–≤–∞–º–µ —Å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞
if [[ "$CSV_INPUT" != /* ]]; then
  CSV_PATH="$SCRIPT_DIR/$CSV_INPUT"
else
  CSV_PATH="$CSV_INPUT"
fi

# –ò–∑—Ö–æ–¥–Ω–∏—è—Ç HTML
OUT_HTML="${2:-interactive_report.html}"

# –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –∏–º–∞ –ª–∏ CSV
if [[ ! -f "$CSV_PATH" ]]; then
  echo "‚ùå –ù–µ –º–æ–≥–∞ –¥–∞ –æ—Ç–∫—Ä–∏—è CSV —Ñ–∞–π–ª–∞:" >&2
  echo "   –ò–∑–≥–ª–µ–∂–¥–∞, —á–µ —Ç—ä—Ä—Å—è —Ç—É–∫: $CSV_PATH" >&2
  echo "   –¢–µ–∫—É—â–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: $(pwd)"   >&2
  echo "   –°—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ $SCRIPT_DIR:"   >&2
  ls -1 "$SCRIPT_DIR" >&2 || true
  exit 1
fi

# –ï–∫—Ä–∞–Ω–∏—Ä–∞–º–µ —Å–∞–º–æ backticks (–æ—Å—Ç–∞–Ω–∞–ª–∏—è—Ç JS/HTML –∫–æ–¥ –Ω–µ —Å–µ –ø–∏–ø–∞)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV_PATH")

# 1) –ü—ä—Ä–≤–∞ —á–∞—Å—Ç –Ω–∞ HTML (single-quoted –∑–∞ –¥–∞ –Ω–µ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞—Ç $)
cat >"$OUT_HTML" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = `
HTML_START

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –Ω–∞ report.csv
printf '%s\n' "$CSV_ESCAPED" >> "$OUT_HTML"

# 3) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML+JS
cat >>"$OUT_HTML" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 4) / 2;  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏

  // header + Difference
  header.forEach(h=>$('#table-header').append(`<th>${h}</th>`));
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // body
  data.forEach(row=>{
    let secsRow=[], maxSec=-1, maxIdx=0;
    for(let j=0;j<N;j++){
      let [hh,mm,ss] = row[4+2*j+1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    for(let j=0;j<N;j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = j===maxIdx?'max':'';
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    let diff = secsRow[secsRow.length-1] - secsRow[0],
        sign = diff<0?'-':'',
        s    = Math.abs(diff),
        h2   = Math.floor(s/3600), m2=Math.floor((s%3600)/60), s2=s%60,
        str  = `${sign}${String(h2).padStart(2,'0')}:${String(m2).padStart(2,'0')}:${String(s2).padStart(2,'0')}`;
    tr.append(`<td>${str}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // DataTable –±–µ–∑ paging
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –£—Å–ø–µ—à–Ω–æ: –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω $OUT_HTML (—á–µ—Ç–µ $CSV_PATH)"





#!/usr/bin/env bash
set -euo pipefail

CSV="\${1:-report.csv}"
OUT="\${2:-interactive_report.html}"

if [[ ! -f "\$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö \$CSV" >&2
  exit 1
fi

# –ï–∫—Å–ø–µ–π–ø–≤–∞–º–µ —Å–∞–º–æ backticks
CSV_ESCAPED=\$(sed 's/`/\\\\`/g' "\$CSV")

# 1) HTML —Å—Ç–∞—Ä—Ç (–Ω–∏—â–æ –Ω–µ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞ —Ç—É–∫, –∑–∞—Ä–∞–¥–∏ single-quoted here-doc)
cat >"\$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <!-- Bootstrap -->
  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <style>
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
    th, td       { padding: 4px 8px; }
    th            { cursor: pointer; background: #f0f0f0; }
    td.max        { background-color: #ffeb3b !important; }
    #data-table   { width: 100%!important; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <table id="data-table" class="table table-striped table-bordered">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js">
  </script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js">
  </script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV –∫–∞—Ç–æ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–µ–Ω string ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = \`
HTML_START

# 2) –í–∫–∞—Ä–≤–∞–º–µ —Å–∞–º–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ CSV
printf '%s\n' "\$CSV_ESCAPED" >> "\$OUT"

# 3) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML+JS (–ø–∞–∫ –±–µ–∑ —Ä–∞–∑—à–∏—Ä—è–≤–∞–Ω–∏—è)
cat >>"\$OUT" <<'HTML_END'
\`;
function parseCSV(text){
  return text.trim().split("\\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  // –±—Ä–æ–π Date/Elapsed –¥–≤–æ–π–∫–∏
  const N      = (header.length - 4) / 2;

  // --- –†–∏—Å—É–≤–∞–º–µ header + –¥–æ–±–∞–≤—è–º–µ Difference ---
  header.forEach(h => {
    $('#table-header').append(`<th>\${h}</th>`);
  });
  $('#table-header').append('<th>Difference</th>');

  const secsData = [];

  // --- –ü–æ–ø—ä–ª–≤–∞–º–µ body + highlight –º–∞–∫—Å–∏–º—É–º–∞ ---
  data.forEach(row => {
    // –ü–∞—Ä—Å–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ —Ç—ä—Ä—Å–∏–º max
    let secsRow = [], maxSec=-1, maxIdx=0;
    for(let j=0; j<N; j++){
      let [hh,mm,ss] = row[4 + 2*j + 1].split(':').map(Number);
      let sec = hh*3600 + mm*60 + ss;
      secsRow.push(sec);
      if(sec > maxSec){ maxSec=sec; maxIdx=j; }
    }

    // –°—ä–∑–¥–∞–≤–∞–º–µ —Ä–µ–¥
    const tr = $('<tr>');
    // STATUS, STAGE, BATCH, JOB.NAME
    row.slice(0,4).forEach(cell => tr.append(`<td>\${cell}</td>`));
    // Date/Elapsed –¥–≤–æ–π–∫–∏
    for(let j=0; j<N; j++){
      tr.append(`<td>\${row[4 + 2*j]}</td>`);
      let cls = (j===maxIdx ? 'max' : '');
      tr.append(`<td class="\${cls}">\${row[4 + 2*j + 1]}</td>`);
    }
    // –†–∞–∑–ª–∏–∫–∞ = last - first
    let diffSec = secsRow[secsRow.length-1] - secsRow[0],
        sign    = diffSec<0 ? '-' : '',
        s       = Math.abs(diffSec),
        hh2     = Math.floor(s/3600),
        mm2     = Math.floor((s%3600)/60),
        ss2     = s%60,
        diffStr = `${sign}${String(hh2).padStart(2,'0')}:${String(mm2).padStart(2,'0')}:${String(ss2).padStart(2,'0')}`;
    tr.append(`<td>\${diffStr}</td>`);

    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable –±–µ–∑ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∏ —Å –±—É—Ç–æ–Ω –∑–∞ hide/show ---
  $('#data-table').DataTable({
    dom: 'Bfrtip',
    paging: false,
    searching: true,
    buttons: ['colvis'],
    responsive: true,
    order: []
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '\$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

if [[ ! -f "$CSV" ]]; then
  echo "‚ùå –ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi

# 1) –ü—Ä–æ—á–∏—Ç–∞–º–µ CSV –∏ escape-–∞–º–µ —Å–∞–º–æ backticks
#    (–æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ $ –Ω—è–º–∞—Ç –∑–Ω–∞—á–µ–Ω–∏–µ, –∑–∞—â–æ—Ç–æ —Ç—É–∫ —Å–∞–º–æ
#     —â–µ –≥–æ inser—Ç–∏–º)
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) –ü—ä—Ä–≤–∞ —á–∞—Å—Ç –æ—Ç HTML (–±–µ–∑ –¥–∞ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞—Ç –Ω–∏–∫–∞–∫–≤–∏ $)
cat >"$OUT" <<'HTML_START'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/>
  <!-- DataTables + Buttons + Responsive -->
  <link rel="stylesheet"
        href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"/>
  <!-- Flatpickr -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"/>

  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th { cursor: pointer; background: #f0f0f0; }
    th input { width:100%; box-sizing:border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libs -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = `
HTML_START

# 3) –ò–Ω–∂–µ–∫—Ç–∏—Ä–∞–º–µ —Å–∞–º–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –Ω–∞ report.csv
printf '%s\n' "$CSV_ESCAPED" >>"$OUT"

# 4) –û—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç HTML + JS logic
cat >>"$OUT" <<'HTML_END'
`;
function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

$(document).ready(function(){
  const data   = parseCSV(rawCSV);
  const header = data.shift();
  const N      = (header.length - 5)/2; // –¥–≤–æ–π–∫–∏—Ç–µ Date/Elapsed

  // Render header
  header.forEach((h,i)=>{
    $('#table-header').append(`<th data-col="${i}">${h}</th>`);
  });

  const secsData = [];

  // Render body + highlight max
  data.forEach((row, ridx)=>{
    let maxSec=-1, maxIdx=-1, secsRow=[];
    for(let j=0; j<N; j++){
      let [h,m,s] = row[4+2*j+1].split(':').map(Number);
      let sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }
    const tr = $('<tr>');
    // STATUS,STAGE,BATCH,JOB.NAME
    row.slice(0,4).forEach(c=>tr.append(`<td>${c}</td>`));
    // Date/Elapsed pairs
    for(let j=0; j<N; j++){
      tr.append(`<td>${row[4+2*j]}</td>`);
      let cls = (j===maxIdx?'max':'');
      tr.append(`<td class="${cls}">${row[4+2*j+1]}</td>`);
    }
    // Average
    let sum = secsRow.reduce((a,b)=>a+b,0), avg = Math.floor(sum/secsRow.length);
    let hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
    secsData.push(secsRow);
    $('#table-body').append(tr);
  });

  // Init DataTables
  const table = $('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });
  // Column filters
  table.columns().every(function(){
    const col=this, idx=col.index();
    const inp = $('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    $(col.header()).empty().append(inp);
  });

  // Date-range filter + Difference
  function applyDateFilter(){
    const min = $('#min-date').val(), max = $('#max-date').val();
    const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      let show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !$('#table-header th:contains("Difference")').length){
      let i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      $('#table-header').append('<th>Difference</th>');
      $('#table-body tr').each((ri,tr)=>{
        let d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        let s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        let sign=delta<0?'-':'';
        $(tr).append(`<td>${sign}${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}</td>`);
      });
      table.destroy();
      $('#data-table').DataTable({ dom:'Bfrtip',buttons:['colvis'],responsive:true,order:[] });
    }
  }
  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  $('#clear-dates').on('click',()=>{
    $('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
</script>
</body>
</html>
HTML_END

echo "‚úÖ –ì–æ—Ç–æ–≤–æ ‚Äì –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

# 1) –ü—Ä–æ—á–∏—Ç–∞–º–µ CSV –∏ –≥–æ –µ–∫—Ä–∞–Ω–∏—Ä–∞–º–µ –∑–∞ backticks
if [ ! -f "$CSV" ]; then
  echo "–ù–µ –æ—Ç–∫—Ä–∏—Ö $CSV" >&2
  exit 1
fi
# Slurp whole file, –∏–∑–±—è–≥–≤–∞–º–µ backtick ‚Äû`‚Äú
CSV_ESCAPED=$(sed 's/`/\\`/g' "$CSV")

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ HTML-–∞
cat >"$OUT" <<EOF
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />
  <style>
    td.max { background-color: #ffeb3b !important; }
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
    th { cursor: pointer; background: #f0f0f0; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
// ‚Äî‚Äî‚Äî –í–ì–†–ê–î–ï–ù–û CSV ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
const rawCSV = \`
${CSV_ESCAPED}
\`;
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

function parseCSV(text){
  return text.trim().split("\n").map(r=>r.split(","));
}

\$(document).ready(function(){
  const data = parseCSV(rawCSV);
  const header = data.shift();
  const N = (header.length - 5) / 2; // –±—Ä–æ—è—Ç –¥–≤–æ–π–∫–∏ Date/Elapsed

  // –†–∏—Å—É–≤–∞–º–µ header
  header.forEach((h,i)=>{
    \$('#table-header').append(
      `<th data-col="\${i}">\${h}</th>`
    );
  });

  const secsData = [];

  // –ü–æ–ø—ä–ª–≤–∞–º–µ body
  data.forEach((row,ridx)=>{
    const tr = \$('<tr>');
    const secsRow = [];
    let maxSec = -1, maxIdx = -1;

    // –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ —Å–µ–∫—É–Ω–¥–∏ –∏ –Ω–∞–º–∏—Ä–∞–º–µ max
    for(let j=0;j<N;j++){
      const val = row[4+2*j+1];
      const [h,m,s] = val.split(':').map(Number);
      const sec = h*3600 + m*60 + s;
      secsRow.push(sec);
      if(sec>maxSec){ maxSec=sec; maxIdx=j; }
    }

    // STATUS..JOB.NAME
    for(let c=0;c<4;c++){
      tr.append(`<td>\${row[c]}</td>`);
    }
    // Date/Elapsed
    for(let j=0;j<N;j++){
      tr.append(`<td>\${row[4+2*j]}</td>`);
      const cls = j===maxIdx ? 'max' : '';
      tr.append(`<td class="\${cls}">\${row[4+2*j+1]}</td>`);
    }
    // AVERAGE
    const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
    const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
    tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

    secsData.push(secsRow);
    \$('#table-body').append(tr);
  });

  // Init DataTable
  const table = \$('#data-table').DataTable({
    dom: 'Bfrtip', buttons:['colvis'], responsive:true, order:[],
    columnDefs:[{ targets:[0], orderable:false }]
  });

  // Column filters
  table.columns().every(function(){
    const col=this;
    const idx=col.index();
    const inp=\$('<input>').attr('placeholder','filter').addClass('form-control form-control-sm')
      .on('keyup change clear',()=>col.search(inp.val()).draw());
    \$(col.header()).empty().append(inp);
  });

  // Date-range filter
  function applyDateFilter(){
    const min=\$('#min-date').val();
    const max=\$('#max-date').val();
    const dates=header.slice(4,4+2*N).filter((_,i)=>i%2===0);
    dates.forEach((d,i)=>{
      const show = (!min||d>=min) && (!max||d<=max);
      table.column(4+2*i).visible(show);
      table.column(4+2*i+1).visible(show);
    });

    // –∞–∫–æ —Ç–æ—á–Ω–æ 2 –¥–∞—Ç–∏ ‚Äì Difference
    const sel = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
    if(sel.length===2 && !table.column(':contains("Difference")').nodes().length){
      const i1=dates.indexOf(sel[0]), i2=dates.indexOf(sel[1]);
      table.column.adjust().draw(false);
      \$('#table-header').append('<th>Difference</th>');
      \$('#table-body tr').each((ri,tr)=>{
        const d1=secsData[ri][i1], d2=secsData[ri][i2], delta=d2-d1;
        const s=Math.abs(delta), hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60;
        const sign=delta<0?'-':'';
        \$(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
      });
    }
  }

  flatpickr(".flatpickr",{dateFormat:"Y-m-d",onChange:applyDateFilter});
  \$('#clear-dates').on('click',()=>{
    \$('#min-date,#max-date').val('');
    applyDateFilter();
  });
});
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ: $OUT (–æ—Ç $CSV). –û—Ç–≤–æ—Ä–∏ –≤ –±—Ä–∞—É–∑—ä—Ä ‚Äî –≤–µ—á–µ —Ä–∞–±–æ—Ç–∏ –±–µ–∑ fetch!"







#!/usr/bin/env bash
set -euo pipefail

# Usage: ./generate_interactive.sh [input.csv] [output.html]
CSV="${1:-report.csv}"
OUT="${2:-interactive_report.html}"

cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>JT Interactive Report</title>

  <!-- Bootstrap 4 -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
  />

  <!-- DataTables + Buttons + Responsive -->
  <link 
    rel="stylesheet" 
    href="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.css"
  />

  <!-- Flatpickr –∑–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä -->
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
  />

  <style>
    /* –ñ—ä–ª—Ç–æ highlight –∑–∞ max */
    td.max { background-color: #ffeb3b !important; }
    /* –ú–∞–ª–∫–æ padding –Ω–∞ date-range –ø–æ–ª–µ—Ç–æ */
    #date-range { margin-bottom: 1rem; }
    th input { width: 100%; box-sizing: border-box; }
  </style>
</head>
<body class="bg-light">
  <div class="container-fluid py-4">
    <h2 class="mb-4">JT Interactive Report</h2>

    <!-- Date range pickers -->
    <div id="date-range" class="form-row">
      <div class="col-sm-3">
        <label>–û—Ç –¥–∞—Ç–∞:</label>
        <input type="text" id="min-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3">
        <label>–î–æ –¥–∞—Ç–∞:</label>
        <input type="text" id="max-date" class="form-control flatpickr" placeholder="YYYY-MM-DD">
      </div>
      <div class="col-sm-3 align-self-end">
        <button id="clear-dates" class="btn btn-secondary btn-block">–ò–∑—á–∏—Å—Ç–∏ —Ñ–∏–ª—Ç—ä—Ä–∞</button>
      </div>
    </div>

    <!-- Table -->
    <table id="data-table" class="table table-striped table-bordered w-100">
      <thead><tr id="table-header"></tr></thead>
      <tbody id="table-body"></tbody>
    </table>
  </div>

  <!-- JS libraries -->
  <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"
  ></script>
  <script 
    src="https://cdn.datatables.net/v/bs4/dt-1.13.4/b-2.3.6/r-2.5.0/datatables.min.js"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <script>
  // 1) –ó–∞—Ä–µ–∂–¥–∞–º–µ CSV
  async function loadCSV(path) {
    const resp = await fetch(path);
    const text = await resp.text();
    return text.trim().split('\n').map(r => r.split(','));
  }

  $(document).ready(async function(){
    const data = await loadCSV('${CSV}');
    const header = data.shift();
    const N = (header.length - 5) / 2; // –±—Ä–æ—è—Ç –¥–≤–æ–π–∫–∏ Date/Elapsed (–ø–æ—Å–ª–µ –∏–º–∞ AVERAGE)

    // –†–∏—Å—É–≤–∞–º–µ header
    header.forEach((h,i) => {
      $('#table-header').append(
        `<th data-col="\${i}" class="text-nowrap">${h}</th>`
      );
    });

    // –ü–æ–ø—ä–ª–≤–∞–º–µ body –∏ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ secsData
    const secsData = [];
    data.forEach((row, ridx) => {
      const tr = $('<tr>');
      const secsRow = [];

      // –∏–∑–æ–ª–∏—Ä–∞–º–µ Elapsed –∫–æ–ª–æ–Ω–∏ (index: 5,7,9,...)
      let maxSec = -1, maxIdx = -1;
      for(let j=0; j<N; j++){
        const val = row[4 + 2*j + 1];
        const [h,m,s] = val.split(':').map(Number);
        const sec = h*3600 + m*60 + s;
        secsRow.push(sec);
        if(sec > maxSec){ maxSec=sec; maxIdx=j; }
      }

      // STATUS, STAGE, BATCH, JOB.NAME (0..3)
      for(let c=0; c<4; c++){
        tr.append(`<td>\${row[c]}</td>`);
      }
      // Date/Elapsed –¥–≤–æ–π–∫–∏
      for(let j=0; j<N; j++){
        tr.append(`<td>\${row[4 + 2*j]}</td>`);
        const cls = (j===maxIdx ? 'max' : '');
        tr.append(`<td class="\${cls}">\${row[4 + 2*j +1]}</td>`);
      }
      // AVERAGE
      const avg = Math.floor(secsRow.reduce((a,b)=>a+b,0)/secsRow.length);
      const hh = Math.floor(avg/3600), mm = Math.floor((avg%3600)/60), ss = avg%60;
      tr.append(`<td>\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);

      secsData.push(secsRow);
      $('#table-body').append(tr);
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–º–µ DataTable
    const table = $('#data-table').DataTable({
      dom: 'Bfrtip',
      buttons: [ 'colvis' ],
      responsive: true,
      order: [],
      columnDefs: [{ targets: [0], orderable: false }]
    });

    // –ö–æ–ª–æ–Ω–Ω–∏ —Ñ–∏–ª—Ç—Ä–∏
    table.columns().every(function(){
      const col = this;
      const idx = col.index();
      const inp = $('<input>')
        .attr('placeholder','filter')
        .addClass('form-control form-control-sm')
        .on('keyup change clear', ()=>col.search(inp.val()).draw());
      $(col.header()).empty().append(inp);
    });

    // Date range —Ñ–∏–ª—Ç—ä—Ä
    function applyDateFilter() {
      const min = $('#min-date').val();
      const max = $('#max-date').val();
      const dates = header.slice(4,4+2*N).filter((_,i)=>i%2===0);
      dates.forEach((d,i)=>{
        const show = (!min||d>=min) && (!max||d<=max);
        table.column(4+2*i).visible(show);
        table.column(4+2*i+1).visible(show);
      });

      // —Ç–æ—á–Ω–æ –¥–≤–µ –¥–∞—Ç–∏ => —Ä–∞–∑–ª–∏–∫–∞
      const selected = dates.filter(d=>(!min||d>=min)&&(!max||d<=max));
      if(selected.length===2 && !table.column(':contains("Difference")').nodes().length) {
        const i1 = dates.indexOf(selected[0]);
        const i2 = dates.indexOf(selected[1]);
        // –¥–æ–±–∞–≤—è–º–µ –∫–æ–ª–æ–Ω–∞ Difference
        table.column.adjust().draw(false);
        $('#table-header').append('<th>Difference</th>');
        $('#table-body tr').each((ri,tr)=>{
          const sec1 = secsData[ri][i1], sec2 = secsData[ri][i2];
          const dsec = sec2 - sec1, s = Math.abs(dsec);
          const hh = Math.floor(s/3600), mm = Math.floor((s%3600)/60), ss = s%60;
          const sign = dsec<0?'-':'';
          $(tr).append(`<td>\${sign}\${String(hh).padStart(2,'0')}:\${String(mm).padStart(2,'0')}:\${String(ss).padStart(2,'0')}</td>`);
        });
      }
    }

    // flatpickr –∑–∞ date inputs
    flatpickr(".flatpickr", { dateFormat: "Y-m-d", onChange: applyDateFilter });
    $('#clear-dates').on('click', ()=>{
      $('#min-date,#max-date').val('');
      applyDateFilter();
    });
  });
  </script>
</body>
</html>
EOF

echo "‚úÖ –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–æ: $OUT (—á–µ—Ç–µ $CSV). –û—Ç–≤–æ—Ä–∏ –≥–æ –≤ –±—Ä–∞—É–∑—ä—Ä."





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ó–∞–ø–∏—Å–≤–∞–º–µ –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  th { cursor: pointer; background: #f0f0f0; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ <table> —Å –æ—Ü–≤–µ—Ç—è–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º—É–º–∞ –∏ –∫–ª–∏–∫–∞–µ–º–∏ <th>
awk -F, '
BEGIN {
  print "<table id=\"data-table\"><thead>";
}
NR==1 {
  print "<tr>";
  for(i=1;i<=NF;i++){
    # –ø—Ä–∞–≤–∏–º –∫–æ–ª–æ–Ω–∞—Ç–∞ —Å–æ—Ä—Ç–∏—Ä–∞—â –±—É—Ç–æ–Ω
    printf "<th onclick=\"sortTable(%d)\">%s</th>", i-1, $i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
  }
  print "</tr></thead><tbody>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600 + T[2]*60 + T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –º–∞—Ä–∫–∏—Ä–∞–º–µ class="max" —Å–∞–º–æ –Ω–∞ maxcol
  printf "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    printf "<td%s>%s</td>", cls, $i;
  }
  print "</tr>";
}
END {
  print "</tbody></table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ
cat >>"$OUT" <<'EOF'
<script>
// –ñ–∏–≤–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ:
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("#data-table tbody tr").forEach(function(row) {
    row.style.display = row.textContent.toLowerCase().includes(filter) ? "" : "none";
  });
});

// –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø—Ä–∏ –∫–ª–∏–∫ –Ω–∞ –∑–∞–≥–ª–∞–≤–∏–µ:
function sortTable(colIndex) {
  var table = document.getElementById("data-table");
  var tbody = table.tBodies[0];
  var rows  = Array.from(tbody.rows);
  // –û–ø—Ä–µ–¥–µ–ª—è–º–µ –ø–æ—Å–æ–∫–∞ (toggle)
  var currentCol = table.getAttribute("data-sort-col");
  var currentDir = table.getAttribute("data-sort-dir");
  var asc = !(currentCol==colIndex && currentDir=="asc");
  // –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ
  rows.sort(function(a, b) {
    var A = a.cells[colIndex].textContent.trim();
    var B = b.cells[colIndex].textContent.trim();
    return asc 
      ? (A > B ? 1 : A < B ? -1 : 0)
      : (A < B ? 1 : A > B ? -1 : 0);
  });
  // –†–µ–±–∏–ª–¥ –Ω–∞ tbody
  rows.forEach(function(r) { tbody.appendChild(r); });
  // –ó–∞–ø–æ–º–Ω—è–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ
  table.setAttribute("data-sort-col", colIndex);
  table.setAttribute("data-sort-dir", asc ? "asc" : "desc");
}
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä." 





#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

# 1) –ü–∏—à–µ–º –Ω–∞—á–∞–ª–æ—Ç–æ –Ω–∞ HTML + —Å—Ç–∏–ª–æ–≤–µ + —Ç—ä—Ä—Å–∞—á–∫–∞
cat >"$OUT" <<'EOF'
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  table, th, td { border: 1px solid #ccc; border-collapse: collapse; }
  th, td { padding: 4px 8px; }
  .max { background-color: #ffeb3b; }
  #search { margin: 10px 0; padding: 6px; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<input type="text" id="search" placeholder="–¢—ä—Ä—Å–∏ –≤ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞‚Ä¶">
EOF

# 2) –ì–µ–Ω–µ—Ä–∏—Ä–∞–º–µ —Å–∞–º–∞—Ç–∞ <table> –æ—Ç CSV, –∫–∞—Ç–æ –æ—Ü–≤–µ—Ç—è–≤–∞–º–µ max Elapsed –Ω–∞ —Ä–µ–¥
awk -F, '
BEGIN {
  OFS="";
  print "<table>";
}
NR==1 {
  # header
  print "<tr>";
  for(i=1;i<=NF;i++){
    header[i]=$i;
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    print "<th>"$i"</th>";
  }
  print "</tr>";
  next;
}
{
  # –Ω–∞–º–∏—Ä–∞–º–µ max —Å—Ä–µ–¥ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  maxsec=-1; maxcol=0;
  for(j=1;j<=ecount;j++){
    idx=elapsed_idx[j];
    split($idx, T, ":");
    sec=T[1]*3600+T[2]*60+T[3];
    if(sec>maxsec){ maxsec=sec; maxcol=idx }
  }
  # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –∫–∞—Ç–æ —Å–∞–º–æ –ø—Ä–∏ maxcol –¥–æ–±–∞–≤—è–º–µ class="max"
  print "<tr>";
  for(i=1;i<=NF;i++){
    cls = (i==maxcol ? " class=\"max\"" : "");
    print "<td" cls ">" , $i , "</td>";
  }
  print "</tr>";
}
END {
  print "</table>";
}' "$CSV" >> "$OUT"

# 3) –î–æ–±–∞–≤—è–º–µ JS –∑–∞ –∂–∏–≤–æ—Ç–æ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ –ø—Ä–∏ –ø–∏—Å–∞–Ω–µ –≤ –ø–æ–ª–µ—Ç–æ #search
cat >>"$OUT" <<'EOF'
<script>
document.getElementById('search').addEventListener('input', function(e) {
  var filter = e.target.value.toLowerCase();
  document.querySelectorAll("table tr").forEach(function(row, i) {
    if(i === 0) return; // skip header
    var text = row.textContent.toLowerCase();
    row.style.display = text.includes(filter) ? "" : "none";
  });
});
</script>
</body>
</html>
EOF

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ '$OUT' –≤ –±—Ä–∞—É–∑—ä—Ä, –∑–∞ –¥–∞ –≤–∏–¥–∏—à —Ç—ä—Ä—Å–∞—á–∫–∞—Ç–∞ –∏ –æ—Ü–≤–µ—Ç–µ–Ω–∏—è –º–∞–∫—Å–∏–º—É–º."




#!/usr/bin/env bash
set -euo pipefail

CSV="${1:-report.csv}"
OUT="${2:-report.html}"

awk -F, '
BEGIN {
  OFS=""
  # –ù–∞—á–∞–ª–æ –Ω–∞ HTML-–∞ –∏ —Å—Ç–∏–ª–∏—Å—Ç–∏–∫–∞
  print "<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><style>"
  print "table, th, td { border: 1px solid #ccc; border-collapse: collapse; }"
  print "th, td { padding: 4px 8px; }"
  print ".max { background-color: #ffeb3b; }"
  print "</style></head><body><table>"
}
NR==1 {
  # –•–µ–¥—ä—Ä-—Ä–µ–¥: –Ω–∞–º–∏—Ä–∞–º–µ –∏–Ω–¥–µ–∫—Å–∏—Ç–µ –Ω–∞ Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ
  printf "<tr>"
  for(i=1;i<=NF;i++){
    header[i]=$i
    if($i ~ /^Elapsed/) { ecount++; elapsed_idx[ecount]=i }
    printf "<th>%s</th>", $i
  }
  print "</tr>"
  next
}
{
  # –ó–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥ –Ω–∞–º–∏—Ä–∞–º–µ –∫–æ—è –æ—Ç Elapsed –∫–æ–ª–æ–Ω–∏—Ç–µ –µ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞
  maxsec = -1; maxcol = 0
  for(j=1;j<=ecount;j++){
    idx = elapsed_idx[j]
    split($idx, T, ":")
    sec = T[1]*3600 + T[2]*60 + T[3]
    if(sec > maxsec){
      maxsec = sec
      maxcol = idx
    }
  }
  # –û—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ —Ä–µ–¥–∞, –∫–∞—Ç–æ cell i=maxcol –ø–æ–ª—É—á–∞–≤–∞ –∫–ª–∞—Å="max"
  printf "<tr>"
  for(i=1;i<=NF;i++){
    if(i==maxcol)
      printf "<td class=\"max\">%s</td>", $i
    else
      printf "<td>%s</td>", $i
  }
  print "</tr>"
}
END {
  print "</table></body></html>"
}' "$CSV" > "$OUT"

echo "‚úÖ –ì–æ—Ç–æ–≤–æ! –û—Ç–≤–æ—Ä–∏ $OUT –≤ –±—Ä–∞—É–∑—ä—Ä, –∑–∞ –¥–∞ –≤–∏–¥–∏—à –æ—Ü–≤–µ—Ç–µ–Ω–∏—Ç–µ –º–∞–∫—Å–∏–º—É–º–∏."






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º—è–Ω–∞ –Ω–∞ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# --- –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –¥–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files     = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# --- –ü–∞—Ä—Å–≤–∞–º–µ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª –∏ –ø—ä–ª–Ω–∏–º data[key][idx] ---
data  = {}                           # data[(stage,batch,job)] = { idx0: {...}, idx1: {...}, ... }
dates = [None]*len(files)            # dates[i] = –¥–∞—Ç–∞ –æ—Ç —Ñ–∞–π–ª i

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date              = parts[3]
            elapsed           = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # –ó–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª
    if dates[idx] is None:
        dates[idx] = date

# --- –ü–∏—Å–∞–Ω–µ –Ω–∞ CSV –Ω–∞ stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
header.append("AVERAGE")
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á –≥–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –ø–æ –µ–¥–∏–Ω —Ä–µ–¥
for key in sorted(data.keys()):
    rec = []
    d   = data[key]
    # STATUS: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–æ (idx=0) –∏ –ø–æ—Å–ª–µ–¥–Ω–æ (idx=N-1) Elapsed
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "‚Üë"
    elif sN < s1: status = "‚Üì"
    else:          status = "="

    # –ü—ä—Ä–≤–∏—Ç–µ 4 –ø–æ–ª–µ—Ç–∞
    rec = [status, *key]

    # –°–ø–∏—Å—ä–∫ –∑–∞ –≤—Å–∏—á–∫–∏ secs, –∑–∞ —Å–º—è—Ç–∞–Ω–µ –Ω–∞ —Å—Ä–µ–¥–Ω–æ
    secs_list = []

    # –ü–æ –¥–≤–æ–π–∫–∏ Date_i, Elapsed_i
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec.append(info["date"])
            rec.append(info["elapsed"])
            secs_list.append(info["secs"])
        else:
            rec += ["", ""]

    # –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ AVERAGE (floor of mean)
    if secs_list:
        avg = sum(secs_list) // len(secs_list)
        hh  = avg // 3600
        mm  = (avg % 3600) // 60
        ss  = avg % 60
        avg_str = f"{hh:02d}:{mm:02d}:{ss:02d}"
    else:
        avg_str = ""
    rec.append(avg_str)

    out.writerow(rec)






#!/usr/bin/env python3
import glob, sys, os, csv

def parse_time(t):
    """–ü—Ä–µ–≤—Ä—ä—â–∞ 'HH:MM:SS' –≤ —Å–µ–∫—É–Ω–¥–∏."""
    h, m, s = t.split(":")
    return int(h)*3600 + int(m)*60 + int(s)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∏ –±—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ ---
# –ê–∫–æ –∏–º–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏, –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –ø—ä—Ä–≤–∏—è—Ç –µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:
arg1 = sys.argv[1] if len(sys.argv) > 1 else None
arg2 = sys.argv[2] if len(sys.argv) > 2 else None

if arg1 and os.path.isdir(arg1):
    files_dir = arg1
    try:
        N = int(arg2) if arg2 else 31
    except ValueError:
        N = 31
else:
    files_dir = "."
    try:
        N = int(arg1) if arg1 else 31
    except ValueError:
        N = 31

# –°–º–µ–Ω—è–º–µ —Ä–∞–±–æ—Ç–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
try:
    os.chdir(files_dir)
except Exception as e:
    sys.exit(f"–ù–µ –º–æ–≥–∞ –¥–∞ –≤–ª—è–∑–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è '{files_dir}': {e}")

# --- –°—ä–±–∏—Ä–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ JT* –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –ø—Ä–æ–º—è–Ω–∞ ---
all_files = [f for f in glob.glob("JT*") if os.path.isfile(f)]
files = sorted(all_files, key=os.path.getmtime)[-N:]
if not files:
    sys.exit("–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT* –≤ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–∞–ø–∫–∞.")

# --- –ü–∞—Ä—Å–∏–º–µ –≤—Å–µ–∫–∏ —Ä–µ–¥ –∏ –≥—Ä–∞–¥–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ data[key][idx] ---
data = {}
dates = [None]*len(files)

for idx, fn in enumerate(files):
    with open(fn) as f:
        for line in f:
            parts = line.rstrip("\n").split(",")
            if len(parts) < 8:
                continue
            stage, batch, job = parts[0], parts[1], parts[2]
            date    = parts[3]
            elapsed = parts[7]
            try:
                secs = parse_time(elapsed)
            except:
                secs = 0
            key = (stage, batch, job)
            data.setdefault(key, {})[idx] = {
                "date":    date,
                "elapsed": elapsed,
                "secs":    secs
            }
    # –ó–∞–ø–∞–∑–≤–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –Ω–∞ idx-—Ç–∏—è —Ñ–∞–π–ª
    if dates[idx] is None:
        dates[idx] = date

# --- –ü–∏—à–µ–º CSV –Ω–∞ stdout ---
out = csv.writer(sys.stdout, lineterminator="\n")
# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
header = ["STATUS", "STAGE", "BATCH", "JOB.NAME"]
for i in range(1, len(files)+1):
    header += [f"Date{i}", f"Elapsed{i}"]
out.writerow(header)

# –ó–∞ –≤—Å–µ–∫–∏ job (—Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ STAGE,BATCH,JOB)
for key in sorted(data.keys()):
    rec = []
    d = data[key]
    # STATUS = ‚Üë –∞–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç e –ø–æ-–±–∞–≤–µ–Ω, ‚Üì –∞–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç e –µ –ø–æ-–±—ä—Ä–∑, = –∞–∫–æ –µ–¥–Ω–∞–∫–≤–∏
    s1 = d.get(0, {}).get("secs", 0)
    sN = d.get(len(files)-1, {}).get("secs", 0)
    if   sN > s1: status = "‚Üë"
    elif sN < s1: status = "‚Üì"
    else:          status = "="

    rec = [status, *key]
    for idx in range(len(files)):
        info = d.get(idx)
        if info:
            rec += [info["date"], info["elapsed"]]
        else:
            rec += ["", ""]
    out.writerow(rec)





#!/usr/bin/env bash
set -euo pipefail

# –ë—Ä–æ–π —Ñ–∞–π–ª–∞ –Ω–∞–∑–∞–¥ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 31)
N=${1:-31}

# –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ (–ø–æ modification time)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")
if [ "${#files[@]}" -lt 1 ]; then
  echo "–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ JT* —Ñ–∞–π–ª–æ–≤–µ."
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS=","
    # –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    printf "STATUS,STAGE,BATCH,JOB.NAME"
    for(i=1;i<=N;i++){
      printf ",Date%d,Elapsed%d", i, i
    }
    print ""
    idx=0
  }
  # –ó–∞ –≤—Å–µ–∫–∏ —Ñ–∞–π–ª —É–≤–µ–ª–∏—á–∞–≤–∞–º–µ idx
  FNR==1 { idx++ }
  {
    # –∫–ª—é—á –∑–∞ JOB
    key = $1 SUBSEP $2 SUBSEP $3
    if (!(key in seen)) {
      seen[key]=1
      keys[++K]=key
    }
    # –∑–∞–ø–æ–º–Ω—è–º–µ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª (–µ–¥–Ω–∞ –∏ —Å—ä—â–∞ per —Ñ–∞–π–ª)
    if (!(idx in dates)) {
      dates[idx] = $4
    }
    # Elapsed –∏ –≤ —Å–µ–∫—É–Ω–¥–∏
    elapsed[key,idx] = $8
    split($8, T, ":")
    secs[key,idx]    = T[1]*3600 + T[2]*60 + T[3]
  }
  END {
    # –∑–∞ –≤—Å–µ–∫–∏ JOB –∫–ª—é—á
    for(j=1;j<=K;j++){
      key = keys[j]
      # —Å—Ç–∞—Ç—É—Å: —Å—Ä–∞–≤–Ω—è–≤–∞–º–µ –ø—ä—Ä–≤–∏ vs –ø–æ—Å–ª–µ–¥–µ–Ω –¥–µ–Ω
      s1 = (key,1 in secs ? secs[key,1] : 0)
      sN = (key,N in secs ? secs[key,N] : 0)
      status = (sN > s1 ? "‚Üë" : (sN < s1 ? "‚Üì" : "="))
      # —Ä–∞–∑–±–∏–≤–∞–º–µ –∫–ª—é—á–∞ –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ STAGE,BATCH,JOB.NAME
      split(key, F, SUBSEP)
      printf "%s,%s,%s,%s", status, F[1], F[2], F[3]
      # –∏ –∑–∞ –≤—Å–µ–∫–∏ –¥–µ–Ω Datei, Elapsedi
      for(i=1;i<=N;i++){
        d = (i in dates ? dates[i] : "")
        e = ((key,i) in elapsed ? elapsed[key,i] : "")
        printf ",%s,%s", d, e
      }
      print ""
    }
  }
' "${files[@]}"







#!/usr/bin/env bash
set -euo pipefail

# –ë—Ä–æ–π –¥–Ω–∏ –Ω–∞–∑–∞–¥ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 31; –º–æ–∂–µ—à –¥–∞ –ø–æ–¥–∞–¥–µ—à –¥—Ä—É–≥–æ —á–∏—Å–ª–æ –∫–∞—Ç–æ –ø—ä—Ä–≤–∏ –∞—Ä–≥—É–º–µ–Ω—Ç)
N=${1:-31}

# –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ –ø–æ modification time
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -eq 0 ]; then
  echo "–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ JT*"
  exit 1
fi

awk -F, -v N="$N" '
  BEGIN {
    OFS = ",";
    idx = 0;
  }
  # –í—Å–µ–∫–∏ –ø—ä—Ç, –∫–æ–≥–∞—Ç–æ –∑–∞–ø–æ—á–≤–∞ –Ω–æ–≤ —Ñ–∞–π–ª, –≤–¥–∏–≥–∞–º–µ –±—Ä–æ—è—á–∞
  FNR==1 { idx++; }
  {
    # –°—Ç—Ä–æ–∏–º –∫–ª—é—á–∞ –æ—Ç BATCH.STAGE,BATCH,JOB.NAME
    key = $1 FS $2 FS $3;
    # –ü–∞–∑–∏ —Å–ø–∏—Å—ä–∫ —Å —É–Ω–∏–∫–∞–ª–Ω–∏ –∫–ª—é—á–æ–≤–µ –∑–∞ –∫—Ä–∞–π–Ω–æ—Ç–æ –æ–±—Ö–æ–∂–¥–∞–Ω–µ
    if (!(key in seen)) {
      seen[key]=1;
      keys[++K]=key;
    }
    # –ó–∞–ø–∏—à–∏ –¥–∞—Ç–∞—Ç–∞ –∑–∞ —Ç–æ–∑–∏ —Ñ–∞–π–ª (—Ñ–∞–π–ª—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ —Å—ä—â–∞—Ç–∞ –¥–∞—Ç–∞ –Ω–∞ –≤—Å–µ–∫–∏ —Ä–µ–¥)
    if (!(idx in dates)) {
      dates[idx] = $4;
    }
    # –ó–∞–ø–∞–∑–∏ elapsed –∏ —Å–µ–∫—É–Ω–¥–∏
    elapsed[key","idx] = $8;
    split($8, T, ":");
    secs[key","idx] = T[1]*3600 + T[2]*60 + T[3];
  }
  END {
    # 1) –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
    printf "BATCH.STAGE,BATCH,JOB.NAME";
    for (i=1; i<=N; i++) {
      printf ",Date%d,Elapsed%d", i, i;
    }
    print "";

    # 2) –ó–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á ‚Äì –∏–∑–ø–∏—Å–≤–∞–º–µ —Ä–µ–¥
    for (r=1; r<=K; r++) {
      key = keys[r];
      split(key, F, FS);
      # –ø—ä—Ä–≤–∏—Ç–µ —Ç—Ä–∏ –ø–æ–ª–µ—Ç–∞
      printf "%s,%s,%s", F[1], F[2], F[3];
      # —Å–ª–µ–¥ —Ç–æ–≤–∞ –∑–∞ –≤—Å–µ–∫–∏ –æ—Ç N-—Ç–µ –¥–Ω–∏
      for (i=1; i<=N; i++) {
        d = dates[i];
        e = elapsed[key","i] ? elapsed[key","i] : "";
        arrow = "";
        if (i>1 && e!="") {
          prev = secs[key","i-1];
          curr = secs[key","i];
          if (curr > prev)   arrow = "‚Üë";  # –∑–∞–±–∞–≤—è–Ω–µ
          else if (curr < prev) arrow = "‚Üì";  # —É—Å–∫–æ—è–≤–∞–Ω–µ
        }
        printf ",%s,%s%s", d, arrow, e;
      }
      print "";
    }
  }
' "${files[@]}"






#!/usr/bin/env bash
set -euo pipefail

# –∞–∫–æ –ø–æ–¥–∞–¥–µ—à –µ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç, —Ç–æ–≤–∞ –µ –±—Ä–æ—è—Ç –¥–Ω–∏ –Ω–∞–∑–∞–¥; –∏–Ω–∞—á–µ ‚Äì 31
N=${1:-31}

# 1) —Å—ä–±–∏—Ä–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ñ–∞–π–ª–∞ –ø–æ modification time (ls -1tr —Å—Ç–∞—Ä—Ç–∏—Ä–∞ —Å—Ç–∞—Ä–æ->–Ω–æ–≤–æ)
mapfile -t files < <(ls -1tr JT* | tail -n "$N")

if [ "${#files[@]}" -lt 2 ]; then
  echo "–ù—è–º–∞ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ —Ñ–∞–π–ª–æ–≤–µ –≤ JT* (—Ç—Ä—è–±–≤–∞—Ç –ø–æ–Ω–µ 2 –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ $N)."
  exit 1
fi

# –ü–µ—á–∞—Ç–∞–º–µ header —Å–∞–º–æ –≤–µ–¥–Ω—ä–∂
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# 2) –∑–∞ –≤—Å–µ–∫–∏ –¥–≤–∞ –ø–æ—Ä–µ–¥–Ω–∏ —Ñ–∞–π–ª–∞ ‚Äì —Å—Ç–∞—Ä–∏—è—Ç –∏ —Å–ª–µ–¥–≤–∞—â–∏—è
for ((i=1; i<${#files[@]}; i++)); do
  f1=${files[i-1]}
  f2=${files[i]}

  # —Å—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ awk –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–Ω–µ
  awk -F, -v OFS=, '
    FNR==NR {
      # —á–µ—Ç–µ–º file1
      key            = $1 FS $2 FS $3
      date1[key]     = $4
      elapsed1[key]  = $8
      split($8, t1, ":")
      secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
      next
    }
    {
      # —á–µ—Ç–µ–º file2
      key            = $1 FS $2 FS $3
      d2             = $4
      e2             = $8
      split(e2, t2, ":")
      secs2          = t2[1]*3600 + t2[2]*60 + t2[3]

      # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
      delta          = (key in secs1 ? secs1[key] : 0) - secs2

      # –ø–µ—á–∞—Ç–∞–º–µ —Å–∞–º–æ –∞–∫–æ secs1 > secs2 (—Ç.–µ. date1 –µ –ø–æ-–±–∞–≤–Ω–æ)
      if (secs1[key] > secs2) {
        # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ Diff –∫–∞—Ç–æ HH:MM:SS (–ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–æ —á–∏—Å–ª–æ)
        hh   = int(delta/3600)
        mm   = int((delta%3600)/60)
        ss   = delta % 60
        diff = sprintf("%02d:%02d:%02d", hh, mm, ss)

        # —Å—Ç—Ä–µ–ª–∫–∞—Ç–∞ –≤–∏–Ω–∞–≥–∏ ‚Üë (date1 –µ –ø–æ-–±–∞–≤–Ω–æ)
        arrow = "‚Üë"

        # –æ—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ:
        #   arrow+stage, batch, job.name,
        #   date1, elapsed1,
        #   date2, elapsed2,
        #   diff
        print arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
      }
    }
  ' "${f1}" "${f2}"
done




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- –≤—Ç–æ—Ä–∏ —Ñ–∞–π–ª (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ‚Üë –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2), –∏–Ω–∞—á–µ ‚Üì
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "‚Üë" : "‚Üì")

    # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-







#!/usr/bin/env bash
set -euo pipefail

if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –Ω–∞–º–µ—Ä–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ JT*<–¥–∞—Ç–∞>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# –ø–µ—á–∞—Ç–∞–º–µ header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# –ø—Ä–∞–≤–∏–º awk –∏ –≤–µ–¥–Ω–∞–≥–∞ pipe –∫—ä–º sort –∏ cut
awk -F, -v OFS=, '
  # –ü—ä—Ä–≤–æ: –∑–∞—Ä–µ–∂–¥–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç file1 (date1)
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t1, ":")
    secs1[key]     = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # –°–ª–µ–¥ —Ç–æ–≤–∞ file2 (date2)
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta          = secs1[key] - secs2
    # —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2)
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ Diff –∫–∞—Ç–æ HH:MM:SS (–±–µ–∑ –∑–Ω–∞–∫, –≤–∏–Ω–∞–≥–∏ –ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–æ)
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta % 60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ –≤–∏–Ω–∞–≥–∏ ‚Üë (date1 –ø–æ-–±–∞–≤–Ω–æ)
      arrow = "‚Üë"
      # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) –ø—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) —Å–µ–≥–∞ file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = secs1[key] - secs2
    # —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ (—â–µ –µ –≤–∏–Ω–∞–≥–∏ ‚Üë —Ç—É–∫)
      arrow = "‚Üë"
      # –ø–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –∫–æ–ª–æ–Ω–∏—Ç–µ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # —Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ delta (–Ω–∞–π-–≥–æ–ª—è–º first)
| cut -d, -f2-          # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞




#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK: collect date1 info, then in file2 only print if secs1>secs2
awk -F, -v OFS=, '
  # 1) –ø—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # 2) —Å–µ–≥–∞ file2
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = secs1[key] - secs2
    # —Å–∞–º–æ –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ
    if (secs1[key] > secs2) {
      # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
      hh    = int(delta/3600)
      mm    = int((delta%3600)/60)
      ss    = delta%60
      diff  = sprintf("%02d:%02d:%02d", hh, mm, ss)
      # —Å—Ç—Ä–µ–ª–∫–∞ (—â–µ –µ –≤–∏–Ω–∞–≥–∏ ‚Üë —Ç—É–∫)
      arrow = "‚Üë"
      # –ø–µ—á–∞—Ç–∞–º–µ –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –∫–æ–ª–æ–Ω–∏—Ç–µ
      print delta, \
            arrow $1, $2, $3, \
            date1[key], elapsed1[key], \
            d2,          e2, \
            diff
    }
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \    # —Å–æ—Ä—Ç–∏—Ä–∞–º–µ –ø–æ delta (–Ω–∞–π-–≥–æ–ª—è–º first)
| cut -d, -f2-          # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta in favor of date1, add arrow, sort and drop temp col
awk -F, -v OFS=, '
  # --- –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª (date1) ---
  FNR==NR {
    key           = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t1, ":")
    secs1[key]    = t1[1]*3600 + t1[2]*60 + t1[3]
    next
  }
  # --- –≤—Ç–æ—Ä–∏ —Ñ–∞–π–ª (date2) ---
  {
    key           = $1 FS $2 FS $3
    d2            = $4
    e2            = $8
    split(e2, t2, ":")
    secs2         = t2[1]*3600 + t2[2]*60 + t2[3]

    # delta = secs1 - secs2 (–≤ –ø–æ–ª–∑–∞ –Ω–∞ date1)
    delta         = (key in secs1 ? secs1[key] : 0) - secs2

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ ¬±HH:MM:SS
    sign          = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh            = int(delta/3600)
    mm            = int((delta%3600)/60)
    ss            = delta % 60
    diff          = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # arrow: ‚Üë –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2), –∏–Ω–∞—á–µ ‚Üì
    arrow         = ((key in secs1 && secs1[key] > secs2) ? "‚Üë" : "‚Üì")

    # –ø—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# AWK + SORT + CUT –Ω–∞ –µ–¥–∏–Ω —Ä–µ–¥
awk -F, -v OFS=, '
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    arrow          = (secs1[key] > secs2 ? "‚Üë" : "‚Üì")

    # –ü—ä—Ä–≤–∞ –∫–æ–ª–æ–Ω–∞ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
    print delta, arrow $1, $2, $3, date1[key], elapsed1[key], d2, e2, diff
  }
' "$file1" "$file2" | sort -t, -k1,1nr | cut -d, -f2-





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find the two files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Print header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# Extract, compute delta, add arrow, sort and drop the temp column
awk -F, -v OFS=, '
  # 1) –ü—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ file1 –∏ –∑–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ:
  #      key = BATCH.STAGE FS BATCH FS JOB.NAME
  #      date1[key]    = $4
  #      elapsed1[key] = $8  (–∏ –≤ —Å–µ–∫—É–Ω–¥–∏ secs1[key])
  FNR==NR {
    key            = $1 FS $2 FS $3
    date1[key]     = $4
    elapsed1[key]  = $8
    split($8, t, ":")
    secs1[key]     = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  # 2) –ü–æ—Å–ª–µ –º–∏–Ω–∞–≤–∞–º–µ file2 –∏ –∑–∞ –≤—Å–µ–∫–∏ —Å—ä—â–∏—è key:
  {
    key            = $1 FS $2 FS $3
    d2             = $4
    e2             = $8
    split(e2, t2, ":")
    secs2          = t2[1]*3600 + t2[2]*60 + t2[3]
    s1             = (key in secs1 ? secs1[key] : 0)
    delta          = secs2 - s1

    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ diff –≤ ¬±HH:MM:SS
    sign           = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh             = int(delta/3600)
    mm             = int((delta%3600)/60)
    ss             = delta % 60
    diff           = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –∞–∫–æ date1 –µ –ø–æ-–±–∞–≤–Ω–æ (secs1 > secs2) ‚Äì —Å—Ç—Ä–µ–ª–∫–∞ ‚Üë, –∏–Ω–∞—á–µ ‚Üì
    arrow          = (secs1[key] > secs2 ? "‚Üë" : "‚Üì")

    # –ü—ä—Ä–≤–æ delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ —Å—Ç—Ä–µ–ª–∫–∞—Ç–∞+stage –∏ –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –ø–æ–ª–µ—Ç–∞
    print delta, \
          arrow $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \     # —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ –ø–æ delta –Ω–∏–∑—Ö–æ–¥—è—â–æ
| cut -d, -f2-            # –º–∞—Ö–∞–º–µ –≤—Ä–µ–º–µ–Ω–Ω–∞—Ç–∞ numeric delta-–∫–æ–ª–æ–Ω–∞





#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# Find files
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# Header
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

# awk + sort + cut
awk -F, -v OFS=, '
  # –ß–µ—Ç–µ–º –ø—ä—Ä–≤–∏ —Ñ–∞–π–ª: –∑–∞–ø–∞–∑–≤–∞–º–µ –ø–æ –∫–ª—é—á (1,2,3) –¥–∞—Ç–∞—Ç–∞ –∏ elapsed, –∏ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ secs1
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }
  # –í—Ç–æ—Ä–∏ —Ñ–∞–π–ª: —Å–º—è—Ç–∞–º–µ secs2 –∏ delta
  {
    key    = $1 FS $2 FS $3
    d2     = $4
    e2     = $8
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    # –§–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ diff –∫–∞—Ç–æ ¬±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü—ä—Ä–≤–æ –∫–æ–ª–æ–Ω–∞ —Å delta (–∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ), –ø–æ—Å–ª–µ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ
    print delta, \
          $1, $2, $3, \
          date1[key], elapsed1[key], \
          d2,          e2, \
          diff
  }
' "$file1" "$file2" \
| sort -t, -k1,1nr \
| cut -d, -f2-



#!/usr/bin/env bash

# Usage check
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –ù–∞–º–µ—Ä–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞ JT*<–¥–∞—Ç–∞>*
f1=(JT*${d1}*)
f2=(JT*${d2}*)
if [ ! -f "${f1[0]}" ] || [ ! -f "${f2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
file1=${f1[0]}
file2=${f2[0]}

# –ó–∞–≥–ª–∞–≤–µ–Ω —Ä–µ–¥
echo "BATCH.STAGE,BATCH,JOB.NAME,Date1,Elapsed1,Date2,Elapsed2,Diff"

awk -F, -v OFS=, '
  # –ü—ä—Ä–≤–æ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ –ø—ä—Ä–≤–∏—è —Ñ–∞–π–ª –∏ –∑–∞–ø–∞–º–µ—Ç—è–≤–∞–º–µ –∑–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á (1,2,3):
  #   - –Ω–µ–≥–æ–≤–∞—Ç–∞ –¥–∞—Ç–∞ (–ø–æ–ª–µ 4)
  #   - elapsed time (–ø–æ–ª–µ 8) –∫–∞–∫—Ç–æ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª, —Ç–∞–∫–∞ –∏ –≤ —Å–µ–∫—É–Ω–¥–∏
  FNR==NR {
    key = $1 FS $2 FS $3
    date1[key]    = $4
    elapsed1[key] = $8
    split($8, tt, ":")
    secs1[key]    = tt[1]*3600 + tt[2]*60 + tt[3]
    next
  }

  # –°–µ–≥–∞ –≤—ä–≤ –≤—Ç–æ—Ä–∏—è —Ñ–∞–π–ª –∑–∞ –≤—Å–µ–∫–∏ —Å—ä—â–∏—è –∫–ª—é—á:
  {
    key      = $1 FS $2 FS $3
    d2       = $4
    e2       = $8
    split(e2, tt2, ":")
    secs2    = tt2[1]*3600 + tt2[2]*60 + tt2[3]
    s1       = (key in secs1 ? secs1[key] : 0)
    delta    = secs2 - s1

    # –§–æ—Ä–º–∞—Ç–∏—Ä–∞–º–µ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –≤ ¬±HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ –∂–µ–ª–∞–Ω–∏—è —Ä–µ–¥
    print \
      $1,    $2,    $3,          \
      date1[key], elapsed1[key], \
      d2,          e2,            \
      diff
  }
' "$file1" "$file2"




#!/usr/bin/env bash

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –¥–≤–µ –¥–∞—Ç–∏
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

d1=$1
d2=$2

# –û—Ç–∫—Ä–∏–≤–∞–º–µ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞ JT*<–¥–∞—Ç–∞>*
files1=(JT*${d1}*)
files2=(JT*${d2}*)
if [ ! -f "${files1[0]}" ] || [ ! -f "${files2[0]}" ]; then
  echo "–ù–µ –Ω–∞–º–µ—Ä–∏—Ö —Ñ–∞–π–ª–æ–≤–µ JT*${d1}* –∏–ª–∏ JT*${d2}*"
  exit 1
fi
f1=${files1[0]}
f2=${files2[0]}

awk -F, -v OFS=, '
  #
  # –ü—ä—Ä–≤–æ —á–µ—Ç–µ–º —Ñ–∞–π–ª1 (–∑–∞ date1):
  #   key = –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –æ—Ç –ø–æ–ª–µ—Ç–∞ 1..4 (JOB fields)
  #   –∑–∞–ø–∏—Å–≤–∞–º–µ date1, start, stop –∏ elapsed –∏ –ø—Ä–µ—Å–º—è—Ç–∞–º–µ —Å–µ–∫—É–Ω–¥–∏
  #
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4
    date1[key]    = $5        # –ø–æ–ªe 5 –µ –¥–∞—Ç–∞—Ç–∞ –≤—ä–≤ –≤—Ö–æ–¥–Ω–∏—è —Ä–µ–¥
    start1[key]   = $7        # –ø–æ–ª–µ 7 = —Å—Ç–∞—Ä—Ç –≤—Ä–µ–º–µ
    stop1[key]    = $8        # –ø–æ–ª–µ 8 = —Å—Ç–æ–ø –≤—Ä–µ–º–µ
    elapsed1[key] = $9        # –ø–æ–ª–µ 9 = elapsed
    split($9, t, ":")
    secs1[key]    = t[1]*3600 + t[2]*60 + t[3]
    next
  }

  #
  # –°–µ–≥–∞ —á–µ—Ç–µ–º —Ñ–∞–π–ª2 (–∑–∞ date2) –∏ –∑–∞ –≤—Å–µ–∫–∏ –∫–ª—é—á
  # ‚óè –≤–∑–∏–º–∞–º–µ –ø–æ–ª–µ—Ç–∞ 1..4
  # ‚óè –≤–∑–∏–º–∞–º–µ date2, start2, stop2, elapsed2
  # ‚óè —Å–º—è—Ç–∞–º–µ diff = elapsed2 - elapsed1
  #
  {
    key    = $1 FS $2 FS $3 FS $4
    d2     = $5
    s2     = $7
    e2     = $9
    split(e2, t2, ":")
    secs2  = t2[1]*3600 + t2[2]*60 + t2[3]
    s1     = (key in secs1 ? secs1[key] : 0)
    delta  = secs2 - s1

    sign   = ""
    if (delta<0) { sign="-"; delta = -delta }
    hh     = int(delta/3600)
    mm     = int((delta%3600)/60)
    ss     = delta%60
    diff   = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ:
    #  $1,$2,$3,$4 ‚Äî –ø–æ–ª–µ—Ç–∞ –¥–æ JOB.NAME
    #  date1, start1, stop1, elapsed1
    #  date2, start2, stop2, elapsed2
    #  diff
    print \
      $1, $2, $3, $4, \
      date1[key], start1[key], stop1[key], elapsed1[key], \
      d2,       s2,         $8,        e2,        \
      diff
  }
' "$f1" "$f2"




#!/usr/bin/env bash

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
if [ $# -ne 2 ]; then
  echo "Usage: $0 <date1: YYYYMMDD> <date2: YYYYMMDD>"
  exit 1
fi

date1=$1
date2=$2

# –ù–∞–º–∏—Ä–∞–º–µ –∏–º–µ–Ω–∞—Ç–∞ –Ω–∞ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –º–∞—Å–∫–∞
file1=(JT*${date1}*)
file2=(JT*${date2}*)

if [ ! -f "${file1[0]}" ] || [ ! -f "${file2[0]}" ]; then
  echo "–ù–µ –º–æ–∂–∞—Ö–∞ –¥–∞ —Å–µ –Ω–∞–º–µ—Ä—è—Ç —Ñ–∞–π–ª–æ–≤–µ JT*${date1}* –∏–ª–∏ JT*${date2}*"
  exit 1
fi

file1=${file1[0]}
file2=${file2[0]}

awk -F, -v OFS=, '
  # –ü—Ä–æ—á–∏—Ç–∞–º–µ –ø—ä—Ä–≤–∏—è —Ñ–∞–π–ª, –∑–∞–ø–∞–∑–≤–∞–º–µ Elapsed Time (–ø–æ–ª–µ 8) –≤ —Å–µ–∫—É–Ω–¥–∏ –∏ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –Ω–∏–∑
  FNR==NR {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t = $8
    split(t, a, ":")
    secs = a[1]*3600 + a[2]*60 + a[3]
    t1_secs[key] = secs
    t1_str[key]  = t
    next
  }
  # –°–µ–≥–∞ –≤—Ç–æ—Ä–∏—è —Ñ–∞–π–ª: –ø–∞–∫ –ø—Ä–∞–≤–∏–º –∫–ª—é—á–∞ –∏ –≤–∑–∏–º–∞–º–µ –≤—Ä–µ–º–µ t2
  {
    key = $1 FS $2 FS $3 FS $4 FS $6 FS $7
    t2 = $8
    split(t2, b, ":")
    secs2 = b[1]*3600 + b[2]*60 + b[3]
    secs1 = (key in t1_secs ? t1_secs[key] : 0)
    delta = secs2 - secs1

    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–º–µ delta –≤ HH:MM:SS
    sign = ""
    if (delta < 0) { sign = "-"; delta = -delta }
    hh = int(delta/3600)
    mm = int((delta%3600)/60)
    ss = delta%60
    diff = sprintf("%s%02d:%02d:%02d", sign, hh, mm, ss)

    # –ü–µ—á–∞—Ç–∞–º–µ –ø–æ–ª–µ—Ç–∞ 1,2,3,4,6,7, original t1, t2 –∏ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞
    print $1, $2, $3, $4, $6, $7, t1_str[key], t2, diff
  }
' "$file1" "$file2"




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Usage: $0 <DATE1> <DATE2>"
  exit 1
fi

DATE1="$1"
DATE2="$2"

FILE1=$(ls JT*"$DATE1"*.CSV 2>/dev/null | head -n 1)
FILE2=$(ls JT*"$DATE2"*.CSV 2>/dev/null | head -n 1)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "Missing input files for given dates."
  exit 1
fi

echo "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ $FILE1 —Å $FILE2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,Start1,Stop1,Elapsed1,Start2,Stop2,Elapsed2,–†–∞–∑–ª–∏–∫–∞"

awk -F',' '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
{
  key = $1","$2","$3","$4;
  data[key] = $6","$7","$8;
  elapsed[key] = hms_to_minutes($8);
}
' "$FILE2" > /tmp/jt2.map

awk -F',' -v f2="/tmp/jt2.map" '
function hms_to_minutes(t,   h,m,s) {
  split(t, a, ":");
  h = a[1]; m = a[2]; s = a[3];
  return h * 60 + m + s / 60;
}
function minutes_to_hhmm(mm,   h, m) {
  sign = (mm < 0) ? "-" : "";
  mm = (mm < 0) ? -mm : mm;
  h = int(mm);
  m = int((mm - h) * 60 + 0.5);
  return sign sprintf("%d:%02d", h, m);
}
BEGIN {
  while ((getline < f2) > 0) {
    split($0, parts, " ");
    split(parts[1], k, "=");
    split(k[2], d, ",");
    key = d[1]","d[2]","d[3]","d[4];
    info[key] = d[5]","d[6]","d[7];
    e2[key] = hms_to_minutes(d[7]);
  }
}
{
  key = $1","$2","$3","$4;
  if (key in info) {
    e1 = hms_to_minutes($8);
    diff = e1 - e2[key];
    printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", $1,$2,$3,$4,$6,$7,$8,info[key],minutes_to_hhmm(diff);
  }
}
' "$FILE1" | sort -t',' -k11,11





#!/bin/bash

d1="$1"
d2="$2"

f1=$(ls JT*${d1}*.CSV 2>/dev/null)
f2=$(ls JT*${d2}*.CSV 2>/dev/null)

if [[ -z "$f1" || -z "$f2" ]]; then
  echo "–§–∞–π–ª(–æ–≤–µ) –Ω–µ —Å–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏."
  exit 1
fi

echo "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ $f1 —Å $f2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,–ü–æ–ª–µ6,–ü–æ–ª–µ7,–î–∞—Ç–∞1 Elapsed,–î–∞—Ç–∞2 Start,–î–∞—Ç–∞2 Stop,–î–∞—Ç–∞2 Elapsed,–†–∞–∑–ª–∏–∫–∞"

join -t, -1 1 -2 1 <(cut -d',' -f1-8 "$f1" | sort) <(cut -d',' -f1-8 "$f2" | sort) | awk -F',' '
function to_seconds(t,  a) {
  split(t, a, ":"); return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs) {
  sign = (secs < 0) ? "-" : "";
  secs = (secs < 0) ? -secs : secs;
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return sign h ":" (m < 10 ? "0" m : m);
}
{
  print $0 > "/tmp/jt_temp.csv"  # –∞–∫–æ –∏—Å–∫–∞—à –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏—à
  e1 = $8; e2 = $16;
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", 
    $1, $2, $3, $4, $6, $7, e1, $14, $15, e2, to_hhmm(diff)
}
' | sort -t',' -k11 -r




#!/bin/bash

if [ $# -ne 2 ]; then
  echo "–ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ: $0 <DATE1: YYYYMMDD> <DATE2: YYYYMMDD>"
  exit 1
fi

DATE1=$1
DATE2=$2

FILE1=$(ls JT*${DATE1}*.CSV 2>/dev/null)
FILE2=$(ls JT*${DATE2}*.CSV 2>/dev/null)

if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
  echo "–ù—è–∫–æ–π –æ—Ç —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ª–∏–ø—Å–≤–∞:"
  echo "  $FILE1"
  echo "  $FILE2"
  exit 2
fi

echo "–°—Ä–∞–≤–Ω—è–≤–∞–Ω–µ –Ω–∞ $FILE1 —Å $FILE2 –ø–æ Elapsed Time (–ø–æ–ª–µ 8)"
echo "------------------------------------------------------------------"
echo "–ü–æ–ª–µ1,–ü–æ–ª–µ2,–ü–æ–ª–µ3,–ü–æ–ª–µ4,–ü–æ–ª–µ6,–ü–æ–ª–µ7,Elapsed1,Elapsed2,–†–∞–∑–ª–∏–∫–∞"

paste -d'\n' "$FILE1" "$FILE2" | paste - - | awk -F'\t' '
function to_seconds(t,  a) {
  split(t, a, ":");
  return a[1]*3600 + a[2]*60 + a[3];
}
function to_hhmm(secs, h, m) {
  h = int(secs / 3600);
  m = int((secs % 3600) / 60);
  return h ":" (m < 10 ? "0" m : m);
}
{
  split($1, f1, ",");
  split($2, f2, ",");

  e1 = f1[8]; e2 = f2[8];
  s1 = to_seconds(e1);
  s2 = to_seconds(e2);
  diff = s1 - s2;

  printf "%s,%s,%s,%s,%s,%s,%s,%s,%s\n", f1[1], f1[2], f1[3], f1[4], f1[6], f1[7], e1, e2, to_hhmm(diff)
}' | sort -t',' -k9 -r



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ —Ö–µ–¥—ä—Ä–∏—Ç–µ
  const total = rows.length;
  const rawValue = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = rawValue + 1;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const total = rows.length;
  const requested = parseInt(document.getElementById('eomRange').value, 10);
  const maxRows = Math.min(requested, total); // –ù–µ –ø–æ–∑–≤–æ–ª—è–≤–∞–π –¥–∞ –∏—Å–∫–∞–º–µ –ø–æ–≤–µ—á–µ, –æ—Ç–∫–æ–ª–∫–æ—Ç–æ –∏–º–∞–º–µ

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // —Å–∞–º–æ –¥–∞–Ω–Ω–∏
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




function updateEomTableRows(days) {
  const allRows = Array.from(document.getElementById('eomTable').getElementsByTagName('tr'));
  const dataRows = allRows.slice(2); // –ü—Ä–µ—Å–∫–∞—á–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ –¥–≤–∞ —Ä–µ–¥–∞
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –≤–∏–Ω–∞–≥–∏ –ø–æ–∫–∞–∑–≤–∞–π –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
    } else {
      tr.hidden = (i - 2) < start ? false : true;
    }
  });
}




const visibleRows = Math.min(maxRows, rows.length);
rows.forEach((tr, i) => {
  tr.hidden = i < rows.length - visibleRows;
});






#!/bin/bash

main_log="main_log.txt"
rrex_log="rrex_data.txt"
output_log="merged_log.txt"

> "$output_log"

while IFS= read -r line; do
    # –ò–∑–≤–ª–∏—á–∞–º–µ –¥–∞—Ç–∞—Ç–∞ –æ—Ç —Ñ–æ—Ä–º–∞—Ç–∞ JT.20240520
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # –¢—ä—Ä—Å–∏–º —Å—ä–≤–ø–∞–¥–∞—â —Ä–µ–¥ –≤ RREX —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –ø–æ –ø—ä—Ä–≤–æ—Ç–æ –ø–æ–ª–µ (–¥–∞—Ç–∞—Ç–∞)
        match=$(awk -F'|' -v d="$date" '$1 == d {print $0}' "$rrex_log")

        if [[ -n "$match" ]]; then
            # –í–∑–µ–º–∞–º–µ —Å–∞–º–æ –≤—Ä–µ–º–µ–Ω–∞—Ç–∞
            rrex_start=$(echo "$match" | awk -F'|' '{print $2}' | cut -d' ' -f2)
            rrex_end=$(echo "$match" | awk -F'|' '{print $3}' | cut -d' ' -f2)
            rrex_duration=$(echo "$match" | awk -F'|' '{print $4}')

            echo "$line | RREX_START: $rrex_start | RREX_END: $rrex_end | RREX_DURATION: $rrex_duration" >> "$output_log"
        else
            echo "$line | RREX: N/A" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

main_log="main_log.txt"        # –ª–æ–≥ —Å JT.20240520
rrex_log="rrex_log.txt"        # –ª–æ–≥ —Å—ä—Å Start/End/Duration –∑–∞ –≤—Å—è–∫–∞ –¥–∞—Ç–∞
output_log="enhanced_log.txt"

> "$output_log"

while IFS= read -r line; do
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]{8}')

    if [[ -n "$date" ]]; then
        # –¢—ä—Ä—Å–∏ —Ä–µ–¥ –≤ rrex_log, –∑–∞–ø–æ—á–≤–∞—â —Å –¥–∞—Ç–∞—Ç–∞
        rrex_info=$(awk -F'|' -v d="$date" '$1 == d { print $2, $3, $4 }' "$rrex_log")

        if [[ -n "$rrex_info" ]]; then
            echo "$line | $rrex_info" >> "$output_log"
        else
            echo "$line | [No RREX data]" >> "$output_log"
        fi
    else
        echo "$line" >> "$output_log"
    fi
done < "$main_log"






#!/bin/bash

input_log="main_log.txt"
output_log="enhanced_log.txt"
log_dir="./logs"  # –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –ø–æ –¥–∞—Ç–∏

> "$output_log"  # –ø—Ä–∞–∑–Ω–æ –∏–∑—Ö–æ–¥–µ–Ω —Ñ–∞–π–ª

while IFS= read -r line; do
    # –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞—Ç–∞—Ç–∞ —Å–ª–µ–¥ JT.
    date=$(echo "$line" | grep -oP 'JT\.\K[0-9]+')

    if [[ -n "$date" ]]; then
        file="$log_dir/$date.log"

        if [[ -f "$file" ]]; then
            # –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ —Ä–µ–¥–∞ —Å—ä—Å Stop, Start, Elapsed (–ø—Ä–∏–º–µ—Ä–Ω–∞ –ª–æ–≥–∏–∫–∞)
            match=$(grep -i 'Stop.*Start.*Elapsed' "$file" | head -n 1)

            # –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ –≤ –∫—Ä–∞—è –Ω–∞ —Ä–µ–¥–∞
            echo "$line $match" >> "$output_log"
        else
            echo "$line [No file for $date]" >> "$output_log"
        fi
    else
        echo "$line [No JT date found]" >> "$output_log"
    fi
done < "$input_log"




def run_advanced_shell_script():
    script_path = os.path.join(BASE_DIR, "scripts", "advanced_log.sh")
    try:
        output = subprocess.check_output(["bash", script_path], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("Shell —Å–∫—Ä–∏–ø—Ç—ä—Ç –∑–∞ advanced –ª–æ–≥ –∞–Ω–∞–ª–∏–∑ –µ –∏–∑–ø—ä–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ.")
        # –ê–∫–æ –∏—Å–∫–∞—à –¥–∞ –≥–æ –∑–∞–ø–∏—à–µ—à:
        result_file = os.path.join(RESULT_DIR, "advanced_combined.log")
        os.makedirs(RESULT_DIR, exist_ok=True)
        with open(result_file, "w") as f:
            f.write(output)
    except subprocess.CalledProcessError as e:
        logging.error(f"Shell —Å–∫—Ä–∏–ø—Ç –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ shell —Å–∫—Ä–∏–ø—Ç–∞: {str(e)}")




import tempfile

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # –°—ä–∑–¥–∞–≤–∞–º–µ –≤—Ä–µ–º–µ–Ω–µ–Ω shell —Å–∫—Ä–∏–ø—Ç —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞—Ç–∞ –ª–æ–≥–∏–∫–∞
    script_content = f"""#!/bin/bash
LIMIT_DATE="{limit_date}"
CHAR_LIMIT={char_limit}
LOG_DIR="{log_dir}"
for f in $LOG_DIR/{log_files}; do
    awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
        /\\[ERROR\\]/ && length($0) >= {char_limit} {{
            log_date = substr($0, 2, 10)
            if (log_date >= limit) {{
                if ($0 ~ /{match_keywords}/) {{
                    match($0, /\\] .*? /, arr)
                    if (arr[1] != "" && arr[1] != "\\\\") {{
                        key = arr[1]
                        print key "|" "[" host "] [" file "] " $0
                    }}
                }}
            }}
        }}
    ' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
"""

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sh", mode="w") as tmpfile:
            tmpfile.write(script_content)
            tmpfile_path = tmpfile.name

        remote_path = f"/tmp/monitor_adv_{host}.sh"

        # –ö–∞—á–≤–∞–º–µ —Å–∫—Ä–∏–ø—Ç–∞ –Ω–∞ –æ—Ç–¥–∞–ª–µ—á–µ–Ω–∞—Ç–∞ –º–∞—à–∏–Ω–∞
        subprocess.run(["scp", tmpfile_path, f"{user}@{host}:{remote_path}"], check=True)

        # –î–∞–≤–∞–º–µ –ø—Ä–∞–≤–∞ –∏ –≥–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞–º–µ –ø—Ä–µ–∑ ssh
        ssh_cmd = f"chmod +x {remote_path} && bash {remote_path} && rm {remote_path}"
        output = subprocess.check_output(["ssh", f"{user}@{host}", ssh_cmd], stderr=subprocess.STDOUT, timeout=60, universal_newlines=True)

        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH/Script –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ advanced_log_filter: {str(e)}")
    finally:
        if os.path.exists(tmpfile_path):
            os.unlink(tmpfile_path)






def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_dir = conf.get('log_dirs', 'paths').split(',')[0]
    char_limit = conf.get("advanced_log_filter", "char_limit")
    log_files = conf.get("advanced_log_filter", "log_files")
    match_keywords = conf.get("advanced_log_filter", "match_keywords")

    # Shell —Å–∫—Ä–∏–ø—Ç, –≤–≥—Ä–∞–¥–µ–Ω –≤ Python (—Ç–æ—á–Ω–æ –∫–∞—Ç–æ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞)
    remote_script = f'''
        LIMIT_DATE="{limit_date}"
        CHAR_LIMIT={char_limit}
        for f in {log_dir}/{{{log_files}}}; do
            awk -v limit="$LIMIT_DATE" -v file="$f" -v host="{host}" '
                /\\[ERROR\\]/ && length($0) >= {char_limit} {{
                    log_date = substr($0, 2, 10)
                    if (log_date >= limit) {{
                        if ($0 ~ /{match_keywords}/) {{
                            match($0, /\\] .*? /, arr)
                            if (arr[1] != "" && arr[1] != "\\\\") {{
                                key = arr[1]
                                print key "|" "[" host "] [" file "] " $0
                            }}
                        }}
                    }}
                }}
            ' "$f"
        done | sort -t'|' -k1,1 -u | cut -d'|' -f2-
    '''

    ssh_cmd = ["ssh", f"{user}@{host}", remote_script]

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=40, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")







def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        logging.warning(f"[{host}] –ª–∏–ø—Å–≤–∞ —Å–µ–∫—Ü–∏—è [advanced_log_filter]")
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dirs = conf.get('log_dirs', 'paths').split(',')

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å—ä–∫ –æ—Ç –ª–æ–≥ —Ñ–∞–π–ª–æ–≤–µ –≤—ä–≤ –≤—Å–∏—á–∫–∏ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    log_patterns = []
    for log_dir in log_dirs:
        log_dir = log_dir.rstrip('/')
        for f in log_files:
            log_patterns.append(f"{log_dir}/{f}")
    log_patterns_str = ' '.join(log_patterns)

    # awk —Å–∫—Ä–∏–ø—Ç (–±–µ–∑ –≤—ä–Ω—à–µ–Ω shell parsing)
    awk_script = (
        f"""/\\[ERROR\\]/ && length($0) > {char_limit} {{
            log_date = substr($0, 2, 19);
            if (log_date >= "{limit_date}") {{
                if ($0 ~ /{match_keywords}/)
                    print host "|" file "|" $0;
            }}
        }}"""
    )

    remote_cmd = f"for file in {log_patterns_str}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"
    ssh_cmd = ["ssh", f"{user}@{host}", remote_cmd]

    logging.debug(f"[{host}] SSH –∫–æ–º–∞–Ω–¥–∞: {' '.join(ssh_cmd)}")

    try:
        output = subprocess.check_output(ssh_cmd, stderr=subprocess.STDOUT, timeout=30, universal_newlines=True)
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
        else:
            logging.info(f"[{host}] –ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç advanced_log_filter.")
    except subprocess.CalledProcessError as e:
        logging.error(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {e.output.strip()}")
    except Exception as e:
        logging.error(f"[{host}] Exception: {str(e)}")






#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print host \"|\" file \"|\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done | sort -t'|' -k1,1 -u | cut -d'|' -f2-"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=20, universal_newlines=True
        )
        if output:
            os.makedirs(RESULT_DIR, exist_ok=True)
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced –ª–æ–≥ —Ä–µ–∑—É–ª—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan –Ω–µ—É—Å–ø–µ—à–µ–Ω: {str(e)}")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()




[advanced_log_filter]
log_files = mdb.log,runtime.log*,database.log*,ejb.log*
char_limit = 1000
match_keywords = DATABASE|RUNTIME|EJB|MDB



#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] –ó–∞–ø–æ—á–≤–∞ —Å–∫–∞–Ω–∏—Ä–∞–Ω–µ...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
            logging.warning(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {str(e)}")
            logging.error(f"[{host}] SSH –≤—Ä—ä–∑–∫–∞ –Ω–µ—É—Å–ø–µ—à–Ω–∞: {str(e)}")
            break

    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] –ù—è–º–∞ –æ—Ç–∫—Ä–∏—Ç–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏–ª–∏ –Ω—è–º–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.")

    logging.info(f"[{host}] –°–∫–∞–Ω–∏—Ä–∞–Ω–µ –∑–∞–≤—ä—Ä—à–∏.")

def advanced_log_filter(host, user, conf, limit_date):
    if not conf.has_section("advanced_log_filter"):
        return

    log_files = conf.get("advanced_log_filter", "log_files").split(',')
    char_limit = int(conf.get("advanced_log_filter", "char_limit"))
    match_keywords = conf.get("advanced_log_filter", "match_keywords")
    log_dir = conf.get('log_dirs', 'paths').split(',')[0]

    log_patterns = ' '.join([f"{log_dir}/{f}" for f in log_files])
    awk_script = (
        f"/\\[ERROR\\]/ && length($0) > {char_limit} {{"
        " log_date = substr($0, 2, 19); "
        f" if (log_date >= \"{limit_date}\") {{ "
        f"   if ($0 ~ /{match_keywords}/) "
        "     print \"[advanced] |\" host \"|\" file \":\" $0; "
        " }"
        "}"
    )

    remote_cmd = f"for file in {log_patterns}; do awk -v host='{host}' -v file=\"$file\" '{awk_script}' $file 2>/dev/null; done"

    try:
        output = subprocess.check_output(
            ["ssh", f"{user}@{host}", remote_cmd],
            stderr=subprocess.STDOUT, timeout=15, universal_newlines=True
        )
        if output:
            with open(os.path.join(RESULT_DIR, f"{host}_adv.log"), "w") as f:
                f.write(output)
            logging.info(f"[{host}] Advanced log scan –∑–∞–ø–∏—Å–∞–Ω.")
    except Exception as e:
        logging.warning(f"[{host}] Advanced log scan –Ω–µ—É—Å–ø–µ—à–µ–Ω: {str(e)}")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')
    limit_date = datetime.now() - timedelta(days=7)
    limit_str = limit_date.strftime("%Y-%m-%d")

    for host in hosts:
        scan_host(host, user, log_dirs, keywords)
        advanced_log_filter(host, user, conf, limit_str)

    monitor_files(conf)
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()





# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –ª–æ–≥–æ–≤–µ
[log_dirs]
paths = /var/log,/opt/bank/logs

# –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (–ª–æ–∫–∞–ª–Ω–∏ –∑–∞ –±–µ–∫–µ–Ω–¥–∞)
[file_monitor]
dirs = /var/bank/inbox,/tmp/transactions

# –ö–ª—é—á–æ–≤–∏ –¥—É–º–∏ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ
[keywords]
errors = ERROR,FATAL,EXCEPTION
warnings = WARN,DEPRECATED

# –ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
[users]
admin = root,monitoring_user
readonly = viewer


# Monitoring Framework for Banking VMs

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞
- `config/`: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (.conf –∏ .properties)
- `hosts/`: –°–ø–∏—Å—ä–∫ —Å —Ö–æ—Å—Ç–æ–≤–µ
- `logs/`: –õ–æ–≥–æ–≤–µ –æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∫—Ä–∏–ø—Ç–∞
- `scripts/`: Python —Å–∫—Ä–∏–ø—Ç–æ–≤–µ

## –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
- `common.conf`: —Å—ä–¥—ä—Ä–∂–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –∫–ª—é—á–æ–≤–∏ –¥—É–º–∏ –∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏
- `settings.properties`: –ª–æ–≥ –Ω–∏–≤–æ, ssh –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –∏–Ω—Ç–µ—Ä–≤–∞–ª–∏
- `host_list.txt`: –µ–¥–∏–Ω —Ä–µ–¥ = –µ–¥–∏–Ω hostname

## –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ
```bash
cd scripts
python3 monitor.py


# –õ–æ–≥–≤–∞–Ω–µ
log.level=INFO
log.rotation=daily
log.retention_days=7

# SSH –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
backend.host=this-backend-host
remote.user=monitoring_user
connection.timeout=10

# –°–∫–∞–Ω–∏—Ä–∞–Ω–µ
scan.interval=300        # —Å–µ–∫—É–Ω–¥–∏ –º–µ–∂–¥—É –ø—Ä–æ–≤–µ—Ä–∫–∏
scan.parallelism=4       # –ø–∞—Ä–∞–ª–µ–ª–Ω–∏ ssh –∑–∞–¥–∞—á–∏


#!/usr/bin/env python3

import configparser
import logging
import os
import subprocess
import shutil
from datetime import datetime, timedelta

# –ü—ä—Ç–∏—â–∞
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
CONF_PATH = os.path.join(BASE_DIR, 'config', 'common.conf')
PROPERTIES_PATH = os.path.join(BASE_DIR, 'config', 'settings.properties')
HOSTS_FILE = os.path.join(BASE_DIR, 'hosts', 'host_list.txt')
LOG_FILE = os.path.join(BASE_DIR, 'logs', 'monitor.log')
RESULT_DIR = os.path.join(BASE_DIR, 'logs', 'results')
ARCHIVE_DIR = os.path.join(BASE_DIR, 'logs', 'archives')

# –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
def load_conf(path):
    config = configparser.ConfigParser()
    config.read(path)
    return config

def load_properties(path):
    props = {}
    with open(path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                key, value = line.strip().split("=", 1)
                props[key.strip()] = value.strip()
    return props

def load_hostnames(path):
    with open(path) as f:
        return [line.strip() for line in f if line.strip()]

def extract_keywords(conf):
    keywords = []
    for k in conf['keywords']:
        keywords += [kw.strip() for kw in conf['keywords'][k].split(',')]
    return list(set(keywords))

# –ê—Ä—Ö–∏–≤–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ
def archive_results():
    if not os.path.exists(RESULT_DIR):
        return

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    archive_name = f"results_{timestamp}"
    archive_path = os.path.join(ARCHIVE_DIR, archive_name)

    os.makedirs(ARCHIVE_DIR, exist_ok=True)
    shutil.make_archive(archive_path, 'zip', RESULT_DIR)
    logging.info(f"–†–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –∞—Ä—Ö–∏–≤–∏—Ä–∞–Ω–∏ –≤ {archive_path}.zip")

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–∞ –ª–æ–∫–∞–ª–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ —Ñ–∞–π–ª–æ–≤–µ
def monitor_files(conf):
    logging.info("[LOCAL FILE CHECK] –°—Ç–∞—Ä—Ç–∏—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ —Ñ–∞–π–ª–æ–≤–µ.")

    if not conf.has_section("file_monitor"):
        logging.info("[LOCAL FILE CHECK] –ù—è–º–∞ –∑–∞–¥–∞–¥–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.")
        return

    directories = conf.get("file_monitor", "dirs").split(',')
    now = datetime.now()
    threshold = timedelta(minutes=5)

    for directory in directories:
        directory = directory.strip()
        if not os.path.exists(directory):
            logging.warning(f"[LOCAL FILE CHECK] –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞: {directory}")
            continue

        found = False
        for fname in os.listdir(directory):
            fpath = os.path.join(directory, fname)
            if os.path.isfile(fpath):
                found = True
                mtime = datetime.fromtimestamp(os.path.getmtime(fpath))
                age = now - mtime
                if age > threshold:
                    logging.warning(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
                else:
                    logging.info(f"[LOCAL FILE CHECK] {fname} –≤ {directory} –µ –Ω–∞ {int(age.total_seconds()//60)} –º–∏–Ω—É—Ç–∏.")
        if not found:
            logging.info(f"[LOCAL FILE CHECK] –ù—è–º–∞ —Ñ–∞–π–ª–æ–≤–µ –≤ {directory}.")

# SSH –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –ª–æ–≥–æ–≤–µ
def scan_host(host, user, log_dirs, keywords):
    logging.info(f"[{host}] –ó–∞–ø–æ—á–≤–∞ —Å–∫–∞–Ω–∏—Ä–∞–Ω–µ...")
    result_lines = []

    keyword_grep = '|'.join(keywords)
    for log_dir in log_dirs:
        remote_cmd = f"grep -E '{keyword_grep}' {log_dir}/* 2>/dev/null"
        full_cmd = ["ssh", f"{user}@{host}", remote_cmd]

        try:
            output = subprocess.check_output(full_cmd, stderr=subprocess.STDOUT, timeout=15, universal_newlines=True)
            if output:
                result_lines.append(f"\n# {log_dir}\n{output}")
        except subprocess.CalledProcessError as e:
            result_lines.append(f"[–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}]: {e.output.strip()}")
            logging.warning(f"[{host}] –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—ä—Ä—Å–µ–Ω–µ –≤ {log_dir}: {e.output.strip()}")
        except subprocess.TimeoutExpired:
            result_lines.append(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
            logging.warning(f"[{host}] –í—Ä–µ–º–µ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –∏–∑—Ç–µ—á–µ –≤ {log_dir}")
        except Exception as e:
            result_lines.append(f"[{host}] SSH –≥—Ä–µ—à–∫–∞: {str(e)}")
            logging.error(f"[{host}] SSH –≤—Ä—ä–∑–∫–∞ –Ω–µ—É—Å–ø–µ—à–Ω–∞: {str(e)}")
            break  # –ø—Ä–µ–∫—ä—Å–≤–∞–º–µ –∞–∫–æ –Ω—è–º–∞ SSH –¥–æ—Å—Ç—ä–ø

    # –ó–∞–ø–∏—Å –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–µ–Ω —Ñ–∞–π–ª
    os.makedirs(RESULT_DIR, exist_ok=True)
    with open(os.path.join(RESULT_DIR, f"{host}.log"), "w") as f:
        if result_lines:
            f.write("\n".join(result_lines))
        else:
            f.write(f"[{host}] –ù—è–º–∞ –æ—Ç–∫—Ä–∏—Ç–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏–ª–∏ –Ω—è–º–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ª–æ–≥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.")

    logging.info(f"[{host}] –°–∫–∞–Ω–∏—Ä–∞–Ω–µ –∑–∞–≤—ä—Ä—à–∏.")

def main():
    logging.info("Monitoring —Å—Ç–∞—Ä—Ç–∏—Ä–∞.")

    conf = load_conf(CONF_PATH)
    props = load_properties(PROPERTIES_PATH)
    hosts = load_hostnames(HOSTS_FILE)

    log_dirs = conf.get('log_dirs', 'paths').split(',')
    keywords = extract_keywords(conf)
    user = props.get('remote.user', 'monitoring_user')

    # Remote log scan
    for host in hosts:
        scan_host(host, user, log_dirs, keywords)

    # Local file check
    monitor_files(conf)

    # Archive results
    archive_results()

    logging.info("Monitoring –ø—Ä–∏–∫–ª—é—á–∏.")

if __name__ == "__main__":
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    logging.basicConfig(filename=LOG_FILE,
                        level=getattr(logging, load_properties(PROPERTIES_PATH).get("log.level", "INFO").upper()),
                        format="%(asctime)s [%(levelname)s] %(message)s")
    main()






function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const x = cobMeta.data[i].x;
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const barVal = data.datasets[0].data[i];
              if (barVal > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(barVal);
                ctx.fillText(formatHHMM(barVal), x, y + 12);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}





plugins: {
  tooltip: {
    callbacks: {
      label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
    }
  },
  title: {
    display: true,
    text: "EOM COB Elapsed Times",
    font: {
      size: 13,
      weight: "bold"
    },
    color: getTextColor()
  },
  legend: {
    labels: {
      font: { size: 13 },
      color: getTextColor()
    }
  },
  labelsInside: labelsInsidePlugin // —Ç–æ–≤–∞ –µ –∫–ª—é—á–æ–≤–æ
}







const labelsInsidePlugin = {
  id: "labelsInside",
  afterDatasetsDraw(chart) {
    const { ctx, data, scales } = chart;
    const meta = chart.getDatasetMeta(0);
    const yScale = scales.y;

    ctx.save();
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = getTextColor();

    data.labels.forEach((_, i) => {
      const value = data.datasets[0].data[i];
      if (value > 0) {
        const x = meta.data[i].x;
        const y = yScale.getPixelForValue(value) + 14;
        ctx.fillText(formatHHMM(value), x, y);
      }
    });

    ctx.restore();
  }
};




<div class="chart-container" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime > 0) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1"
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            },
            color: getTextColor()
          }
        },
        labelsInside: {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const value = data.datasets[0].data[i];
              if (value > 0) {
                const x = meta.data[i].x;
                const y = yScale.getPixelForValue(value) + 12;
                ctx.fillText(formatHHMM(value), x, y);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartTheme();
}
</script>





<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>






function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}







function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "COB Elapsed",
        data: cobElapsed,
        backgroundColor: "rgba(154,200,245,1)",
        stack: "stack1",
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}








<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>

<script>
function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();

    if (date && cobVal) {
      labels.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45,
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHMM(v),
            maxTicksLimit: 8
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        },
        labelsInside: {
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const meta = chart.getDatasetMeta(0);
            const yScale = scales.y;

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const val = data.datasets[0].data[i];
              const y = yScale.getPixelForValue(val);
              const x = meta.data[i].x;
              if (val > 0) {
                ctx.fillText(formatHMM(val), x, y + 15);
              }
            });

            ctx.restore();
          }
        }
      }
    }
  });

  updateChartsTheme();
}
</script>





function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 4) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseElapsedToHours(cells[3].innerText.trim());

    if (date && cobTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse()
  };
}



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 13,
              color: "#333"
            }
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHMM(v),
            font: {
              size: 13,
              color: "#333"
            }
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      }
    },
    plugins: [{
      id: 'labelsInside',
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const meta = chart.getDatasetMeta(0);
        const yScale = scales.y;

        ctx.save();
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const bar = meta.data[i];
          const value = data.datasets[0].data[i];
          const y = yScale.getPixelForValue(value);
          const x = bar.x;
          if (value > 0) {
            ctx.fillText(formatHMM(value), x, y + 12);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





<table class="rounded" id="eomChartTable">
  <tr>
    <th colspan="6">EOM COB & RR Elapsed Time</th>
  </tr>
  <tr>
    <td colspan="6">
      <div class="chart-container" id="eomChartWrapper">
        <canvas id="eomChart"></canvas>
      </div>
    </td>
  </tr>
</table>



function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 },
            color: getTextColor()
          }
        }
      }
    },
    plugins: [
      {
        id: "labelsInside",
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const cobMeta = chart.getDatasetMeta(0);
          const rrMeta = chart.getDatasetMeta(1);
          const yScale = scales.y;

          ctx.save();
          ctx.font = "bold 11px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob = data.datasets[0].data[i] || 0;
            const rr = data.datasets[1].data[i] || 0;
            const total = cob + rr;
            const x = cobMeta.data[i].x;

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }

            if (rr > 0) {
              const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
              ctx.fillText(formatHHMM(rr), x, yRR);
            }

            if (total > 0) {
              const yTotal = yScale.getPixelForValue(total) - 6;
              ctx.fillText(formatHHMM(total), x, yTotal);
            }
          });

          ctx.restore();
        }
      }
    ]
  });

  updateChartsTheme();
}






options: {
  responsive: true,
  maintainAspectRatio: false,
  scales: {
    x: {
      stacked: true,
      ticks: {
        maxRotation: 45,
        minRotation: 45
      }
    },
    y: {
      beginAtZero: true,
      ticks: {
        callback: v => formatHHMM(v)
      }
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
      }
    },
    title: {
      display: true,
      text: "EOM COB & RR Elapsed Times",
      font: {
        size: 13,
        weight: "bold"
      },
      color: getTextColor()
    },
    legend: {
      labels: {
        font: { size: 13 }
      }
    }
  }
},
plugins: [
  {
    id: "labelsInside",
    afterDatasetsDraw(chart) {
      const { ctx, data, scales } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);
      const yScale = scales.y;

      ctx.save();
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i] || 0;
        const rr = data.datasets[1].data[i] || 0;
        const total = cob + rr;
        const x = cobMeta.data[i].x;

        if (cob > 0) {
          const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        if (rr > 0) {
          const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        if (total > 0) {
          const yTotal = yScale.getPixelForValue(total) - 6;
          ctx.fillText(formatHHMM(total), x, yTotal);
        }
      });

      ctx.restore();
    }
  }
]




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = cobElapsed[i] || 0;
              const rr = rrElapsed[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}







function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => {
              const raw = ctx.raw || 0;
              return `${ctx.dataset.label}: ${formatHHMM(raw)}`;
            }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);
            const yScale = scales.y;

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i] || 0;
              const rr = data.datasets[1].data[i] || 0;
              const total = cob + rr;
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCobMid = (yScale.getPixelForValue(0) + yScale.getPixelForValue(cob)) / 2;
                ctx.fillText(formatHHMM(cob), x, yCobMid);
              }

              if (rr > 0) {
                const yRRMid = (yScale.getPixelForValue(cob) + yScale.getPixelForValue(total)) / 2;
                ctx.fillText(formatHHMM(rr), x, yRRMid);
              }

              if (total > 0) {
                const yTotal = yScale.getPixelForValue(total) - 6;
                ctx.fillText(formatHHMM(total), x, yTotal);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      plugins: [
        {
          id: "labelsInside",
          afterDatasetsDraw(chart) {
            const { ctx, data, scales: { y } } = chart;
            const cobMeta = chart.getDatasetMeta(0);
            const rrMeta = chart.getDatasetMeta(1);

            ctx.save();
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.fillStyle = getTextColor();

            data.labels.forEach((_, i) => {
              const cob = data.datasets[0].data[i];
              const rr = data.datasets[1].data[i];
              const total = cob + rr;

              const cobTop = y.getPixelForValue(cob);
              const rrTop = y.getPixelForValue(rr);
              const totalTop = y.getPixelForValue(total);
              const cobBottom = y.getPixelForValue(0);
              const rrBottom = y.getPixelForValue(cob);
              const x = cobMeta.data[i].x;

              if (cob > 0) {
                const yCob = (cobTop + cobBottom) / 2;
                ctx.fillText(formatHHMM(cob), x, yCob);
              }

              if (rr > 0) {
                const yRR = (rrTop + rrBottom) / 2;
                ctx.fillText(formatHHMM(rr), x, yRR);
              }

              if (total > 0) {
                ctx.fillText(formatHHMM(total), x, totalTop - 6);
              }
            });

            ctx.restore();
          }
        }
      ]
    }
  });

  updateChartTheme();
}




plugins: [
  {
    id: 'labelsInside',
    afterDatasetsDraw(chart) {
      const { ctx, data, scales: { y } } = chart;
      const cobMeta = chart.getDatasetMeta(0);
      const rrMeta = chart.getDatasetMeta(1);

      ctx.save();
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = getTextColor();

      data.labels.forEach((_, i) => {
        const cob = data.datasets[0].data[i];
        const rr = data.datasets[1].data[i];
        const total = cob + rr;

        const cobTop = y.getPixelForValue(cob);
        const rrTop = y.getPixelForValue(rr);
        const totalTop = y.getPixelForValue(total);
        const cobBottom = y.getPixelForValue(0);
        const rrBottom = y.getPixelForValue(cob);

        const x = cobMeta.data[i].x;

        // COB inside
        if (cob > 0) {
          const yCob = (cobTop + cobBottom) / 2;
          ctx.fillText(formatHHMM(cob), x, yCob);
        }

        // RR inside
        if (rr > 0) {
          const yRR = (rrTop + rrBottom) / 2;
          ctx.fillText(formatHHMM(rr), x, yRR);
        }

        // Total on top
        if (total > 0) {
          ctx.fillText(formatHHMM(total), x, totalTop - 6);
        }
      });

      ctx.restore();
    }
  }
]




function parseElapsedToHours(timeStr) {
  const parts = timeStr.split(':');
  if (parts.length === 3) {
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    return h + m / 60 + s / 3600;
  }
  return 0;
}

function formatHHMM(hoursFloat) {
  const h = Math.floor(hoursFloat);
  const m = Math.round((hoursFloat - h) * 60);
  return `${h}:${m.toString().padStart(2, '0')}`;
}

function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 9) continue;

    const date = cells[0].innerText.trim();
    const cobVal = cells[3].innerText.trim();
    const rrVal = cells[6].innerText.trim();

    if (date && cobVal && rrVal) {
      dates.push(date);
      cobElapsed.push(parseElapsedToHours(cobVal));
      rrElapsed.push(parseElapsedToHours(rrVal));
    }
  }

  dates.reverse();
  cobElapsed.reverse();
  rrElapsed.reverse();

  return { dates, cobElapsed, rrElapsed };
}

let eomChartInstance;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) eomChartInstance.destroy();

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1",
          order: 1
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1",
          order: 2
        },
        {
          label: "Duration Limit (2:30)",
          data: Array(dates.length).fill(2.5),
          type: "line",
          borderColor: "red",
          borderDash: [6, 4],
          pointRadius: 0,
          borderWidth: 2,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 20, bottom: 20, left: 10, right: 10 }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            autoSkip: false,
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          max: 7,
          ticks: {
            maxTicksLimit: 8,
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: [] // –ü—Ä–∞–∑–Ω–æ, –±–µ–∑ EOM –º–∞—Ä–∫–µ—Ä–∏
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times vs Duration Limit",
          color: getTextColor(),
          font: {
            size: 13,
            weight: "bold"
          }
        },
        legend: {
          labels: {
            font: { size: 13 }
          }
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [{
      id: "labelsInside",
      afterDatasetsDraw(chart) {
        const { ctx, data, scales } = chart;
        const cobMeta = chart.getDatasetMeta(0);
        const yScale = scales.y;
        ctx.save();
        ctx.font = "bold 11px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = getTextColor();

        data.labels.forEach((_, i) => {
          const cob = data.datasets[0].data[i];
          const rr = data.datasets[1].data[i];
          const total = cob + rr;
          const x = cobMeta.data[i].x;

          if (cob > 0) {
            const yCob = yScale.getPixelForValue(cob);
            ctx.fillText(formatHHMM(cob), x, yCob);
          }

          if (rr > 0) {
            const yTop = yScale.getPixelForValue(cob + rr);
            const yBottom = yScale.getPixelForValue(cob);
            const yRR = (yTop + yBottom) / 2;
            ctx.fillText(formatHHMM(rr), x, yRR);
          }

          if (total > 0) {
            const yTotal = yScale.getPixelForValue(total) - 6;
            ctx.fillText(formatHHMM(total), x, yTotal);
          }
        });

        ctx.restore();
      }
    }]
  });

  updateChartsTheme();
}





function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { dates, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(54, 162, 235, 0.6)",
          borderColor: "rgba(54, 162, 235, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(128, 128, 128, 0.6)",
          borderColor: "rgba(128, 128, 128, 1)",
          borderWidth: 2,
          borderRadius: 10,
          stack: "elapsed"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 13 },
            color: "#333"
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: formatHHMM,
            font: { size: 13 },
            color: "#333"
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: {
            font: { size: 13 }
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: "#222"
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        datalabels: {
          display: true,
          color: () => document.body.classList.contains("dark-mode") ? "white" : "black",
          font: {
            weight: 'bold',
            size: 11,
            family: 'sans-serif'
          },
          formatter: value => formatHHMM(value)
        }
      },
      animation: {
        duration: 1500,
        easing: "easeOutBounce"
      }
    },
    plugins: [ChartDataLabels]
  });

  updateChartsTheme();
}




function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ header

  const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
  const dates = [], cobElapsed = [], rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    const date = cells[0].innerText.trim();
    const cob = parseElapsedToHours(cells[3].innerText);
    const rr = parseElapsedToHours(cells[7].innerText);

    dates.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    dates: dates.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}





document.addEventListener("DOMContentLoaded", () => {
  const eomSlider = document.getElementById("eomRange");
  const eomInput = document.getElementById("eomValue");

  function syncEomFromSlider() {
    eomInput.value = eomSlider.value;
    updateEomTableRows();
    renderEOMChart();
  }

  function syncEomFromInput() {
    let value = parseInt(eomInput.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 12) value = 12;
    eomInput.value = value;
    eomSlider.value = value;
    syncEomFromSlider();
  }

  eomSlider.addEventListener("input", syncEomFromSlider);
  eomInput.addEventListener("input", syncEomFromInput);

  syncEomFromSlider(); // Initial load
});





<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


const eomChartWrapper = document.getElementById("eomChartWrapper");

toggleEomBtn.addEventListener("click", () => {
  eomVisible = !eomVisible;
  eomTable.classList.toggle("hidden", !eomVisible);
  eomSliderWrapper.classList.toggle("hidden", !eomVisible);
  eomChartWrapper.classList.toggle("hidden", !eomVisible);

  if (eomVisible) {
    updateEomTableRows();
    renderEOMChart();
  }
});



function getEOMTimes() {
  const table = document.getElementById("eomTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
  const maxDays = parseInt(document.getElementById("eomRange").value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cobTime = parseTimeToMinutes(cells[3].innerText.trim());
    const rrTime = parseTimeToMinutes(cells[6].innerText.trim());

    if (cobTime && rrTime) {
      labels.push(date);
      cobElapsed.push(cobTime);
      rrElapsed.push(rrTime);
    }
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (window.eomChartInstance) {
    window.eomChartInstance.destroy();
  }

  window.eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatHHMM(v)
          }
        }
      },
      plugins: {
        annotation: {
          annotations: getEOMAnnotations(labels, cobElapsed)
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
          }
        },
        title: {
          display: true,
          text: "EOM COB & RR Elapsed Times",
          font: {
            size: 13,
            weight: "bold"
          },
          color: getTextColor()
        },
        legend: {
          labels: {
            font: {
              size: 13
            }
          }
        }
      }
    }
  });

  updateChartsTheme();
}






let eomChartInstance = null;

function parseElapsedToHours(str) {
    if (!str || str.length < 8) return 0;
    const parts = str.split(':').map(Number);
    const hours = parts[0];
    const minutes = parts[1];
    const seconds = parts[2];
    return hours + (minutes / 60) + (seconds / 3600);
}

function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 12;

    const dates = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cobTime = parseElapsedToHours(cells[3].innerText.trim());
        const rrTime = parseElapsedToHours(cells[6].innerText.trim());

        if (cobTime && rrTime) {
            dates.push(date);
            cobElapsed.push(cobTime);
            rrElapsed.push(rrTime);
        }
    }

    return {
        labels: dates.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (eomChartInstance) {
        eomChartInstance.destroy();
    }

    eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1"
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1"
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 20,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        font: {
                            size: 13,
                            weight: "bold"
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });

    updateChartsTheme();
}







<div class="chart-container hidden" id="eomChartWrapper">
  <canvas id="eomChart"></canvas>
</div>


let eomChartInstance = null;

function renderEOMChart() {
  const ctx = document.getElementById("eomChart").getContext("2d");
  const { labels, cobElapsed, rrElapsed } = getEOMTimes();

  if (eomChartInstance) {
    eomChartInstance.destroy();
  }

  eomChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "COB Elapsed",
          data: cobElapsed,
          backgroundColor: "rgba(154,200,245,1)",
          stack: "stack1"
        },
        {
          label: "RR Elapsed",
          data: rrElapsed,
          backgroundColor: "rgba(181,181,181,1)",
          stack: "stack1"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        },
        y: {
          beginAtZero: true,
          stacked: true,
          ticks: {
            stepSize: 1
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: "EOM COB + RR Elapsed Time (stacked)",
          font: {
            size: 13,
            weight: 'bold'
          },
          color: "#222"
        },
        legend: {
          display: true,
          labels: {
            font: {
              size: 13
            }
          }
        }
      },
      animation: {
        duration: 1000,
        easing: 'easeOutBounce'
      }
    }
  });
}


function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: rrElapsed.reverse()
  };
}

function getEOMTimes() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

  const maxDays = parseInt(document.getElementById('eomDaysRange').value, 10) || 10;

  const labels = [];
  const cobElapsed = [];
  const rrElapsed = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length < 8) continue;

    const date = cells[0].innerText.trim();
    const cob = parseFloat(cells[3].innerText.trim()) || 0;
    const rr = parseFloat(cells[7].innerText.trim()) || 0;

    labels.push(date);
    cobElapsed.push(cob);
    rrElapsed.push(rr);
  }

  return {
    labels: labels.reverse(),
    cobElapsed: cobElapsed.reverse(),
    rrElapsed: 






function getEOMTimes() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

    const maxDays = parseInt(document.getElementById("eomDaysRange").value, 10) || 10;
    const labels = [];
    const cobElapsed = [];
    const rrElapsed = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 6) continue;

        const date = cells[0].innerText.trim();
        const cob = parseTimeToMinutes(cells[3].innerText.trim());
        const rr = parseTimeToMinutes(cells[6].innerText.trim());

        if (cob > 0 || rr > 0) {
            labels.push(date);
            cobElapsed.push(cob);
            rrElapsed.push(rr);
        }
    }

    return {
        labels: labels.reverse(),
        cobElapsed: cobElapsed.reverse(),
        rrElapsed: rrElapsed.reverse()
    };
}

function renderEOMChart() {
    const ctx = document.getElementById("eomChart").getContext("2d");
    const { labels, cobElapsed, rrElapsed } = getEOMTimes();

    if (window.eomChartInstance) {
        window.eomChartInstance.destroy();
    }

    window.eomChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: labels,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    top: 10,
                    bottom: 20,
                    left: 10,
                    right: 10
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        maxTicksLimit: 8,
                        callback: v => formatHHMM(v)
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: ctx => `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`
                    }
                },
                title: {
                    display: true,
                    text: "EOM COB & RR Elapsed Times",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });

    updateChartsTheme();
}



<script>
document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    eomTable.classList.toggle("show", eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });

  function updateEomTableRows() {
    const table = document.getElementById("eomTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2); // Skip headers
    const maxRows = parseInt(eomRange.value, 10);

    rows.forEach((tr, i, arr) => {
      tr.hidden = i < arr.length - maxRows;
    });
  }
});
</script>





#eomTable {
  opacity: 0;
  transform: scaleY(0);
  transform-origin: top;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

#eomTable.show {
  opacity: 1;
  transform: scaleY(1);
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomTable = document.getElementById("eomTable");

let isEomVisible = false;

toggleEomBtn.addEventListener("click", () => {
  isEomVisible = !isEomVisible;
  if (isEomVisible) {
    eomTable.classList.add("show");
  } else {
    eomTable.classList.remove("show");
  }
});





<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <div class="daysValue" id="eomValue">10</div>
    </div>
  </div>
</div>






<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span>
      <span>&nbsp;days</span>
    </div>
  </div>
</div>




document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);

    if (eomVisible) {
      updateEomTableRows();
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}




<div class="tool-button" id="eomControlWrapper">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
  <div id="eomSliderWrapper" class="daysSliderWrapper hidden">
    <label for="eomRange" id="eomLabel">EOM Days:</label>
    <div class="daysInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10" />
      <span id="eomValue">10</span><span>&nbsp;days</span>
    </div>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");
  const eomRange = document.getElementById("eomRange");
  const eomValue = document.getElementById("eomValue");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;
    eomTable.classList.toggle("hidden", !eomVisible);
    eomSliderWrapper.classList.toggle("hidden", !eomVisible);
    
    if (eomVisible) {
      updateEomTableRows(); // –ü—Ä–µ—Å–º—è—Ç–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ, –∫–æ–≥–∞—Ç–æ —Å–µ –ø–æ–∫–∞–∑–≤–∞
    }
  });

  eomRange.addEventListener("input", (e) => {
    eomValue.textContent = e.target.value;
    updateEomTableRows();
  });
});



function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxRows = parseInt(document.getElementById('eomRange').value, 10);
  const total = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < total - maxRows;
  });
}





<div class="tool-button">
  <button id="toggleEomBtn">üî¥ Show EOM COBs</button>
</div>
<div id="eomSliderWrapper" class="daysSliderWrapper hidden">
  <label for="eomRange" id="eomLabel">EOM Days:</label>
  <div class="daysInputWrapper">
    <input type="range" id="eomRange" min="3" max="12" value="10" />
    <span id="eomValue">10</span><span>&nbsp;days</span>
  </div>
</div>


document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
      updateEomTableRows(); // –æ–±–Ω–æ–≤–∏ –ø—Ä–∏ –ø–æ–∫–∞–∑–≤–∞–Ω–µ
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows();
  });
});





function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3
  const totalRows = rows.length;

  rows.forEach((tr, i) => {
    tr.hidden = i < totalRows - maxRows; // —Å–∫—Ä–∏–≤–∞–º–µ –≥–æ—Ä–Ω–∏—Ç–µ
  });
}




function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞—à –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = Math.max(parseInt(document.getElementById('eomRange').value, 10), 3); // min 3

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}

if (eomVisible) {
  eomTable.classList.remove("hidden");
  eomSliderWrapper.classList.remove("hidden");
  updateEomTableRows(); // <-- –¢—É–∫ —Å–µ –≤–∏–∫–∞
}



document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows();
});






document.addEventListener("DOMContentLoaded", () => {
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("mousedown", (e) => {
    if (e.target.tagName === 'INPUT') return; // –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è–≤–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –æ—Ç range

    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });

  document.getElementById("eomRange").addEventListener("input", (e) => {
    document.getElementById("eomValue").textContent = e.target.value;
    updateEomTableRows(e.target.value); // —Å–∞–º–æ –∞–∫–æ –∏–º–∞—à —Ñ—É–Ω–∫—Ü–∏—è
  });
});




<script>
  const toggleEomBtn = document.getElementById("toggleEomBtn");
  const eomTable = document.getElementById("eomTable");
  const eomSliderWrapper = document.getElementById("eomSliderWrapper");

  let eomVisible = false;

  toggleEomBtn.addEventListener("click", () => {
    eomVisible = !eomVisible;

    if (eomVisible) {
      eomTable.classList.remove("hidden");
      eomSliderWrapper.classList.remove("hidden");
    } else {
      eomTable.classList.add("hidden");
      eomSliderWrapper.classList.add("hidden");
    }
  });
</script>





toggleEomBtn.addEventListener("click", (event) => {
  // –ò–≥–Ω–æ—Ä–∏—Ä–∞–π –∫–ª–∏–∫–æ–≤–µ –ø–æ –≤–ª–æ–∂–µ–Ω–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤—ä—Ç—Ä–µ –≤ –±—É—Ç–æ–Ω–∞
  if (event.target !== toggleEomBtn && !toggleEomBtn.contains(event.target)) return;

  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});



<div class="tool-button" id="toggleEomBtn">
  <span>Show EOM COBs</span>
  <div id="eomSliderWrapper" class="hidden eom-slider">
    <label for="eomRange" id="eomLabel">EOM COB Days:</label>
    <div id="eomInputWrapper">
      <input type="range" id="eomRange" min="3" max="12" value="10">
      <span id="eomValue">10</span>
      <span>days</span>
    </div>
  </div>
</div>


.eom-slider {
  margin-top: 8px;
  font-size: 13px;
  text-align: center;
}

#eomInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 5px;
}

#eomInputWrapper input[type="range"] {
  width: 85px;
  accent-color: #3b8de3;
}

#eomLabel {
  color: #111;
  font-weight: bold;
}

body.dark-mode #eomLabel {
  color: #eee;
}


const toggleEomBtn = document.getElementById("toggleEomBtn");
const eomSliderWrapper = document.getElementById("eomSliderWrapper");
const eomTable = document.getElementById("eomTable");

toggleEomBtn.addEventListener("click", () => {
  eomSliderWrapper.classList.toggle("hidden");
  eomTable.classList.toggle("hidden");
});

document.getElementById("eomRange").addEventListener("input", (e) => {
  document.getElementById("eomValue").textContent = e.target.value;
  updateEomTableRows(e.target.value); // –∞–∫–æ –∏–º–∞—à —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ
});







<div class="eom-controls">
  <button id="toggleEomTable" class="tool-button">Show EOM COBs</button>

  <div id="eomSliderWrapper" class="tool-button hidden">
    <label for="eomRange">EOM COB Days:</label>
    <span id="eomValue">10</span>
    <input type="range" id="eomRange" min="3" max="12" value="10" />
  </div>
</div>


.eom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

#eomSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  color: #333;
  margin-right: 5px;
}

#eomSliderWrapper input[type="range"] {
  width: 85px;
  accent-color: #b3e0ff;
}

#eomValue {
  font-size: 13px;
  font-weight: bold;
  color: #111;
  margin: 0 5px;
}

body.dark-mode #eomSliderWrapper label {
  color: #eee;
}
body.dark-mode #eomValue {
  color: #eee;
}


document.getElementById("toggleEomTable").addEventListener("click", () => {
  const table = document.getElementById("eomTable");
  const slider = document.getElementById("eomSliderWrapper");
  table.classList.toggle("hidden");
  slider.classList.toggle("hidden");
});


<button id="toggleEomBtn" class="tool-button">üìÖ Show EOM COBs</button>

<div id="eomDaysSliderWrapper" class="tool-button hidden">
  <label for="eomDaysRange">EOM COB Days:</label>
  <span id="eomDaysValue">10</span>
  <input type="range" min="3" max="12" value="10" id="eomDaysRange" />
</div>

document.addEventListener('DOMContentLoaded', () => {
  const eomBtn = document.getElementById('toggleEomBtn');
  const eomTable = document.getElementById('eomTable');
  const eomSlider = document.getElementById('eomDaysRange');
  const eomValue = document.getElementById('eomDaysValue');
  const eomSliderWrapper = document.getElementById('eomDaysSliderWrapper');

  eomBtn.addEventListener('click', () => {
    const isHidden = eomTable.classList.contains('hidden');
    eomTable.classList.toggle('hidden', !isHidden);
    eomSliderWrapper.classList.toggle('hidden', !isHidden);
  });

  eomSlider.addEventListener('input', () => {
    eomValue.textContent = eomSlider.value;
    updateEomTableRows(); // —Ç—Ä—è–±–≤–∞ –¥–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞, —â–µ –¥–æ–±–∞–≤–∏–º –ª–æ–≥–∏–∫–∞—Ç–∞ –ø–æ—Å–ª–µ
  });
});

function updateEomTableRows() {
  const table = document.getElementById('eomTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const maxRows = parseInt(document.getElementById('eomDaysRange').value, 10);

  rows.forEach((tr, i) => {
    tr.hidden = i >= maxRows;
  });
}




<button id="toggleEomBtn" class="tool-button">üìÖ Show EOM COBs</button>

<div id="eomSliderWrapper" class="tool-bottom hidden">
  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

#eomSliderWrapper {
  margin-top: 10px;
  font-size: 14px;
}


const toggleEomBtn = document.getElementById('toggleEomBtn');
const eomSliderWrapper = document.getElementById('eomSliderWrapper');
const eomTable = document.getElementById('eomTable'); // –£–≤–µ—Ä–∏ —Å–µ, —á–µ –∏–º–∞ —Ç–∞–∫–∞–≤–∞ —Ç–∞–±–ª–∏—Ü–∞

toggleEomBtn.addEventListener('click', () => {
  eomTable?.classList.toggle('hidden');
  eomSliderWrapper.classList.toggle('hidden');
});

function syncEOMSliderAndInput(value) {
  const v = Math.max(1, Math.min(12, parseInt(value) || 5));
  document.getElementById('eomDaysRange').value = v;
  document.getElementById('eomDaysInput').value = v;
  updateEOMTableRows(v); // –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–π —Ç–∞–∑–∏ —Ñ—É–Ω–∫—Ü–∏—è, –∞–∫–æ –æ—â–µ –Ω–µ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞
}

document.getElementById('eomDaysRange').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));
document.getElementById('eomDaysInput').addEventListener('input', (e) => syncEOMSliderAndInput(e.target.value));





<div id="cobToolsMenu" class="tools-menu">
  <!-- Existing tools -->
  
  <button onclick="toggleEOMTable()">Show EOM COBs</button>

  <label for="eomDaysRange">EOM COBs:</label>
  <input type="range" id="eomDaysRange" min="1" max="12" value="5">
  <input type="number" id="eomDaysInput" min="1" max="12" value="5" style="width: 40px; margin-left: 5px;">
</div>

<table id="eomTable" style="display: none;">
  <!-- Your EOM table rows -->
</table>

<script>
  function toggleEOMTable() {
    const table = document.getElementById('eomTable');
    table.style.display = table.style.display === 'none' ? 'table' : 'none';
  }

  function syncEOMSliderAndInput(value) {
    const v = Math.max(1, Math.min(12, parseInt(value) || 5));
    document.getElementById('eomDaysRange').value = v;
    document.getElementById('eomDaysInput').value = v;
    updateEOMTableRows(v); // –¢—Ä—è–±–≤–∞ –¥–∞ –∏–º–∞—à –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∞ —Ç–∞–∑–∏ —Ñ—É–Ω–∫—Ü–∏—è
  }

  document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('eomDaysRange');
    const input = document.getElementById('eomDaysInput');
    slider.addEventListener('input', () => syncEOMSliderAndInput(slider.value));
    input.addEventListener('input', () => syncEOMSliderAndInput(input.value));
    syncEOMSliderAndInput(5);
  });
</script>




<footer>
  <p style="margin-top: 30px;">
    –ó–∞ –∏–¥–µ–∏/–±—ä–≥–æ–≤–µ, –º–æ–ª—è –ø–∏—à–µ—Ç–µ –≤ –æ—Ñ–∏—Ü–∏–∞–ª–Ω–∞—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–∞ <strong>COB Analyser</strong>.<br>
    <a href="https://your-confluence-link-here" style="color: #66c1ff; text-decoration: none;" target="_blank">
      –û—Ç–≤–æ—Ä–∏ COB Analyser –≤ Confluence
    </a>
  </p>
  <br>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>
  –î–∏–ª—è–Ω
</footer>



<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7f9;
      color: #333;
      padding: 30px;
      line-height: 1.6;
    }
    .container {
      background-color: #fff;
      border: 1px solid #ddd;
      border-left: 5px solid #007ACC;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }
    h1 {
      font-size: 1.5em;
      color: #007ACC;
    }
    .section {
      margin-top: 20px;
    }
    .highlight {
      background-color: #eef;
      padding: 4px 8px;
      font-weight: bold;
      border-radius: 4px;
      display: inline-block;
    }
    footer {
      margin-top: 30px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</h1>

    <div class="section">
      –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser –≤ SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <span class="highlight">today_cob_date</span> –µ –ø—Ä–∏–∫—Ä–µ–ø–µ–Ω.
    </div>

    <div class="section">
      <strong>LOG —Ñ–∞–π–ª—ä—Ç</strong>, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:
      <div class="highlight">/opt/t24/support_scripts/cob_analyser/log/</div>
    </div>

    <footer>
      –ü–æ–∑–¥—Ä–∞–≤–∏,<br>
      –î–∏—è–Ω
    </footer>
  </div>
</body>
</html>





<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* –û–±—â —Å—Ç–∏–ª –∑–∞ –∏–º–µ–π–ª–∞ */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }

    /* –¶–µ–Ω—Ç—Ä–∏—Ä–∞—â–∞ —Ç–∞–±–ª–∏—Ü–∞ */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    /* –•–µ–¥—ä—Ä */
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* –¢—è–ª–æ */
    .email-body {
      padding: 30px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ —Ç–µ–∫—Å—Ç–∞ */
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ –∏ –∫–æ–¥–∞ */
    }

    /* –§—É—Ç—ä—Ä */
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
      text-align: center;            /* —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–º–µ –ø–æ–¥–ø–∏—Å–∞ */
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</p>
              <p>üìÇ –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser</strong> –≤ <strong>SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <em>today_cob_date</em> –µ –ø—Ä–∏–∫–∞—á–µ–Ω.</p>
              <p>üìÇ LOG —Ñ–∞–π–ª—ä—Ç, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:</p>
              <p><code>/opt/t24/support_scripts/cob_analyser/log</code></p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>–î–∏–ª—è–Ω</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>






<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>COB Analyser Report</title>
  <style>
    /* –û–±—â —Å—Ç–∏–ª –∑–∞ –∏–º–µ–π–ª–∞ */
    body {
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.4;
    }
    a { color: #0066cc; text-decoration: none; }
    /* –¶–µ–Ω—Ç—Ä–∏—Ä–∞—â–∞ —Ç–∞–±–ª–∏—Ü–∞ */
    .email-container {
      width: 100%;
      background-color: #f4f4f4;
      padding: 20px 0;
    }
    .email-content {
      width: 600px;
      max-width: 100%;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .email-header {
      background-color: #004080;
      color: white;
      padding: 20px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }
    .email-body {
      padding: 30px;
    }
    .email-body p {
      margin: 0 0 16px;
    }
    .email-body code {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: Menlo, monospace;
      font-size: 14px;
    }
    .email-footer {
      padding: 0 30px 30px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <table class="email-container" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table class="email-content" cellpadding="0" cellspacing="0">
          <!-- Header -->
          <tr>
            <td class="email-header">
              COB Analyser Report
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td class="email-body">
              <p>–ó–¥—Ä–∞–≤–µ–π—Ç–µ,</p>
              <p>üìÇ –§–∞–π–ª—ä—Ç –∑–∞ <strong>COB Analyser</strong> –≤ <strong>SP24 PROD</strong> –∑–∞ –¥–∞—Ç–∞ <em>today_cob_date</em> –µ –ø—Ä–∏–∫–∞—á–µ–Ω.</p>
              <p>üìÇ LOG —Ñ–∞–π–ª—ä—Ç, –∫–∞–∫—Ç–æ –∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ —Å–ª–µ–¥–Ω–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è:<br>
                 <code>/opt/t24/support_scripts/cob_analyser/log</code>
              </p>
            </td>
          </tr>
          <!-- Footer -->
          <tr>
            <td class="email-footer">
              <p>–ü–æ–∑–¥—Ä–∞–≤–∏,<br>–î–∏–ª—è–Ω</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>



for i in {0..11}; do
  last_day=$(date -d "$current_date -$i month -1 day" +%Y%m%d)
  echo "$last_day"

  jtfind="$jt_path/JT_$last_day.csv"

  if [[ -s "$jtfind" ]]; then
    echo "COB $last_day $jtfind"
    echo "-----Started-----"
    cat "$jtfind" | grep A000 | cut -d ',' -f6 | head -1
    echo "-----Stopped-----"
    cat "$jtfind" | grep R999 | cut -d ',' -f7 | head -1
  else
    echo "File not found or empty: $jtfind, skipping..."
  fi
done





function getEOMAnnotations(labels, yData) {
  const annotations = {};
  const topY = Math.max(...yData);  // –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Å–∏–≤–∞ –æ—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç–∏

  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}



function getEOMAnnotations(labels, chart) {
  const annotations = {};
  const topY = Math.max(...chart.data.datasets[0].data);  // –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ Y
  
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: topY + 30,  // –ª–µ–∫–æ –Ω–∞–¥ –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: 0,
        rotation: 0
      };
    }
  }

  return annotations;
}




function getEOMAnnotations(labels, heights) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    if (current.substring(0, 6) !== next.substring(0, 6)) {
      const height = heights?.[i] || 1; // –∞–∫–æ –Ω—è–º–∞ –º–∞—Å–∏–≤, –ø–∞–¥–∞–º–µ –Ω–∞ 1
      const adjustedY = height + 50; // –∏–∑–¥–∏–≥–∞–º–µ —Ç–µ–∫—Å—Ç–∞ —Å 50 –Ω–∞–¥ —Å—Ç—ä–ª–±–∞

      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
      };

      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: adjustedY,
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -10,
        rotation: 0
      };
    }
  }

  return annotations;
}





// make sure you‚Äôve imported & registered both Chart.js and chartjs-plugin-annotation before this runs
// e.g.:
//   import { Chart, BarController, BarElement, CategoryScale, LinearScale, Title } from 'chart.js';
//   import annotationPlugin from 'chartjs-plugin-annotation';
//   Chart.register(BarController, BarElement, CategoryScale, LinearScale, Title, annotationPlugin);

let recordsChartInstance;

function renderRecordsChart() {
  // 1) pull your data
  const { labels, recordsPerMinute } = getRecordsData();  // your existing extractor

  // 2) destroy previous chart
  if (recordsChartInstance) recordsChartInstance.destroy();

  // 3) create new one
  const ctx = document.getElementById('recordsChart').getContext('2d');
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: 'rgba(54,162,235,0.6)',
        borderColor:   'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { 
          stacked: true,
          ticks: { font: { size: 13 }, color: '#333' }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { font: { size: 13 }, color: '#333' }
        }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 14, weight: 'bold' },
          color: '#222'
        },
        annotation: {
          // ask our helper to build a map of annotations:
          annotations: buildEOMAnnotations(recordsChartInstance)
        }
      }
    }
  });
}

/**
 * Walks the chart‚Äôs labels and data, finds month-breaks
 * and returns a map of annotation configs for line + label.
 */
function buildEOMAnnotations(chart) {
  const ann = {};
  const labels = chart.data.labels;
  const data   = chart.data.datasets[0].data;
  const yScale = chart.scales.y;

  labels.forEach((lbl, i) => {
    const next = labels[i + 1];
    // compare YYYYMM prefix of this vs next
    if (next && lbl.slice(0,6) !== next.slice(0,6)) {
      // vertical dashed line
      ann[`eomLine${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: lbl,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6,4],
        borderDashOffset: 2
      };
      // label at the top
      ann[`eomLabel${i}`] = {
        type: 'label',
        xScaleID: 'x',
        xValue: lbl,
        yScaleID: 'y',
        yValue: yScale.max,     // attach to top of the scale
        content: ['EOM'],
        font: { size: 12, weight: 'bold' },
        color: 'orange',
        textAlign: 'center',
        backgroundColor: 'transparent',
        yAdjust: -8             // shift up 8px from top
      };
    }
  });

  return ann;
}

// call on load / whenever you update your table
renderRecordsChart();




function getEOMAnnotationsWithHeights(records, labels) {
    const annotations = {};
    for (let i = 0; i < labels.length - 1; i++) {
        const current = labels[i];
        const next = labels[i + 1];

        if (current.substring(0, 6) !== next.substring(0, 6)) {
            const yVal = records[i] || 0;
            annotations[`line-eom-${i}`] = {
                type: 'line',
                scaleID: 'x',
                value: current,
                borderColor: 'orange',
                borderWidth: 2,
                borderDash: [6, 4]
            };

            annotations[`text-eom-${i}`] = {
                type: 'label',
                xValue: current,
                yValue: yVal,
                backgroundColor: 'transparent',
                content: ['EOM'],
                font: {
                    size: 12,
                    weight: 'bold'
                },
                color: 'orange',
                textAlign: 'center',
                position: 'start',
                xAdjust: 0,
                yAdjust: -Math.max(20, Math.min(yVal * 0.05, 40)), // –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–∞–Ω–µ
                rotation: 0
            };
        }
    }
    return annotations;
}





function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Records Per Minute',
                    data: recordsPerMinute,
                    backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                    borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                    borderRadius: 15,
                    hoverBorderWidth: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                annotation: {
                    annotations: getEOMAnnotationsWithHeights(recordsPerMinute, labels)
                },
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });

    updateChartsTheme();
}




function getEOMAnnotationsWithHeights(chart) {
  const annotations = [];
  const labels = chart.data.labels;
  const datasets = chart.data.datasets;

  // –ù–∞–º–µ—Ä–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ –¥–Ω–∏ –æ—Ç –º–µ—Å–µ—Ü–∞
  const lastDays = [];
  for (let i = 0; i < labels.length; i++) {
    const current = labels[i].substring(0, 6);
    const next = labels[i + 1]?.substring(0, 6);
    if (current !== next) {
      lastDays.push({ index: i, date: labels[i] });
    }
  }

  // –ó–∞ –≤—Å—è–∫–∞ –¥–∞—Ç–∞ –Ω–∞–º–µ—Ä–∏ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ Y
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(ds => {
      const val = ds.data[index];
      if (typeof val === 'number' && val > maxY) {
        maxY = val;
      }
    });

    annotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [4, 4],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: {
          x: 'end',
          y: 'start'
        },
        yAdjust: -10,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          size: 11,
          weight: 'bold'
        }
      }
    });
  });

  return annotations;
}


const annotations = getEOMAnnotationsWithHeights(chart);

options: {
  // ...
  plugins: {
    annotation: {
      annotations: annotations
    }
  }
}





function getEOMAnnotationsWithHeights(chart, labels, datasets) {
  const eomAnnotations = [];
  const lastDays = [];

  // –ù–∞–º–∏—Ä–∞–º–µ –≤—Å–∏—á–∫–∏ –ø–æ—Å–ª–µ–¥–Ω–∏ –¥–∞—Ç–∏ –∑–∞ –≤—Å–µ–∫–∏ –º–µ—Å–µ—Ü
  for (let i = 0; i < labels.length; i++) {
    const currentDate = labels[i];
    const currentMonth = currentDate.substring(0, 6);
    const nextDate = labels[i + 1];
    const nextMonth = nextDate ? nextDate.substring(0, 6) : null;

    if (currentMonth !== nextMonth) {
      lastDays.push({ index: i, date: currentDate });
    }
  }

  // –ó–∞ –≤—Å—è–∫–∞ —Ç–∞–∫–∞–≤–∞ –¥–∞—Ç–∞ –Ω–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–≤–∏—Å–æ–∫–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –æ—Ç –≤—Å–∏—á–∫–∏ datasets
  lastDays.forEach(({ index, date }) => {
    let maxY = 0;

    datasets.forEach(dataset => {
      const value = dataset.data[index];
      if (typeof value === 'number' && value > maxY) {
        maxY = value;
      }
    });

    eomAnnotations.push({
      type: 'line',
      xMin: date,
      xMax: date,
      borderColor: 'orange',
      borderDash: [6, 3],
      borderWidth: 1,
      label: {
        content: 'EOM',
        enabled: true,
        position: 'end',
        yAdjust: -8,
        backgroundColor: 'transparent',
        color: 'orange',
        font: {
          weight: 'bold'
        }
      },
      yMax: maxY
    });
  });

  return eomAnnotations;
}





function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`line-eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4]
      };
      annotations[`text-eom-${i}`] = {
        type: 'label',
        xValue: current,
        yValue: 1, // –ù—è–º–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, —â–µ –≥–æ –∫–æ—Ä–∏–≥–∏—Ä–∞–º–µ —Å—ä—Å yAdjust
        backgroundColor: 'transparent',
        content: ['EOM'],
        font: {
          size: 12,
          weight: 'bold'
        },
        color: 'orange',
        textAlign: 'center',
        position: 'start',
        xAdjust: 0,
        yAdjust: -30, // —Ç–æ–≤–∞ –º–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç–∞ –Ω–∞–¥ –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
        rotation: 0
      };
    }
  }
  return annotations;
}







function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];
    if (current.substring(0, 6) !== next.substring(0, 6)) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          xAdjust: 30,
          yAdjust: -5,
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}





<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>



function getEOMAnnotations(labels) {
  const annotations = {};
  for (let i = 0; i < labels.length - 1; i++) {
    const current = labels[i];
    const next = labels[i + 1];

    // –ò–∑–≤–ª–∏—á–∞–º–µ –º–µ—Å–µ—Ü –∏ –≥–æ–¥–∏–Ω–∞ –æ—Ç –¥–∞—Ç–∞—Ç–∞ (—Ñ–æ—Ä–º–∞—Ç YYYYMMDD)
    const currentMonth = current.slice(0, 6);
    const nextMonth = next.slice(0, 6);

    if (currentMonth !== nextMonth) {
      annotations[`eom-${i}`] = {
        type: 'line',
        scaleID: 'x',
        value: current,
        borderColor: 'orange',
        borderWidth: 2,
        borderDash: [6, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'orange',
          font: {
            size: 11,
            weight: 'bold'
          }
        }
      };
    }
  }
  return annotations;
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendline(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5, 5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return formatSecondsToHMS(value);
            }
          },
          title: {
            display: false,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function (context) {
              const val = context.raw;
              return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
            }
          }
        },
        legend: {
          display: true,
          labels: {
            font: { size: 13, weight: 'bold' },
            color: getTextColor()
          }
        },
        title: {
          display: true,
          text: 'COB Elapsed Time + Trend',
          color: getTextColor(),
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        annotation: {
          annotations: getEOMAnnotations(labels)
        }
      }
    },
    plugins: [{
      id: 'barLabelsOnly',
      afterDatasetsDraw(chart) {
        const ctx = chart.ctx;
        const datasetMeta = chart.getDatasetMeta(0);
        const dark = document.body.classList.contains('dark-mode');

        datasetMeta.data.forEach((bar, i) => {
          const val = chart.data.datasets[0].data[i];
          const label = formatSecondsToHMS(val);
          const barHeight = bar.base - bar.y;

          ctx.save();
          ctx.font = `bold ${barHeight > 30 ? '12px' : '10px'} sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillStyle = dark ? '#fff' : '#000';
          ctx.fillText(label, bar.x, bar.y - 6);
          ctx.restore();
        });
      }
    }]
  });
}






function getEOMAnnotations(labels) {
  const eomAnnotations = [];

  for (let i = 1; i < labels.length; i++) {
    const prev = labels[i - 1].slice(0, 6); // YYYYMM
    const curr = labels[i].slice(0, 6);
    if (prev !== curr) {
      const eomDate = labels[i - 1];
      eomAnnotations.push({
        type: 'line',
        scaleID: 'x',
        value: eomDate,
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'EOM',
          position: 'start',
          color: 'black',
          font: {
            size: 11,
            weight: 'bold'
          },
          rotation: -90
        }
      });
    }
  }

  return eomAnnotations;
}

plugins: {
  annotation: {
    annotations: getEOMAnnotations(labels)
  },
  title: {
    display: true,
    text: 'COB & RR Times vs Cutoff Threshold',
    font: { size: 13, weight: 'bold' }
  }
}


#!/usr/bin/env python3
import random
import string

def password_generator(length=16,
                       use_special=True,
                       use_upper=True,
                       use_lower=True,
                       use_digits=True):
    """Generate a random password."""
    chars = ""
    if use_lower:
        chars += string.ascii_lowercase
    if use_upper:
        chars += string.ascii_uppercase
    if use_digits:
        chars += string.digits
    if use_special:
        chars += string.punctuation

    if not chars:
        raise ValueError("You must choose at least one type of symbol!")

    return "".join(random.choice(chars) for _ in range(length))


def ask_user():
    """Prompt the user for options and print out the password."""
    try:
        length = int(input("How many characters should the password be? "))
        if length < 1:
            print("Length must be a positive integer.")
            return
    except ValueError:
        print("Please enter a valid number!")
        return

    use_special = input("Include special characters? (y/n): ").strip().lower() == "y"
    use_upper   = input("Include uppercase letters? (y/n): ").strip().lower() == "y"
    use_lower   = input("Include lowercase letters? (y/n): ").strip().lower() == "y"
    use_digits  = input("Include digits? (y/n): ").strip().lower() == "y"

    try:
        pwd = password_generator(
            length,
            use_special=use_special,
            use_upper=use_upper,
            use_lower=use_lower,
            use_digits=use_digits,
        )
    except ValueError as e:
        print(e)
        return

    print("\nYour generated password is:", pwd)
    print("=" * 40)


if __name__ == "__main__":
    ask_user()




COB Analyser is a lightweight, browser-based tool designed to help operations and development teams monitor and troubleshoot their overnight batch processes (‚ÄúClose-Of-Business‚Äù or COB runs). Its main goals are to:
	1.	Collect and display key COB metrics
	‚Ä¢	Start & Stop Times for each day‚Äôs batch run
	‚Ä¢	Elapsed Duration (how long the entire COB took)
	‚Ä¢	Throughput (records or transactions processed per minute)
	‚Ä¢	CPU Usage across USER, SYSTEM and IDLE time slices during the run
	‚Ä¢	Batch Health Checks (e.g. detecting missing or unusually slow batches, or unexpected application restarts)
	2.	Provide configurable historical views
	‚Ä¢	A slider lets you choose how many days of history to display (from 3 up to 31), defaulting to the last 10 days
	‚Ä¢	Tables and charts automatically update whenever you move the slider, so you can zoom in on a recent window or zoom out to see longer trends
	3.	Visualize trends at a glance
	‚Ä¢	Bar charts for throughput (records per minute) and COB durations
	‚Ä¢	A trend-line overlay on the duration chart to highlight whether your nightly runs are speeding up or slowing down over time
	‚Ä¢	A line chart for CPU usage, so you can spot spikes in user/system load or shifts in idle time
	4.	Flag anomalies and export data
	‚Ä¢	Automatic warnings for missing batches, slow batches, and restarts during COB
	‚Ä¢	One-click export of any table to CSV, plus the ability to download chart images for reporting

By combining automatic data extraction, interactive filtering, and clear visualizations, COB Analyser makes it easy to detect performance regressions, capacity bottlenecks, or configuration issues‚Äîwithout manual spreadsheet work every morning.





upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}

  # –æ–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ø–∏—Å—ä–∫ –æ—Ç —Ñ–∞–π–ª–æ–≤–µ
  local files=()
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi

  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"

  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest"   || die "Destination not found: $dest"
    dzdo test -w "$dest"   || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}

  # –æ–ø—Ä–µ–¥–µ–ª—è–º–µ —Å–ø–∏—Å—ä–∫ –æ—Ç –æ—Ç–¥–∞–ª–µ—á–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ
  local remotes=()
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi

  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"

  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}




#!/usr/bin/env bash
set -euo pipefail
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# scb_file.sh ‚Äî Secure Upload/Download/Cleanup wrapper with ‚Äìall & mask support
# ------------------------------------------------------------------------------

# Color definitions
declare -r RED='\e[31m'
declare -r GREEN='\e[32m'
declare -r YELLOW='\e[33m'
declare -r BLUE='\e[34m'
declare -r CYAN='\e[36m'
declare -r NC='\e[0m'

# Paths & names
readonly SELF=$(basename "$0")
readonly BASE_DIR=$(cd "$(dirname "$0")" && pwd)
readonly LOG_DIR="$BASE_DIR/log"
readonly UPLOAD_DIR="$BASE_DIR/upload"
readonly DOWNLOAD_BASE="$BASE_DIR/download"
readonly LOG_FILE="$LOG_DIR/${SELF%.sh}.log"
readonly REMOTE_DIR="/opt/t24/bnk/UD/DUMMY"
readonly USER_NAME=$(id -un)
readonly LOGIN_USER=$(logname 2>/dev/null || echo "")

# Ensure we run as the login user
if [[ "$LOGIN_USER" != "$USER_NAME" ]]; then
  echo -e "${RED}Error:${NC} Please run as login user '$LOGIN_USER', not '$USER_NAME'." >&2
  exit 1
fi

# Ensure directories exist & we‚Äôre in the right folder
mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$DOWNLOAD_BASE"
if [[ "$(pwd)" != "$BASE_DIR" ]]; then
  echo -e "${RED}Error:${NC} Please run '$SELF' from its own directory: $BASE_DIR" >&2
  exit 1
fi

# --- logging helpers ---
tlog()      { echo "$(date '+%F %T') [$1] ${*:2}" >> "$LOG_FILE"; }
die()       { echo -e "${RED}Error:${NC} $1" >&2; tlog ERROR "$1"; exit 1; }
echo_info() { echo -e "${BLUE}Info:${NC} $1"; tlog INFO "$1"; }

# --- ASCII table printer (single row) ---
show_table() {
  local func=$1 src=$2 file=$3 dest=$4
  local headers=(Function Source\ Dir File Destination)
  local rows=("$func" "$src" "$file" "$dest")
  local cols=4 widths=()
  for ((i=0;i<cols;i++)); do
    widths[i]=${#headers[i]}
    (( ${#rows[i]} > widths[i] )) && widths[i]=${#rows[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  printf "${GREEN}${fmt}${NC}\n" "${rows[@]}"
  echo -e "${YELLOW}${border}${NC}"
}

# --- ASCII table printer (multiple rows) ---
show_table_multi() {
  local args=("$@"); local total=${#args[@]} cols=4 rows_num=$((total/cols))
  local headers=(Function Source\ Dir File Destination) widths=()
  for ((i=0;i<cols;i++)); do widths[i]=${#headers[i]}; done
  for ((i=0;i<total;i++)); do
    local c=$((i%cols))
    (( ${#args[i]} > widths[c] )) && widths[c]=${#args[i]}
  done
  local border=""
  for w in "${widths[@]}"; do
    border+="+$(printf '%*s' $((w+2)) '' | tr ' ' '-')"
  done
  border+="+"
  local fmt=""
  for w in "${widths[@]}"; do fmt+="| %-${w}s "; done; fmt+="|"
  echo -e "${YELLOW}${border}${NC}"
  printf "${CYAN}${fmt}${NC}\n" "${headers[@]}"
  echo -e "${YELLOW}${border}${NC}"
  for ((r=0;r<rows_num;r++)); do
    local idx=$((r*cols))
    printf "${GREEN}${fmt}${NC}\n" \
      "${args[idx]}" "${args[idx+1]}" "${args[idx+2]}" "${args[idx+3]}"
  done
  echo -e "${YELLOW}${border}${NC}"
}

# --- help & usage ---
display_help() {
  cat <<EOF
${CYAN}scb_file.sh${NC} ‚Äî Secure Upload/Download/Cleanup Utility

${YELLOW}Usage:${NC}
  $SELF [OPTIONS] <command> <pattern| -all> [<path>]

${YELLOW}Commands:${NC}
  upload   <pattern>|-all    [<dest_dir>]
  download <pattern>|-all    [<src_dir>]
  cleanup                    Cleanup files >7d or >10MB under $DOWNLOAD_BASE

${YELLOW}Options:${NC}
  -h, --help    Display this help and exit

${YELLOW}Examples:${NC}
  $SELF upload    -all
  $SELF upload    **.txt
  $SELF download  -all
  $SELF download  **.log
  $SELF cleanup
EOF
}

usage() {
  echo -e "${YELLOW}Usage:${NC}"
  show_table_multi \
    "Upload"   "$UPLOAD_DIR"                  "<pattern| -all>"            "$REMOTE_DIR" \
    "Download" "$REMOTE_DIR"                  "<pattern| -all>"            "$DOWNLOAD_BASE/<user>/<YYYYmmdd>" \
    "Cleanup"  "$DOWNLOAD_BASE"               "<older than 7d or >10MB>"   "-"
  echo -e "${YELLOW}Options:${NC}"
  echo "  -h, --help    Display detailed help"
  exit 1
}

# --- parse args ---
if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  display_help; exit 0
fi
(( $# >= 1 )) || usage
ACTION=$1; shift

# --- command implementations ---
upload() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for upload"
  local pattern=$1; shift
  local dest=${1:-$REMOTE_DIR}
  local files
  if [[ $pattern == "-all" ]]; then
    files=( "$UPLOAD_DIR"/* )
  else
    files=( "$UPLOAD_DIR"/$pattern )
  fi
  (( ${#files[@]} > 0 )) || die "No matching files for '$pattern' in $UPLOAD_DIR"
  for src in "${files[@]}"; do
    [[ -f $src ]] || continue
    [[ -r $src ]] || { echo_info "Skipping unreadable: ${src##*/}"; continue; }
    dzdo test -d "$dest" || die "Destination not found: $dest"
    dzdo test -w "$dest" || die "No write permission: $dest"

    local name=${src##*/}
    show_table  "Upload" "$UPLOAD_DIR" "$name" "$dest"
    echo_info "Uploading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    cp "$src" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    dzdo mv "$tmpf" "$dest/$name"

    echo_info "Upload complete: '$name'"
  done
}

download() {
  (( $# >= 1 )) || die "Missing <pattern| -all> for download"
  local pattern=$1; shift
  local srcd=${1:-$REMOTE_DIR}
  local remotes
  if [[ $pattern == "-all" ]]; then
    remotes=( "$srcd"/* )
  else
    remotes=( "$srcd"/$pattern )
  fi
  (( ${#remotes[@]} > 0 )) || die "No matching files for '$pattern' in $srcd"
  for remote in "${remotes[@]}"; do
    [[ -f $remote ]] || continue
    dzdo test -r "$remote" || { echo_info "Skipping unreadable: ${remote##*/}"; continue; }

    local name=${remote##*/}
    local date_dir=$(date '+%Y%m%d')
    local dest="$DOWNLOAD_BASE/$USER_NAME/$date_dir"
    mkdir -p "$dest"
    [[ -w $dest ]] || die "No write permission: $dest"

    show_table  "Download" "$srcd" "$name" "$dest"
    echo_info "Downloading '$name' ‚Üí '$dest/'"

    local tmpf
    tmpf=$(mktemp "/tmp/${name}.XXXXXX") || die "Cannot create temp file"
    dzdo cp "$remote" "$tmpf"
    dzdo chown "$USER_NAME":"$USER_NAME" "$tmpf"
    dzdo chmod 770 "$tmpf"
    mv "$tmpf" "$dest/$name"

    echo_info "Download complete: '$name'"
  done
}

cleanup() {
  local base="$DOWNLOAD_BASE"
  [[ -d $base ]] || { echo_info "Nothing to clean in $base"; return; }

  echo_info "Removing files older than 7 days under '$base'..."
  find "$base" -mindepth 2 -type f -mtime +7 -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed old file: $f"; done

  echo_info "Removing files larger than 10MB under '$base'..."
  find "$base" -mindepth 2 -type f -size +10M -print -exec rm -f {} \; \
    | while read -r f; do echo_info "Removed large file: $f"; done

  echo_info "Cleanup complete."
}

# --- main dispatch ---
case "$ACTION" in
  upload)   upload   "$@" ;;
  download) download "$@" ;;
  cleanup)  (( $# == 0 )) || die "cleanup takes no arguments"; cleanup ;;
  *)        usage ;;
esac








/**
 * –ü—Ä–æ–º–µ–Ω—è —à–∏—Ä–∏–Ω–∞—Ç–∞ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ
 * —Å–ø—Ä—è–º–æ –±—Ä–æ—è –¥–Ω–∏:
 *   3‚Äì10  –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-0-10
 *  11‚Äì20  –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-11-20
 *  21‚Äì31+ –¥–Ω–∏ ‚Üí –∫–ª–∞—Å w-21-plus
 */
function updateContainerWidth(days) {
  const ctr = document.getElementById("chartContainer");
  if (!ctr) return;
  // –º–∞—Ö–∞–º–µ –≤—Å–∏—á–∫–∏ –ø—Ä–µ–¥–∏—à–Ω–∏
  ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
  // —Å–ª–∞–≥–∞–º–µ –Ω–æ–≤–∏—è
  if (days <= 10) {
    ctr.classList.add("w-0-10");
  }
  else if (days <= 20) {
    ctr.classList.add("w-11-20");
  }
  else {
    ctr.classList.add("w-21-plus");
  }
}


document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input  = document.getElementById("daysInput");

  function syncSliderAndInput(value) {
    // –æ–≥—Ä–∞–Ω–∏—á–∞–≤–∞–º–µ 3‚Äì31
    const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
    slider.value = v;
    input.value  = v;

    // 1) —Å–∫—Ä–∏–≤–∞–º–µ/–ø–æ–∫–∞–∑–≤–∞–º–µ —Ä–µ–¥–æ–≤–µ
    updateTableRows(v);
    // 2) –ø—Ä–µ–∏–∑—á–µ—Ä—Ç–∞–≤–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ
    renderIDsChart();
    renderCOBChart();
    renderCPUChart();
    // 3) –Ω–∞—Å—Ç—Ä–æ–π–≤–∞–º–µ —à–∏—Ä–∏–Ω–∞—Ç–∞
    updateContainerWidth(v);
  }

  // —Å–ª—É—à–∞–º–µ –ø—Ä–æ–º–µ–Ω–∏ –∏ –æ—Ç –¥–≤–∞—Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∞
  slider.addEventListener("input", () => syncSliderAndInput(slider.value));
  input .addEventListener("input", () => syncSliderAndInput(input.value ));

  // –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ ‚Äì 10 –¥–Ω–∏
  syncSliderAndInput(10);
});




// 1) –í–∑–∏–º–∞–º–µ —Å–∞–º–æ –≤–∏–¥–∏–º–∏—Ç–µ (–Ω–µ—Å–∫—Ä–∏—Ç–∏) –¥–∞–Ω–Ω–∏ –æ—Ç —Ç–∞–±–ª—Ü–∞—Ç–∞
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 header-—Ä–µ–¥–∞ –∏ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ —Å–∞–º–æ –Ω–µ—Å–∫—Ä–∏—Ç–∏—Ç–µ
  const rows = Array.from(table.getElementsByTagName('tr'))
                    .slice(2)
                    .filter(row => !row.hidden);

  const labels = [];
  const values = [];

  for (const row of rows) {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) continue;
    const date = cells[0].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return { labels, values };
}

// 2) –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ (–∏–ª–∏ –ø—Ä–µ-—Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ) COB-–≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const ctx = document.getElementById('cobChart').getContext('2d');
  // –∞–∫–æ –≤–µ—á–µ –∏–º–∞–º–µ Chart, –ø—ä—Ä–≤–æ –≥–æ —É–Ω–∏—â–æ–∂–∞–≤–∞–º–µ
  if (window._cobChart) window._cobChart.destroy();

  window._cobChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154, 208, 245, 1)',
          borderColor: 'rgba(154, 208, 245, 1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: v => formatSecondsToHMS(v)
          }
        }
      },
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        }
      },
      layout: {
        padding: { top: 10, right: 20 }
      }
    }
  });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const visibleRows = rows.filter(row => !row.hidden); // —Å–∞–º–æ –≤–∏–¥–∏–º–∏—Ç–µ —Ä–µ–¥–æ–≤–µ

    const labels = [];
    const recordsPerMinute = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsedTime > 0 && !isNaN(transactions)) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels, recordsPerMinute };
}




function renderIDChart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: { size: 13, weight: 'bold' },
                        color: '#444'
                    }
                },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}





function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ –∑–∞–≥–ª–∞–≤–∫–∞—Ç–∞
    const visibleRows = rows.filter(row => !row.hidden); // –í–ó–ò–ú–ê–® –°–ê–ú–û –í–ò–î–ò–ú–ò–¢–ï —Ä–µ–¥–æ–≤–µ

    const labels = [];
    const values = [];

    for (const row of visibleRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);

            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // –∫–∞–∫—Ç–æ –≥–æ—Ä–µ
    });
}



let cobChartInstance = null;

function renderCOBChart() {
    if (cobChartInstance) {
        cobChartInstance.destroy();
    }

    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    cobChartInstance = new Chart(ctx, {
        // –∫–∞–∫—Ç–æ –≥–æ—Ä–µ
    });
}


function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const slider = document.getElementById('daysRange');
    const maxDays = parseInt(slider.value, 10) || 10;

    const labels = [];
    const values = [];

    const dataRows = Array.from(rows).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏–µ—Ç–æ
    const selectedRows = dataRows.slice(-maxDays); // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ä–µ–¥–∞

    for (const row of selectedRows) {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return { labels, values };
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    if (!table) return { labels: [], values: [] };

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const totalRows = rows.length;

    const visibleRows = rows.slice(-days); // –ü–æ—Å–ª–µ–¥–Ω–∏—Ç–µ "days" —Ä–µ–¥–∞
    const labels = [];
    const values = [];

    visibleRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 2) {
            labels.push(cells[0].innerText.trim());        // –î–∞—Ç–∞
            values.push(parseElapsedTime(cells[1].innerText.trim())); // –í—Ä–µ–º–µ –≤ —Å–µ–∫—É–Ω–¥–∏
        }
    });

    return { labels, values };
}




function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable(); // –í–∑–∏–º–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –æ—Ç —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
    const trend = calculateTrendline(values);         // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ —Ç—Ä–µ–Ω–¥ –ª–∏–Ω–∏—è—Ç–∞
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy(); // —É–Ω–∏—â–æ–∂–∞–≤–∞–º–µ —Å—Ç–∞—Ä–∞—Ç–∞ –≥—Ä–∞—Ñ–∏–∫–∞ –∞–∫–æ –∏–º–∞
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: (value) => formatSecondsToHMS(value),
                        font: { size: 13 },
                        color: '#333'
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)',
                        font: { size: 13 },
                        color: '#333'
                    }
                },
                x: {
                    ticks: {
                        font: { size: 13 },
                        color: '#333'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}



if (window.id8Chart) window.id8Chart.destroy();





function renderCOBChart() {
    const { labels, values } = getCOBDataFromTable();
    const trend = calculateTrendline(values);
    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);

    if (window.cobChart) {
        window.cobChart.destroy();
    }

    window.cobChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    clip: false,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'COB Elapsed Time + Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    },
                    title: {
                        display: true,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            }
        }
    });
}




function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let values = [];

    const selectedRows = rows.slice(-maxDays);

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    });

    return { labels, values };
}




function renderID8Chart() {
    const { labels, recordsPerMinute } = getRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (window.id8Chart) {
        window.id8Chart.destroy();
    }

    window.id8Chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    font: { size: 13, weight: 'bold' },
                    color: '#222'
                }
            },
            animation: {
                duration: 1500,
                easing: 'easeOutBounce'
            }
        }
    });
}




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    const selectedRows = rows.slice(-maxDays); // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N —Ä–µ–¥–∞

    selectedRows.forEach(row => {
        const cells = row.getElementsByTagName('td');
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    });

    return { labels, recordsPerMinute };
}




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // –ü—Ä–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    syncSliderAndInput(10);
});



<script>
document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');

    function syncSliderAndInput(value) {
        const v = Math.max(3, Math.min(31, parseInt(value, 10) || 10));
        slider.value = v;
        input.value = v;
        updateTableRows(v);
        renderID8Chart();
        renderCOBChart();
        renderCPUChart();
    }

    slider.addEventListener('input', () => syncSliderAndInput(slider.value));
    input.addEventListener('input', () => syncSliderAndInput(input.value));

    // –ü—Ä–∏ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    syncSliderAndInput(10);
});

function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);

            if (elapsed > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    return { labels, recordsPerMinute };
}

function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const values = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 3) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (elapsed > 0) {
                labels.push(date);
                values.push(elapsed);
            }
        }
    }

    return { labels, values };
}

function getCPUData() {
    const table = document.getElementById('cpuTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    const labels = [];
    const userUsage = [];
    const systemUsage = [];
    const idleUsage = [];

    for (let i = Math.max(rows.length - maxDays, 0); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 4) {
            labels.push(cells[0].innerText.trim());
            userUsage.push(parseFloat(cells[1].innerText));
            systemUsage.push(parseFloat(cells[2].innerText));
            idleUsage.push(parseFloat(cells[3].innerText));
        }
    }

    return { labels, userUsage, systemUsage, idleUsage };
}
</script>




function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let recordsPerMinute = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length === 5) {
            const date = cells[0].innerText;
            const elapsedTime = parseTimeToMinutes(cells[3].innerText);
            const transactions = parseInt(cells[4].innerText, 10);

            if (elapsedTime > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return [labels, recordsPerMinute];
}



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).filter(row => !row.hidden);

    let labels = [];
    let values = [];

    for (let i = 2; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length >= 4) {
            const date = cells[0].innerText;
            const elapsedStr = cells[3].innerText.trim();
            const elapsedSec = parseElapsedToSeconds(elapsedStr);
            if (!isNaN(elapsedSec)) {
                labels.push(date);
                values.push(elapsedSec);
            }
        }
    }

    return [labels, values];
}




document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function updateAllViews(days) {
        updateTableRows(days);
        renderIDChart();
        renderCOBChart();
    }

    // –°—Ç–∞—Ä—Ç–æ–≤–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ - 10 –¥–Ω–∏
    slider.value = 10;
    input.value = 10;
    updateAllViews(10);

    // –ü—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞
    slider.addEventListener("input", () => {
        const v = parseInt(slider.value, 10);
        input.value = v;
        updateAllViews(v);
    });

    // –ü—Ä–∏ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –∏–Ω–ø—É—Ç
    input.addEventListener("input", () => {
        let v = parseInt(input.value, 10);
        if (isNaN(v)) v = 10;
        if (v < 3) v = 3;
        if (v > 31) v = 31;
        input.value = v;
        slider.value = v;
        updateAllViews(v);
    });
});




function getRecordsData() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[4].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}

function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

  let labels = [];
  let values = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName('td');
    if (cells.length !== 5) continue;

    const date = cells[0].innerText.trim();
    const elapsedDesc = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedDesc);

    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  }

  return {
    labels: labels.reverse(),
    values: values.reverse()
  };
}


<script>
// helper –∑–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞ —Å default 10, min 3, max 31
function getDays() {
  const v = parseInt(document.getElementById('daysRange').value, 10);
  if (isNaN(v) || v < 3) return 3;
  if (v > 31) return 31;
  return v;
}

// --------- –∑–∞ Records per Minute –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ ---------
function getRecordsData() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // skip –∑–∞–≥–ª–∞–≤–∏—è
  const labels = [];
  const recordsPerMinute = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length === 5) {
      const date = cells[0].innerText.trim();
      const elapsed = parseTimeToMinutes(cells[3].innerText.trim());
      const tx = parseInt(cells[4].innerText.trim(), 10);
      if (elapsed > 0) {
        labels.push(date);
        recordsPerMinute.push(tx / elapsed);
      }
    }
  });

  // slice –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –µ–ª–µ–º–µ–Ω—Ç–∞
  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    recordsPerMinute: recordsPerMinute.slice(start)
  };
}

function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        /* –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —Ç–≤–æ–π –≤–∫—É—Å */
      }]
    },
    options: {
      // ...
    }
  });
}

// --------- –∑–∞ COB elapsed –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ ---------
function getCOBDataFromTable() {
  const days = getDays();
  const table = document.getElementById('recordsTable');
  const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // skip –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
  const labels = [];
  const values = [];

  rows.forEach(tr => {
    const cells = tr.getElementsByTagName('td');
    if (cells.length >= 4) {
      const date = cells[0].innerText.trim();
      const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());
      if (!isNaN(elapsedSec)) {
        labels.push(date);
        values.push(elapsedSec);
      }
    }
  });

  const total = labels.length;
  const start = Math.max(0, total - days);
  return {
    labels: labels.slice(start),
    values: values.slice(start)
  };
}

function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);
  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);
  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'COB Elapsed', data: values /* ... */ },
        { label: 'Trend Line', data: trend, type: 'line' /* ... */ }
      ]
    },
    options: {
      // ...
    }
  });
}

// –ø—Ä–∏ –≤—Å—è–∫–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å–ª–∞–π–¥—ä—Ä–∞
document.getElementById('daysRange').addEventListener('input', () => {
  document.getElementById('daysInput').value = getDays();
  updateTableRows(getDays());
  renderIDsChart();
  renderCOBChart();
  // ... –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ –∏ –¥—Ä—É–≥–∏—Ç–µ –≥—Ä–∞—Ñ–∏–∫–∏
});

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ
window.addEventListener('DOMContentLoaded', () => {
  const def = 10;
  document.getElementById('daysRange').value = def;
  document.getElementById('daysInput').value = def;
  updateTableRows(def);
  renderIDsChart();
  renderCOBChart();
  // ...
});
</script>





<script>
  // helper-–∏, –∞–∫–æ –≤–µ—á–µ –Ω—è–º–∞—à —Ç–∞–∫–∏–≤–∞:
  function getAllRows() {
    return Array.from(document
      .getElementById("recordsTable")
      .getElementsByTagName("tr"));
  }

  function getDataRows() {
    // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 (header-–∏)
    return getAllRows().slice(2);
  }

  // –¢–æ—á–Ω–æ —Ç–≤–æ–µ—Ç–æ –ø–æ—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ —Ä–µ–¥–æ–≤–µ—Ç–µ
  function updateTableRows(days) {
    const minRows = 3;
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const total = dataRows.length;

    // –±—Ä–æ–π, –∫–æ–π—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –ø–æ–∫–∞–∑–≤–∞–º–µ
    const count = Math.max(minRows, Math.min(days, total));
    // –∏–Ω–¥–µ–∫—Å –≤ dataRows, –æ—Ç –∫–æ–π—Ç–æ –∑–∞–ø–æ—á–≤–∞–º–µ –¥–∞ –ø–æ–∫–∞–∑–≤–∞–º–µ
    const firstToShow = total - count;

    // –≤–∏–Ω–∞–≥–∏ –ø–æ–∫–∞–∑–≤–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ 2 —Ä–µ–¥–∞
    allRows[0].hidden = false;
    allRows[1].hidden = false;

    dataRows.forEach((tr, i) => {
      tr.hidden = i < firstToShow;
    });
  }

  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è slider ‚Üî input –∏ initial load
  document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const input  = document.getElementById("daysInput");

    // –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 10 –¥–Ω–∏
    slider.value = 10;
    input.value  = 10;
    updateTableRows(10);

    // –∫–æ–≥–∞—Ç–æ –º—ä—Ä–¥–∞–º–µ —Å–ª–∞–π–¥–µ—Ä–∞
    slider.addEventListener("input", () => {
      const v = parseInt(slider.value, 10);
      input.value = v;
      updateTableRows(v);

      // –∞–∫–æ –∏—Å–∫–∞—à –¥–∞ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞—à –∏ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ:
      renderIDsChart();
      renderCOBChart();
    });

    // –∫–æ–≥–∞—Ç–æ –ø—Ä–æ–º–µ–Ω–∏–º —Ä—ä—á–Ω–æ –≤ –ø–æ–ª–µ—Ç–æ
    input.addEventListener("input", () => {
      let v = parseInt(input.value, 10);
      if (isNaN(v) || v < 3)  v = 3;
      if (v > 31)             v = 31;
      input.value  = v;
      slider.value = v;
      updateTableRows(v);

      renderIDsChart();
      renderCOBChart();
    });
  });
</script>




document.addEventListener('DOMContentLoaded', () => {
    const slider = document.getElementById("daysRange");
    const input = document.getElementById("daysInput");

    function syncDaysFromSlider() {
        input.value = slider.value;

        updateContainerWidth(slider.value);
        updateTableRows(slider.value);
    }

    // –°–ª–∞–≥–∞–º–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ 10
    slider.value = 10;
    input.value = 10;
    updateTableRows(10);

    // –í—Ä—ä–∑–∫–∞ –º–µ–∂–¥—É —Å–ª–∞–π–¥–µ—Ä–∞ –∏ –∏–Ω–ø—É—Ç–∞
    slider.addEventListener('input', syncDaysFromSlider);
    input.addEventListener('input', () => {
        let value = parseInt(input.value, 10);
        if (isNaN(value) || value < 3) value = 3;
        if (value > 31) value = 31;
        slider.value = value;
        syncDaysFromSlider();
    });
});

function updateTableRows(days) {
    const allRows = getAllRows();   // –§—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ –≤—Å–∏—á–∫–∏ <tr>
    const dataRows = getDataRows(); // –§—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ —Å–∞–º–æ –≤–∞–ª–∏–¥–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ (–±–µ–∑ —Ö–µ–¥—ä—Ä–∞)
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, n - visibleCount);

    allRows.forEach((tr, i) => {
        if (i < 2) {
            tr.hidden = false; // –ü–æ–∫–∞–∑–≤–∞ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
        } else {
            tr.hidden = (i - 2) < start ? false : true;
        }
    });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows);
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');
  
  if (slider) slider.value = 10;
  if (input) input.value = 10;

  updateTableRows(10);
});




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const totalRows = rows.length;
  const visibleCount = Math.min(Math.max(days, 3), totalRows); // –ù–ï –ø–æ–≤–µ—á–µ –æ—Ç —Ä–µ–¥–æ–≤–µ—Ç–µ
  const start = totalRows - visibleCount;

  rows.forEach((tr, index) => {
    tr.hidden = index < start ? false : true;
  });
}




function updateTableRows(days) {
  const table = document.getElementById('recordsTable');
  if (!table) return;
  const rows = Array.from(table.getElementsByTagName('tr')).slice(2); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  const input = document.getElementById('daysInput');

  function syncDaysFromSlider() {
    input.value = slider.value;
    updateTableRows(parseInt(slider.value, 10) || 10);
    renderIDChart();
    renderCOBChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
  }

  // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø–æ–∫–∞–∑–≤–∞–º–µ 10 –¥–Ω–∏
  updateTableRows(10);

  // –ó–∞–∫–∞—á–∞–º–µ —Å–ª—É—à–∞—Ç–µ–ª–∏ –∑–∞ –ø—Ä–æ–º—è–Ω–∞
  slider.addEventListener('input', syncDaysFromSlider);
  input.addEventListener('input', syncDaysFromInput);
});






function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞
  const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 –¥–µ–Ω–∞
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    tr.hidden = i < start ? false : true;
  });
}

// –ü—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('daysRange');
  if (slider) {
    updateTableRows(parseInt(slider.value, 10) || 10);
    
    slider.addEventListener('input', () => {
      const days = parseInt(slider.value, 10) || 10;
      updateTableRows(days);
    });
  }
});




function updateTableRows(days) {
  const rows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ header-–∏—Ç–µ
  const visibleCount = Math.max(days, 3); // –º–∏–Ω–∏–º—É–º 3 –¥–µ–Ω–∞ –≤–∏–¥–∏–º–∏
  const start = Math.max(0, rows.length - visibleCount);

  rows.forEach((tr, i) => {
    if (i >= start) {
      tr.hidden = false;
    } else {
      tr.hidden = true;
    }
  });
}


const slider = document.getElementById('daysRange');
slider.addEventListener('input', () => {
  const days = parseInt(slider.value, 10) || 10;
  updateTableRows(days);
});





// helper –∑–∞ –¥–∞ –≤–∑–µ–º–µ–º —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Å–ª–∞–π–¥–µ—Ä–∞ (–∏ –¥–∞ –∏–º–∞–º–µ –≤–∏–Ω–∞–≥–∏ –ø–æ–Ω–µ 10)
function getMaxDays() {
  return Math.max(10, parseInt(document.getElementById('daysRange').value, 10) || 10);
}

// 1) –∞–¥–∞–ø—Ç–∏—Ä–∞–Ω–∞ getRecordsData(), –≤—Ä—ä—â–∞ —Å–∞–º–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
function getRecordsData() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ –¥–≤–∞ <tr> (header-–∏—Ç–µ)
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(2);
  const maxDays = getMaxDays();

  const labels = [];
  const recordsPerMinute = [];

  // –≤–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ maxDays —Ä–µ–¥–∞ (–æ–±—Ä–∞—Ç–µ–Ω —Ä–µ–¥ –∑–∞ —É–¥–æ–±–Ω–æ –ø–æ–ø—ä–ª–≤–∞–Ω–µ)
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 5) return;
    const date = cells[0].innerText.trim();
    const elapsed = parseTimeToMinutes(cells[3].innerText);
    const tx = parseInt(cells[4].innerText, 10);
    if (elapsed > 0) {
      labels.push(date);
      recordsPerMinute.push(tx / elapsed);
    }
  });

  return { labels, recordsPerMinute };
}

// 2) –∞–¥–∞–ø—Ç–∏—Ä–∞–Ω–∞ getCOBDataFromTable(), –≤—Ä—ä—â–∞ —Å–∞–º–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
function getCOBDataFromTable() {
  const table = document.getElementById('recordsTable');
  // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ —Å–∞–º–æ –∑–∞–≥–ª–∞–≤–Ω–∏—è <tr>
  const allRows = Array.from(table.getElementsByTagName('tr')).slice(1);
  const maxDays = getMaxDays();

  const labels = [];
  const values = [];

  // –≤–∑–∏–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ maxDays —Ä–µ–¥–∞
  const rows = allRows.slice(-maxDays).reverse();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (cells.length < 4) return;
    const date = cells[0].innerText.trim();
    const elapsedStr = cells[3].innerText.trim();
    const elapsedSec = parseElapsedToSeconds(elapsedStr);
    if (!isNaN(elapsedSec)) {
      labels.push(date);
      values.push(elapsedSec);
    }
  });

  return { labels, values };
}


// 3) renderIDsChart() ‚Äì –≤–µ—á–µ –ø–æ–ª–∑–≤–∞ dynamic getRecordsData()
let recordsChartInstance = null;
function renderIDsChart() {
  const { labels, recordsPerMinute } = getRecordsData();
  const ctx = document.getElementById('recordsChart').getContext('2d');
  if (recordsChartInstance) recordsChartInstance.destroy();
  recordsChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Records Per Minute',
        data: recordsPerMinute,
        backgroundColor: ['rgba(255,99,132,0.6)', /* ‚Ä¶ */],
        borderColor:     ['rgba(255,99,132,1)',   /* ‚Ä¶ */],
        borderWidth: 2,
        borderRadius: 15,
        hoverBorderWidth: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { stacked: true, ticks: { font: { size: 13 }, color: '#333' } },
        y: { stacked: true, beginAtZero: true, ticks: { font: { size: 13 }, color: '#333' } }
      },
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: 'Records Processed per minute',
          font: { size: 13, weight: 'bold' },
          color: getTextColor()
        }
      },
      animation: { duration: 1500, easing: 'easeOutBounce' }
    }
  });
}

// 4) renderCOBChart() ‚Äì –≤–µ—á–µ –ø–æ–ª–∑–≤–∞ dynamic getCOBDataFromTable()
let cobChartInstance = null;
function renderCOBChart() {
  const { labels, values } = getCOBDataFromTable();
  const trend = calculateTrendLine(values);

  const canvas = document.getElementById('cobChart');
  const ctx = setupCanvas(canvas, 500, 500);

  if (cobChartInstance) cobChartInstance.destroy();
  cobChartInstance = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'COB Elapsed',
          data: values,
          backgroundColor: 'rgba(154,208,245,1)',
          borderColor:     'rgba(154,208,245,1)',
          borderWidth: 1,
          order: 1,
          clip: false
        },
        {
          label: 'Trend Line',
          data: trend,
          type: 'line',
          borderColor: 'red',
          borderDash: [5,5],
          borderWidth: 2,
          fill: false,
          pointRadius: 0,
          tension: 0,
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: {
          display: true,
          text: 'COB Elapsed Time & Trend',
          color: getTextColor(),
          font: { size: 13, weight: 'bold' }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatSecondsToHMS(v) }
        }
      },
      layout: { padding: { top: 10, right: 20 } },
      plugins: [{
        id: 'barLabelsOnly',
        afterDatasetsDraw(chart) {
          const ctx2 = chart.ctx;
          const meta = chart.getDatasetMeta(0);
          const dark = document.body.classList.contains('dark-mode');
          meta.data.forEach((bar, i) => {
            const val = chart.data.datasets[0].data[i];
            const label = formatSecondsToHMS(val);
            const barHeight = bar.base - bar.y;
            ctx2.save();
            ctx2.font = `bold ${barHeight > 30 ? 12 : 10}px sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'bottom';
            ctx2.fillStyle = dark ? '#fff' : '#000';
            ctx2.fillText(label, bar.x, bar.y - 6);
            ctx2.restore();
          });
        }
      }]
    }
  });
}


// 5) –±–∏–Ω–¥–∏—Ä–∞–º–µ –∫—ä–º slider-–∞ –¥–∞ —Ä–µ-—Ä–∏—Å—É–≤–∞ –∏ –¥–≤–µ—Ç–µ
document.getElementById('daysRange').addEventListener('input', () => {
  renderElapsedChart();
  renderTimingChart();
  renderIDsChart();
  renderCOBChart();
  renderCPUChart();
});

// –≥–æ—Ç–æ–≤–æ ‚Äî —Å–∞–º–æ —Ç–µ–∑–∏ 5 –±–ª–æ–∫–∞ –¥–æ–±–∞–≤—è—à/–∑–∞–º–µ—Å—Ç–≤–∞—à, –æ—Å—Ç–∞–Ω–∞–ª–æ—Ç–æ –Ω–µ —Å–µ –ø—Ä–æ–º–µ–Ω—è. 





function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ:
syncDaysFromSlider();




let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}





function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




function syncDaysFromSlider() {
    const value = slider.value;
    updateTableRows(value);
    renderIDChart();
    renderCOBChart();
}

function syncDaysFromInput() {
    let value = parseInt(input.value, 10);
    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;
    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
}

slider.addEventListener('input', syncDaysFromSlider);
input.addEventListener('input', syncDaysFromInput);

// –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ:
syncDaysFromSlider();



let idChartInstance = null;
let cobChartInstance = null;

function renderIDChart() {
    const { labels, recordsPerMinute } = getFilteredRecordsData();
    const ctx = document.getElementById('recordsChart').getContext('2d');

    if (idChartInstance) idChartInstance.destroy();

    idChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Records Processed per Minute',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: { font: { size: 13 }, color: '#333' }
                }
            },
            animation: { duration: 1500, easing: 'easeOutBounce' }
        }
    });
}

function renderCOBChart() {
    const { labels, elapsedValues } = getFilteredCOBData();
    const trend = calculateTrendline(elapsedValues);
    const ctx = document.getElementById('cobChart').getContext('2d');

    if (cobChartInstance) cobChartInstance.destroy();

    cobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: elapsedValues,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                    clip: false
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: true },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: { size: 13, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: { padding: { top: 10, right: 20 } }
        }
    });
}


function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥

    const visibleCount = Math.max(days, 3);
    const start = Math.max(dataRows.length - visibleCount, 0);

    dataRows.forEach((tr, i) => {
        tr.hidden = (i < start);
    });
}

function getFilteredRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsedTime = parseTimeToMinutes(cells[3].innerText.trim());
            const transactions = parseInt(cells[4].innerText.trim(), 10);
            if (elapsedTime) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsedTime);
            }
        }
    }

    return { labels: labels.reverse(), recordsPerMinute: recordsPerMinute.reverse() };
}

function getFilteredCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(1); // –±–µ–∑ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;

    let labels = [];
    let elapsedValues = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 5) {
            const date = cells[0].innerText.trim();
            const elapsed = parseElapsedToSeconds(cells[3].innerText.trim());
            if (!isNaN(elapsed)) {
                labels.push(date);
                elapsedValues.push(elapsed);
            }
        }
    }

    return { labels: labels.reverse(), elapsedValues: elapsedValues.reverse() };
}




<script>
// –û–±–Ω–æ–≤—è–≤–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ —Å –Ω–æ–≤–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ header —Ä–µ–¥–æ–≤–µ—Ç–µ
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ —Å–ª–∞–π–¥–µ—Ä–∞ -> input –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ input -> —Å–ª–∞–π–¥–µ—Ä–∞ –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –ó–∞–∫–∞—á–∞–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});
</script>



// –û–±–Ω–æ–≤—è–≤–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ —Å –Ω–æ–≤–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr')).slice(2); // –ø—Ä–æ–ø—É—Å–Ω–∏ header —Ä–µ–¥–æ–≤–µ—Ç–µ
    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, allRows.length - visibleCount);

    allRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ —Å–ª–∞–π–¥–µ—Ä–∞ -> input –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–∞ input -> —Å–ª–∞–π–¥–µ—Ä–∞ –∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∏
function syncDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderCOBChart(); // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    renderIDChart();  // —Ç–≤–æ—è—Ç–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
}

// –ó–∞–∫–∞—á–∞–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncDaysFromInput);

// –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
document.addEventListener('DOMContentLoaded', () => {
    syncDaysFromSlider();
});





// –í–∑–∏–º–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ —Ä–µ–¥–æ–≤–µ –æ—Ç —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
function getNewAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

// –û–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –≤–∏–¥–∏–º–∏—Ç–µ —Ä–µ–¥–æ–≤–µ —Å–ø–æ—Ä–µ–¥ –∏–∑–±—Ä–∞–Ω–∏—Ç–µ –¥–Ω–∏
function updateNewTableRows(days) {
    const allRows = getNewAllRows();
    const dataRows = allRows.slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ

    const visibleCount = Math.max(days, 3);
    const start = Math.max(0, dataRows.length - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = !(i >= start);
    });
}

// –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏ –∑–∞ COB –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function getNewCOBData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const values = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsed = cells[3].innerText.trim();

        if (date && elapsed) {
            labels.push(date);
            values.push(parseElapsedToSeconds(elapsed));
        }
    }

    return {
        labels: labels.reverse(),
        values: values.reverse()
    };
}

// –ò–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏ –∑–∞ ID –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞
function getNewIDData() {
    const table = document.getElementById('recordsTable');
    const rows = Array.from(table.getElementsByTagName('tr')).slice(2);

    const maxDays = parseInt(document.getElementById('daysRange').value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 8) continue;

        const date = cells[0].innerText.trim();
        const elapsedStr = cells[3].innerText.trim();
        const recordsStr = cells[4].innerText.trim();

        if (date && elapsedStr && recordsStr) {
            const elapsedMinutes = parseElapsedToSeconds(elapsedStr) / 60;
            const records = parseInt(recordsStr, 10);

            if (elapsedMinutes > 0 && !isNaN(records)) {
                labels.push(date);
                recordsPerMinute.push(records / elapsedMinutes);
            }
        }
    }

    return {
        labels: labels.reverse(),
        recordsPerMinute: recordsPerMinute.reverse()
    };
}

// –ü–æ–º–æ—â–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –ø–∞—Ä—Å–≤–∞–Ω–µ –Ω–∞ –≤—Ä–µ–º–µ
function parseElapsedToSeconds(timeStr) {
    const parts = timeStr.split(':');
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 3600 + minutes * 60 + seconds;
}

// –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–æ–≤–∞—Ç–∞ COB –≥—Ä–∞—Ñ–∏–∫–∞
let newCobChartInstance = null;

function renderNewCobChart() {
    const { labels, values } = getNewCOBData();

    const canvas = document.getElementById('cobChart');
    const ctx = canvas.getContext('2d');

    if (newCobChartInstance) {
        newCobChartInstance.destroy();
    }

    newCobChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'COB Elapsed',
                data: values,
                backgroundColor: 'rgba(154, 208, 245, 1)',
                borderColor: 'rgba(154, 208, 245, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'COB Elapsed Time',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: value => formatSecondsToHMS(value)
                    }
                }
            }
        }
    });
}

// –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–æ–≤–∞—Ç–∞ ID –≥—Ä–∞—Ñ–∏–∫–∞
let newIdChartInstance = null;

function renderNewIdChart() {
    const { labels, recordsPerMinute } = getNewIDData();

    const canvas = document.getElementById('recordChart');
    const ctx = canvas.getContext('2d');

    if (newIdChartInstance) {
        newIdChartInstance.destroy();
    }

    newIdChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records per Minute',
                data: recordsPerMinute,
                backgroundColor: 'rgba(54, 162, 235, 1)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Records per Minute',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–µ–∫—É–Ω–¥–∏ –∫—ä–º HH:MM:SS
function formatSecondsToHMS(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–ª–∞–π–¥–µ—Ä–∞
function syncNewDaysFromSlider() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    const value = parseInt(slider.value, 10);

    input.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// –§—É–Ω–∫—Ü–∏—è –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç input box
function syncNewDaysFromInput() {
    const slider = document.getElementById('daysRange');
    const input = document.getElementById('daysInput');
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    updateNewTableRows(value);
    renderNewCobChart();
    renderNewIdChart();
}

// –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏
document.getElementById('daysRange').addEventListener('input', syncNewDaysFromSlider);
document.getElementById('daysInput').addEventListener('input', syncNewDaysFromInput);

// –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –ø—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ
document.addEventListener('DOMContentLoaded', () => {
    syncNewDaysFromSlider();
});



window.onload = function() {
    renderIDChart();
    renderCOBChart();
    filterRecordsTable(10);
};




const daysRange = document.getElementById('daysRange');
daysRange.addEventListener('input', () => {
    const days = parseInt(daysRange.value, 10);
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});

const daysInput = document.getElementById('daysInput');
daysInput.addEventListener('input', () => {
    let days = parseInt(daysInput.value, 10);
    if (isNaN(days) || days < 3) days = 3;
    if (days > 31) days = 31;

    daysRange.value = days;
    document.getElementById('daysInput').value = days;

    filterRecordsTable(days);
    renderIDChart();
    renderCOBChart();
});



function getCOBDataFromTable() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const values = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // –Ω–æ–≤–æ!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedSec = parseElapsedToSeconds(cells[3].innerText.trim());

        if (elapsedSec) {
            labels.push(date);
            values.push(elapsedSec);
        }
    }

    return { labels, values };
}



function getRecordsData() {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const labels = [];
    const recordsPerMinute = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].style.display === 'none') continue; // –Ω–æ–≤–æ!
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length < 5) continue;

        const date = cells[0].innerText.trim();
        const elapsedTime = parseInt(cells[3].innerText.trim(), 10);
        const transactions = parseInt(cells[4].innerText.trim(), 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return { labels, recordsPerMinute };
}


function filterRecordsTable(days) {
    const table = document.getElementById('recordsTable');
    const rows = table.getElementsByTagName('tr');
    const today = new Date();
    let count = 0;

    for (let i = 1; i < rows.length; i++) { // –ü—Ä–µ—Å–∫–∞—á–∞–º–µ –∑–∞–≥–ª–∞–≤–Ω–∏—è —Ä–µ–¥
        const cell = rows[i].getElementsByTagName('td')[0];
        if (!cell) continue;

        const dateStr = cell.innerText.trim();
        if (dateStr.length !== 8) {
            rows[i].style.display = 'none';
            continue;
        }

        const year = parseInt(dateStr.substring(0, 4), 10);
        const month = parseInt(dateStr.substring(4, 6), 10) - 1;
        const day = parseInt(dateStr.substring(6, 8), 10);

        const rowDate = new Date(year, month, day);

        const diffTime = today - rowDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        if (diffDays <= days - 1) {
            rows[i].style.display = '';
            count++;
        } else {
            rows[i].style.display = 'none';
        }
    }
}






function renderCOBChart() {
    const allLabels = getCOBDataFromTable().labels;
    const allValues = getCOBDataFromTable().values;

    const days = parseInt(document.getElementById('daysRange').value, 10) || 10;

    // –í–∑–µ–º–∞–º–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ N –¥–Ω–∏
    const labels = allLabels.slice(-days);
    const values = allValues.slice(-days);
    const trend = calculateTrendline(values);

    const canvas = document.getElementById('cobChart');
    const ctx = setupCanvas(canvas, 500, 500);
    const dark = document.body.classList.contains('dark-mode');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: 'COB Elapsed',
                    data: values,
                    backgroundColor: 'rgba(154, 208, 245, 1)',
                    borderColor: 'rgba(154, 208, 245, 1)',
                    borderWidth: 1,
                    order: 1,
                },
                {
                    label: 'Trend Line',
                    data: trend,
                    type: 'line',
                    borderColor: 'red',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    tension: 0,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: getTextColor(),
                    }
                },
                title: {
                    display: true,
                    text: 'COB Elapsed Time & Trend',
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const val = context.raw;
                            return `${context.dataset.label}: ${formatSecondsToHMS(val)}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return formatSecondsToHMS(value);
                        }
                    },
                    title: {
                        display: false,
                        text: 'Elapsed Time (HH:mm:ss)'
                    }
                }
            },
            layout: {
                padding: { top: 10, right: 20 }
            }
        }
    });
}


document.getElementById('daysRange').addEventListener('input', () => {
    renderCOBChart();
});



<script>
const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');

toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : '‚òÄÔ∏è';
    updateChartsTheme?.();
});

// --- Export CSV Logic ---
const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');
const exportAllBtn = document.getElementById('exportAllBtn');

exportCsvBtn.addEventListener('click', () => {
    csvOptions.classList.remove('hidden');
});

cancelExportBtn.addEventListener('click', () => {
    csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
    const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'));
    if (selectedTables.length === 0) return;

    selectedTables.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        let csvRows = [];
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            csvRows.push(rowData.join(','));
        });

        const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `${reportDate}_${tableId}.csv`;
        link.click();
    });

    csvOptions.classList.add('hidden');
});

// --- Export All Tables to One CSV ---
exportAllBtn.addEventListener('click', () => {
    const allCheckboxes = document.querySelectorAll('.csv-checkboxes input');
    let allCsv = [];

    allCheckboxes.forEach(cb => {
        const tableId = cb.value;
        const table = document.getElementById(tableId);
        if (!table) return;

        // –î–æ–±–∞–≤—è–º–µ –∏–º–µ –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
        allCsv.push(`=== ${tableId} ===`);

        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cols = row.querySelectorAll('td, th');
            const rowData = [];
            cols.forEach(col => {
                let text = col.innerText.replace(/\n/g, ' ').trim();
                rowData.push('"' + text.replace(/"/g, '""') + '"');
            });
            allCsv.push(rowData.join(','));
        });

        allCsv.push(''); // –ü—Ä–∞–∑–µ–Ω —Ä–µ–¥ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∏—Ç–µ
    });

    const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.href = URL.createObjectURL(blob);
    link.download = `${reportDate}_all_tables.csv`;
    link.click();

    csvOptions.classList.add('hidden');
});
</script>





<div class="csv-buttons">
  <button id="exportSelectedBtn" class="small-button">‚úÖ Export Selected</button>
  <button id="exportAllBtn" class="small-button">‚¨áÔ∏è Export All to Single CSV</button>
  <button id="cancelExportBtn" class="small-button">‚ùå Cancel</button>
</div>


const exportAllBtn = document.getElementById('exportAllBtn');

exportAllBtn.addEventListener('click', () => {
  const tables = document.querySelectorAll('.csv-checkboxes input');

  let allCsv = [];

  tables.forEach(cb => {
    const tableId = cb.value;
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
      const cols = row.querySelectorAll('td, th');
      const rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      allCsv.push(rowData.join(','));
    });
    allCsv.push(''); // –ø—Ä–∞–∑–µ–Ω —Ä–µ–¥ –º–µ–∂–¥—É —Ç–∞–±–ª–∏—Ü–∏—Ç–µ
  });

  const blob = new Blob([allCsv.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
  link.href = URL.createObjectURL(blob);
  link.download = `${reportDate}_all_tables.csv`;
  link.click();

  csvOptions.classList.add('hidden');
});




<button id="exportCsvBtn" class="tool-button">üìÑ Export to CSV</button>

<div id="csvOptions" class="csv-panel hidden">
  <div class="csv-options-title">Select tables to export:</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
  </div>
  <div class="csv-buttons">
    <button id="exportSelectedBtn" class="small-button">‚úÖ Export Selected</button>
    <button id="cancelExportBtn" class="small-button">‚ùå Cancel</button>
  </div>
</div>


.csv-panel {
  position: absolute;
  top: 110px; /* –ø–æ–¥ "Export CSV" –±—É—Ç–æ–Ω–∞ */
  left: 180px; /* –∏–∑–Ω–∞—Å—è —Å–µ –≤–¥—è—Å–Ω–æ */
  background: var(--toggle-bg-light);
  color: black;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 2px 4px 8px rgba(0,0,0,0.2);
  z-index: 9999;
  min-width: 180px;
}

body.dark-mode .csv-panel {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.csv-options-title {
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 8px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

.csv-buttons {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.small-button {
  background: var(--toggle-bg-light);
  border: none;
  border-radius: 8px;
  padding: 5px 10px;
  font-size: 13px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .small-button {
  background: var(--toggle-bg-dark);
  color: #f0f0f0;
}

.small-button:hover {
  opacity: 0.9;
}

.hidden {
  display: none;
}



.csv-options-title {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

.csv-checkboxes {
  text-align: left;
  margin-bottom: 10px;
}

#csvOptions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  padding: 10px;
  border-radius: 10px;
}

body.dark-mode #csvOptions {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}


<button id="exportCsvBtn" class="tool-button">üìÑ Export to CSV</button>

<div id="csvOptions" class="tool-button hidden">
  <div class="csv-options-title">Select tables to export</div>
  <div class="csv-checkboxes">
    <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
    <!-- –ê–∫–æ –∏—Å–∫–∞—à –º–æ–∂–µ –¥–∞ –¥–æ–±–∞–≤–∏—à –æ—â–µ —á–µ–∫–±–æ–∫—Å–æ–≤–µ -->
  </div>
  <button id="exportSelectedBtn" class="tool-button">‚úÖ Export Selected</button>
  <button id="cancelExportBtn" class="tool-button">‚ùå Cancel</button>
</div>

.hidden {
  display: none;
}

const exportCsvBtn = document.getElementById('exportCsvBtn');
const csvOptions = document.getElementById('csvOptions');
const cancelExportBtn = document.getElementById('cancelExportBtn');
const exportSelectedBtn = document.getElementById('exportSelectedBtn');

exportCsvBtn.addEventListener('click', () => {
  csvOptions.classList.toggle('hidden');
});

cancelExportBtn.addEventListener('click', () => {
  csvOptions.classList.add('hidden');
});

exportSelectedBtn.addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.csv-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  csvOptions.classList.add('hidden');
});


<button id="exportCsvBtn" class="tool-button">Export CSV</button>


document.getElementById('exportCsvBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.remove('hidden');
});

document.getElementById('cancelExportBtn').addEventListener('click', () => {
  document.getElementById('csvExportModal').classList.add('hidden');
});

document.getElementById('exportSelectedBtn').addEventListener('click', () => {
  const selectedTables = Array.from(document.querySelectorAll('.modal-checkboxes input:checked'))
    .map(cb => cb.value);

  selectedTables.forEach(tableId => {
    const table = document.getElementById(tableId);
    if (!table) return;

    let csv = [];
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      let cols = row.querySelectorAll('td, th');
      let rowData = [];
      cols.forEach(col => {
        let text = col.innerText.replace(/\n/g, ' ').trim();
        rowData.push('"' + text.replace(/"/g, '""') + '"');
      });
      csv.push(rowData.join(','));
    });

    const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const reportDate = document.getElementById('reportDate')?.textContent.trim() || 'export';
    link.download = `${reportDate}_${tableId}.csv`;
    link.click();
  });

  document.getElementById('csvExportModal').classList.add('hidden');
});


<!-- CSV Export Modal -->
<div id="csvExportModal" class="modal hidden">
  <div class="modal-content">
    <h3>Select tables to export</h3>
    <div class="modal-checkboxes">
      <label><input type="checkbox" value="recordsTable" checked> Records Table</label>
      <!-- –ê–∫–æ –∏–º–∞—à –æ—â–µ —Ç–∞–±–ª–∏—Ü–∏ –¥–æ–±–∞–≤—è—à —Ç—É–∫ -->
    </div>
    <button id="exportSelectedBtn" class="tool-button">Export Selected</button>
    <button id="cancelExportBtn" class="tool-button">Cancel</button>
  </div>
</div>




document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.innerText.trim());

    // –°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ —á–µ–∫–±–æ–∫—Å –ø—Ä–æ–∑–æ—Ä–µ—Ü
    const checkboxContainer = document.createElement("div");
    checkboxContainer.style.padding = "10px";
    checkboxContainer.style.fontSize = "14px";

    headers.forEach((header, index) => {
        const label = document.createElement("label");
        label.style.display = "block";
        label.style.marginBottom = "5px";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        checkbox.checked = true; // –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –≤—Å–∏—á–∫–∏ —Å–∞ –º–∞—Ä–∫–∏—Ä–∞–Ω–∏

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${header}`));
        checkboxContainer.appendChild(label);
    });

    const confirmButton = document.createElement("button");
    confirmButton.textContent = "Export Selected";
    confirmButton.style.marginTop = "10px";
    confirmButton.className = "tool-button";

    checkboxContainer.appendChild(confirmButton);

    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "0";
    modal.style.left = "0";
    modal.style.width = "100%";
    modal.style.height = "100%";
    modal.style.background = "rgba(0,0,0,0.6)";
    modal.style.display = "flex";
    modal.style.justifyContent = "center";
    modal.style.alignItems = "center";
    modal.appendChild(checkboxContainer);
    document.body.appendChild(modal);

    confirmButton.addEventListener("click", () => {
        const selectedIndexes = Array.from(checkboxContainer.querySelectorAll("input[type='checkbox']:checked")).map(cb => parseInt(cb.value, 10));

        if (selectedIndexes.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        let csv = [];
        const rows = table.querySelectorAll("tr");

        rows.forEach(row => {
            const cols = row.querySelectorAll("td, th");
            const selectedCols = Array.from(cols).filter((col, idx) => selectedIndexes.includes(idx));
            const rowData = selectedCols.map(col => `"${col.innerText.trim()}"`);
            csv.push(rowData.join(","));
        });

        const csvContent = csv.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.setAttribute("href", url);
        const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        link.setAttribute("download", `Export_${today}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // –ó–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –º–æ–¥–∞–ª –ø—Ä–æ–∑–æ—Ä–µ—Ü–∞
        document.body.removeChild(modal);
    });
});



document.getElementById("exportCsvButton").addEventListener("click", () => {
    const table = document.getElementById("recordsTable");
    if (!table) {
        alert("No table found to export.");
        return;
    }

    let csv = [];
    const rows = table.querySelectorAll("tr");

    rows.forEach(row => {
        const cols = row.querySelectorAll("td, th");
        const rowData = Array.from(cols).map(col => `"${col.innerText.trim()}"`);
        csv.push(rowData.join(","));
    });

    const csvContent = csv.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.setAttribute("href", url);
    const today = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    link.setAttribute("download", `Export_${today}.csv`);
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});


#exportCsvButton {
    margin-top: 10px;
    padding: 8px 15px;
    font-size: 14px;
    border-radius: 20px;
    border: none;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    background: var(--main-color);
    color: white;
}

body.dark-mode #exportCsvButton {
    background: var(--hover-color);
    color: white;
}


<button id="exportCsvButton" class="tool-button">Export CSV</button>



function getChartTextColor() {
    return document.body.classList.contains('dark-mode') ? '#f0f0f0' : '#111';
}


function updateChartsTheme() {
    if (elapsedChartInstance) {
        elapsedChartInstance.options.scales.x.ticks.color = getChartTextColor();
        elapsedChartInstance.options.scales.y.ticks.color = getChartTextColor();
        elapsedChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        elapsedChartInstance.options.plugins.title.color = getChartTextColor();
        elapsedChartInstance.update();
    }

    if (timingChartInstance) {
        timingChartInstance.options.scales.x.ticks.color = getChartTextColor();
        timingChartInstance.options.scales.y.ticks.color = getChartTextColor();
        timingChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        timingChartInstance.options.plugins.title.color = getChartTextColor();
        timingChartInstance.update();
    }

    if (recordsChartInstance) {
        recordsChartInstance.options.scales.x.ticks.color = getChartTextColor();
        recordsChartInstance.options.scales.y.ticks.color = getChartTextColor();
        recordsChartInstance.options.plugins.legend.labels.color = getChartTextColor();
        recordsChartInstance.options.plugins.title.color = getChartTextColor();
        recordsChartInstance.update();
    }
}


toggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : 'üåû';
    updateChartsTheme();
});




#daysLabel {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #111; /* –ó–∞ —Å–≤–µ—Ç—ä–ª —Ñ–æ–Ω */
}

body.dark-mode #daysLabel {
    color: #f0f0f0; /* –ó–∞ —Ç—ä–º–µ–Ω —Ñ–æ–Ω */
}

<label id="daysLabel" for="daysRange">COB Days:</label>


#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
  background-color: var(--toggle-bg-light);
  color: white;
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background 0.3s ease, color 0.3s ease;
}

body.dark-mode #daysSliderWrapper {
  background-color: var(--toggle-bg-dark);
  color: #f0f0f0;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
  text-align: center;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
  accent-color: white; /* –°–ª–∞–π–¥—ä—Ä —Ü–≤–µ—Ç—ä—Ç */
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #ffffff;
  color: #333333;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #f0f0f0;
}



<div id="daysSliderWrapper" class="tool-button">
  <div class="daysContent">
    <label for="daysRange">COB Days:</label>
    <input type="range" id="daysRange" min="3" max="31" value="10">
    <div class="daysInputWrapper">
      <input type="number" id="daysInput" min="3" max="31" value="10">
      <span>days</span>
    </div>
  </div>
</div>

#daysSliderWrapper {
  flex-direction: column;
  gap: 5px;
}

#daysSliderWrapper label {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 5px;
}

#daysSliderWrapper input[type="range"] {
  width: 100%;
  margin: 5px 0;
}

.daysInputWrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

#daysInput {
  width: 50px;
  text-align: center;
  font-size: 13px;
  border: none;
  border-radius: 5px;
  padding: 3px;
  background: #fff;
  color: #000;
}

body.dark-mode #daysInput {
  background: #1f1f1f;
  color: #e0e0e0;
}



<div id="daysSliderWrapper" class="tool-button" style="flex-direction: column; gap: 5px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


#daysSliderWrapper input[type="range"],
#daysSliderWrapper input[type="number"] {
  background: none;
  border: none;
  outline: none;
  color: inherit;
}

#daysSliderWrapper label {
  margin-bottom: 5px;
}

body.dark-mode #daysSliderWrapper input[type="number"] {
  background-color: #1f1f1f;
  color: #e0e0e0;
}

body:not(.dark-mode) #daysSliderWrapper input[type="number"] {
  background-color: #fff;
  color: #000;
}



<div id="daysSliderWrapper" style="margin-top: 10px;">
  <label for="daysRange" style="font-size: 13px; font-weight: bold;">COB Days:</label>
  
  <input type="range" id="daysRange" min="3" max="31" value="10" style="width: 100%; margin-bottom: 5px;">
  
  <div style="display: flex; align-items: center; justify-content: center; gap: 5px;">
    <input type="number" id="daysInput" min="3" max="31" value="10" style="width: 60px; font-size: 13px; text-align: center;">
    <span style="font-size: 13px;">days</span>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  const slider = document.getElementById("daysRange");
  const input = document.getElementById("daysInput");

  function syncDaysFromSlider() {
    input.value = slider.value;
    // —Ç—É–∫ –∏–∑–≤–∏–∫–≤–∞—à –∫–∞–∫–≤–æ—Ç–æ –æ—â–µ –∏—Å–∫–∞—à –∫–∞—Ç–æ update –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–∏, —Ç–∞–±–ª–∏—Ü–∏ –∏ —Ç.–Ω.
    updateContainerWidth(slider.value);
    updateTableRows(slider.value);
    renderElapsedChart();
    renderTimingChart();
    renderIDsChart();
  }

  function syncDaysFromInput() {
    let value = parseInt(input.value, 10);

    if (isNaN(value)) value = 10;
    if (value < 3) value = 3;
    if (value > 31) value = 31;

    input.value = value;
    slider.value = value;
    syncDaysFromSlider();
  }

  slider.addEventListener("input", syncDaysFromSlider);
  input.addEventListener("input", syncDaysFromInput);

  syncDaysFromSlider(); // –∑–∞ –¥–∞ —Å–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞ –ø—Ä–∞–≤–∏–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});
</script>




const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  icon.textContent = document.body.classList.contains('dark-mode') ? 'üåô' : 'üåû';
});




#darkModeToggle {
  background-color: var(--toggle-bg-light);
  display: flex;
  align-items: center;
  justify-content: start;
  padding: 0 10px;
}

body.dark-mode #darkModeToggle {
  background-color: var(--toggle-bg-dark);
}

#darkModeToggle .toggle-thumb {
  width: 32px;
  height: 32px;
  background-color: var(--thumb-bg-light);
  border-radius: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, background-color 0.4s ease;
}

body.dark-mode #darkModeToggle .toggle-thumb {
  background-color: var(--thumb-bg-dark);
  transform: translateX(60px); /* –ü—Ä–µ–º–µ—Å—Ç–≤–∞–Ω–µ –∑–∞–µ–¥–Ω–æ —Å —Ç–µ–∫—Å—Ç–∞ */
}

#darkModeToggle .icon {
  font-size: 18px;
  transition: transform 1s ease;
}

body.dark-mode #darkModeToggle .icon {
  transform: rotate(360deg);
}

#darkModeToggle .toggle-text {
  margin-left: 10px;
  font-size: 14px;
  font-weight: bold;
  transition: color 0.3s ease;
  color: #333;
}

body.dark-mode #darkModeToggle .toggle-text {
  color: #eee;
}



const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  
  if (document.body.classList.contains('dark-mode')) {
    icon.textContent = 'üåô';
    text.textContent = 'Switch Light';
  } else {
    icon.textContent = 'üåû';
    text.textContent = 'Switch Dark';
  }

  updateChartsTheme?.();
});



<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">üåû</span>
  </div>
  <span id="themeText" class="toggle-text">Switch Dark</span>
</div>




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">‚òÄÔ∏è</span>
  </div>
  <span id="themeText" style="margin-left: 8px;">Switch Dark</span>
</div>

const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? 'üåô' : '‚òÄÔ∏è';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




<div id="darkModeToggle" class="tool-button" title="Switch Dark Mode">
  <div class="toggle-thumb">
    <span class="icon" id="themeIcon">‚òÄÔ∏è</span>
    <span id="themeText" style="margin-left: 5px;">Switch Dark</span>
  </div>
</div>


const toggleBtn = document.getElementById('darkModeToggle');
const icon = document.getElementById('themeIcon');
const text = document.getElementById('themeText');

toggleBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const dark = document.body.classList.contains('dark-mode');
  icon.textContent = dark ? 'üåô' : '‚òÄÔ∏è';
  text.textContent = dark ? 'Switch Light' : 'Switch Dark';
  updateChartsTheme?.();
});




function updateTableRows(days) {
  const allRows = getAllRows();    // –≤—Å–∏—á–∫–∏ <tr>
  const dataRows = getDataRows();  // —Å–∞–º–æ <tr> –∑–∞ –¥–∞–Ω–Ω–∏
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –ø–æ–∫–∞–∑–≤–∞–º–µ –≤–∏–Ω–∞–≥–∏ header-–∏—Ç–µ
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}





function updateTableRows(days) {
  const allRows = getAllRows(); // –≤—Å–∏—á–∫–∏ tr (–≤–∫–ª. th + tr)
  const dataRows = getDataRows(); // —Å–∞–º–æ –¥–∞–Ω–Ω–∏—Ç–µ
  const n = dataRows.length;

  const visibleCount = Math.max(days, 3);
  const start = Math.max(0, n - visibleCount);

  allRows.forEach((tr, i) => {
    if (i < 2) {
      tr.hidden = false; // –ø—ä—Ä–≤–∏—Ç–µ –¥–≤–∞ (header) –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    } else {
      tr.hidden = (i - 2) < start;
    }
  });
}



function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}


function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = Array.from(table.getElementsByTagName("tr")).slice(2);

  const maxDays = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText.trim();
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10);
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t;
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return {
    dates: dates.reverse(),
    ilc03time: ilc03time.reverse(),
    cobStart: cobStart.reverse(),
    cobStop: cobStop.reverse(),
    rrStart: rrStart.reverse(),
    rrStop: rrStop.reverse(),
    a77time: a77time.reverse()
  };
}



function getRecordsData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const days = parseInt(document.getElementById("daysRange").value, 12) || 10;
  const labels = [];
  const recordsPerMinute = [];

  for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const elapsedTime = parseTimeToMinutes(cells[3].innerText);
    const transactions = parseInt(cells[5].innerText, 10);

    if (elapsedTime > 0) {
      labels.push(date);
      recordsPerMinute.push(transactions / elapsedTime);
    }
  }

  return {
    labels: labels.reverse(),
    recordsPerMinute: recordsPerMinute.reverse()
  };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}




function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const labels = [];
    const recordsPerMinute = [];

    for (let i = rows.length - 1; i >= 0 && labels.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const elapsedStr = cells[3].innerText.trim();
            const transactionsStr = cells[4].innerText.trim();

            const elapsed = parseElapsedToMinutes(elapsedStr);
            const transactions = parseInt(transactionsStr, 10);

            if (date && elapsed > 0 && transactions > 0) {
                labels.push(date);
                recordsPerMinute.push(transactions / elapsed);
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    labels.reverse();
    recordsPerMinute.reverse();

    return { labels, recordsPerMinute };
}



function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    // –û–±—Ä—ä—â–∞–º–µ —Ä–µ–¥–∞ –Ω–∞ –º–∞—Å–∏–≤–∏—Ç–µ
    dates.reverse();
    ilc03Time.reverse();
    cobStart.reverse();
    cobStop.reverse();
    rrStart.reverse();
    rrStop.reverse();
    a770Time.reverse();

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}





function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(2);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10) || 10;

    const dates = [];
    const ilc03Time = [];
    const cobStart = [];
    const cobStop = [];
    const rrStart = [];
    const rrStop = [];
    const a770Time = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length >= 10) {
            const date = cells[0].innerText.trim();
            const ilc03 = cells[1].innerText.trim();
            const cobS = cells[2].innerText.trim();
            const cobE = cells[3].innerText.trim();
            const rrS = cells[6].innerText.trim();
            const rrE = cells[7].innerText.trim();
            const a770 = cells[9].innerText.trim();
            if (date && ilc03 && cobS && cobE && rrS && rrE && a770) {
                dates.push(date);
                ilc03Time.push(adjustTime(ilc03));
                cobStart.push(adjustTime(cobS));
                cobStop.push(adjustTime(cobE));
                rrStart.push(adjustTime(rrS));
                rrStop.push(adjustTime(rrE));
                a770Time.push(adjustTime(a770));
            }
        }
    }

    return { dates, ilc03Time, cobStart, cobStop, rrStart, rrStop, a770Time };
}

function adjustTime(timeStr) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    const totalMinutes = hours * 60 + minutes + seconds / 60;
    const noon = 12 * 60;
    return totalMinutes < noon ? totalMinutes + 1440 : totalMinutes;
}



function getAllRows() {
    return Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
}

function getDataRows() {
    const rows = getAllRows();
    return rows.slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –ø—ä—Ä–≤–∏—Ç–µ 2 —Ä–µ–¥–∞ —Å <th>
}

function updateTableRows(days) {
    const allRows = getAllRows();
    const dataRows = getDataRows();
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º–∞–ª–Ω–æ 3 –¥–Ω–∏
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // –ó–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    if (allRows[0]) allRows[0].hidden = false;
    if (allRows[1]) allRows[1].hidden = false;
}



function updateTableRows(days) {
    const allRows = Array.from(document.getElementById('recordsTable').getElementsByTagName('tr'));
    const dataRows = allRows.slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ 2 –∑–∞–≥–ª–∞–≤–Ω–∏ —Ä–µ–¥–∞
    const n = dataRows.length;

    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º–∞–ª–Ω–æ 3 –¥–Ω–∏
    const start = Math.max(0, n - visibleCount);

    dataRows.forEach((tr, i) => {
        tr.hidden = i < start;
    });

    // –ó–∞–≥–ª–∞–≤–Ω–∏—Ç–µ —Ä–µ–¥–æ–≤–µ –≤–∏–Ω–∞–≥–∏ –¥–∞ —Å–∞ –≤–∏–¥–∏–º–∏
    allRows[0].hidden = false;
    allRows[1].hidden = false;
}



function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // –ø—Ä–æ–ø—É—Å–∫–∞–º–µ 2 –∑–∞–≥–ª–∞–≤–Ω–∏ —Ä–µ–¥–∞

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // –º–∏–Ω–∏–º—É–º 3 –¥–Ω–∏, –Ω–µ 5
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start ? true : false;
    });
}



document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);

        // –ú–∏–Ω–∏–º—É–º 3 –¥–Ω–∏
        if (days < 3) {
            days = 3;
            slider.value = 3;
        }

        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderIDsChart();
        renderTimingChart();
        renderElapsedChart();
        renderCPUChart(); // –∞–∫–æ –∏—Å–∫–∞—à –∏ CPU –≥—Ä–∞—Ñ–∏–∫–∞—Ç–∞ –¥–∞ —Å–µ –∞–¥–∞–ø—Ç–∏—Ä–∞!
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});


let idsChartInstance;

function renderIDsChart() {
    const { dates, recordsPerMinute } = getRecordsData();

    if (idsChartInstance) {
        idsChartInstance.destroy();
    }

    const ctx = document.getElementById("recordsChart").getContext("2d");
    idsChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [{
                label: "Records Per Minute",
                data: recordsPerMinute,
                backgroundColor: ["rgba(255, 99, 132, 0.6)", "rgba(54, 162, 235, 0.6)", "rgba(75, 192, 192, 0.6)"],
                borderColor: ["rgba(255, 99, 132, 1)", "rgba(54, 162, 235, 1)", "rgba(75, 192, 192, 1)"],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: "easeOutBounce"
                }
            }
        }
    });
}


let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255, 99, 132, 1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54, 162, 235, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(175, 92, 192, 1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54, 113, 35, 1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                },
                x: {
                    stacked: true,
                    ticks: {
                        autoSkip: false,
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60);
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    font: {
                        size: 13,
                        weight: "bold"
                    },
                    color: getTextColor()
                },
                legend: {
                    labels: {
                        font: {
                            size: 13
                        }
                    }
                }
            }
        }
    });
}







let timingChartInstance;
function renderTimingChart(days) {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    const sliceStart = Math.max(dates.length - days, 0);

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates.slice(sliceStart),
            datasets: [
                { label: "ILC03 Time", data: ilc03time.slice(sliceStart), borderColor: "rgba(155,99,132,1)", tension: 0.3 },
                { label: "COB Start Time", data: cobStart.slice(sliceStart), borderColor: "rgba(255,99,132,1)", tension: 0.3 },
                { label: "COB End Time", data: cobStop.slice(sliceStart), borderColor: "rgba(54,162,235,1)", tension: 0.3 },
                { label: "RR Start Time", data: rrStart.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "RR Stop Time", data: rrStop.slice(sliceStart), borderColor: "rgba(75,192,192,1)", tension: 0.3 },
                { label: "A770 Time", data: a77time.slice(sliceStart), borderColor: "rgba(54,113,35,1)", tension: 0.3 },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350).slice(sliceStart),
                    borderColor: "black",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530).slice(sliceStart),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)",
                        font: { size: 13, weight: "bold" }
                    }
                },
                x: {}
            },
            plugins: {
                legend: {
                    labels: { font: { size: 13 } }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: { size: 13, weight: "bold" }
                }
            }
        }
    });
}



function onDaysChange() {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    let days = parseInt(slider.value, 10);

    if (days < 3) {
        days = 3;
        slider.value = 3;
    }

    label.textContent = `${days} days`;

    updateContainerWidth(days);
    updateTableRows(days);

    renderElapsedChart();
    renderTimingChart();
}


document.addEventListener("DOMContentLoaded", () => {
    const slider = document.getElementById("daysRange");

    slider.addEventListener("input", onDaysChange);
    onDaysChange(); // –ó–∞ –¥–∞ —Å–µ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞—Ç –ø—Ä–∞–≤–∏–ª–Ω–æ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
});



let timingChartInstance;

function renderTimingChart() {
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    const ctx = document.getElementById("timingChart").getContext("2d");
    timingChartInstance = new Chart(ctx, {
        type: "line",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "ILC03 Time",
                    data: ilc03time,
                    borderColor: "rgba(155,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB Start Time",
                    data: cobStart,
                    borderColor: "rgba(255,99,132,1)",
                    tension: 0.3
                },
                {
                    label: "COB End Time",
                    data: cobStop,
                    borderColor: "rgba(54,162,235,1)",
                    tension: 0.3
                },
                {
                    label: "RR Start Time",
                    data: rrStart,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "RR Stop Time",
                    data: rrStop,
                    borderColor: "rgba(75,192,192,1)",
                    tension: 0.3
                },
                {
                    label: "A770 Time",
                    data: a77time,
                    borderColor: "rgba(54,113,35,1)",
                    tension: 0.3
                },
                {
                    label: "ILC03 Cutoff (22:30)",
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: "RR Cutoff (01:30)",
                    data: Array(dates.length).fill(1530),
                    borderColor: "orange",
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function (value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    }
                },
                x: {}
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}


let elapsedChartInstance;

function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    if (elapsedChartInstance) {
        elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
            labels: dates,
            datasets: [
                {
                    label: "COB Elapsed",
                    data: cobElapsed,
                    backgroundColor: "rgba(154,200,245,1)",
                    stack: "stack1",
                    order: 1
                },
                {
                    label: "RR Elapsed",
                    data: rrElapsed,
                    backgroundColor: "rgba(181,181,181,1)",
                    stack: "stack1",
                    order: 2
                },
                {
                    label: "Duration Limit (2:30)",
                    data: Array(dates.length).fill(2.5),
                    type: "line",
                    borderColor: "red",
                    borderDash: [6, 4],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 7,
                    ticks: {
                        callback: function (value) {
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${h}:${m.toString().padStart(2, '0')}`;
                        },
                        font: { size: 13 },
                        color: "#333"
                    },
                    title: {
                        display: false
                    },
                    stacked: true
                },
                x: {
                    stacked: true
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const value = context.raw;
                            const h = Math.floor(value);
                            const m = Math.round((value - h) * 60);
                            return `${context.dataset.label}: ${h}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Elapsed Times vs Duration Limit",
                    color: "#222",
                    font: {
                        size: 13,
                        weight: "bold"
                    }
                },
                legend: {
                    labels: {
                        font: { size: 13 }
                    }
                }
            }
        }
    });
}



window.onload = function () {
    const slider = document.getElementById("daysRange");
    const label = document.getElementById("daysValue");

    function onDaysChange() {
        let days = parseInt(slider.value, 10);
        days = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 –¥–Ω–∏
        label.textContent = `${days} days`;

        updateContainerWidth(days);
        updateTableRows(days);
        renderElapsedChart();
    }

    slider.addEventListener("input", onDaysChange);
    onDaysChange();
};

function updateContainerWidth(days) {
    const ctr = document.getElementById("chartContainer");
    ctr.classList.remove("w-0-10", "w-11-20", "w-21-plus");
    if (days <= 10) {
        ctr.classList.add("w-0-10");
    } else if (days <= 20) {
        ctr.classList.add("w-11-20");
    } else {
        ctr.classList.add("w-21-plus");
    }
}

function updateTableRows(days) {
    const rows = Array.from(
        document.getElementById('recordsTable')
            .getElementsByTagName('tr')
    ).slice(2); // –ü—Ä–æ–ø—É—Å–∫–∞–º–µ –∑–∞–≥–ª–∞–≤–∏—è—Ç–∞

    const n = rows.length;
    const visibleCount = Math.max(days, 3); // –ú–∏–Ω–∏–º—É–º 3 —Ä–µ–¥–∞
    const start = Math.max(0, n - visibleCount);

    rows.forEach((tr, i) => {
        tr.hidden = i < start;
    });
}



const daysRange = document.getElementById("daysRange");
const daysValue = document.getElementById("daysValue");

daysRange.addEventListener("input", () => {
    let selectedDays = parseInt(daysRange.value, 10);
    if (selectedDays < 3) {
        selectedDays = 3;
        daysRange.value = 3;
    }
    daysValue.textContent = `${selectedDays} days`;

    renderAllCharts(selectedDays);
});

function renderAllCharts(selectedDays) {
    renderIDsChart(selectedDays);
    renderTimingChart(selectedDays);
    renderElapsedChart(selectedDays);
    renderCPUChart(selectedDays);
}




let recordsChartInstance = null;
let timingChartInstance = null;


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    if (recordsChartInstance) {
        recordsChartInstance.destroy();
    }

    recordsChartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    if (timingChartInstance) {
        timingChartInstance.destroy();
    }

    timingChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}


window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    daysValue.textContent = `${daysRange.value} days`;

    renderIDsChart();
    renderTimingChart();

    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;
        renderIDsChart();
        renderTimingChart();
    });
};



window.onload = function() {
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");

    // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–Ω–æ –ø–æ–∫–∞–∑–≤–∞–º–µ –∏–∑–±—Ä–∞–Ω–∏—è –±—Ä–æ–π –¥–Ω–∏
    daysValue.textContent = `${daysRange.value} days`;

    // –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ –æ—â–µ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ
    renderIDsChart();
    renderTimingChart();

    // –°–ª—É—à–∞–º–µ –∑–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –ø–ª—ä–∑–≥–∞—á–∞
    daysRange.addEventListener("input", () => {
        daysValue.textContent = `${daysRange.value} days`;

        // –ò–∑—Ç—Ä–∏–≤–∞–º–µ —Å—Ç–∞—Ä–∏—Ç–µ –≥—Ä–∞—Ñ–∏–∫–∏ –ø—Ä–µ–¥–∏ –¥–∞ —Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –Ω–æ–≤–∏
        Chart.helpers.each(Chart.instances, function(instance) {
            instance.destroy();
        });

        // –†–µ–Ω–¥–µ—Ä–∏—Ä–∞–º–µ –≥—Ä–∞—Ñ–∏–∫–∏—Ç–µ –æ—Ç–Ω–æ–≤–æ —Å–ø–æ—Ä–µ–¥ –Ω–æ–≤–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        renderIDsChart();
        renderTimingChart();
    });
};



function getRecordsData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const labels = [];
    const recordsPerMinute = [];

    for (let i = Math.max(2, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const elapsedTime = parseTimeToMinutes(cells[4].innerText);
        const transactions = parseInt(cells[5].innerText, 10);

        if (elapsedTime > 0) {
            labels.push(date);
            recordsPerMinute.push(transactions / elapsedTime);
        }
    }

    return {
        labels,
        recordsPerMinute
    };
}


function renderIDsChart() {
    const ctx = document.getElementById("recordsChart").getContext("2d");
    const { labels, recordsPerMinute } = getRecordsData();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Records Per Minute',
                data: recordsPerMinute,
                backgroundColor: ['rgba(255, 99, 132, 0.6)', 'rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
                borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
                borderWidth: 1,
                borderRadius: 5,
                hoverBorderWidth: 3,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        font: {
                            size: 13
                        },
                        color: "#333"
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                    labels: {
                        font: {
                            size: 13,
                            weight: 'bold'
                        },
                        color: "#444"
                    }
                },
                title: {
                    display: true,
                    text: "Records Processed per minute",
                    font: {
                        size: 13,
                        weight: 'bold'
                    },
                    color: "#222"
                },
                animation: {
                    duration: 1500,
                    easing: 'easeOutBounce'
                }
            }
        }
    });
}


function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const days = parseInt(document.getElementById("daysRange").value, 10) || 10;
    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

    for (let i = Math.max(1, rows.length - days); i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const baseDay = parseInt(date.slice(-2), 10);
        const baseTime = parseTimeToMinutes("12:00:00");

        function adjustTime(timeStr) {
            const t = parseTimeToMinutes(timeStr);
            return (t < baseTime) ? t + 1440 : t;
        }

        dates.push(date);
        ilc03time.push(adjustTime(cells[1].innerText));
        cobStart.push(adjustTime(cells[2].innerText));
        cobStop.push(adjustTime(cells[3].innerText));
        rrStart.push(adjustTime(cells[6].innerText));
        rrStop.push(adjustTime(cells[7].innerText));
        a77time.push(adjustTime(cells[9].innerText));
    }

    return {
        dates,
        ilc03time,
        cobStart,
        cobStop,
        rrStart,
        rrStop,
        a77time
    };
}




function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A770 Time',
                    data: a77time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: getCutoffColor(),
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(1530),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${context.dataset.label}: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: "COB & RR Times vs Cutoff Threshold",
                    color: getTextColor(),
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}

