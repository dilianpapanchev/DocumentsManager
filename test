<script>
document.addEventListener('DOMContentLoaded', () => {
  // Помощни функции (остави ги както са при теб)
  function getTextColor() {
    return document.body.classList.contains('dark-mode') ? 'white' : 'black';
  }
  function parseElapsedToHours(timeStr) {
    const [h, m] = timeStr.split(':').map(v => parseInt(v, 10));
    return isNaN(h) || isNaN(m) ? 0 : h + m/60;
  }
  function formatHHMM(hoursFloat) {
    const h = Math.floor(hoursFloat);
    const m = Math.round((hoursFloat - h) * 60);
    return `${h}:${m.toString().padStart(2,'0')}`;
  }

  // Твоята функция за четене на данните (не променяме логиката)
  function getElapsedChartData() {
    const table = document.getElementById("recordsTable");
    const rows = Array.from(table.getElementsByTagName("tr")).slice(1);
    const maxDays = parseInt(document.getElementById("daysRange").value, 10);
    const dates = [], cob = [], rr = [];

    for (let i = rows.length - 1; i >= 0 && dates.length < maxDays; i--) {
      const cells = rows[i].getElementsByTagName("td");
      if (cells.length >= 9) {
        const date = cells[0].innerText.trim();
        const cobVal = cells[4].innerText.trim();
        const rrVal  = cells[8].innerText.trim();
        if (date && cobVal && rrVal) {
          dates.push(date);
          cob.push(parseElapsedToHours(cobVal));
          rr.push(parseElapsedToHours(rrVal));
        }
      }
    }

    dates.reverse(); cob.reverse(); rr.reverse();
    return { dates, cobElapsed: cob, rrElapsed: rr };
  }

  // Рендериращата функция с dynamic resize
  let elapsedChartInstance;
  function renderElapsedChart() {
    const { dates, cobElapsed, rrElapsed } = getElapsedChartData();

    // Динамична височина на контейнера спрямо броя дни
    const perDayHeight = 12;
    const minH = 200, maxH = 800;
    const neededH = Math.min(maxH, Math.max(minH, dates.length * perDayHeight + 100));
    document.querySelector('.chart-container').style.height = neededH + 'px';

    // Убий стария чарт, ако има
    if (elapsedChartInstance) {
      elapsedChartInstance.destroy();
    }

    const ctx = document.getElementById("elapsedChart").getContext("2d");
    elapsedChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: dates,
        datasets: [
          {
            label: 'COB Elapsed',
            data: cobElapsed,
            backgroundColor: 'rgba(154,200,245,1)',
            stack: 's1',
            order: 1
          },
          {
            label: 'RR Elapsed',
            data: rrElapsed,
            backgroundColor: 'rgba(181,181,181,1)',
            stack: 's1',
            order: 2
          },
          {
            label: 'Duration Limit (2:30)',
            data: Array(dates.length).fill(2.5),
            type: 'line',
            borderColor: 'red',
            borderDash: [6,4],
            pointRadius: 0,
            borderWidth: 2,
            order: 0
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: {
          padding: { top:20, bottom:20, left:10, right:10 }
        },
        scales: {
          x: {
            stacked: true,
            ticks: {
              autoSkip: true,
              maxTicksLimit: 10,
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true,
            max: 7,
            ticks: {
              maxTicksLimit: 8,
              callback: v => formatHHMM(v)
            }
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              label(ctx) {
                return `${ctx.dataset.label}: ${formatHHMM(ctx.raw)}`;
              }
            }
          },
          title: {
            display: true,
            text: 'COB & RR Elapsed Times vs Duration Limit',
            color: getTextColor(),
            font: { size:13, weight:'bold' }
          },
          legend: {
            labels: { font: { size:13 } }
          }
        }
      },
      plugins: [{
        id: 'labelsInside',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales } = chart;
          const metaCob = chart.getDatasetMeta(0);
          const yScale  = scales.y;
          ctx.save();
          ctx.font = 'bold 11px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = getTextColor();

          data.labels.forEach((_, i) => {
            const cob   = data.datasets[0].data[i];
            const rr    = data.datasets[1].data[i];
            const total = cob + rr;
            const x     = metaCob.data[i].x;
            const topCob = yScale.getPixelForValue(cob);
            const topTot = yScale.getPixelForValue(total);

            if (cob > 0) {
              const yCob = (yScale.getPixelForValue(0) + topCob) / 2;
              ctx.fillText(formatHHMM(cob), x, yCob);
            }
            if (rr > 0) {
              const yRr = (topCob + topTot) / 2;
              ctx.fillText(formatHHMM(rr), x, yRr);
            }
            if (total > 0) {
              ctx.fillText(formatHHMM(total), x, topTot - 6);
            }
          });

          ctx.restore();
        }
      }]
    });
  }

  // Свързваме slider-а
  const slider = document.getElementById('daysRange');
  const label  = document.getElementById('daysValue');
  slider.addEventListener('input', () => {
    label.textContent = slider.value;
    renderElapsedChart();
  });

  // Първоначално рендериране
  renderElapsedChart();
});
</script>
