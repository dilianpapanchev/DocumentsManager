#!/bin/bash

# -------- Load configuration --------
script_dir="$(dirname "$0")"
script_name="$(basename "$0")"
# Convert script_dir to absolute path
script_dir="$(cd "$script_dir" && pwd)"
script_path="$script_dir/$script_name"
conf_file="${script_name%.*}.conf"
conf_path="$script_dir/$conf_file"

if [ ! -f "$conf_path" ]; then
    dialog --title "Error" --msgbox "Configuration file '$conf_file' not found!" 6 50
    clear
    exit 1
fi

# Source config file (expected to define VERSION, UPDATE_SOURCE, LOG_DIR, DEFAULT_HOST, etc.)
. "$conf_path"

# Temporary file for capturing SCP/PSCP error messages
SCP_ERR_LOG="/tmp/${script_name}_scp_error.log"

# -------- Convert Windows path to Cygwin path for UPDATE_SOURCE if needed --------
if [[ -n "$UPDATE_SOURCE" && "$UPDATE_SOURCE" =~ ^[A-Za-z]: ]]; then
    drive_letter="${UPDATE_SOURCE:0:1}"
    drive_lower="$(echo "$drive_letter" | tr '[:upper:]' '[:lower:]')"
    win_path="${UPDATE_SOURCE:2}"    # drop "C:" (drive letter and colon)
    # Replace backslashes with forward slashes
    win_path=$(printf "%s" "$win_path" | tr '\\' '/')
    # Remove leading slash to avoid double slashes
    clean_path="${win_path#/}"
    UPDATE_SOURCE="/cygdrive/${drive_lower}/${clean_path}"
fi

# -------- Auto-update check at startup --------
if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
    remote_conf="${UPDATE_SOURCE%.*}.conf"
    remote_version=""
    if [ -f "$remote_conf" ]; then
        remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
    else
        remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
    fi
    local_version="$(echo "$VERSION" | tr -d '"')"
    if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
        # Compare versions
        newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
        if [ "$newest" != "$local_version" ]; then
            # Newer version available, perform self-update
            dialog --infobox "New version $remote_version is available. Updating now..." 4 50
            sleep 1
            dialog --clear

            # Copy new script and config from update source
            cp -f "$UPDATE_SOURCE" "$script_path.tmp"
            if [ -f "$remote_conf" ]; then
                cp -f "$remote_conf" "$conf_path.tmp"
            fi
            chmod +x "$script_path.tmp"

            # Create an update script to replace the running script safely
            updater="$script_dir/update_temp.sh"
            cat > "$updater" <<EOF
#!/bin/bash
mv -f "$script_path.tmp" "$script_path"
if [ -f "$conf_path.tmp" ]; then
    mv -f "$conf_path.tmp" "$conf_path"
fi
rm -f "\$0"
exec "$script_path" "$@"
EOF
            chmod +x "$updater"
            # Run the update script (this will replace the current process)
            exec "$updater" "$@"
            # If exec fails, exit to avoid continuing old code
            exit 1
        fi
    fi
fi

# -------- Dialog main menu loop --------
while true; do
    CHOICE=$(dialog --clear --title "Main Menu" \
            --menu "Choose an option:" 15 50 5 \
            1 "Download File" \
            2 "Upload File" \
            3 "PSCP Download" \
            4 "Check for Updates" \
            5 "Exit" \
            --stdout)
    STATUS=$?
    if [ $STATUS -ne 0 ]; then
        # User pressed Cancel/ESC
        break
    fi

    case $CHOICE in
        1)  # Download File
            # Prompt for remote file path
            remote_path=$(dialog --title "Download File" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue  # back to menu if canceled or empty
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "Download File" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            # If destination is a directory (ends with /), append file name
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file, please wait..." 3 50
            scp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                # Log the transfer
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        2)  # Upload File
            # File selector for local file to upload
            initial_dir="/"
            if [ -d "/cygdrive" ]; then
                initial_dir="/cygdrive/"
            fi
            local_file=$(dialog --title "Upload File" --fselect "$initial_dir" 15 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$local_file" ]; then
                continue
            fi
            # Prompt for remote destination path
            remote_dest=$(dialog --title "Upload File" --inputbox "Enter remote destination path on $DEFAULT_HOST:\n(directory or filename)" 8 60 "~/" --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_dest" ]; then
                continue
            fi

            dialog --infobox "Uploading file, please wait..." 3 50
            scp -q "$local_file" "$DEFAULT_HOST:$remote_dest" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File uploaded successfully to:\n$DEFAULT_HOST:$remote_dest" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Uploaded $local_file to $DEFAULT_HOST:$remote_dest" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Upload failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR uploading $local_file to $DEFAULT_HOST:$remote_dest. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        3)  # PSCP Download
            if ! command -v pscp >/dev/null 2>&1; then
                dialog --title "Error" --msgbox "PSCP not found. Please ensure PuTTY's pscp is installed and in PATH." 7 60
                continue
            fi
            remote_path=$(dialog --title "PSCP Download" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "PSCP Download" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file (using PSCP), please wait..." 3 60
            pscp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            pscp_status=$?
            dialog --clear

            if [ $pscp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - [PSCP] Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "PSCP download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR [PSCP] downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        4)  # Check for Updates
            if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
                remote_conf="${UPDATE_SOURCE%.*}.conf"
                remote_version=""
                if [ -f "$remote_conf" ]; then
                    remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
                else
                    remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
                fi
                local_version="$(echo "$VERSION" | tr -d '"')"
                if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
                    newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
                    if [ "$newest" != "$local_version" ]; then
                        dialog --title "Update Available" --msgbox "A newer version ($remote_version) is available.\n(Current version: $local_version)\nIt will be downloaded on next script start." 8 60
                    else
                        dialog --title "No Update" --msgbox "You have the latest version ($local_version)." 6 50
                    fi
                else
                    dialog --title "Check Failed" --msgbox "Could not check for updates (source not accessible or version info missing)." 7 60
                fi
            else
                dialog --title "Check for Updates" --msgbox "Update source is not configured or accessible." 6 50
            fi
            ;;
        5)  # Exit
            break
            ;;
    esac
done

# Clean up and exit
dialog --clear
clear
exit 0







#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password below)"

  ssh -q "JF200069@$host" bash <<'EOF' > /tmp/log_buffer
    cd /opt/t24/support_scripts/log_search
    sudo su - $host_user <<EOSU
      (
        spin='|/-\'
        i=0
        echo -n "[ ] Processing logs..."
        ./unique_logs.sh > temp_log &
        pid=$!
        while kill -0 \$pid 2>/dev/null; do
          printf "\r[%c] Processing logs..." "\${spin:\$((i++ % 4)):1}"
          sleep 0.2
        done
        wait \$pid
        printf "\r✓ Logs collected.         \n"
        cat temp_log
        rm -f temp_log
      )
EOSU
EOF

  # Save output to final file
  cat /tmp/log_buffer > "$log_file"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local pid=$1
  local spinstr='|/-\'
  while kill -0 "$pid" 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"

  # Стартираме SSH във фон и пазим PID
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  ssh_pid=$!
  spin "$ssh_pid"
  wait "$ssh_pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local spinstr='|/-\'
  for i in $(seq 1 10); do
    for j in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$j:1}"
      sleep 0.15
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"
  
  ssh -q "JF200069@$host" bash <<EOF > "$log_file"
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  spin
done

echo -e "\nAll logs downloaded to: $full_path"





#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

# Създай основна и поддиректории
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Анимация: въртящ се спинър
spin() {
  local pid=$1
  local env_name=$2
  local spinstr='|/-\'
  echo ""
  echo -e "\n==============================="
  echo -e "  Downloading logs from $env_name"
  echo -e "===============================\n"

  while kill -0 $pid 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Please wait..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\rDone downloading logs from %s\n" "$env_name"
  echo ""
}

# Основен цикъл
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  # Стартирай SSH във фон
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  pid=$!
  spin "$pid" "$env_name"
  wait "$pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория и подпапки
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# ✅ Въвеждане на пароли (без echo)
declare -A passwords
echo "Въведи SSH паролите за средите:"
for env in "${envs[@]}"; do
  read -s -p "Парола за $env: " pass
  echo ""
  passwords["$env"]="$pass"
done

# ✅ Цикъл с expect логика вътре
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  pass="${passwords[$env_name]}"
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  echo "▶ Downloading logs from $env_name..."

  expect <<EOF
  spawn ssh $host
  expect "assword:"
  send "$pass\r"
  expect "\$ "
  send "sudo su - $host_user\r"
  expect "# "
  send "cd /opt/t24/support_scripts/log_search\r"
  expect "# "
  send "./unique_logs.sh > $log_file\r"
  expect "# "
  send "exit\r"
  expect "\$ "
  send "exit\r"
EOF

  echo "✔ Завършено за $env_name → ${env_name}/${env_name}_${dateLogs}_unique.log"
done




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория за дата ако не съществува
if [ ! -d "$full_path" ]; then
  mkdir -p "$full_path"
fi

# Създаване на поддиректории по среди
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Обхождане на сървърите
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo ">> $env_name on $host"

  ssh -q "$host" bash <<EOF > "${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done






#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

cd "/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo "Running on $host for $env_name with user $host_user..."

  ssh -q "$host" bash <<EOF > "${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done




def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    restarted_found = False

    # Заглавен ред
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() != "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            restarted_found = True

    # Ако няма рестартирани — специален ред
    if not restarted_found:
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]






def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    jboss_marker = "FALSE"

    # Добавяме header реда (винаги в началото)
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() == "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: green;'><b>{status}</b></td></tr>\n"
        else:
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            jboss_marker = "TRUE"

    # Ако никой не е рестартирал — пишем само един ред
    if jboss_marker == "FALSE":
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    # Заменяме вътрешността на таблицата
    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]




#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2
            if (log_date >= limit) {
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Хващане на "No such file or directory" като ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                if (key != "" && key != "\\\"") {
                  print key \"|\" \"[\" host \"] [\" file \"] \" \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-



#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          # Проверка за [ERROR] и дължина
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2

            # Сравняваме датата по низ (формат YYYY-MM-DD)
            if (log_date >= limit) {

              # Ограничаваме само до желаните типове
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Ако съдържа "No such file or directory", правим го фиксиран ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                # Само ако имаме key, отпечатваме
                if (key != "" && key != "\"") {
                  print key "|" "[" host "] [" file "] " \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-






#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in \${LOG_DIR}/*mdb.log \${LOG_DIR}/*runtime.log \${LOG_DIR}/*database.log \${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        /\[ERROR\]/ && length(\$0) <= maxlen {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

              # Фиксирана проверка за честа грешка
              if (\$0 ~ /No such file or directory/) {
                key = "No such file or directory"
              } else {
                match(\$0, /\} *(.*)/, arr)
                key = arr[1]
              }

              if (key != "" && key != "\"") {
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
  match($0, /No such file or directory/, nsf)
  if (nsf[0] != "") {
    key = "No such file or directory"
  } else {
    match($0, /\} *(.*)/, arr)
    key = arr[1]
  }
  if (key != "" && key != "\"") {
    print key "|" "[" host "] [" file "] " $0
  }
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Responsive Chart & Table</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html {
      font-size: 16px;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }

    .container {
      max-width: 90vw;
      margin: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 2rem;
    }

    th, td {
      border: 1px solid #aaa;
      padding: 0.5rem;
      font-size: 0.9rem;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>

<div class="container">
  <h2>Sample Table</h2>
  <table>
    <tr>
      <th>Date</th>
      <th>COB Elapsed</th>
    </tr>
    <tr>
      <td>2025-04-01</td>
      <td>01:23:00</td>
    </tr>
    <tr>
      <td>2025-04-02</td>
      <td>00:45:00</td>
    </tr>
    <tr>
      <td>2025-04-03</td>
      <td>01:10:00</td>
    </tr>
  </table>

  <h2>Responsive Chart</h2>
  <canvas id="cobChart"></canvas>
</div>

<script>
function parseHMS(str) {
  const [h, m, s] = str.split(':').map(Number);
  return h * 3600 + m * 60 + s;
}

function formatSecondsToHMS(totalSec) {
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function fixCanvasResolution(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return ctx;
}

window.onload = function () {
  const canvas = document.getElementById("cobChart");
  const ctx = fixCanvasResolution(canvas);

  const labels = ['2025-04-01', '2025-04-02', '2025-04-03'];
  const rawTimes = ['01:23:00', '00:45:00', '01:10:00'];
  const values = rawTimes.map(parseHMS);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'COB Elapsed',
        data: values,
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        },
        legend: {
          display: true
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: value => formatSecondsToHMS(value)
          },
          title: {
            display: true,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    }
  });
};
</script>

</body>
</html>







#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" -v host="${server}" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-









#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" '
    LIMIT_DATE='"$LIMIT_DATE"'
    LOG_DIR='"$LOG_DIR"'

    for f in ${LOG_DIR}/*.log; do
      awk -v limit="$LIMIT_DATE" -v file="$f" '
      /\[ERROR\]/ && length($0) <= 600 {
          log_date = $2
          if (log_date >= limit) {
              if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
                  match($0, /\} *(.*)/, arr)
                  if (arr[1] != "" && arr[1] != "\"") {
                      key = arr[1]
                      print key "|" "[" file "] " $0
                  }
              }
          }
      }' "$f"
    done
  ' 
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-








#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|" "[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-







#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|||___LINE___|||[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -u -t'|||___LINE___|||' -k1,1 | cut -d'|||___LINE___|||' -f2




for f in *.log; do
  awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '
  /\[ERROR\]/ && length($0) <= 100 {
      date_str = $2
      if (date_str >= limit) print FILENAME ": " $0
  }' "$f"
done



awk -v limit="$(date -d '7 days ago' +%Y-%m-%dT%H:%M:%S)" '
$0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/ && 
/ERROR/ && 
length($0) <= 100 {
    gsub(",", "", $2); # премахва ,111 от часа
    ts = $1 "T" $2;
    if (ts >= limit) print
}' файл.log




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Export Example</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    body { font-family: Arial; padding: 20px; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
    }
    th, td {
      border: 1px solid #333;
      padding: 6px 10px;
      font-size: 12px;
    }
    canvas {
      max-width: 100%;
      margin-bottom: 40px;
    }
    @media print {
      .pagebreak {
        page-break-before: always;
      }
    }
  </style>
</head>
<body>

<button onclick="exportToPDF()" style="margin-bottom: 20px;">Export Full Page to PDF</button>

<div id="exportArea">
  <h2>Sample Report</h2>

  <!-- Table -->
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>COB Elapsed</th>
        <th>RR Elapsed</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>2025-03-01</td><td>01:30:00</td><td>00:45:00</td></tr>
      <tr><td>2025-03-02</td><td>01:45:00</td><td>01:15:00</td></tr>
      <tr><td>2025-03-03</td><td>02:00:00</td><td>00:50:00</td></tr>
    </tbody>
  </table>

  <!-- Chart -->
  <canvas id="sampleChart" width="800" height="300"></canvas>

  <div class="pagebreak"></div>

  <!-- More content if needed -->
  <h3>Summary</h3>
  <p>This report was generated to show performance across multiple days...</p>
</div>

<script>
function exportToPDF() {
  const element = document.getElementById('exportArea');
  const opt = {
    margin: [0.5, 0.5, 0.5, 0.5],
    filename: 'report-export.pdf',
    image: { type: 'jpeg', quality: 1 },
    html2canvas: { scale: 3, useCORS: true, scrollX: 0, scrollY: 0 },
    jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
    pagebreak: { mode: ['css', 'legacy'] }
  };
  html2pdf().set(opt).from(element).save();
}

// Simple bar chart
window.onload = function () {
  const ctx = document.getElementById('sampleChart').getContext('2d');
  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['2025-03-01', '2025-03-02', '2025-03-03'],
      datasets: [{
        label: 'COB Elapsed (
min)',
        data: [90, 105, 120],
        backgroundColor: 'orange'
      }]
    },
    options: {




awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '/ERROR/ && $0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ && substr($0, 1, 10) >= limit && length($0) <= 100' файл.log
      responsive: false,
      scales: {
        y: { beginAtZero: true }
      }
    }
  });
};
</script>

</body>
</html>
