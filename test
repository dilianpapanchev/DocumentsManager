while true; do
  while true; do
    exec 3>&1
    MASK=$(dialog --nocancel --inputbox "Enter search mask for $SEARCH_TYPE:" 8 50 2>&1 1>&3)
    exec 3>&-
    [[ -n "$MASK" ]] && break
    dialog --msgbox "Mask cannot be empty!" 6 40
  done
  logger "INFO" "Mask entered: $MASK"

  TMP_OUT=$(mktemp)

  ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"
dzdo bash -o vi <<'INNER'
$(cat ./lib/functions)

cd /opt/t24/tafj/bin
echo "[Switched to user \$(whoami)]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"
sql_query "${SEARCH_TYPE}" "${MASK}" "$dbtools"
INNER
EOF

  clear && clear

  TMP_OUT_COLOR=$(grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -F'|' '{printf "'"\${SEARCH_TYPE}"' \Zb\Z1%s\Zn is installed on \Zb\Z4%s\Zn\n", $1, $2}')
  grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -F'|' -v type="$SEARCH_TYPE" '{print type, $1, "is installed on", $2}' > ./debug_log.tmp

  while read -r line; do
    logger "DEBUG" "$line"
  done < ./debug_log.tmp

  dialog_window=$(wc -l ./debug_log.tmp | awk '{print $1}')
  dialog_window=$((dialog_window + 5))

  dialog --colors \
    --title "Results for '$MASK'" \
    --yes-label "Search again" \
    --no-label "Exit" \
    --yesno "$TMP_OUT_COLOR" $dialog_window 90

  RESPONSE=$?
  logger "INFO" "SSH execution complete"

  if [[ "$RESPONSE" -ne 0 ]]; then
    break
  fi
done







TMP_OUT_COLOR=$(grep "$MASK" "$TMP_OUT" | grep -v 'Searching for' | awk -v type="$SEARCH_TYPE" -F '|' '{printf type " \Zb\Z1%s\Zn is installed on \Zb\Z4%s\Zn\n", $1, $2}')



ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"

dzdo su - je35696 -s /bin/bash <<'INNER'
$(cat ./lib/sql_query.sh)

echo "[Switched to user \$(whoami)]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"

sql_query "${SEARCH_TYPE}" "${MASK}"
INNER
EOF





ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"

dzdo su - je35696 -c "$(cat <<EOF_INNER
$(declare -f sql_query)

echo "[Switched to user \`whoami\`]"
echo "You selected: ${SEARCH_TYPE}"
echo "Searching for: ${MASK}"
sql_query "${SEARCH_TYPE}" "${MASK}"
EOF_INNER
)"
EOF





# Зареждаме функцията локално
source ./lib/sql_query.sh

# Инжектираме функцията и променливите в SSH + dzdo
ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"

dzdo su - je35696 -c "$(cat <<'INNER'
$(declare -f sql_query)

echo "[Switched to user \$(whoami)]"
echo "You selected: $SEARCH_TYPE"
echo "Searching for: $MASK"

sql_query "$SEARCH_TYPE" "$MASK"
INNER
)"
EOF




ssh "${USER}@${HOSTNAME}" bash <<EOF >"$TMP_OUT" 2>&1
$(declare -f sql_query)

echo "[Connected to \$(hostname)]"
dzdo su - je35696 -c '
  $(declare -f sql_query)
  echo "[Switched to user \$(whoami)]"
  echo "You selected: ${SEARCH_TYPE}"
  echo "Searching for: ${MASK}"
  sql_query "${SEARCH_TYPE}" "${MASK}"
'
EOF





ssh "${USER}@${HOSTNAME}" 'bash -s' -- "$SEARCH_TYPE" "$MASK" < ./lib/sql_query.sh > "$TMP_OUT" 2>&1




<script>
function parseTimeToMinutes(timeStr) {
  const parts = timeStr.split(":");
  if (parts.length === 3) {
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 60 + minutes + seconds / 60;
  }
  return null;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const cobStart = [], cobStop = [], rrStart = [], rrStop = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 7) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10); // банков ден като число

    // референтен час – използваме го за откриване на време след полунощ
    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t; // добави 24 часа ако е след полунощ
    }

    dates.push(date);
    cobStart.push(adjustTime(cells[1].innerText));
    cobStop.push(adjustTime(cells[2].innerText));
    rrStart.push(adjustTime(cells[5].innerText));
    rrStop.push(adjustTime(cells[6].innerText));
  }

  return { dates, cobStart, cobStop, rrStart, rrStop };
}

function renderTimingChart() {
  const ctx = document.getElementById("timingChart").getContext("2d");
  const { dates, cobStart, cobStop, rrStart, rrStop } = getTimingChartData();

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: dates,
      datasets: [
        {
          label: "COB Start Time",
          data: cobStart,
          borderColor: 'rgba(255, 99, 132, 1)',
          tension: 0.3
        },
        {
          label: "COB End Time",
          data: cobStop,
          borderColor: 'rgba(54, 162, 235, 1)',
          tension: 0.3
        },
        {
          label: "RR Start Time",
          data: rrStart,
          borderColor: 'rgba(75, 192, 192, 1)',
          tension: 0.3
        },
        {
          label: "RR Stop Time",
          data: rrStop,
          borderColor: 'rgba(153, 102, 255, 1)',
          tension: 0.3
        },
        {
          label: "RR Cutoff (04:48)",
          data: Array(dates.length).fill(1728), // 4*60 + 48 = 288 + 1440
          borderColor: 'orange',
          borderDash: [10, 5],
          pointRadius: 0,
          borderWidth: 2
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          min: 1260,  // 21:00
          max: 1800,  // 06:00
          ticks: {
            callback: function(value) {
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          },
          title: {
            display: true,
            text: 'Time (HH:mm)'
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB & RR Times vs Cutoff Threshold',
          color: '#222',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          display: true
        }
      }
    }
  });
}
</script>




<script>
function parseTimeToMinutes(timeStr, reference = null) {
  const parts = timeStr.split(":");
  if (parts.length !== 3) return 0;

  let hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);
  const seconds = parseInt(parts[2], 10);

  let totalMinutes = hours * 60 + minutes + seconds / 60;

  if (reference !== null && totalMinutes < reference - 300) {
    totalMinutes += 1440; // преминаване след полунощ
  }

  return totalMinutes;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const cobStart = [], cobStop = [], rrStart = [], rrStop = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length < 5) continue;

    const date = cells[0].innerText;
    const startTime = parseTimeToMinutes(cells[1].innerText); // COB Start е референцията

    const stopTime = parseTimeToMinutes(cells[2].innerText, startTime);
    const rrStartTime = parseTimeToMinutes(cells[3].innerText, startTime);
    const rrStopTime = parseTimeToMinutes(cells[4].innerText, startTime);

    dates.push(date);
    cobStart.push(startTime);
    cobStop.push(stopTime);
    rrStart.push(rrStartTime);
    rrStop.push(rrStopTime);
  }

  return { dates, cobStart, cobStop, rrStart, rrStop };
}

function renderTimingChart() {
  const ctx = document.getElementById("timingChart").getContext("2d");
  const { dates, cobStart, cobStop, rrStart, rrStop } = getTimingChartData();

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: dates,
      datasets: [
        {
          label: 'COB Start Time',
          data: cobStart,
          borderColor: 'rgba(255, 99, 132, 1)',
          tension: 0.3
        },
        {
          label: 'COB End Time',
          data: cobStop,
          borderColor: 'rgba(54, 162, 235, 1)',
          tension: 0.3
        },
        {
          label: 'RR Start Time',
          data: rrStart,
          borderColor: 'rgba(75, 192, 192, 1)',
          tension: 0.3
        },
        {
          label: 'RR Stop Time',
          data: rrStop,
          borderColor: 'rgba(153, 102, 255, 1)',
          tension: 0.3
        },
        {
          label: 'RR Cutoff (04:48)',
          data: Array(dates.length).fill(1728),
          borderColor: 'orange',
          borderDash: [10, 5],
          pointRadius: 0,
          borderWidth: 2
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          min: 1260,
          max: 1780,
          ticks: {
            callback: function(value) {
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          },
          title: {
            display: true,
            text: 'Time (HH:mm)'
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const h = Math.floor(value / 60) % 24;
              const m = Math.floor(value % 60);
              return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
            }
          }
        },
        title: {
          display: true,
          text: 'COB & RR Times vs Cutoff Threshold',
          color: '#222',
          font: {
            size: 13,
            weight: 'bold'
          }
        },
        legend: {
          display: true
        }
      }
    }
  });
}
</script>



function parseTimeToMinutes(timeStr) {
  const parts = timeStr.split(":");
  if (parts.length === 3) {
    let hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    return hours * 60 + minutes + seconds / 60;
  }
  return null;
}

function getTimingChartData() {
  const table = document.getElementById("recordsTable");
  const rows = table.getElementsByTagName("tr");

  const dates = [];
  const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77time = [];

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].getElementsByTagName("td");
    if (cells.length !== 10) continue;

    const date = cells[0].innerText;
    const baseDay = parseInt(date.slice(-2), 10); // банков ден

    const baseTime = parseTimeToMinutes("12:00:00");

    function adjustTime(timeStr) {
      const t = parseTimeToMinutes(timeStr);
      return (t < baseTime) ? t + 1440 : t; // ако е след полунощ – добави 24 часа
    }

    dates.push(date);
    ilc03time.push(adjustTime(cells[1].innerText));
    cobStart.push(adjustTime(cells[2].innerText));
    cobStop.push(adjustTime(cells[3].innerText));
    rrStart.push(adjustTime(cells[6].innerText));
    rrStop.push(adjustTime(cells[7].innerText));
    a77time.push(adjustTime(cells[9].innerText));
  }

  return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77time };
}



<script>
function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return null;

    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);

    let total = h * 60 + m + s / 60;

    if (reference !== null && total < reference - 300) {
        total += 1440; // След полунощ
    }

    return total;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const refTime = parseTimeToMinutes(cells[2].innerText); // COB Start

        if (refTime === null) continue;

        dates.push(date);
        cobStart.push(refTime);
        ilc03time.push(parseTimeToMinutes(cells[1].innerText, refTime));
        cobStop.push(parseTimeToMinutes(cells[3].innerText, refTime));
        rrStart.push(parseTimeToMinutes(cells[6].innerText, refTime));
        rrStop.push(parseTimeToMinutes(cells[7].innerText, refTime));
        a77Time.push(parseTimeToMinutes(cells[9].innerText, refTime));
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                { label: 'ILC03 Time', data: ilc03time, borderColor: 'rgba(155, 99, 132, 1)', tension: 0.3 },
                { label: 'COB Start Time', data: cobStart, borderColor: 'rgba(255, 99, 132, 1)', tension: 0.3 },
                { label: 'COB End Time', data: cobStop, borderColor: 'rgba(54, 162, 235, 1)', tension: 0.3 },
                { label: 'RR Start Time', data: rrStart, borderColor: 'rgba(75, 192, 192, 1)', tension: 0.3 },
                { label: 'RR Stop Time', data: rrStop, borderColor: 'rgba(175, 92, 192, 1)', tension: 0.3 },
                { label: 'A77 Time', data: a77Time, borderColor: 'rgba(54, 113, 35, 1)', tension: 0.3 },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: 'black',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(90),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200,
                    max: 1680,
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: false,
                        text: 'Time (HH:mm)'
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60) % 24;
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB & RR Times vs Cutoff Threshold',
                    color: '#222',
                    font: { size: 13, weight: 'bold' }
                },
                legend: { display: true }
            }
        }
    });
}
</script>




callback: {
    label: function(context) {
        const value = context.raw;
        const h = Math.floor(value / 60);
        const m = Math.floor(value % 60);
        return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    }
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const refTime = parseTimeToMinutes(cells[2].innerText); // COB Start

        if (refTime === null) continue;

        dates.push(date);
        cobStart.push(refTime);
        ilc03time.push(parseTimeToMinutes(cells[1].innerText, refTime));
        cobStop.push(parseTimeToMinutes(cells[3].innerText, refTime));
        rrStart.push(parseTimeToMinutes(cells[6].innerText, refTime));
        rrStop.push(parseTimeToMinutes(cells[7].innerText, refTime));
        a77Time.push(parseTimeToMinutes(cells[9].innerText, refTime));
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}


function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return null;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return null;

    let total = hours * 60 + minutes + seconds / 60;

    // Shift next-day entries over 24h window
    if (reference !== null && total < reference - 300) {
        total += 1440;
    }

    return total;
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const cobStartText = cells[2].innerText;
        const cobStartMinutes = parseTimeToMinutes(cobStartText);  // без reference, това Е reference

        // Парсваме останалите с тази стойност като reference
        const ilc03Minutes = parseTimeToMinutes(cells[1].innerText, cobStartMinutes);
        const cobStopMinutes = parseTimeToMinutes(cells[3].innerText, cobStartMinutes);
        const rrStartMinutes = parseTimeToMinutes(cells[6].innerText, cobStartMinutes);
        const rrStopMinutes = parseTimeToMinutes(cells[7].innerText, cobStartMinutes);
        const a77Minutes = parseTimeToMinutes(cells[9].innerText, cobStartMinutes);

        dates.push(date);
        cobStart.push(cobStartMinutes);
        ilc03time.push(ilc03Minutes);
        cobStop.push(cobStopMinutes);
        rrStart.push(rrStartMinutes);
        rrStop.push(rrStopMinutes);
        a77Time.push(a77Minutes);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}






function parseTimeToMinutes(timeStr, reference = null) {
    const parts = timeStr.split(":");
    if (parts.length !== 3) return 0;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);

    let totalMinutes = hours * 60 + minutes + seconds / 60;

    // Ако времето е след полунощ и по-малко от reference, премести с +1440 минути
    if (reference !== null && totalMinutes < reference - 300) {
        totalMinutes += 1440;
    }

    return totalMinutes;
}




function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;

        // 1. COB Start as reference
        const cobStartText = cells[2].innerText;
        const cobStartMin = parseTimeToMinutes(cobStartText);
        cobStart.push(cobStartMin);

        // 2. Parse rest with reference
        const ilcTime = parseTimeToMinutes(cells[1].innerText, cobStartMin);
        const cobStopTime = parseTimeToMinutes(cells[3].innerText, cobStartMin);
        const rrStartTime = parseTimeToMinutes(cells[6].innerText, cobStartMin);
        const rrStopTime = parseTimeToMinutes(cells[7].innerText, cobStartMin);
        const a77_Time = parseTimeToMinutes(cells[9].innerText, cobStartMin);

        dates.push(date);
        ilc03time.push(ilcTime);
        cobStop.push(cobStopTime);
        rrStart.push(rrStartTime);
        rrStop.push(rrStopTime);
        a77Time.push(a77_Time);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}




<script>
function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        const hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        if (reference !== null && totalMinutes < reference - 300) {
            totalMinutes += 1440; // добави 24 часа ако е след полунощ
        }

        return totalMinutes;
    }
    return 0;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobStart = [], cobStop = [], rrStart = [], rrStop = [], a77Time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length < 10) continue;

        const date = cells[0].innerText;
        const reference = parseTimeToMinutes(cells[2].innerText); // COB Start

        const startTime = reference;

        const ilcTime = parseTimeToMinutes(cells[1].innerText, startTime);
        const cobStartTime = parseTimeToMinutes(cells[2].innerText, startTime);
        const cobStopTime = parseTimeToMinutes(cells[3].innerText, startTime);
        const rrStartTime = parseTimeToMinutes(cells[6].innerText, startTime);
        const rrStopTime = parseTimeToMinutes(cells[7].innerText, startTime);
        const a77_Time = parseTimeToMinutes(cells[9].innerText, startTime);

        dates.push(date);
        ilc03time.push(ilcTime);
        cobStart.push(cobStartTime);
        cobStop.push(cobStopTime);
        rrStart.push(rrStartTime);
        rrStop.push(rrStopTime);
        a77Time.push(a77_Time);
    }

    return { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time };
}

function renderTimingChart() {
    const ctx = document.getElementById("timingChart").getContext("2d");
    const { dates, ilc03time, cobStart, cobStop, rrStart, rrStop, a77Time } = getTimingChartData();

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dates,
            datasets: [
                {
                    label: 'ILC03 Time',
                    data: ilc03time,
                    borderColor: 'rgba(155, 99, 122, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB Start Time',
                    data: cobStart,
                    borderColor: 'rgba(255, 99, 132, 1)',
                    tension: 0.3
                },
                {
                    label: 'COB End Time',
                    data: cobStop,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Start Time',
                    data: rrStart,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'RR Stop Time',
                    data: rrStop,
                    borderColor: 'rgba(175, 92, 192, 1)',
                    tension: 0.3
                },
                {
                    label: 'A77 Time',
                    data: a77Time,
                    borderColor: 'rgba(54, 113, 35, 1)',
                    tension: 0.3
                },
                {
                    label: 'ILC03 Cutoff (22:30)',
                    data: Array(dates.length).fill(1350),
                    borderColor: 'black',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                },
                {
                    label: 'RR Cutoff (01:30)',
                    data: Array(dates.length).fill(90),
                    borderColor: 'orange',
                    borderDash: [10, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 1200, // 20:00
                    max: 1680, // 04:00
                    ticks: {
                        callback: function(value) {
                            const hours = Math.floor(value / 60) % 24;
                            const minutes = Math.floor(value % 60);
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        }
                    },
                    title: {
                        display: true,
                        text: "Time (HH:mm)"
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const h = Math.floor(value / 60) % 24;
                            const m = Math.floor(value % 60);
                            return `${context.dataset.label}: ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                        }
                    }
                },
                title: {
                    display: true,
                    text: 'COB & RR Times vs Cutoff Threshold',
                    color: '#222',
                    font: {
                        size: 13,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true
                }
            }
        }
    });
}
</script>


<script>
function parseTimeToMinutes(timeString, referenceMinutes = null) {
    const parts = timeString.split(":");
    if (parts.length !== 3) return 0;

    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseInt(parts[2], 10);
    let totalMinutes = hours * 60 + minutes + seconds / 60;

    if (referenceMinutes !== null && totalMinutes < referenceMinutes) {
        totalMinutes += 1440; // означава, че времето е на следващия ден
    }

    return totalMinutes;
}

function getTimingChartData() {
    const table = document.getElementById("recordsTable");
    const rows = table.getElementsByTagName("tr");

    const dates = [];
    const ilc03time = [], cobstart = [], cobstop = [], rrstart = [], rrstop = [], a77time = [];

    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName("td");
        if (cells.length !== 10) continue;

        const date = cells[0].innerText;
        const cobStartText = cells[2].innerText;

        const cobStartMinutes = parseTimeToMinutes(cobStartText); // базово
        const ilc03Minutes = parseTimeToMinutes(cells[1].innerText, cobStartMinutes);
        const cobStopMinutes = parseTimeToMinutes(cells[3].innerText, cobStartMinutes);
        const rrStartMinutes = parseTimeToMinutes(cells[6].innerText, cobStartMinutes);
        const rrStopMinutes = parseTimeToMinutes(cells[7].innerText, cobStartMinutes);
        const a77Minutes = parseTimeToMinutes(cells[9].innerText, cobStartMinutes);

        dates.push(date);
        ilc03time.push(ilc03Minutes);
        cobstart.push(cobStartMinutes);
        cobstop.push(cobStopMinutes);
        rrstart.push(rrStartMinutes);
        rrstop.push(rrStopMinutes);
        a77time.push(a77Minutes);
    }

    return { dates, ilc03time, cobstart, cobstop, rrstart, rrstop, a77time };
}
</script>



function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440;
        }

        return totalMinutes;
    }
    return 0;
}




function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        // Shift if after midnight and earlier than the reference (like COB Start)
        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440;
        }

        return totalMinutes;
    }
    return 0;
}



const startTime = parseTimeToMinutes(cells[2].innerText); // COB Start

const stopTime = parseTimeToMinutes(cells[3].innerText, startTime);  // COB Stop
const rrStartTime = parseTimeToMinutes(cells[6].innerText, startTime);
const rrStopTime = parseTimeToMinutes(cells[7].innerText, startTime);
const a77Time = parseTimeToMinutes(cells[9].innerText, startTime);
const ilc03Process = parseTimeToMinutes(cells[1].innerText, startTime);




function parseTimeToMinutes(timeString, reference = null) {
    const parts = timeString.split(":");
    if (parts.length === 3) {
        let hours = parseInt(parts[0], 10);
        const minutes = parseInt(parts[1], 10);
        const seconds = parseInt(parts[2], 10);
        let totalMinutes = hours * 60 + minutes + seconds / 60;

        // Ако reference е под 300 мин (5ч), и времето е < reference => преминаване след полунощ
        if (reference !== null && totalMinutes < reference) {
            totalMinutes += 1440; // добавя 24ч
        }

        return totalMinutes;
    }
    return 0;
}






awk -F '|' '
  /Package/ && $1 ~ /^Package / && NF >= 2 {
    printf "\\Z1%s\\Zn\\Z2 is installed on \\Zn\\Z1%s\\Zn\n", $1, $2
  }
'



awk -F '|' '
  /Package/ && $1 ~ /^Package / && NF >= 2 {
    printf "\Z1%s \Zn\Z2%s\Zn\n", $1, $2
  }
'



output=$(ssh user@host '
  SQL="SELECT RECID, SAVED_DATE FROM V_F_T24_MODEL_PACKAGES WHERE RECID LIKE '\''R20_KHP%'\'' ORDER BY SAVED_DATE"
  echo "$SQL" | /path/to/sqlcli | grep -v "RECID\|rows selected\|Transaction committed" | awk -F"|" '\''{
    printf "\\Zb\\Z2Package %s\\Zn is installed on \\Zb\\Z4%s\\Zn\n", $1, $2
  }'\'
')

dialog --colors --title "Installed Packages" --msgbox "$output" 20 70




awk -F"|" '!/RECID|rows selected|Transaction committed/ && NF >= 2 {
    print "\\Zb\\Z1" $1 "\\Zn"
    print "\\Zb\\Z2" $2 "\\Zn"
}'




awk -F"|" '!/RECID|rows selected|Transaction committed/ && NF >= 2 {
    printf "\\\\Zb\\\\Z1%s\\\\Zn\\\\n\\\\Zb\\\\Z2%s\\\\Zn", $1, $2
}'




# 1. Въвеждане на маска след избора на Package/Update
while true; do
    exec 3>&1
    MASK=$(dialog --nocancel --inputbox "Enter search mask for $SEARCH_TYPE:" 8 50 2>&1 1>&3)
    exec 3>&-
    [[ -n "$MASK" ]] && break
    dialog --msgbox "Mask cannot be empty!" 6 40
done
logger "INFO" "Mask entered: $MASK"

# 2. Създаваме временно файлче за резултата
TMP_OUT=$(mktemp)

# 3. SSH с dzdo + вътрешна логика
ssh "$HOSTNAME" bash <<EOF > "$TMP_OUT" 2>&1
echo "[Connected to \$(hostname)]"
dzdo su user <<INNER
echo "[Switched to user]"
echo "You selected: $SEARCH_TYPE"
echo "Searching for: $MASK"
# Примерна симулация:
echo "Found entry matching mask: $MASK"
exit
INNER
EOF

# 4. Показване на изхода от SSH в dialog
dialog --title "Results for '$MASK'" --textbox "$TMP_OUT" 20 70
rm -f "$TMP_OUT"
logger "INFO" "SSH execution complete"




# Създаваме временен файл за изхода
TMP_OUT=$(mktemp)

# SSH с dzdo + вътрешни команди
ssh "$HOSTNAME" bash <<EOF > "$TMP_OUT" 2>&1
echo "[CONNECTED as \$(whoami)]"
dzdo su user <<INNER
echo "[SWITCHED to user]"
echo "Searching for $SEARCH_TYPE with mask: $MASK"
# Тук може да добавиш реална команда по-късно
echo "Result for: $MASK"
exit
INNER
EOF

# Показване на резултата в диалог
dialog --title "SSH Output ($SEARCH_TYPE)" --textbox "$TMP_OUT" 20 80
rm -f "$TMP_OUT"




#!/bin/bash

CONFIG_FILE="./conf/dev.conf"
LOG_DIR="./log"
LOGLEVEL="DEBUG"
mkdir -p "$LOG_DIR"
LOGFILE="$LOG_DIR/dialog_$(date +%Y%m%d_%H%M%S).log"

# Logger function
logger() {
    local level=$1
    local message=$2
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOGLEVEL" == "DEBUG" && "$level" =~ ^(DEBUG|INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "INFO"  && "$level" =~ ^(INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "ERROR" && "$level" == "ERROR" ]]; then
        echo "$timestamp [$level] $message" >> "$LOGFILE"
    fi
}

# Validate non-empty input
validate_input() {
    if [[ -z "$1" ]]; then
        dialog --title "Error" --msgbox "Field cannot be empty. Please try again." 6 50
        return 1
    fi
    return 0
}

# Ask for hostname
while true; do
    exec 3>&1
    HOSTNAME=$(dialog --nocancel --inputbox "Enter Hostname:" 8 50 2>&1 1>&3)
    exec 3>&-
    validate_input "$HOSTNAME" && break
done
logger "INFO" "User entered hostname: $HOSTNAME"

# Check for SP/TPH if hostname matches pattern
if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    exec 3>&1
    ENV_SELECTED=$(dialog --nocancel --menu "Select Environment:" 10 40 2 \
        "SP24" "Service Pack 24" \
        "TPH"  "TPH Environment" 2>&1 1>&3)
    exec 3>&-
    logger "INFO" "Environment selected: $ENV_SELECTED"
else
    ENV_SELECTED="N/A"
    logger "DEBUG" "Hostname doesn't match .hu.srv.dev. Skipping env select."
fi

# Ask what to search
exec 3>&1
SEARCH_TYPE=$(dialog --nocancel --menu "What do you want to search?" 10 40 2 \
    "Package" "Search for a package" \
    "Update"  "Search for an update" 2>&1 1>&3)
exec 3>&-
logger "INFO" "Search type selected: $SEARCH_TYPE"

# Confirm and execute SSH (placeholder for now)
dialog --title "SSH Execution" --infobox "Connecting to $HOSTNAME..." 5 40
logger "DEBUG" "Executing SSH to $HOSTNAME"
ssh "$HOSTNAME" "echo Hello from $HOSTNAME" >> "$LOGFILE" 2>&1
logger "INFO" "SSH command executed"

dialog --title "Done" --msgbox "SSH command executed. Check $LOGFILE for output." 6 50
clear





#!/bin/bash

CONFIG_FILE="./conf/dev.conf"
LOG_DIR="./log"
LOGLEVEL="DEBUG"
mkdir -p "$LOG_DIR"
LOGFILE="$LOG_DIR/dialog_$(date +%Y%m%d_%H%M%S).log"

# Logger function
logger() {
    local level=$1
    local message=$2
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if [[ "$LOGLEVEL" == "DEBUG" && "$level" =~ ^(DEBUG|INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "INFO"  && "$level" =~ ^(INFO|ERROR)$ ]] || \
       [[ "$LOGLEVEL" == "ERROR" && "$level" == "ERROR" ]]; then
        echo "$timestamp [$level] $message" >> "$LOGFILE"
    fi
}

# Validate non-empty input
validate_input() {
    if [[ -z "$1" ]]; then
        dialog --title "Error" --msgbox "Field cannot be empty. Please try again." 6 50
        return 1
    fi
    return 0
}

# Ask for hostname
while true; do
    exec 3>&1
    HOSTNAME=$(dialog --nocancel --inputbox "Enter Hostname:" 8 50 2>&1 1>&3)
    exec 3>&-
    validate_input "$HOSTNAME" && break
done
logger "INFO" "User entered hostname: $HOSTNAME"

# Check for SP/TPH if hostname matches pattern
if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    exec 3>&1
    ENV_SELECTED=$(dialog --nocancel --menu "Select Environment:" 10 40 2 \
        "SP24" "Service Pack 24" \
        "TPH"  "TPH Environment" 2>&1 1>&3)
    exec 3>&-
    logger "INFO" "Environment selected: $ENV_SELECTED"
else
    ENV_SELECTED="N/A"
    logger "DEBUG" "Hostname doesn't match .hu.srv.dev. Skipping env select."
fi

# Ask what to search
exec 3>&1
SEARCH_TYPE=$(dialog --nocancel --menu "What do you want to search?" 10 40 2 \
    "Package" "Search for a package" \
    "Update"  "Search for an update" 2>&1 1>&3)
exec 3>&-
logger "INFO" "Search type selected: $SEARCH_TYPE"

# Confirm and execute SSH (placeholder for now)
dialog --title "SSH Execution" --infobox "Connecting to $HOSTNAME..." 5 40
logger "DEBUG" "Executing SSH to $HOSTNAME"
ssh "$HOSTNAME" "echo Hello from $HOSTNAME" >> "$LOGFILE" 2>&1
logger "INFO" "SSH command executed"

dialog --title "Done" --msgbox "SSH command executed. Check $LOGFILE for output." 6 50
clear




#!/bin/bash

CONF_DIR="./conf"
LOG_DIR="./log"
mkdir -p "$LOG_DIR"

LOG_FILE="${LOG_DIR}/log_$(date +%Y%m%d_%H%M%S).log"
touch "$LOG_FILE"

log() {
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

get_input() {
    local prompt=$1
    local result_var=$2
    while true; do
        exec 3>&1
        value=$(dialog --clear --backtitle "Host Configuration" \
            --inputbox "$prompt" 8 50 2>&1 1>&3)
        exec 3>&-
        if [[ -z "$value" ]]; then
            dialog --msgbox "Value cannot be empty." 6 40
        else
            eval "$result_var=\"$value\""
            log "$prompt: $value"
            break
        fi
    done
}

select_environment() {
    exec 3>&1
    env_choice=$(dialog --clear --backtitle "Environment Choice" \
        --menu "Hostname matches .hu.srv.dev. Choose environment:" 10 50 2 \
        1 "SP24" \
        2 "TPH" \
        2>&1 1>&3)
    exec 3>&-

    case $env_choice in
        1) ENV_NAME="SP24";;
        2) ENV_NAME="TPH";;
        *) ENV_NAME="UNKNOWN";;
    esac

    log "Selected ENV: $ENV_NAME"
}

# Main
get_input "Enter Hostname:" HOSTNAME

if [[ "$HOSTNAME" == *".hu.srv.dev"* ]]; then
    select_environment
else
    ENV_NAME="Unknown"
    log "Hostname does not match .hu.srv.dev. Skipping ENV selection."
fi

dialog --msgbox "Hostname: $HOSTNAME\nEnvironment: $ENV_NAME\nLog saved to $LOG_FILE" 10 60
clear




#!/bin/bash

CONFIG_FILE="./conf/config.conf"
source "$CONFIG_FILE"

# Проверка за наличен dialog
if ! command -v dialog &>/dev/null; then
    echo "dialog is not installed!"
    exit 1
fi

# Избор на хост
dialog --inputbox "Enter Hostname:" 10 60 2>temp_hostname
HOSTNAME=$(<temp_hostname)
rm -f temp_hostname

# Проверка за .hu.srv.dev или .hu.srv.acc
if [[ "$HOSTNAME" == *".hu.srv.dev"* || "$HOSTNAME" == *".hu.srv.acc"* ]]; then
    dialog --menu "Environment Detected. Select:" 10 50 2 \
        "SP24" "Service Pack 24" \
        "TPH" "TPH Environment" 2>temp_env
    ENV_SELECTED=$(<temp_env)
    rm -f temp_env
else
    ENV_SELECTED="UNKNOWN"
fi

# Потвърждение
dialog --msgbox "Hostname: $HOSTNAME\nDetected Env: $ENV_SELECTED" 10 50
clear





use_shadow = OFF
use_colors = ON

screen_color = (BLACK,BLACK,OFF)
shadow_color = (BLACK,BLACK,OFF)
dialog_color = (BLACK,BLACK,OFF)
title_color = (GREEN,BLACK,OFF)
border_color = (GREEN,BLACK,OFF)
button_active_color = (GREEN,BLACK,OFF)
button_inactive_color = (GREEN,BLACK,OFF)
button_key_active_color = (GREEN,BLACK,OFF)
button_key_inactive_color = (GREEN,BLACK,OFF)
button_label_active_color = (GREEN,BLACK,OFF)
button_label_inactive_color = (GREEN,BLACK,OFF)
inputbox_color = (GREEN,BLACK,OFF)
searchbox_color = (GREEN,BLACK,OFF)





aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = OFF
use_colors = ON

screen_color = (GREEN,BLACK,OFF)
shadow_color = (GREEN,BLACK,OFF)
dialog_color = (GREEN,BLACK,OFF)
title_color = (GREEN,BLACK,OFF)
border_color = (GREEN,BLACK,OFF)
button_active_color = (GREEN,BLACK,OFF)
button_inactive_color = (GREEN,BLACK,OFF)
button_key_active_color = (GREEN,BLACK,OFF)
button_key_inactive_color = (GREEN,BLACK,OFF)
button_label_active_color = (GREEN,BLACK,OFF)
button_label_inactive_color = (GREEN,BLACK,OFF)
inputbox_color = (GREEN,BLACK,OFF)
inputbox_border_color = (GREEN,BLACK,OFF)
searchbox_color = (GREEN,BLACK,OFF)
searchbox_title_color = (GREEN,BLACK,OFF)
searchbox_border_color = (GREEN,BLACK,OFF)
position_indicator_color = (GREEN,BLACK,OFF)
uarrow_color = (GREEN,BLACK,OFF)
darrow_color = (GREEN,BLACK,OFF)
itemhelp_color = (GREEN,BLACK,OFF)
form_active_text_color = (GREEN,BLACK,OFF)
form_text_color = (GREEN,BLACK,OFF)
form_item_readonly_color = (GREEN,BLACK,OFF)
menubox_color = (GREEN,BLACK,OFF)
menubox_border_color = (GREEN,BLACK,OFF)
item_color = (GREEN,BLACK,OFF)
item_selected_color = (GREEN,BLACK,OFF)
tag_color = (GREEN,BLACK,OFF)
tag_selected_color = (GREEN,BLACK,OFF)
tag_key_color = (GREEN,BLACK,OFF)
tag_key_selected_color = (GREEN,BLACK,OFF)
check_color = (GREEN,BLACK,OFF)
check_selected_color = (GREEN,BLACK,OFF)
gauge_color = (GREEN,BLACK,OFF)






aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = OFF
use_colors = ON

screen_color             = (BLACK,DEFAULT,OFF)
shadow_color             = (BLACK,GREEN,OFF)
dialog_color             = (BLACK,BLACK,OFF)
title_color              = (GREEN,BLACK,OFF)
border_color             = (BLACK,BLACK,OFF)

button_active_color      = (BLACK,GREEN,OFF)
button_inactive_color    = (BLACK,BLACK,OFF)
button_key_active_color  = (BLACK,GREEN,OFF)
button_key_inactive_color= (RED,BLACK,OFF)
button_label_active_color= (BLACK,GREEN,OFF)
button_label_inactive_color= (BLACK,BLACK,OFF)




# ~/.mydialogrc

# Черен фон и зелен текст
use_shadow = NO
screen_color = BLACK
title_color = GREEN
border_color = GREEN
dialog_color = BLACK
inputbox_color = GREEN
textbox_color = GREEN
button_active_color = GREEN
button_inactive_color = GREEN






dialog --colors --title "Error" --msgbox "You have entered GLOW J*******: \Zb\Z1${curr_user}\Zn" 6 50





import os
import shutil
import datetime
import Tkinter as tk
import tkMessageBox
import tkFileDialog

CONFIG_FILE = "transfer_tool.conf"

def read_config(path):
    config = {}
    if not os.path.exists(path):
        return config
    for line in open(path):
        if "=" in line:
            k, v = line.strip().split("=", 1)
            config[k.strip()] = v.strip().strip('"')
    return config

config = read_config(CONFIG_FILE)
VERSION = config.get("VERSION", "1.0")
USER = config.get("USER", "defaultuser")
UPDATE_SOURCE = config.get("UPDATE_SOURCE", "")
LOG_DIR = config.get("LOG_DIR", "C:/Users/{}/OneDrive/Logs".format(USER))

def get_transfer_dir():
    now = datetime.datetime.now()
    folder = "C:/Users/{}/OneDrive/file_transfer_{}/{}".format(USER, now.year, now.strftime("%Y%m%d"))
    if not os.path.exists(folder):
        os.makedirs(folder)
    return folder

def run_scp_download():
    host = host_entry.get()
    remote = remote_entry.get()
    if not host or not remote:
        tkMessageBox.showerror("Error", "Enter host and remote path.")
        return
    filename = os.path.basename(remote)
    local_path = os.path.join(get_transfer_dir(), filename)
    result = os.system('scp {}:"{}" "{}"'.format(host, remote, local_path))
    if result == 0:
        tkMessageBox.showinfo("Downloaded", "Saved to:\n{}".format(local_path))
    else:
        tkMessageBox.showerror("Error", "Download failed.")

def run_scp_upload():
    host = host_entry.get()
    if not host:
        tkMessageBox.showerror("Error", "Enter host.")
        return
    local = tkFileDialog.askopenfilename()
    if not local:
        return
    remote = remote_entry.get() or "~/"
    result = os.system('scp "{}" {}:"{}"'.format(local, host, remote))
    if result == 0:
        tkMessageBox.showinfo("Uploaded", "File uploaded to:\n{}:{}".format(host, remote))
    else:
        tkMessageBox.showerror("Error", "Upload failed.")

def check_update():
    if not os.path.exists(UPDATE_SOURCE):
        tkMessageBox.showerror("Update", "Source not found.")
        return
    remote_version = None
    for line in open(UPDATE_SOURCE):
        if line.startswith("VERSION="):
            remote_version = line.split("=")[1].strip().strip('"')
            break
    if remote_version and remote_version > VERSION:
        if tkMessageBox.askyesno("Update", "New version {} available.\nUpdate?".format(remote_version)):
            shutil.copy(UPDATE_SOURCE, os.path.realpath(__file__))
            tkMessageBox.showinfo("Updated", "Script updated. Restart now.")
    else:
        tkMessageBox.showinfo("No Update", "You have the latest version.")

root = tk.Tk()
root.title("File Transfer Tool v{}".format(VERSION))

tk.Label(root, text="Host (user@host):").grid(row=0, column=0, sticky="e")
host_entry = tk.Entry(root, width=40)
host_entry.grid(row=0, column=1)

tk.Label(root, text="Remote Path:").grid(row=1, column=0, sticky="e")
remote_entry = tk.Entry(root, width=40)
remote_entry.grid(row=1, column=1)

tk.Button(root, text="Download", command=run_scp_download).grid(row=2, column=0, pady=10)
tk.Button(root, text="Upload", command=run_scp_upload).grid(row=2, column=1, pady=10)
tk.Button(root, text="Check for Update", command=check_update).grid(row=3, column=0, columnspan=2, pady=5)
tk.Button(root, text="Exit", command=root.quit).grid(row=4, column=0, columnspan=2, pady=10)

root.mainloop()




#!/bin/bash

# === ИНИЦИАЛИЗАЦИЯ ===
script_dir="$(cd "$(dirname "$0")" && pwd)"
script_name="$(basename "$0")"
script_path="$script_dir/$script_name"
conf_path="$script_dir/${script_name%.*}.conf"
SCP_ERR_LOG="/tmp/${script_name}_scp_error.log"

# === ЗАРЕЖДАНЕ НА КОНФИГУРАЦИЯ ===
if [[ ! -f "$conf_path" ]]; then
  dialog --title "Error" --msgbox "Missing config: ${conf_path}" 6 50
  exit 1
fi
. "$conf_path"

# === AUTO-UPDATE ===
if [[ -f "$UPDATE_SOURCE" ]]; then
  remote_conf="${UPDATE_SOURCE%.*}.conf"
  remote_version="$(grep VERSION "$remote_conf" 2>/dev/null | cut -d= -f2 | tr -d '"')"
  local_version="$(echo "$VERSION" | tr -d '"')"

  if [[ "$remote_version" > "$local_version" ]]; then
    dialog --infobox "Updating to version $remote_version..." 3 40
    sleep 1
    cp "$UPDATE_SOURCE" "$script_path.tmp" && chmod +x "$script_path.tmp"
    cp "$remote_conf" "$conf_path.tmp"
    cat > "$script_dir/update_runner.sh" <<EOF
#!/bin/bash
mv "$script_path.tmp" "$script_path"
mv "$conf_path.tmp" "$conf_path"
rm -- "\$0"
exec "$script_path"
EOF
    chmod +x "$script_dir/update_runner.sh"
    exec "$script_dir/update_runner.sh"
    exit
  fi
fi

# === ДАТА + ПАПКИ ===
date_check=$(date +%Y%m%d)
year_check=$(date +%Y)
base_path="/cygdrive/c/Users/$USER/OneDrive/file_transfer_${year_check}/${date_check}"

mkdir -p "$base_path" 2>/dev/null

# === ПРОМПТ ЗА HOST ===
ask_host() {
  host=$(dialog --stdout --title "Enter hostname" --inputbox "Enter SSH hostname (user@host):" 8 50)
  if [[ -z "$host" ]]; then return 1; fi
  return 0
}

# === DOWNLOAD ===
download_file() {
  ask_host || return
  remote_file=$(dialog --stdout --inputbox "Enter full remote file path:" 8 50)
  [ -z "$remote_file" ] && return
  filename=$(basename "$remote_file")
  local_path="$base_path/$filename"

  dialog --infobox "Downloading..." 3 30
  scp "$host:$remote_file" "$local_path" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Downloaded to:\n$local_path" 6 50
  else
    dialog --msgbox "Download failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === UPLOAD ===
upload_file() {
  ask_host || return
  local_file=$(dialog --stdout --fselect "/cygdrive/c/" 14 60)
  [ -z "$local_file" ] && return
  dest_path=$(dialog --stdout --inputbox "Remote destination path:" 8 50 "~")
  [ -z "$dest_path" ] && return

  dialog --infobox "Uploading..." 3 30
  scp "$local_file" "$host:$dest_path" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Uploaded to:\n$host:$dest_path" 6 50
  else
    dialog --msgbox "Upload failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === PSCP (от Windows) ===
pscp_download() {
  remote_file=$(dialog --stdout --inputbox "Enter remote path (PSCP):" 8 50)
  [ -z "$remote_file" ] && return
  file_name=$(basename "$remote_file")
  local_dest="$base_path/$file_name"

  dialog --infobox "Downloading via PSCP..." 3 40
  pscp "$remote_file" "$local_dest" 2> "$SCP_ERR_LOG"
  if [[ $? -eq 0 ]]; then
    dialog --msgbox "Saved to $local_dest" 6 50
  else
    dialog --msgbox "PSCP failed:\n$(<"$SCP_ERR_LOG")" 8 60
  fi
}

# === UPDATE CHECK ===
check_update() {
  if [[ -f "$UPDATE_SOURCE" ]]; then
    remote_conf="${UPDATE_SOURCE%.*}.conf"
    remote_version="$(grep VERSION "$remote_conf" | cut -d= -f2 | tr -d '"')"
    if [[ "$remote_version" > "$VERSION" ]]; then
      dialog --msgbox "Update available: $remote_version (you have $VERSION)" 6 50
    else
      dialog --msgbox "You're on the latest version: $VERSION" 5 40
    fi
  else
    dialog --msgbox "Cannot reach update source." 5 40
  fi
}

# === МЕНЮ ===
while true; do
  choice=$(dialog --clear --menu "File Transfer Utility (v$VERSION)" 15 50 6 \
    1 "Download File" \
    2 "Upload File" \
    3 "PSCP Download" \
    4 "Check for Update" \
    5 "Exit" \
    --stdout)

  case "$choice" in
    1) download_file ;;
    2) upload_file ;;
    3) pscp_download ;;
    4) check_update ;;
    5|*) clear; exit 0 ;;
  esac
done










#!/bin/bash

# -------- Load configuration --------
script_dir="$(dirname "$0")"
script_name="$(basename "$0")"
# Convert script_dir to absolute path
script_dir="$(cd "$script_dir" && pwd)"
script_path="$script_dir/$script_name"
conf_file="${script_name%.*}.conf"
conf_path="$script_dir/$conf_file"

if [ ! -f "$conf_path" ]; then
    dialog --title "Error" --msgbox "Configuration file '$conf_file' not found!" 6 50
    clear
    exit 1
fi

# Source config file (expected to define VERSION, UPDATE_SOURCE, LOG_DIR, DEFAULT_HOST, etc.)
. "$conf_path"

# Temporary file for capturing SCP/PSCP error messages
SCP_ERR_LOG="/tmp/${script_name}_scp_error.log"

# -------- Convert Windows path to Cygwin path for UPDATE_SOURCE if needed --------
if [[ -n "$UPDATE_SOURCE" && "$UPDATE_SOURCE" =~ ^[A-Za-z]: ]]; then
    drive_letter="${UPDATE_SOURCE:0:1}"
    drive_lower="$(echo "$drive_letter" | tr '[:upper:]' '[:lower:]')"
    win_path="${UPDATE_SOURCE:2}"    # drop "C:" (drive letter and colon)
    # Replace backslashes with forward slashes
    win_path=$(printf "%s" "$win_path" | tr '\\' '/')
    # Remove leading slash to avoid double slashes
    clean_path="${win_path#/}"
    UPDATE_SOURCE="/cygdrive/${drive_lower}/${clean_path}"
fi

# -------- Auto-update check at startup --------
if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
    remote_conf="${UPDATE_SOURCE%.*}.conf"
    remote_version=""
    if [ -f "$remote_conf" ]; then
        remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
    else
        remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
    fi
    local_version="$(echo "$VERSION" | tr -d '"')"
    if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
        # Compare versions
        newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
        if [ "$newest" != "$local_version" ]; then
            # Newer version available, perform self-update
            dialog --infobox "New version $remote_version is available. Updating now..." 4 50
            sleep 1
            dialog --clear

            # Copy new script and config from update source
            cp -f "$UPDATE_SOURCE" "$script_path.tmp"
            if [ -f "$remote_conf" ]; then
                cp -f "$remote_conf" "$conf_path.tmp"
            fi
            chmod +x "$script_path.tmp"

            # Create an update script to replace the running script safely
            updater="$script_dir/update_temp.sh"
            cat > "$updater" <<EOF
#!/bin/bash
mv -f "$script_path.tmp" "$script_path"
if [ -f "$conf_path.tmp" ]; then
    mv -f "$conf_path.tmp" "$conf_path"
fi
rm -f "\$0"
exec "$script_path" "$@"
EOF
            chmod +x "$updater"
            # Run the update script (this will replace the current process)
            exec "$updater" "$@"
            # If exec fails, exit to avoid continuing old code
            exit 1
        fi
    fi
fi

# -------- Dialog main menu loop --------
while true; do
    CHOICE=$(dialog --clear --title "Main Menu" \
            --menu "Choose an option:" 15 50 5 \
            1 "Download File" \
            2 "Upload File" \
            3 "PSCP Download" \
            4 "Check for Updates" \
            5 "Exit" \
            --stdout)
    STATUS=$?
    if [ $STATUS -ne 0 ]; then
        # User pressed Cancel/ESC
        break
    fi

    case $CHOICE in
        1)  # Download File
            # Prompt for remote file path
            remote_path=$(dialog --title "Download File" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue  # back to menu if canceled or empty
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "Download File" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            # If destination is a directory (ends with /), append file name
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file, please wait..." 3 50
            scp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                # Log the transfer
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        2)  # Upload File
            # File selector for local file to upload
            initial_dir="/"
            if [ -d "/cygdrive" ]; then
                initial_dir="/cygdrive/"
            fi
            local_file=$(dialog --title "Upload File" --fselect "$initial_dir" 15 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$local_file" ]; then
                continue
            fi
            # Prompt for remote destination path
            remote_dest=$(dialog --title "Upload File" --inputbox "Enter remote destination path on $DEFAULT_HOST:\n(directory or filename)" 8 60 "~/" --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_dest" ]; then
                continue
            fi

            dialog --infobox "Uploading file, please wait..." 3 50
            scp -q "$local_file" "$DEFAULT_HOST:$remote_dest" 2> "$SCP_ERR_LOG"
            scp_status=$?
            dialog --clear

            if [ $scp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File uploaded successfully to:\n$DEFAULT_HOST:$remote_dest" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - Uploaded $local_file to $DEFAULT_HOST:$remote_dest" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "Upload failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR uploading $local_file to $DEFAULT_HOST:$remote_dest. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        3)  # PSCP Download
            if ! command -v pscp >/dev/null 2>&1; then
                dialog --title "Error" --msgbox "PSCP not found. Please ensure PuTTY's pscp is installed and in PATH." 7 60
                continue
            fi
            remote_path=$(dialog --title "PSCP Download" --inputbox "Enter remote file path on $DEFAULT_HOST:" 8 60 --stdout)
            if [ $? -ne 0 ] || [ -z "$remote_path" ]; then
                continue
            fi
            file_name="$(basename "$remote_path")"
            default_local="./$file_name"
            local_path=$(dialog --title "PSCP Download" --inputbox "Enter local destination path:" 8 60 "$default_local" --stdout)
            if [ $? -ne 0 ] || [ -z "$local_path" ]; then
                continue
            fi
            if [[ "$local_path" == */ ]]; then
                local_path="${local_path}${file_name}"
            fi

            dialog --infobox "Downloading file (using PSCP), please wait..." 3 60
            pscp -q "$DEFAULT_HOST:$remote_path" "$local_path" 2> "$SCP_ERR_LOG"
            pscp_status=$?
            dialog --clear

            if [ $pscp_status -eq 0 ]; then
                dialog --title "Success" --msgbox "File downloaded successfully to:\n$local_path" 6 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - [PSCP] Downloaded $remote_path from $DEFAULT_HOST to $local_path" >> "$LOG_DIR/transfer.log"
                fi
            else
                error_msg=$(<"$SCP_ERR_LOG")
                dialog --title "Error" --msgbox "PSCP download failed:\n$error_msg" 8 60
                if [ -n "$LOG_DIR" ]; then
                    mkdir -p "$LOG_DIR" 2>/dev/null
                    echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR [PSCP] downloading $remote_path from $DEFAULT_HOST. $error_msg" >> "$LOG_DIR/transfer.log"
                fi
            fi
            ;;
        4)  # Check for Updates
            if [ -n "$UPDATE_SOURCE" ] && [ -f "$UPDATE_SOURCE" ]; then
                remote_conf="${UPDATE_SOURCE%.*}.conf"
                remote_version=""
                if [ -f "$remote_conf" ]; then
                    remote_version=$(grep -E '^VERSION=' "$remote_conf" | cut -d= -f2 | tr -d '"')
                else
                    remote_version=$(grep -E '^VERSION=' "$UPDATE_SOURCE" | cut -d= -f2 | tr -d '"')
                fi
                local_version="$(echo "$VERSION" | tr -d '"')"
                if [ -n "$remote_version" ] && [ -n "$local_version" ]; then
                    newest=$(printf "%s\n%s" "$local_version" "$remote_version" | sort -V | tail -n1)
                    if [ "$newest" != "$local_version" ]; then
                        dialog --title "Update Available" --msgbox "A newer version ($remote_version) is available.\n(Current version: $local_version)\nIt will be downloaded on next script start." 8 60
                    else
                        dialog --title "No Update" --msgbox "You have the latest version ($local_version)." 6 50
                    fi
                else
                    dialog --title "Check Failed" --msgbox "Could not check for updates (source not accessible or version info missing)." 7 60
                fi
            else
                dialog --title "Check for Updates" --msgbox "Update source is not configured or accessible." 6 50
            fi
            ;;
        5)  # Exit
            break
            ;;
    esac
done

# Clean up and exit
dialog --clear
clear
exit 0







#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password below)"

  ssh -q "JF200069@$host" bash <<'EOF' > /tmp/log_buffer
    cd /opt/t24/support_scripts/log_search
    sudo su - $host_user <<EOSU
      (
        spin='|/-\'
        i=0
        echo -n "[ ] Processing logs..."
        ./unique_logs.sh > temp_log &
        pid=$!
        while kill -0 \$pid 2>/dev/null; do
          printf "\r[%c] Processing logs..." "\${spin:\$((i++ % 4)):1}"
          sleep 0.2
        done
        wait \$pid
        printf "\r✓ Logs collected.         \n"
        cat temp_log
        rm -f temp_log
      )
EOSU
EOF

  # Save output to final file
  cat /tmp/log_buffer > "$log_file"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local pid=$1
  local spinstr='|/-\'
  while kill -0 "$pid" 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"

  # Стартираме SSH във фон и пазим PID
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  ssh_pid=$!
  spin "$ssh_pid"
  wait "$ssh_pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

show_header() {
  local env_name=$1
  echo ""
  echo "==============================="
  echo "  Downloading logs from $env_name"
  echo "==============================="
}

spin() {
  local spinstr='|/-\'
  for i in $(seq 1 10); do
    for j in $(seq 0 3); do
      printf "\r[%c] Processing..." "${spinstr:$j:1}"
      sleep 0.15
    done
  done
  printf "\r✓ Logs ready.                  \n"
}

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  show_header "$env_name"
  echo "(You'll be prompted for password if needed)"
  
  ssh -q "JF200069@$host" bash <<EOF > "$log_file"
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  spin
done

echo -e "\nAll logs downloaded to: $full_path"





#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

clear

# Създай основна и поддиректории
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Анимация: въртящ се спинър
spin() {
  local pid=$1
  local env_name=$2
  local spinstr='|/-\'
  echo ""
  echo -e "\n==============================="
  echo -e "  Downloading logs from $env_name"
  echo -e "===============================\n"

  while kill -0 $pid 2>/dev/null; do
    for i in $(seq 0 3); do
      printf "\r[%c] Please wait..." "${spinstr:$i:1}"
      sleep 0.2
    done
  done
  printf "\rDone downloading logs from %s\n" "$env_name"
  echo ""
}

# Основен цикъл
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  # Стартирай SSH във фон
  ssh -q "JF200069@$host" bash <<EOF > "$log_file" 2>/dev/null &
    cd /opt/t24/support_scripts/log_search
    sudo su $host_user
    ./unique_logs.sh
EOF

  pid=$!
  spin "$pid" "$env_name"
  wait "$pid"
done

echo -e "\nAll logs downloaded to: $full_path"




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория и подпапки
mkdir -p "$full_path"
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# ✅ Въвеждане на пароли (без echo)
declare -A passwords
echo "Въведи SSH паролите за средите:"
for env in "${envs[@]}"; do
  read -s -p "Парола за $env: " pass
  echo ""
  passwords["$env"]="$pass"
done

# ✅ Цикъл с expect логика вътре
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}
  pass="${passwords[$env_name]}"
  log_file="${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"

  echo "▶ Downloading logs from $env_name..."

  expect <<EOF
  spawn ssh $host
  expect "assword:"
  send "$pass\r"
  expect "\$ "
  send "sudo su - $host_user\r"
  expect "# "
  send "cd /opt/t24/support_scripts/log_search\r"
  expect "# "
  send "./unique_logs.sh > $log_file\r"
  expect "# "
  send "exit\r"
  expect "\$ "
  send "exit\r"
EOF

  echo "✔ Завършено за $env_name → ${env_name}/${env_name}_${dateLogs}_unique.log"
done




#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

base_path="/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"
full_path="${base_path}/${dateLogs}"

# Създаване на директория за дата ако не съществува
if [ ! -d "$full_path" ]; then
  mkdir -p "$full_path"
fi

# Създаване на поддиректории по среди
for env in "${envs[@]}"; do
  mkdir -p "${full_path}/${env}"
done

# Обхождане на сървърите
for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo ">> $env_name on $host"

  ssh -q "$host" bash <<EOF > "${full_path}/${env_name}/${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done






#!/bin/bash

servers=("s0ab0ol6.sk.srv.sys" "s0ab0nhq.hu.srv.sys" "s0ab0nh9.hu.srv.sys" "s0ab0pl2.bg.srv.sys")
users=("je5273" "je4466" "je3696" "je7681")
envs=("CSOB" "TPH" "SP24" "UBB")
dateLogs=$(date +%Y%m%d)

cd "/cygdrive/c/Users/j18959/OneDrive - KBC Group/24x7 Operations/PROD Logs"

for i in "${!servers[@]}"; do
  host=${servers[$i]}
  host_user=${users[$i]}
  env_name=${envs[$i]}

  echo "Running on $host for $env_name with user $host_user..."

  ssh -q "$host" bash <<EOF > "${env_name}_${dateLogs}_unique.log"
    sudo su - $host_user
    cd /opt/t24/support_scripts/log_search
    ./unique_logs.sh
EOF

done




def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    restarted_found = False

    # Заглавен ред
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() != "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            restarted_found = True

    # Ако няма рестартирани — специален ред
    if not restarted_found:
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]






def insert_jboss_table_in_html(html_content, jboss_entries):
    start_marker = "<!-- START_JBOSS_TABLE -->"
    end_marker = "<!-- END_JBOSS_TABLE -->"

    start_index = html_content.find(start_marker)
    end_index = html_content.find(end_marker, start_index)

    if start_index == -1 or end_index == -1:
        return html_content

    new_table_content = ""
    jboss_marker = "FALSE"

    # Добавяме header реда (винаги в началото)
    new_table_content += "<tr><th>Server</th><th>If Restarted</th></tr>\n"

    for server, status in jboss_entries:
        if status.strip().upper() == "NO":
            new_table_content += f"<tr><td>{server}</td><td style='color: green;'><b>{status}</b></td></tr>\n"
        else:
            new_table_content += f"<tr><td>{server}</td><td style='color: red;'><b>{status}</b></td></tr>\n"
            jboss_marker = "TRUE"

    # Ако никой не е рестартирал — пишем само един ред
    if jboss_marker == "FALSE":
        new_table_content = "<tr><th>No JBOSS Restart during COB</th></tr>\n"

    # Заменяме вътрешността на таблицата
    return html_content[:start_index + len(start_marker)] + "\n" + new_table_content + html_content[end_index:]




#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2
            if (log_date >= limit) {
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Хващане на "No such file or directory" като ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                if (key != "" && key != "\\\"") {
                  print key \"|\" \"[\" host \"] [\" file \"] \" \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-



#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*mdb.log ${LOG_DIR}/*runtime.log ${LOG_DIR}/*database.log ${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        {
          # Проверка за [ERROR] и дължина
          if (\$0 ~ /\[ERROR\]/ && length(\$0) <= maxlen) {
            log_date = \$2

            # Сравняваме датата по низ (формат YYYY-MM-DD)
            if (log_date >= limit) {

              # Ограничаваме само до желаните типове
              if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

                # Ако съдържа "No such file or directory", правим го фиксиран ключ
                if (\$0 ~ /No such file or directory/) {
                  key = "No such file or directory"
                } else {
                  match(\$0, /\} *(.*)/, arr)
                  key = arr[1]
                }

                # Само ако имаме key, отпечатваме
                if (key != "" && key != "\"") {
                  print key "|" "[" host "] [" file "] " \$0
                }
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-






#!/bin/bash

CHAR_LIMIT=1000
LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in \${LOG_DIR}/*mdb.log \${LOG_DIR}/*runtime.log \${LOG_DIR}/*database.log \${LOG_DIR}/*ejb.log; do
      if [ -f "\$f" ]; then
        awk -v limit="$LIMIT_DATE" -v file="\$f" -v host="$server" -v maxlen=$CHAR_LIMIT '
        /\[ERROR\]/ && length(\$0) <= maxlen {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {

              # Фиксирана проверка за честа грешка
              if (\$0 ~ /No such file or directory/) {
                key = "No such file or directory"
              } else {
                match(\$0, /\} *(.*)/, arr)
                key = arr[1]
              }

              if (key != "" && key != "\"") {
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }' "\$f"
      fi
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
  match($0, /No such file or directory/, nsf)
  if (nsf[0] != "") {
    key = "No such file or directory"
  } else {
    match($0, /\} *(.*)/, arr)
    key = arr[1]
  }
  if (key != "" && key != "\"") {
    print key "|" "[" host "] [" file "] " $0
  }
}







<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Responsive Chart & Table</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html {
      font-size: 16px;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      background: #f9f9f9;
    }

    .container {
      max-width: 90vw;
      margin: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 2rem;
    }

    th, td {
      border: 1px solid #aaa;
      padding: 0.5rem;
      font-size: 0.9rem;
    }

    canvas {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
    }
  </style>
</head>
<body>

<div class="container">
  <h2>Sample Table</h2>
  <table>
    <tr>
      <th>Date</th>
      <th>COB Elapsed</th>
    </tr>
    <tr>
      <td>2025-04-01</td>
      <td>01:23:00</td>
    </tr>
    <tr>
      <td>2025-04-02</td>
      <td>00:45:00</td>
    </tr>
    <tr>
      <td>2025-04-03</td>
      <td>01:10:00</td>
    </tr>
  </table>

  <h2>Responsive Chart</h2>
  <canvas id="cobChart"></canvas>
</div>

<script>
function parseHMS(str) {
  const [h, m, s] = str.split(':').map(Number);
  return h * 3600 + m * 60 + s;
}

function formatSecondsToHMS(totalSec) {
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function fixCanvasResolution(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return ctx;
}

window.onload = function () {
  const canvas = document.getElementById("cobChart");
  const ctx = fixCanvasResolution(canvas);

  const labels = ['2025-04-01', '2025-04-02', '2025-04-03'];
  const rawTimes = ['01:23:00', '00:45:00', '01:10:00'];
  const values = rawTimes.map(parseHMS);

  new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'COB Elapsed',
        data: values,
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${formatSecondsToHMS(ctx.raw)}`
          }
        },
        legend: {
          display: true
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: value => formatSecondsToHMS(value)
          },
          title: {
            display: true,
            text: 'Elapsed Time (HH:mm:ss)'
          }
        }
      }
    }
  });
};
</script>

</body>
</html>







#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" -v host="${server}" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" host "] [" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-









#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" bash <<EOF
    for f in ${LOG_DIR}/*.log; do
      awk -v limit="${LIMIT_DATE}" -v file="\$f" '
        /\[ERROR\]/ && length(\$0) <= 600 {
          log_date = \$2
          if (log_date >= limit) {
            if (\$0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match(\$0, /\\} *(.*)/, arr)
              if (arr[1] != "" && arr[1] != "\\"") {
                key = arr[1]
                print key "|" "[" file "] " \$0
              }
            }
          }
        }
      ' "\$f"
    done
EOF
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-





#!/bin/bash

LIMIT_DATE=$(date -d '1 days ago' +%Y-%m-%d)
LOG_DIR="/opt/t24/tafjbatch/log"

for server in $(cat hosts); do
  ssh -q "$server" '
    LIMIT_DATE='"$LIMIT_DATE"'
    LOG_DIR='"$LOG_DIR"'

    for f in ${LOG_DIR}/*.log; do
      awk -v limit="$LIMIT_DATE" -v file="$f" '
      /\[ERROR\]/ && length($0) <= 600 {
          log_date = $2
          if (log_date >= limit) {
              if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
                  match($0, /\} *(.*)/, arr)
                  if (arr[1] != "" && arr[1] != "\"") {
                      key = arr[1]
                      print key "|" "[" file "] " $0
                  }
              }
          }
      }' "$f"
    done
  ' 
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-








#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|" "[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -t'|' -k1,1 -u | cut -d'|' -f2-







#!/bin/bash

LIMIT_DATE=$(date -d '7 days ago' +%Y-%m-%d)

for f in *.log; do
  awk -v limit="$LIMIT_DATE" -v file="$f" '
  /\[ERROR\]/ && length($0) <= 100 {
      log_date = $2
      if (log_date >= limit) {
          if ($0 ~ /DATABASE|RUNTIME|EJB|MDB/) {
              match($0, /\} *(.*)/, arr)
              if (arr[1] != "") {
                  key = arr[1]
                  print key "|||___LINE___|||[" file "] " $0
              }
          }
      }
  }' "$f"
done | sort -u -t'|||___LINE___|||' -k1,1 | cut -d'|||___LINE___|||' -f2




for f in *.log; do
  awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '
  /\[ERROR\]/ && length($0) <= 100 {
      date_str = $2
      if (date_str >= limit) print FILENAME ": " $0
  }' "$f"
done



awk -v limit="$(date -d '7 days ago' +%Y-%m-%dT%H:%M:%S)" '
$0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/ && 
/ERROR/ && 
length($0) <= 100 {
    gsub(",", "", $2); # премахва ,111 от часа
    ts = $1 "T" $2;
    if (ts >= limit) print
}' файл.log




<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Export Example</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    body { font-family: Arial; padding: 20px; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
    }
    th, td {
      border: 1px solid #333;
      padding: 6px 10px;
      font-size: 12px;
    }
    canvas {
      max-width: 100%;
      margin-bottom: 40px;
    }
    @media print {
      .pagebreak {
        page-break-before: always;
      }
    }
  </style>
</head>
<body>

<button onclick="exportToPDF()" style="margin-bottom: 20px;">Export Full Page to PDF</button>

<div id="exportArea">
  <h2>Sample Report</h2>

  <!-- Table -->
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>COB Elapsed</th>
        <th>RR Elapsed</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>2025-03-01</td><td>01:30:00</td><td>00:45:00</td></tr>
      <tr><td>2025-03-02</td><td>01:45:00</td><td>01:15:00</td></tr>
      <tr><td>2025-03-03</td><td>02:00:00</td><td>00:50:00</td></tr>
    </tbody>
  </table>

  <!-- Chart -->
  <canvas id="sampleChart" width="800" height="300"></canvas>

  <div class="pagebreak"></div>

  <!-- More content if needed -->
  <h3>Summary</h3>
  <p>This report was generated to show performance across multiple days...</p>
</div>

<script>
function exportToPDF() {
  const element = document.getElementById('exportArea');
  const opt = {
    margin: [0.5, 0.5, 0.5, 0.5],
    filename: 'report-export.pdf',
    image: { type: 'jpeg', quality: 1 },
    html2canvas: { scale: 3, useCORS: true, scrollX: 0, scrollY: 0 },
    jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
    pagebreak: { mode: ['css', 'legacy'] }
  };
  html2pdf().set(opt).from(element).save();
}

// Simple bar chart
window.onload = function () {
  const ctx = document.getElementById('sampleChart').getContext('2d');
  new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['2025-03-01', '2025-03-02', '2025-03-03'],
      datasets: [{
        label: 'COB Elapsed (
min)',
        data: [90, 105, 120],
        backgroundColor: 'orange'
      }]
    },
    options: {




awk -v limit="$(date -d '7 days ago' +%Y-%m-%d)" '/ERROR/ && $0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ && substr($0, 1, 10) >= limit && length($0) <= 100' файл.log
      responsive: false,
      scales: {
        y: { beginAtZero: true }
      }
    }
  });
};
</script>

</body>
</html>
